{"version":3,"file":"assemblyscript.js","mappings":"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21C,YAAYC,mBAAoB,CACnC,IAAI0M,EAAgC7L,EAAQ6L,UAC5C,GAAIA,EAEF,IAAK,IAAIhM,EAAUC,WAAW+L,GAAY9L,EAAI,EAAGtlC,EAAIolC,EAAQtrC,OAAQwrC,EAAItlC,IAAKslC,EAAG,CAE/E,GADellC,UAAUglC,EAAQE,IACpBxqC,GAAG,EAAAF,YAAYyD,UAAW,OAAO,EAGlD,MAEF,KAAK,EAAAomC,YAAY6d,gBAAiB,CAChC,IAAIlR,EAA6B7L,EAAQ6L,UACzC,GAAIA,EAEF,IAAK,IAAIhM,EAAUC,WAAW+L,GAAY9L,EAAI,EAAGtlC,EAAIolC,EAAQtrC,OAAQwrC,EAAItlC,IAAKslC,EAAG,CAE/E,GADellC,UAAUglC,EAAQE,IACpBxqC,GAAG,EAAAF,YAAYyD,UAAW,OAAO,EAGlD,MAEF,QACE,GAAIknC,EAAOzqC,GAAG,EAAAF,YAAYyD,WAAam3E,EAAkBjwC,GAAS,OAAO,GAMjF,OAAO,EA1TT,gB,2HC7WA,SAAYxe,GACV,+CACA,mDACA,yCACA,6DACA,qGACA,iHACA,iHACA,mHACA,qHACA,uCACA,uHACA,iMACA,iFACA,2FACA,+DACA,yEACA,2EACA,yIACA,uGACA,6EACA,6DACA,2FACA,uEACA,mDACA,+EACA,mGACA,uKACA,6FACA,2JACA,uFACA,iGACA,qHACA,qGACA,+DACA,iEACA,iGACA,uFACA,yDACA,uGACA,qHACA,yEACA,yLACA,2GACA,+GACA,uIACA,uIACA,+GACA,iGACA,yHACA,2EACA,qIACA,oEACA,oDACA,oCACA,8FACA,kEACA,8CACA,gHACA,oHACA,8HACA,8HACA,0GACA,8GACA,4EACA,oFACA,oGACA,0GACA,oHACA,wFACA,gFACA,kIACA,kIACA,4FACA,oHACA,oFACA,kFACA,wKACA,sLACA,kIACA,oDACA,wCACA,oJACA,gDACA,kGACA,wGACA,0CACA,kEACA,0DACA,gDACA,gEACA,sIACA,4IACA,0DACA,4DACA,wEACA,sDACA,4FACA,4FACA,oHACA,wDACA,sDACA,8HACA,gKACA,oKACA,sFACA,wEACA,sKACA,sJACA,8IACA,wFACA,0IACA,sJACA,0DACA,kDACA,gFACA,gGACA,gGACA,wDACA,kFACA,gHACA,sFACA,0GACA,oHACA,8GACA,sHACA,wMACA,oFACA,8HACA,0NACA,sFACA,0IACA,gMACA,0LACA,wGACA,oIACA,kIACA,0HACA,wGACA,oIACA,wFACA,4KACA,sHACA,gFACA,oKACA,gLACA,kKACA,4FACA,0MACA,8HACA,0HACA,wKACA,0FACA,8FACA,kQACA,8DACA,kGACA,gKACA,oIACA,kJACA,0GACA,kKACA,4DACA,oJACA,oJACA,0GACA,0EACA,4FACA,oFACA,sNACA,8FACA,0QACA,kLACA,sLACA,gHACA,sFACA,8IACA,sDACA,0HACA,wEACA,8CACA,4FACA,gIACA,iLACA,+MAxLF,CAAY,EAAAA,iBAAA,EAAAA,eAAc,KA4L1B,kCAAuCyvD,GACrC,OAAQA,GACN,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,oBACjB,KAAK,IAAK,MAAO,gCACjB,KAAK,IAAK,MAAO,sDACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,uDACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,iEACjB,KAAK,IAAK,MAAO,sGACjB,KAAK,IAAK,MAAO,8CACjB,KAAK,IAAK,MAAO,mDACjB,KAAK,IAAK,MAAO,iCACjB,KAAK,IAAK,MAAO,kCACjB,KAAK,IAAK,MAAO,mCACjB,KAAK,IAAK,MAAO,kEACjB,KAAK,IAAK,MAAO,iDACjB,KAAK,IAAK,MAAO,oCACjB,KAAK,IAAK,MAAO,8BACjB,KAAK,IAAK,MAAO,+CACjB,KAAK,IAAK,MAAO,qCACjB,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,yCACjB,KAAK,IAAK,MAAO,+CACjB,KAAK,IAAK,MAAO,qFACjB,KAAK,IAAK,MAAO,gDACjB,KAAK,IAAK,MAAO,iFACjB,KAAK,IAAK,MAAO,yCACjB,KA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SACA,SAOA,SAiCA,IAAiB58D,EAkBLgzB,EAoBAjT,EAqFAriB,EAoRA8B,EAugFAohD,GAt5FZ,SAAiB5gD,GACF,EAAAqb,KAAgB,EAChB,EAAAstC,YAAuB,EACvB,EAAA1oD,IAAe,EACf,EAAAkB,IAAe,EACf,EAAAqgB,IAAe,EACf,EAAAG,IAAe,EACf,EAAA6K,KAAgB,EAChB,EAAAC,QAAmB,EACnB,EAAAC,UAAqB,EACrB,EAAAC,OAAkB,EAClB,EAAAC,MAAiB,GACjB,EAAAC,OAAkB,GAClB,EAAAC,QAAmB,GACnB,EAAA+vC,MAAiB,EAdhC,CAAiB78D,EAAA,EAAAA,UAAA,EAAAA,QAAO,KAkBxB,SAAYgzB,GACV,iBACA,yBACA,uCACA,2BACA,mBACA,gCACA,0BACA,8CACA,6BACA,yCACA,iCACA,kBACA,8BACA,4DACA,qCACA,qBAhBF,CAAYA,EAAA,EAAAA,eAAA,EAAAA,aAAY,KAoBxB,SAAYjT,GACV,yBACA,qBACA,eACA,mBACA,qBACA,uBACA,mBACA,mCACA,2BACA,2BACA,8BACA,8BACA,oBACA,sBACA,sBACA,sBACA,wBACA,wBACA,oBACA,wBACA,gCACA,gCACA,kBACA,kCACA,8BACA,sCACA,gCACA,oCACA,kCACA,kCACA,kCACA,kCACA,kCACA,8BACA,4BACA,8CACA,gCACA,4BACA,gCACA,gCACA,kBACA,0BACA,sBACA,0BACA,sBACA,4BACA,4BACA,8BACA,8BACA,kBACA,sBACA,0BACA,8BACA,oCACA,wBACA,wBACA,0BACA,0BACA,0BACA,oBACA,4BACA,wBACA,8BACA,8BACA,8BACA,4BACA,8BACA,4BACA,4BACA,4BACA,8BACA,sBAxEF,CAAYA,EAAA,EAAAA,eAAA,EAAAA,aAAY,KA4ExB,SAAY+8C,GACV,2BACA,qBACA,uBACA,uBACA,iBALF,CAAY,EAAAA,eAAA,EAAAA,aAAY,KASxB,SAAYp/D,GAEV,uBAEA,uBAEA,uBAEA,uBAEA,6BAEA,6BAEA,uBAEA,uBAEA,uBAEA,uBAEA,0BAEA,0BAEA,4BAEA,4BAEA,4BAEA,4BAEA,gCAEA,gCAEA,0BAEA,0BAEA,wBAEA,wBAEA,wCAEA,wCAEA,oCAEA,sCAEA,sCAEA,sCAEA,sCAEA,sCAEA,sCAEA,sCAEA,sCAEA,kDAEA,kDAEA,0CAEA,0CAEA,0CAEA,0CAEA,0CAEA,0CAEA,0CAEA,0CAEA,0CAEA,wCAEA,kDAEA,kDAKA,gCAEA,kCAEA,gCAEA,kCAEA,kCAKA,4CAEA,4CAEA,4CAEA,4CAEA,4CAEA,4CAEA,4CAEA,4CAKA,gCAEA,gCAEA,gCAEA,gCAEA,gCAEA,gCAEA,0BAEA,kCAEA,4BAEA,4BAEA,oCAEA,oCAEA,kCAEA,4BAEA,4BAEA,oCAEA,oCAEA,4BAEA,4BAEA,oCAEA,oCAEA,4BAEA,4BAEA,oCAEA,oCAEA,4BAEA,4BAEA,8BAEA,8BAEA,gCAEA,gCAEA,oCAEA,4BAEA,4BAEA,8BAEA,8BAEA,gCAEA,gCAEA,oCAEA,gEAEA,iEAEA,iEAEA,iEAEA,qDAEA,qDAEA,mDAEA,mDAEA,uDAEA,yDAEA,uDAEA,yDAEA,uDAEA,yDAEA,uDAEA,yDAEA,uDAEA,yDAEA,uDAEA,yDAEA,yDAEA,yDAEA,6DAEA,6DAEA,yDAEA,yDAEA,uBAKA,2BAEA,2BAEA,iCAEA,2BAhRF,CAAYA,EAAA,EAAAA,UAAA,EAAAA,QAAO,KAoRnB,SAAY8B,GAEV,uBAEA,uBAEA,uBAEA,uBAEA,uBAEA,uBAEA,uBAEA,uBAEA,qBAEA,uBAEA,wBAEA,wBAEA,wBAEA,0BAEA,0BAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,wBAEA,wBAEA,wBAEA,wBAEA,wBAEA,wBAEA,wBAEA,wBAEA,sBAEA,wBAEA,wBAEA,wBAEA,wBAEA,0BAEA,0BAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,wBAEA,wBAEA,wBAEA,wBAEA,kCAEA,wBAEA,wBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,wBAEA,wBAEA,wBAEA,wBAEA,kCAEA,wBAEA,wBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAEA,sBAKA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,0BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,yBAEA,2BAEA,iCAEA,6BAEA,mCAEA,mCAEA,6BAEA,mCAEA,mCAEA,6BAEA,6BAEA,6BAEA,6BAEA,+BAEA,6BAEA,mCAEA,mCAEA,6BAEA,mCAEA,mCAEA,6BAEA,6BAEA,6BAEA,6BAEA,6BAEA,+BAEA,2CAEA,yCAEA,2CAEA,yCAEA,2CAEA,6BAEA,6BAEA,6BAEA,6BAEA,6BAEA,6BAEA,6BAEA,6BAEA,yCAEA,2CAEA,yCAEA,2CAEA,6BAEA,6BAEA,6BAEA,yCAEA,2CAEA,yCAEA,2CAEA,6BAEA,6BAEA,6BAEA,6BAEA,6BAEA,6BAEA,+BAEA,+BAEA,6BAEA,6BAEA,6BAEA,6BAEA,6BAEA,6BAEA,+BAEA,+BAEA,iDAEA,iDAEA,iDAEA,iDAEA,qCAEA,uBAKA,2BAEA,2BAEA,2BAEA,6BAEA,6BAEA,6BAEA,6BAEA,2BAEA,yBAEA,2BAEA,2BAEA,6BAEA,6BAEA,6BAEA,6BAEA,yBAEA,yBAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAlcF,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KAscpB,SAAYwG,GAEV,iBAEA,iBAEA,iBAEA,eAEA,iBAEA,mBAZF,CAAY,EAAAA,cAAA,EAAAA,YAAW,KAgBvB,SAAY4C,GAEV,2CAEA,2CAEA,2CAEA,2CAEA,2CAEA,2CAEA,2CAEA,2CAhBF,CAAY,EAAAA,gBAAA,EAAAA,cAAa,KAoBzB,SAAYW,GAEV,2CAEA,2CAEA,2CAEA,2CAEA,2CAEA,2CAZF,CAAY,EAAAA,gBAAA,EAAAA,cAAa,KAgBzB,SAAYiO,GAEV,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,2BAEA,4BAEA,4BAxBF,CAAY,EAAAA,cAAA,EAAAA,YAAW,KA4BvB,SAAY7M,GAEV,+BAEA,iCAEA,iCAEA,iCAEA,2BAEA,2BAEA,6BAEA,6BAEA,6BAEA,6BAEA,gCAEA,gCAxBF,CAAY,EAAAA,aAAA,EAAAA,WAAU,KA4BtB,SAAYiB,GAEV,6BAEA,+BAEA,+BAEA,+BAEA,+BAEA,iCAEA,iCAEA,iCAhBF,CAAY,EAAAA,sBAAA,EAAAA,oBAAmB,KAoB/B,SAAYqa,GAEV,6BAFF,CAAY,EAAAA,gBAAA,EAAAA,cAAa,KAMzB,SAAYnC,GAEV,6BAEA,6BAEA,6BAEA,2BARF,CAAY,EAAAA,UAAA,EAAAA,QAAO,KAYnB,SAAYi5C,GAEV,mCAEA,6BAEA,6BAEA,2BARF,CAAY,EAAAA,UAAA,EAAAA,QAAO,KAYnB,SAAYC,GAEV,2BAEA,2BAEA,2BAEA,2BAEA,yBAVF,CAAY,EAAAA,SAAA,EAAAA,OAAM,KAclB,SAAYr1D,GACV,yBACA,iDACA,qCAHF,CAAY,EAAAA,wBAAA,EAAAA,sBAAqB,KAMjC,sBACE7hC,YAES88D,EAEA1gB,GAFA,KAAA0gB,OAAAA,EAEA,KAAA1gB,OAAAA,IAIX,MAAa0Q,EACX9sD,YAES84E,EAEAqe,EAEAC,GAJA,KAAAte,IAAAA,EAEA,KAAAqe,eAAAA,EAEA,KAAAC,SAAAA,EA8wBD,KAAAC,sBAA6B,EA4mB7B,KAAAC,wBAA6C,IAAIr+C,IACjD,KAAAs+C,wBAAoD,IAAIt+C,IAz3C9DztC,OAAO4rF,GAAYl9D,EAAQC,KAAOi9D,GAAYl9D,EAAQmB,KACtD57B,KAAK+3F,IAAMC,EAASC,QAAQD,EAASE,0BAKvCx3F,cAAcg3F,EAAsBC,GAClC,OAAO,IAAItqC,EAAO2qC,EAASG,wBAAyBT,EAAgBC,GAGtEj3F,kBAAkB28D,EAAoBq6B,EAAsBC,GAC1D,IAAIS,EAAOC,EAAah7B,GACpB19D,EAAS,IAAI0tD,EAAO2qC,EAASM,oBAAoBF,EAAM/6B,EAAO7xD,QAASksF,EAAgBC,GAE3F,OADAK,EAASO,MAAMxuF,WAAkBquF,IAC1Bz4F,EAKTwZ,IAAI3V,GACF,IAAIg1F,EAAMx4F,KAAK+3F,IAEf,OADAC,EAASS,sBAAsBD,EAAKh1F,GAC7Bw0F,EAASU,eAAe14F,KAAKq5E,IAAKmf,GAG3Cp/E,IAAIu/E,EAAeC,EAAiB,GAClC,IAAIJ,EAAMx4F,KAAK+3F,IAEf,OADAC,EAASa,sBAAsBL,EAAKG,EAAUC,GACvCZ,EAASU,eAAe14F,KAAKq5E,IAAKmf,GAgB3C9+E,MAASlW,GACP,OAAIs1F,OAAOt1F,GACLxD,KAAK23F,UAAYl9D,EAAQmB,IACpB57B,KAAKoZ,IAAI+/B,QAAQ31C,GAAQ61C,SAAS71C,KAE3CuI,OAAOqtC,WAAW51C,IACXxD,KAAKmZ,IAAIggC,QAAQ31C,KAEnBxD,KAAK23F,UAAYl9D,EAAQmB,IAC5B57B,KAAKoZ,IAAID,IAAI3V,IACbxD,KAAKmZ,IAAIA,IAAI3V,IAGnBoW,IAAIpW,GACF,IAAIg1F,EAAMx4F,KAAK+3F,IAEf,OADAC,EAASe,wBAAwBP,EAAKh1F,GAC/Bw0F,EAASU,eAAe14F,KAAKq5E,IAAKmf,GAG3C3+E,IAAIrW,GACF,IAAIg1F,EAAMx4F,KAAK+3F,IAEf,OADAC,EAASgB,wBAAwBR,EAAKh1F,GAC/Bw0F,EAASU,eAAe14F,KAAKq5E,IAAKmf,GAG3C1+E,KAAKmoB,GACHl2B,OAAuB,IAAhBk2B,EAAMz2B,QACb,IAAIgtF,EAAMx4F,KAAK+3F,IACf,IAAK,IAAItsF,EAAI,EAAGA,EAAI,KAAMA,EACxBusF,EAASiB,aAAaT,EAAM/sF,EAAGw2B,EAAMx2B,IAGvC,OADAusF,EAASkB,uBAAuBV,EAAKA,GAC9BR,EAASU,eAAe14F,KAAKq5E,IAAKmf,GAG3CtT,SAASxjF,GACP,OAAOs2F,EAASmB,iBAAiBn5F,KAAKq5E,IAAK33E,GAG7CgwE,OAAO9uE,EAAqBC,GAC1B,OAAOm1F,EAASoB,eAAep5F,KAAKq5E,IAAKz2E,EAAMC,GAKjDq1B,MACE8D,EACAx4B,GAEA,GAAIw4B,EAAK7D,EAAQkhE,MAAO,CACtB,IAAIC,EAAUt5F,KAAK23F,UAAYl9D,EAAQmB,IACvC,OAAQI,GACN,KAAK7D,EAAQohE,QAAS,OAAOv5F,KAAKk4B,MAAMohE,EAAUnhE,EAAQI,OAASJ,EAAQC,OAAQ50B,GACnF,KAAK20B,EAAQqhE,QAAS,OAAOx5F,KAAKk4B,MAAMohE,EAAUnhE,EAAQY,OAASZ,EAAQW,OAAQt1B,GACnF,KAAK20B,EAAQshE,WAAY,OAAOz5F,KAAKk4B,MAAMohE,EAAUnhE,EAAQe,UAAYf,EAAQc,UAAWz1B,GAC5F,KAAK20B,EAAQuhE,QAAS,OAAO15F,KAAKk4B,MAAMohE,EAAUnhE,EAAQkmB,OAASlmB,EAAQimB,OAAQ56C,GAErFuI,QAAO,GAET,OAAOisF,EAAS2B,eAAe35F,KAAKq5E,IAAKr9C,EAAIx4B,GAG/Cw2B,OACEgC,EACAp5B,EACAC,GAEA,GAAIm5B,EAAK/B,EAASo/D,MAAO,CACvB,IAAI/gE,EAAWt4B,KAAK23F,UAAYl9D,EAAQmB,IACxC,OAAQI,GACN,KAAK/B,EAAS2/D,QAAS,OAAO55F,KAAKg6B,OAAO1B,EAAW2B,EAASwB,OAASxB,EAASoB,OAAQz4B,EAAMC,GAC9F,KAAKo3B,EAAS4/D,QAAS,OAAO75F,KAAKg6B,OAAO1B,EAAW2B,EAAS4nB,OAAS5nB,EAASU,OAAQ/3B,EAAMC,GAC9F,KAAKo3B,EAAS6/D,QAAS,OAAO95F,KAAKg6B,OAAO1B,EAAW2B,EAAS83C,OAAS93C,EAAS63C,OAAQlvE,EAAMC,GAC9F,KAAKo3B,EAAS8/D,SAAU,OAAO/5F,KAAKg6B,OAAO1B,EAAW2B,EAASs4C,OAASt4C,EAASq4C,OAAQ1vE,EAAMC,GAC/F,KAAKo3B,EAAS+/D,SAAU,OAAOh6F,KAAKg6B,OAAO1B,EAAW2B,EAASw4C,OAASx4C,EAASu4C,OAAQ5vE,EAAMC,GAC/F,KAAKo3B,EAASggE,SAAU,OAAOj6F,KAAKg6B,OAAO1B,EAAW2B,EAAS44C,OAAS54C,EAAS24C,OAAQhwE,EAAMC,GAC/F,KAAKo3B,EAASigE,SAAU,OAAOl6F,KAAKg6B,OAAO1B,EAAW2B,EAAS84C,OAAS94C,EAAS64C,OAAQlwE,EAAMC,GAC/F,KAAKo3B,EAASkgE,QAAS,OAAOn6F,KAAKg6B,OAAO1B,EAAW2B,EAASi5C,OAASj5C,EAASI,OAAQz3B,EAAMC,GAC9F,KAAKo3B,EAASmgE,OAAQ,OAAOp6F,KAAKg6B,OAAO1B,EAAW2B,EAASk5C,MAAQl5C,EAASC,MAAOt3B,EAAMC,GAC3F,KAAKo3B,EAASogE,QAAS,OAAOr6F,KAAKg6B,OAAO1B,EAAW2B,EAASuB,OAASvB,EAASmB,OAAQx4B,EAAMC,GAC9F,KAAKo3B,EAASqgE,QAAS,OAAOt6F,KAAKg6B,OAAO1B,EAAW2B,EAAS+4C,OAAS/4C,EAASE,OAAQv3B,EAAMC,GAC9F,KAAKo3B,EAASsgE,SAAU,OAAOv6F,KAAKg6B,OAAO1B,EAAW2B,EAASyB,OAASzB,EAASqB,OAAQ14B,EAAMC,GAC/F,KAAKo3B,EAASugE,SAAU,OAAOx6F,KAAKg6B,OAAO1B,EAAW2B,EAASg5C,OAASh5C,EAASM,OAAQ33B,EAAMC,GAC/F,KAAKo3B,EAASwgE,SAAU,OAAOz6F,KAAKg6B,OAAO1B,EAAW2B,EAASa,QAAUb,EAASY,QAASj4B,EAAMC,GACjG,KAAKo3B,EAASygE,SAAU,OAAO16F,KAAKg6B,OAAO1B,EAAW2B,EAASgB,QAAUhB,EAASe,QAASp4B,EAAMC,GACjG,KAAKo3B,EAAS0gE,OAAQ,OAAO36F,KAAKg6B,OAAO1B,EAAW2B,EAASw3C,MAAQx3C,EAASuqC,MAAO5hE,EAAMC,GAC3F,KAAKo3B,EAAS2gE,OAAQ,OAAO56F,KAAKg6B,OAAO1B,EAAW2B,EAASgwC,MAAQhwC,EAAS03C,MAAO/uE,EAAMC,GAC3F,KAAKo3B,EAAS4gE,QAAS,OAAO76F,KAAKg6B,OAAO1B,EAAW2B,EAAS2C,MAAQ3C,EAASyC,MAAO95B,EAAMC,GAC5F,KAAKo3B,EAAS6gE,QAAS,OAAO96F,KAAKg6B,OAAO1B,EAAW2B,EAAS4C,MAAQ5C,EAAS0C,MAAO/5B,EAAMC,GAC5F,KAAKo3B,EAAS8gE,QAAS,OAAO/6F,KAAKg6B,OAAO1B,EAAW2B,EAAS62C,MAAQ72C,EAAS42C,MAAOjuE,EAAMC,GAC5F,KAAKo3B,EAAS+gE,QAAS,OAAOh7F,KAAKg6B,OAAO1B,EAAW2B,EAAS+2C,MAAQ/2C,EAAS82C,MAAOnuE,EAAMC,GAC5F,KAAKo3B,EAASghE,QAAS,OAAOj7F,KAAKg6B,OAAO1B,EAAW2B,EAASkC,MAAQlC,EAASgC,MAAOr5B,EAAMC,GAC5F,KAAKo3B,EAASihE,QAAS,OAAOl7F,KAAKg6B,OAAO1B,EAAW2B,EAASmC,MAAQnC,EAASiC,MAAOt5B,EAAMC,GAC5F,KAAKo3B,EAASkhE,QAAS,OAAOn7F,KAAKg6B,OAAO1B,EAAW2B,EAASm3C,MAAQn3C,EAASk3C,MAAOvuE,EAAMC,GAC5F,KAAKo3B,EAASmhE,QAAS,OAAOp7F,KAAKg6B,OAAO1B,EAAW2B,EAASq3C,MAAQr3C,EAASo3C,MAAOzuE,EAAMC,GAE9FkJ,QAAO,GAET,OAAOisF,EAASqD,gBAAgBr7F,KAAKq5E,IAAKr9C,EAAIp5B,EAAMC,GAGtDszB,cACE,OAAO6hE,EAASsD,oBAAoBt7F,KAAKq5E,KAG3CjjD,YAAYmlE,GACV,OAAOvD,EAASwD,oBAAoBx7F,KAAKq5E,IAAKkiB,GAGhDE,WAAW96F,GACT,IAAI+6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAAS4D,mBAAmB57F,KAAKq5E,IAAKqiB,GAG/CG,WAAWl7F,EAAc46F,EAAsB/3F,EAAuB,GACpE,IAAIk4F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAAS8D,mBAAmB97F,KAAKq5E,IAAKqiB,EAAMl4F,EAAO+3F,GAG5D/gE,UACEb,EACAj4B,GAEA,OAAOs2F,EAAS+D,kBAAkB/7F,KAAKq5E,IAAK1/C,EAAOj4B,GAGrDk0B,QAAQpyB,GACN,GAAIxD,KAAK03F,eAAgB,CACvB,IAAIh2F,EAAOs2F,EAASgE,2BAA2Bx4F,GAE/C,OADAuI,OAAOrK,GAAQ+4B,EAAQC,KAAOh5B,GAAQ+4B,EAAQ2oD,aACvCpjF,KAAK41C,KAAK,EAAA3gC,aAAa2gB,QAAS,CAAEpyB,GAAS9B,GAEpD,OAAO8B,EAGT42B,UACET,EACAn2B,EACA4S,EACA1U,EAAgB+4B,EAAQ68D,MAMxB,OAJI51F,GAAQ+4B,EAAQ68D,OAAM51F,EAAOs2F,EAASgE,2BAA2Bx4F,IACjE4S,GAAapW,KAAK03F,iBACpBl0F,EAAQxD,KAAK41B,QAAQpyB,IAEhBw0F,EAASiE,kBAAkBj8F,KAAKq5E,IAAK1/C,EAAOn2B,EAAO9B,GAG5Dw/C,WACEvgD,EACAe,GAEA,IAAIg6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAASkE,mBAAmBl8F,KAAKq5E,IAAKqiB,EAAMh6F,GAGrDy6F,UACEx7F,EACAg5B,EACAj4B,GAEA,IAAIg6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAASoE,kBAAkBp8F,KAAKq5E,IAAKqiB,EAAM/hE,EAAOj4B,GAG3D+V,KACEwqB,EACAgzD,EACAt3B,EACAj8D,EACAi7C,EAAgB,EAChBvE,EAAenW,GAEf,OAAO+1D,EAASqE,cAAcr8F,KAAKq5E,IAAKp3C,EAAOgzD,EAAQt4C,EAAQvE,EAAO12C,EAAMi8D,GAG9EjmD,MACEuqB,EACA07B,EACAn6D,EACA9B,EACAi7C,EAAgB,EAChBvE,EAAenW,GAEf,OAAO+1D,EAASsE,eAAet8F,KAAKq5E,IAAKp3C,EAAO0a,EAAQvE,EAAOulB,EAAKn6D,EAAO9B,GAG7EiW,YACEsqB,EACA07B,EACAj8D,EACAi7C,EAAgB,GAEhB,OAAOq7C,EAASuE,oBAAoBv8F,KAAKq5E,IAAKp3C,EAAO0a,EAAQj7C,EAAMi8D,GAGrE/lD,aACEqqB,EACA07B,EACAn6D,EACA9B,EACAi7C,EAAgB,GAEhB,OAAOq7C,EAASwE,qBAAqBx8F,KAAKq5E,IAAKp3C,EAAO0a,EAAQghB,EAAKn6D,EAAO9B,GAG5E6+B,WACEvE,EACAiG,EACA0a,EACAghB,EACAn6D,EACA9B,GAEA,OAAOs2F,EAASyE,mBAAmBz8F,KAAKq5E,IAAKr9C,EAAIiG,EAAO0a,EAAQghB,EAAKn6D,EAAO9B,GAG9EyW,eACE8pB,EACA0a,EACAghB,EACA9kB,EACA6jD,EACAh7F,GAEA,OAAOs2F,EAAS2E,uBAAuB38F,KAAKq5E,IAAKp3C,EAAO0a,EAAQghB,EAAK9kB,EAAU6jD,EAAah7F,GAG9F0W,YACEulD,EACA9kB,EACA+jD,EACAhf,GAEA,OAAOoa,EAAS6E,oBAAoB78F,KAAKq5E,IAAK1b,EAAK9kB,EAAU+jD,EAAShf,GAGxEvlE,cACEslD,EACAm/B,GAEA,OAAO9E,EAAS+E,sBAAsB/8F,KAAKq5E,IAAK1b,EAAKm/B,GAGvDxkF,eACE,OAAO0/E,EAASgF,qBAAqBh9F,KAAKq5E,KAK5ClW,UACExpC,EACAn2B,EACA4S,GAKA,OAHIA,GAAapW,KAAK03F,iBACpBl0F,EAAQxD,KAAK41B,QAAQpyB,IAEhBw0F,EAASiF,kBAAkBj9F,KAAKq5E,IAAK1/C,EAAOn2B,GAGrD+uD,WACE5xD,EACA6C,GAEA,IAAIk4F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAASkF,mBAAmBl9F,KAAKq5E,IAAKqiB,EAAMl4F,GAGrD25F,UACEx8F,EACAg5B,EACAn2B,GAEA,IAAIk4F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAASoF,kBAAkBp9F,KAAKq5E,IAAKqiB,EAAM/hE,EAAOn2B,GAG3D29C,MACEr7C,EACAu3F,EACA37F,EAAgB+4B,EAAQqb,MAExB,IAAI4lD,EAAO17F,KAAK27F,kBAAkB71F,GAC9BsyF,EAAOkF,EAAcD,GACrBtjE,EAAMi+D,EAASuF,eAAev9F,KAAKq5E,IAAKqiB,EAAMtD,EAAMiF,EAAS7xF,OAAQ9J,GAEzE,OADAs2F,EAASO,MAAMH,GACRr+D,EAIT0d,QACEoL,EACAnhD,EAAgB+4B,EAAQqb,MAExB,IAAItqC,EAASq3C,EAAMr3C,OACnB,GAAc,GAAVA,EAAa,OAAOxL,KAAK8hC,MAC7B,GAAc,GAAVt2B,EAAa,CACf,IAAIgyF,EAAS36C,EAAM,GACnB,OAAQtI,EAAgBijD,IACtB,KAAKhjD,EAAaijD,OAClB,KAAKjjD,EAAakjD,MAClB,KAAKljD,EAAa4oC,YAEhB,OAAOoa,EAGX,IAAIG,EAAa3/C,EAAkBw/C,GAEnC,OADAzxF,OAAO4xF,GAAcljE,EAAQ2oD,aAAeua,GAAcj8F,GACnD87F,EAET,OAAOx9F,KAAKmhD,MAAM,KAAM0B,EAAOnhD,GAGjCggE,GACE57D,EACAnB,EAA2B,EAC3BnB,EAAuB,GAEvB,IAAIk4F,EAAO17F,KAAK27F,kBAAkB71F,GAClC,OAAOkyF,EAAS4F,eAAe59F,KAAKq5E,IAAKqiB,EAAM/2F,EAAWnB,GAG5Dk/D,KACElgE,GAEA,OAAOw1F,EAAS6F,cAAc79F,KAAKq5E,IAAK72E,GAG1Cq5C,mBAAmBl3C,EAA0Bm5F,GAK3C,OAAmG,IAA9F1iB,EAAez2E,EAAW3E,KAAKq5E,OAASgC,EAAY0iB,WAAa1iB,EAAY2iB,cACzEh+F,KAAKmhD,MAAM,KAAM,CACtBnhD,KAAK0iE,KAAK/9D,GACVm5F,GACC9/C,EAAkB8/C,IAEhBA,EAGT/6B,KACEj9D,EACAwC,GAEA,IAAIozF,EAAO17F,KAAK27F,kBAAkB71F,GAClC,OAAOkyF,EAASiG,cAAcj+F,KAAKq5E,IAAKqiB,EAAMpzF,GAGhDgvC,GACE3yC,EACA2C,EACAC,EAAyB,GAEzB,OAAOywF,EAASkG,YAAYl+F,KAAKq5E,IAAK10E,EAAW2C,EAAQC,GAG3Du6B,MACE,OAAOk2D,EAASmG,aAAan+F,KAAKq5E,KAGpC33B,OACEl/C,EAA4B,GAE5B,OAAOw1F,EAASoG,gBAAgBp+F,KAAKq5E,IAAK72E,GAG5CoW,OACEtR,EACAC,EACA5C,EACAjD,GAEA,OAAOs2F,EAASqG,gBAAgBr+F,KAAKq5E,IAAK10E,EAAW2C,EAAQC,EAAS7F,GAGxEkgD,OACE39C,EACAq6F,EACA35F,EACAnB,EAAuB,GAEvB,IAAIy1E,EAAWh1E,EAAMuH,OACjB+yF,EAAO,IAAInuF,MAAiB6oE,GAChC,IAAK,IAAIxtE,EAAI,EAAGA,EAAIwtE,IAAYxtE,EAC9B8yF,EAAK9yF,GAAKzL,KAAK27F,kBAAkB13F,EAAMwH,IAEzC,IAAI2sF,EAAOkF,EAAciB,GACrB7C,EAAO17F,KAAK27F,kBAAkB2C,GAC9BvkE,EAAMi+D,EAASwG,gBAAgBx+F,KAAKq5E,IAAK+e,EAAMnf,EAAUyiB,EAAM/2F,EAAWnB,GAE9E,OADAw0F,EAASO,MAAMH,GACRr+D,EAGT6b,KACE8T,EACA5xB,EACA52B,EACAu9F,GAAiB,GAEjB,IAAI/C,EAAO17F,KAAK27F,kBAAkBjyC,GAC9B0uC,EAAOkF,EAAcxlE,GACrBiC,EAAM0kE,EACNzG,EAAS0G,oBACP1+F,KAAKq5E,IAAKqiB,EAAMtD,EAAMtgE,EAAWA,EAAStsB,OAAS,EAAGtK,GAExD82F,EAAS2G,cACP3+F,KAAKq5E,IAAKqiB,EAAMtD,EAAMtgE,EAAWA,EAAStsB,OAAS,EAAGtK,GAG5D,OADA82F,EAASO,MAAMH,GACRr+D,EAGT6kE,YACEl1C,EACA5xB,EACA52B,GAEA,OAAOlB,KAAK41C,KAAK8T,EAAQ5xB,EAAU52B,GAAY,GAGjD4X,cACE+lF,EACAllE,EACA7B,EACAgnE,EACAC,EACAN,GAAiB,GAEjB,IAAI/C,EAAO17F,KAAK27F,kBAAgC,OAAdkD,EAAqBA,EAAY,KAC/DzG,EAAOkF,EAAcxlE,GACrBiC,EAAM0kE,EACNzG,EAASgH,4BACPh/F,KAAKq5E,IAAKqiB,EAAM/hE,EAAOy+D,EAAMtgE,EAAWA,EAAStsB,OAAS,EAAGszF,EAAQC,GAEvE/G,EAASiH,sBACPj/F,KAAKq5E,IAAKqiB,EAAM/hE,EAAOy+D,EAAMtgE,EAAWA,EAAStsB,OAAS,EAAGszF,EAAQC,GAG3E,OADA/G,EAASO,MAAMH,GACRr+D,EAGTmlE,qBACEL,EACAllE,EACA7B,EACAgnE,EACAC,GAEA,OAAO/+F,KAAK8Y,cAAc+lF,EAAWllE,EAAO7B,EAAUgnE,EAAQC,GAAS,GAGzElmF,cACE,OAAOm/E,EAASmH,qBAAqBn/F,KAAKq5E,KAK5ChjD,YACE+oE,EACApuF,EACAspB,GAEA,OAAO09D,EAASqH,oBAAoBr/F,KAAKq5E,IAAK+lB,EAAMpuF,EAAQspB,GAG9DhE,YACE8oE,EACA57F,EACA82B,GAEA,OAAO09D,EAASsH,oBAAoBt/F,KAAKq5E,IAAK+lB,EAAM57F,EAAO82B,GAK7DilE,IACE5+F,EACA2H,EACAk3F,EACAC,EACAC,EAAgC,MAEhC,IAAIC,EAAeH,EAAUh0F,OACzB+yF,EAAO,IAAInuF,MAAcuvF,GAC7B,IAAK,IAAIl0F,EAAI,EAAGA,EAAIk0F,IAAgBl0F,EAClC8yF,EAAK9yF,GAAKzL,KAAK27F,kBAAkB6D,EAAU/zF,IAE7C,IAAIm0F,EAAQtC,EAAciB,GACtBsB,EAAQvC,EAAcmC,GACtBK,EAAQ9/F,KAAK27F,kBAAkBh7F,GAC/Bo/F,EAAQ//F,KAAK27F,kBAAkB+D,GAC/B3lE,EAAMi+D,EAASgI,aACjBhgG,KAAKq5E,IAAKymB,EAAOx3F,EAAMs3F,EAAOD,EAAcE,EAAOJ,EAAYj0F,OAAQu0F,GAIzE,OAFA/H,EAASO,MAAMsH,GACf7H,EAASO,MAAMqH,GACR7lE,EAGTkmE,MACEC,EACApoE,GAEA,IAAI4jE,EAAO17F,KAAK27F,kBAAkBuE,GAC9B9H,EAAOkF,EAAcxlE,GACrBiC,EAAMi+D,EAASmI,eAAengG,KAAKq5E,IAAKqiB,EAAMtD,EAAMtgE,EAAStsB,QAEjE,OADAwsF,EAASO,MAAMH,GACRr+D,EAGTqmE,QACE12C,GAEA,IAAIgyC,EAAO17F,KAAK27F,kBAAkBjyC,GAClC,OAAOsuC,EAASqI,iBAAiBrgG,KAAKq5E,IAAKqiB,GAK7CrkB,IACE31E,GAEA,OAAOs2F,EAASsI,aAAatgG,KAAKq5E,IAAK33E,GAGzC6+F,WAAWzoE,GACT,IAAIsgE,EAAOkF,EAAcxlE,GACrBiC,EAAMi+D,EAASwI,mBAAmBxgG,KAAKq5E,IAAK+e,EAAMtgE,EAAStsB,QAE/D,OADAwsF,EAASO,MAAMH,GACRr+D,EAGT0mE,cAAcC,EAAsB/mE,GAClC,OAAOq+D,EAAS2I,sBAAsB3gG,KAAKq5E,IAAKqnB,EAAO/mE,GAKzDyJ,aACEpH,EACA4kE,EACA39D,GAEA,OAAO+0D,EAAS6I,qBAAqB7gG,KAAKq5E,IAAKr9C,EAAI4kE,EAAK39D,GAG1Dc,aACE/H,EACA4kE,EACA39D,EACAz/B,GAEA,OAAOw0F,EAAS8I,qBAAqB9gG,KAAKq5E,IAAKr9C,EAAI4kE,EAAK39D,EAAKz/B,GAG/DuhC,aACEg8D,EACAC,EACAr8D,GAEA54B,OAAsB,IAAf44B,EAAKn5B,QACZ,IAAI4sF,EAAOC,EAAa1zD,GACpB5K,EAAMi+D,EAASiJ,qBAAqBjhG,KAAKq5E,IAAK0nB,EAAMC,EAAM5I,GAE9D,OADAJ,EAASO,MAAMH,GACRr+D,EAGTymB,aACExkB,EACAu+C,EACAC,EACA0mB,GAEA,OAAOlJ,EAASmJ,qBAAqBnhG,KAAKq5E,IAAKr9C,EAAIu+C,EAAGC,EAAG0mB,GAG3DlvD,WACEhW,EACA4kE,EACAphD,GAEA,OAAOw4C,EAASoJ,mBAAmBphG,KAAKq5E,IAAKr9C,EAAI4kE,EAAKphD,GAGxDra,UACEnJ,EACA2hC,EACAhhB,EACAvE,GAEA,OAAO4/C,EAASqJ,kBAAkBrhG,KAAKq5E,IAAKr9C,EAAI2gB,EAAQvE,EAAOulB,GAGjEv3B,mBACEpK,EACA2hC,EACAhhB,EACAvE,EACAze,EACAinE,GAEA,OAAO5I,EAASsJ,2BAA2BthG,KAAKq5E,IAAKr9C,EAAI2gB,EAAQvE,EAAOze,EAAOgkC,EAAKijC,GAKtFtiD,OACEtiB,EACAt2B,GAEA,OAAOsyF,EAASuJ,eAAevhG,KAAKq5E,IAAKr9C,EAAIt2B,GAG/C87F,OACExlE,EACAt2B,GAEA,OAAOsyF,EAASyJ,eAAezhG,KAAKq5E,IAAKr9C,EAAIt2B,GAG/C63E,SACE58E,EACAe,GAEA,IAAIg6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAAS0J,iBAAiB1hG,KAAKq5E,IAAKqiB,EAAMh6F,GAGnD0zB,QACE5xB,GAEA,OAAOw0F,EAAS2J,gBAAgB3hG,KAAKq5E,IAAK71E,GAG5C6xB,QACE3vB,EACAuvF,GAEA,OAAO+C,EAAS4J,gBAAgB5hG,KAAKq5E,IAAK3zE,EAAMuvF,GAKlDtyC,UACEhiD,EACAe,EACAmgG,EACAlgG,GAEA,IAAI+5F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAAS8J,mBAAmB9hG,KAAKq5E,IAAKqiB,EAAMh6F,EAAMmgG,EAASlgG,GAGpE23D,UACE34D,GAEA,IAAI+6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAAS+J,mBAAmB/hG,KAAKq5E,IAAKqiB,GAG/C9qC,aACEjwD,GAEA,IAAI+6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClCq3F,EAASgK,sBAAsBhiG,KAAKq5E,IAAKqiB,GAK3CuG,OACEthG,EACAm+F,EACAC,GAEA,IAAIrD,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAASkK,gBAAgBliG,KAAKq5E,IAAKqiB,EAAMoD,EAAQC,GAG1DoD,OACExhG,GAEA,IAAI+6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAASoK,gBAAgBpiG,KAAKq5E,IAAKqiB,GAG5C2G,UACE1hG,GAEA,IAAI+6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClCq3F,EAASsK,mBAAmBtiG,KAAKq5E,IAAKqiB,GAKxCnkD,YACE52C,EACAm+F,EACAC,EACApnC,EACArvD,GAEA,IAAIozF,EAAO17F,KAAK27F,kBAAkBh7F,GAC9By3F,EAAOkF,EAAc3lC,GACrB59B,EAAMi+D,EAASuK,qBACjBviG,KAAKq5E,IACLqiB,EACAoD,EACAC,EACA3G,EACAzgC,EAAWA,EAASnsD,OAAS,EAC7BlD,GAGF,OADA0vF,EAASO,MAAMH,GACRr+D,EAGTwhC,YACE56D,GAEA,IAAI+6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAOq3F,EAASwK,qBAAqBxiG,KAAKq5E,IAAKqiB,GAGjDhhB,eAAe/5E,GACb,IAAI+6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClCq3F,EAASyK,wBAAwBziG,KAAKq5E,IAAKqiB,GAG7CgH,YAAY/hG,GACV,IAAI+6F,EAAO17F,KAAK27F,kBAAkBh7F,GAClC,OAAwD,GAAjDq3F,EAASwK,qBAAqBxiG,KAAKq5E,IAAKqiB,GAKjDiH,qBACE7E,EACA8E,EACAt6F,GAEAtI,KAAK43F,qBAAuB7rF,QAAQ/L,KAAK43F,sBACzC,IAAIiL,EAAW7iG,KAAK27F,kBAAkB,IAClCvD,EAAOkF,EAAcsF,GACrB7oE,EAAMi+D,EAASuK,qBAAqBviG,KAAKq5E,IAC3CwpB,EACArrD,EAAWorD,GACX9E,EACA,EAAG,EACHx1F,GAGF,OADA0vF,EAASO,MAAMH,GACRr+D,EAGT+oE,0BACE9iG,KAAK43F,sBAAwB7rF,OAAO/L,KAAK43F,sBACzC,IAAIiL,EAAW7iG,KAAK27F,kBAAkB,IACtC3D,EAASyK,wBAAwBziG,KAAKq5E,IAAKwpB,GAG7C3vC,SAAS6vC,GACP/K,EAASgL,kBAAkBhjG,KAAKq5E,IAAK0pB,GAKvCpzC,kBACE9Z,EACA7uC,GAEA,IAAI84F,EAAQ9/F,KAAK27F,kBAAkB9lD,GAC/BkqD,EAAQ//F,KAAK27F,kBAAkB30F,GACnC,OAAOgxF,EAASiL,2BAA2BjjG,KAAKq5E,IAAKymB,EAAOC,GAG9D7tC,eACErc,EACA7uC,GAEA,IAAI84F,EAAQ9/F,KAAK27F,kBAAkB9lD,GAC/BkqD,EAAQ//F,KAAK27F,kBAAkB30F,GACnC,OAAOgxF,EAASkL,wBAAwBljG,KAAKq5E,IAAKymB,EAAOC,GAG3DoD,gBACEttD,EACA7uC,GAEA,IAAI84F,EAAQ9/F,KAAK27F,kBAAkB9lD,GAC/BkqD,EAAQ//F,KAAK27F,kBAAkB30F,GACnC,OAAOgxF,EAASoL,yBAAyBpjG,KAAKq5E,IAAKymB,EAAOC,GAG5DjwC,gBACEja,EACA7uC,GAEA,IAAI84F,EAAQ9/F,KAAK27F,kBAAkB9lD,GAC/BkqD,EAAQ//F,KAAK27F,kBAAkB30F,GACnC,OAAOgxF,EAASqL,yBAAyBrjG,KAAKq5E,IAAKymB,EAAOC,GAG5DuD,aACEztD,EACA7uC,GAEA,IAAI84F,EAAQ9/F,KAAK27F,kBAAkB9lD,GAC/BkqD,EAAQ//F,KAAK27F,kBAAkB30F,GACnC,OAAOgxF,EAASuL,sBAAsBvjG,KAAKq5E,IAAKymB,EAAOC,GAGzDyD,aAAax8F,GACX,IAAI00F,EAAO17F,KAAK27F,kBAAkB30F,GAClCgxF,EAASyL,sBAAsBzjG,KAAKq5E,IAAKqiB,GAG3ChsC,UAAU1oD,GACR,IAAI00F,EAAO17F,KAAK27F,kBAAkB30F,GAClC,OAAsD,GAA/CgxF,EAAS0L,mBAAmB1jG,KAAKq5E,IAAKqiB,GAK/CpgC,kBACEzlB,EACA8tD,EACAC,EACA9E,EACAC,GAEA,IAAIe,EAAQ9/F,KAAK27F,kBAAkB9lD,GAC/BkqD,EAAQ//F,KAAK27F,kBAAkBgI,GAC/BE,EAAQ7jG,KAAK27F,kBAAkBiI,GACnC5L,EAAS8L,2BAA2B9jG,KAAKq5E,IAAKymB,EAAOC,EAAO8D,EAAO/E,EAAQC,GAG7E/sC,eACEnc,EACA8tD,EACAC,GAEA,IAAI9D,EAAQ9/F,KAAK27F,kBAAkB9lD,GAC/BkqD,EAAQ//F,KAAK27F,kBAAkBgI,GAC/BE,EAAQ7jG,KAAK27F,kBAAkBiI,GACnC5L,EAAS+L,wBAAwB/jG,KAAKq5E,IAAKymB,EAAOC,EAAO8D,GAG3D9xC,gBACElc,EACA8tD,EACAC,EACAI,GAAe,GAEf,IAAIlE,EAAQ9/F,KAAK27F,kBAAkB9lD,GAC/BkqD,EAAQ//F,KAAK27F,kBAAkBgI,GAC/BE,EAAQ7jG,KAAK27F,kBAAkBiI,GACnC5L,EAASiM,yBAAyBjkG,KAAKq5E,IAAKymB,EAAOC,EAAO8D,EAAOG,GAGnElrC,gBACEjjB,EACA8tD,EACAC,EACAxmB,EACAykB,GAAgB,GAEhB,IAAI/B,EAAQ9/F,KAAK27F,kBAAkB9lD,GAC/BkqD,EAAQ//F,KAAK27F,kBAAkBgI,GAC/BE,EAAQ7jG,KAAK27F,kBAAkBiI,GACnC5L,EAASkM,yBAAyBlkG,KAAKq5E,IAAKymB,EAAOC,EAAO8D,EAAOzmB,EAAYykB,GAG/EsC,aACEtuD,EACA8tD,EACAC,EACA9E,EACAC,GAEA,IAAIe,EAAQ9/F,KAAK27F,kBAAkB9lD,GAC/BkqD,EAAQ//F,KAAK27F,kBAAkBgI,GAC/BE,EAAQ7jG,KAAK27F,kBAAkBiI,GACnC5L,EAASoM,sBACPpkG,KAAKq5E,IAAKymB,EAAOC,EAAO8D,EAAO/E,EAAQC,GAS3CjtC,UACEuyC,EACAttB,EACAhZ,EACArU,EACA8K,EAA4B,KAC5BwvC,GAAe,GAEf,IAAItI,EAAO17F,KAAK27F,kBAAkBnnC,GAC9B9oD,EAAIqyD,EAASvyD,OACb84F,EAAO,IAAIl0F,MAAa1E,GACxB64F,EAAO,IAAI9tE,WAAW/qB,GACtB84F,EAAO,IAAIp0F,MAAqB1E,GAChC+4F,EAAO,IAAIr0F,MAAa1E,GAC5B,IAAK,IAAID,EAAI,EAAGA,EAAIC,IAAKD,EAAG,CAC1B,IAAIi3C,EAAUqb,EAAStyD,GACnB4xD,EAAS3a,EAAQ2a,OACjB1gB,EAAS+F,EAAQ/F,OACrB2nD,EAAK74F,GAAK4sF,EAAah7B,GACvBknC,EAAK94F,GAAK,EACV+4F,EAAK/4F,GAAKi+C,GAAU,EAAAL,OAAOiC,OACvBtrD,KAAKoZ,IAAI+/B,QAAQwD,GAAStD,SAASsD,IACnC38C,KAAKmZ,IAAIggC,QAAQwD,IACrB8nD,EAAKh5F,GAAK4xD,EAAO7xD,OAEnB,IAAIo0F,EAAQtC,EAAcgH,GACtBzE,EAAQxH,EAAakM,GACrBG,EAAQpH,EAAckH,GACtBG,EAo/BR,SAAuBC,GACrB,IAAKA,EAAM,OAAO,EAClB,IAAI/vF,EAAM+vF,EAAKp5F,OACXmyD,EAAMq6B,EAASC,QAAQpjF,GAAO,GAClC,GAAKkwC,WAEE,CACL,IAAI9hB,EAAM06B,EACV,IAAK,IAAIlyD,EAAI,EAAGA,EAAIoJ,IAAOpJ,EAAG,CAC5B,IAAIo5F,EAAMD,EAAKn5F,GACfusF,EAAS8M,YAAY7hE,EAAK4hE,GAC1B5hE,GAAO,QANT+0D,EAAS+M,QAAQp4F,IAAIi4F,EAAMjnC,IAAQ,GASrC,OAAOA,EAlgCOqnC,CAAcP,GAC1BzM,EAASiN,mBACPjlG,KAAKq5E,IAAKgrB,EAASttB,EAAS2kB,EAAMkE,EAAOC,EAAO6E,EAAOC,EAAOj5F,EAAGs4F,GAEnEhM,EAASO,MAAMoM,GACf3M,EAASO,MAAMmM,GACf1M,EAASO,MAAMsH,GACf7H,EAASO,MAAMqH,GACf,IAAK,IAAIn0F,EAAIC,EAAI,EAAGD,GAAK,IAAKA,EAC5BusF,EAASO,MAAM+L,EAAK74F,IASxB4mD,iBACE1xD,EACA0jG,EACAttB,EACAmuB,EACAvoD,GAEA,IAAI++C,EAAO17F,KAAK27F,kBAAkBh7F,GAC9Bs4E,EAAWisB,EAAM15F,OACjBvH,EAAQ,IAAImM,MAAiB6oE,GACjC,IAAK,IAAIxtE,EAAI,EAAGA,EAAIwtE,IAAYxtE,EAC9BxH,EAAMwH,GAAKzL,KAAK27F,kBAAkBuJ,EAAMz5F,IAE1C,IAAI2sF,EAAOkF,EAAcr5F,GACrBkhG,EAAWnN,EAASoN,kBAAkBplG,KAAKq5E,IAAKqiB,GAC/CyJ,GAGHnN,EAASqN,yBAAyBF,EAAUd,GAC5CrM,EAASsN,qBAAqBH,EAAUpuB,IAHxCouB,EAAWnN,EAASuN,kBAAkBvlG,KAAKq5E,IAAKqiB,EAAM2I,EAASttB,EAASt8C,EAAQysB,SAKlF8wC,EAASwN,iCAAiCxlG,KAAKq5E,IAAKqiB,EAAMA,EAAMtD,EAAMnf,EAAUt8B,GAChFq7C,EAASO,MAAMH,GAuBjBqN,iBAAiB9kG,EAAc+kG,GAC7B,IAAIhK,EAAO17F,KAAK27F,kBAAkBh7F,GAC9By3F,EAAOC,EAAaqN,GACxB1N,EAAS2N,0BAA0B3lG,KAAKq5E,IAAKqiB,EAAMtD,EAAMsN,EAASl6F,QAClEwsF,EAASO,MAAMH,GAKjBwN,mBACE,OAAO5N,EAAS6N,4BAGlBC,iBAAiBC,GACf/N,EAASgO,0BAA0BD,GAGrCE,iBACE,OAAOjO,EAASkO,0BAGlBC,eAAeJ,GACb/N,EAASoO,wBAAwBL,GAGnCM,eACE,OAAOrO,EAASsO,wBAGlBC,aAAaC,GACXxO,EAASyO,sBAAsBD,GAGjCE,qBACE,OAAO1O,EAAS2O,8BAGlBp5C,mBAAmBi5C,GACjBxO,EAAS4O,4BAA4BJ,GAGvCK,sBACE,OAAO7O,EAAS8O,+BAGlBC,oBAAoBP,GAClBxO,EAASgP,6BAA6BR,GAGxCS,cACE,OAAOjP,EAASkP,uBAGlBC,YAAYX,GACVxO,EAASoP,qBAAqBZ,GAGhCa,gBAAgB9T,GACd,IAAImI,EAAO17F,KAAK27F,kBAAkBpI,GAC9B51B,EAAMq6B,EAASsP,yBAAyB5L,GAC5C,OAAO/9B,EAAM4pC,EAAW5pC,GAAO,KAGjC6pC,gBAAgBjU,EAAa/vF,GAC3B,IAAIs8F,EAAQ9/F,KAAK27F,kBAAkBpI,GAC/BwM,EAAQ//F,KAAK27F,kBAAkBn4F,GACnCw0F,EAASyP,yBAAyB3H,EAAOC,GAG3C2H,qBACE1P,EAAS2P,8BAGXC,yBACE,OAAO5P,EAAS6P,kCAGlBC,uBAAuBxtE,GACrB09D,EAAS+P,gCAAgCztE,GAG3C0tE,2BACE,OAAOhQ,EAASiQ,oCAGlBC,yBAAyB5tE,GACvB09D,EAASmQ,kCAAkC7tE,GAG7C8tE,4BACE,OAAOpQ,EAASqQ,qCAGlBC,0BAA0BhuE,GACxB09D,EAASuQ,mCAAmCjuE,GAG9CkuE,qCACE,OAAOxQ,EAASyQ,8CAGlBC,mCAAmCC,GACjC3Q,EAAS4Q,4CAA4CD,GAKvDE,cACE,OAAO7Q,EAAS8Q,2BAA2B9oG,KAAKq5E,KAGlD/qB,YAAYd,GACVwqC,EAAS+Q,2BAA2B/oG,KAAKq5E,IAAK7rB,GAGhDw7C,UAAUC,EAAkBlG,EAAoB,GAC9C,IAAI9pB,EAAWgwB,EAAOz9F,OAClB09F,EAAQ,IAAI94F,MAAiB6oE,GACjC,IAAK,IAAIxtE,EAAI,EAAGA,EAAIwtE,IAAYxtE,EAC9By9F,EAAMz9F,GAAK09F,EAAYF,EAAOx9F,IAEhC,IAAI2sF,EAAOkF,EAAc4L,GACrBnG,EACF/K,EAASoR,2BAA2BrG,EAAM/iG,KAAKq5E,IAAK+e,EAAMnf,GAE1D+e,EAASqR,yBAAyBrpG,KAAKq5E,IAAK+e,EAAMnf,GAEpD+e,EAASO,MAAMH,GACf,IAAK,IAAI3sF,EAAIwtE,EAAW,EAAGxtE,GAAK,IAAKA,EAAGusF,EAASO,MAAM2Q,EAAMz9F,IAG/D69F,SACE3S,EACAC,EACA2S,GAAkB,EAClBp/C,GAAyB,GA+BzB,IA5BIwsC,GAAiB,GAAKC,GAAe,KAAGD,EAAgB,GAE5D32F,KAAK8lG,iBAAiBnP,GACtB32F,KAAKmmG,eAAevP,GACpB52F,KAAKumG,aAAagD,GAClBvpG,KAAK+mG,oBAAoB58C,GACzBnqD,KAAKmnG,aAAY,GACjBnnG,KAAK0nG,qBAGD/Q,GAAiB,GAAoB,GAAfC,GACxB52F,KAAK8nG,uBAAuB,IAC5B9nG,KAAKkoG,yBAAyB,IAC9BloG,KAAKsoG,0BAA0B,KAC/BtoG,KAAK0oG,mCAAmC/R,GAAiB,KAEzD32F,KAAK8nG,uBACHnR,GAAiB,GAAKC,GAAe,EACjC,EACA,GAEN52F,KAAKkoG,yBAAyB,IAC9BloG,KAAKsoG,0BAA0B,IAC/BtoG,KAAK0oG,oCAAmC,IAKtC/R,EAAgB,GAAKC,EAAc,EAAG,CACxC,IAAIqS,EAAS,IAAI74F,MAIjB64F,EAAOx3F,KAAK,kCACZw3F,EAAOx3F,KAAK,iCAGRklF,GAAiB,IACnBsS,EAAOx3F,KAAK,kBACZw3F,EAAOx3F,KAAK,YACZw3F,EAAOx3F,KAAK,iCAEVklF,GAAiB,GAAKC,GAAe,KACvCqS,EAAOx3F,KAAK,OACZw3F,EAAOx3F,KAAK,UACZw3F,EAAOx3F,KAAK,gBACZw3F,EAAOx3F,KAAK,eACZw3F,EAAOx3F,KAAK,aACZw3F,EAAOx3F,KAAK,qBACZw3F,EAAOx3F,KAAK,uBACZw3F,EAAOx3F,KAAK,gBACZw3F,EAAOx3F,KAAK,wBACZw3F,EAAOx3F,KAAK,gCAEVklF,GAAiB,IACnBsS,EAAOx3F,KAAK,+BACZw3F,EAAOx3F,KAAK,WACZw3F,EAAOx3F,KAAK,UACZw3F,EAAOx3F,KAAK,qCACZw3F,EAAOx3F,KAAK,UACZw3F,EAAOx3F,KAAK,QACZw3F,EAAOx3F,KAAK,gBACZw3F,EAAOx3F,KAAK,kBACZw3F,EAAOx3F,KAAK,mBAEdw3F,EAAOx3F,KAAK,0BACRklF,GAAiB,GAAKC,GAAe,IACvCqS,EAAOx3F,KAAK,OAEdw3F,EAAOx3F,KAAK,qBACZw3F,EAAOx3F,KAAK,uBACRklF,GAAiB,GAAKC,GAAe,GACvCqS,EAAOx3F,KAAK,YACZw3F,EAAOx3F,KAAK,wBACZw3F,EAAOx3F,KAAK,gCAEZw3F,EAAOx3F,KAAK,eAEVklF,GAAiB,GAAKC,GAAe,IACvCqS,EAAOx3F,KAAK,mBAEdw3F,EAAOx3F,KAAK,qCACZw3F,EAAOx3F,KAAK,WACRklF,GAAiB,GAAKC,GAAe,IACvCqS,EAAOx3F,KAAK,aAEdw3F,EAAOx3F,KAAK,kBACZw3F,EAAOx3F,KAAK,mBACZw3F,EAAOx3F,KAAK,mBACZw3F,EAAOx3F,KAAK,mBACZw3F,EAAOx3F,KAAK,kBACZw3F,EAAOx3F,KAAK,WACRklF,GAAiB,GAAKC,GAAe,KACvCqS,EAAOx3F,KAAK,OACZw3F,EAAOx3F,KAAK,YAEVklF,GAAiB,GAAKC,GAAe,KACvCqS,EAAOx3F,KAAK,gBACZw3F,EAAOx3F,KAAK,YAEVklF,GAAiB,GAAKC,GAAe,KACvCqS,EAAOx3F,KAAK,+BACZw3F,EAAOx3F,KAAK,gCAEdw3F,EAAOx3F,KAAK,qBACZw3F,EAAOx3F,KAAK,uBACZw3F,EAAOx3F,KAAK,gBACRklF,GAAiB,GACnBsS,EAAOx3F,KAAK,0BAKVklF,GAAiB,GAAKC,GAAe,KACvCqS,EAAOx3F,KAAK,+BACZw3F,EAAOx3F,KAAK,oBAEVklF,GAAiB,GAAKC,GAAe,IACvCqS,EAAOx3F,KAAK,uBAEVzR,KAAK0mG,uBACH/P,GAAiB,GAAKC,GAAe,EACvCqS,EAAOx3F,KAAK,sCAEZw3F,EAAOx3F,KAAK,6BAGhBw3F,EAAOx3F,KAAK,gCACRklF,GAAiB,GAAKC,GAAe,EACvCqS,EAAOx3F,KAAK,gCAEZw3F,EAAOx3F,KAAK,oBACZw3F,EAAOx3F,KAAK,WAEVklF,GAAiB,GAA+C,IAAzC32F,KAAK6oG,cAAgBp7C,EAAaW,MAC3D66C,EAAOx3F,KAAK,cACZw3F,EAAOx3F,KAAK,gBACZw3F,EAAOx3F,KAAK,oBAGVklF,GAAiB,GAAKC,GAAe,GACvCqS,EAAOx3F,KAAK,wBACZw3F,EAAOx3F,KAAK,+BACZw3F,EAAOx3F,KAAK,gCAEZw3F,EAAOx3F,KAAK,cAEdw3F,EAAOx3F,KAAK,aACZw3F,EAAOx3F,KAAK,kBACZw3F,EAAOx3F,KAAK,wBACRklF,GAAiB,GAAKC,GAAe,KACvCqS,EAAOx3F,KAAK,gBACZw3F,EAAOx3F,KAAK,eACZw3F,EAAOx3F,KAAK,OAEZw3F,EAAOx3F,KAAK,gBACRklF,GAAiB,IAEnBsS,EAAOx3F,KAAK,oBACZw3F,EAAOx3F,KAAK,UAEZw3F,EAAOx3F,KAAK,wBAGZw3F,EAAOx3F,KAAK,uBACZw3F,EAAOx3F,KAAK,aACZw3F,EAAOx3F,KAAK,kBACZw3F,EAAOx3F,KAAK,aAEZw3F,EAAOx3F,KAAK,gBACZw3F,EAAOx3F,KAAK,mBACZw3F,EAAOx3F,KAAK,mBACZw3F,EAAOx3F,KAAK,UAEZw3F,EAAOx3F,KAAK,YACZw3F,EAAOx3F,KAAK,wBACZw3F,EAAOx3F,KAAK,OACZw3F,EAAOx3F,KAAK,UACZw3F,EAAOx3F,KAAK,eACZw3F,EAAOx3F,KAAK,mBACZw3F,EAAOx3F,KAAK,oBAEdw3F,EAAOx3F,KAAK,qBACZw3F,EAAOx3F,KAAK,uBACZw3F,EAAOx3F,KAAK,gBACZw3F,EAAOx3F,KAAK,UAEZw3F,EAAOx3F,KAAK,yBACZw3F,EAAOx3F,KAAK,gCAGdw3F,EAAOx3F,KAAK,kCACZw3F,EAAOx3F,KAAK,kBACZw3F,EAAOx3F,KAAK,iCAEZzR,KAAKgpG,UAAUC,IAInBO,WACE,OAAqD,GAA9CxR,EAASyR,wBAAwBzpG,KAAKq5E,KAG/CqwB,YACE1R,EAAS2R,yBAAyB3pG,KAAKq5E,KAGzCuwB,SAASC,EAA8B,MACrC,IAAIrR,EAAMx4F,KAAK+3F,IACfhsF,OAAOisF,EAASE,0BAA4B,IAC5C,IACI4R,EACAC,EAFArO,EAAOyN,EAAYU,GAGvB7R,EAASgS,gCAAgCxR,EAAKx4F,KAAKq5E,IAAKqiB,GACxDoO,EAAY/9F,OAAOisF,EAASiS,WAAWzR,IACvC,IAAI0R,EAAYlS,EAASiS,WAAWzR,EAAM,GAC1CuR,EAAe/R,EAASiS,WAAWzR,EAAM,GACzC,IAAIx+D,EAAS,IAAImwE,EAyrBrB,SAAoBxsC,EAAY9oD,GAC9B,GAAKkwC,WAEE,CACL,IAAIhrB,EAAM,IAAItD,WAAW5hB,GACzB,IAAK,IAAIpJ,EAAI,EAAGA,EAAIoJ,IAAOpJ,EACzBsuB,EAAItuB,GAAKusF,EAASoS,cAAczsC,EAAalyD,GAE/C,OAAOsuB,EANP,OAAOi+D,EAASqS,OAAOrvB,MAAMrd,EAAKA,EAAM9oD,GA3rBVy1F,CAAWR,EAAWI,GAAY3C,EAAWwC,IAI3E,OAHIrO,GAAM1D,EAASO,MAAMmD,GACzB1D,EAASO,MAAMuR,GACXC,GAAc/R,EAASO,MAAMwR,GAC1B/vE,EAGTuwE,OAAOC,GAAkB,GACvB,MAAM,IAAIriD,MAAM,mBAGlBsiD,UACE,MAAM,IAAItiD,MAAM,mBAMlBwzC,kBAAkB9M,GAChB,GAAY,OAARA,EAAc,OAAO,EACzB,IAAI6b,EAAS1qG,KAAK63F,wBAClB,GAAI6S,EAAOxvD,IAAI2zC,GAAM,OAAO9kF,WAAkB2gG,EAAOvvD,IAAI0zC,IACzD,IAAIlxB,EAAMwrC,EAAYta,GAEtB,OADA6b,EAAO/9F,IAAIkiF,EAAKlxB,GACTA,EAGTgtC,iBAAiBhtC,GAGf,GAAW,GAAPA,EAAU,OAAO,KACrB,IAAI+sC,EAAS1qG,KAAK83F,wBAClB,GAAI4S,EAAOxvD,IAAIyiB,GAAM,OAAO5zD,WAAmB2gG,EAAOvvD,IAAIwiB,IAC1D,IAAIkxB,EAAM0Y,EAAW5pC,GAErB,OADA+sC,EAAO/9F,IAAIgxD,EAAKkxB,GACTA,EAGT+b,UACE7+F,OAAO/L,KAAKq5E,KAEZ,IAAK,IAAIviC,EAAUC,WAAW/2C,KAAK63F,yBAA0BpsF,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CAClG,IAAIkyD,EAAM7rD,UAAUglC,EAAQrrC,IAC5BusF,EAASO,MAAM56B,GAEjB39D,KAAK63F,wBAAwB5nC,QAC7BjwD,KAAK83F,wBAAwB7nC,QAC7B+nC,EAASO,MAAMv4F,KAAK+3F,KACpBC,EAAS6S,uBAAuB7qG,KAAKq5E,KACrCr5E,KAAKq5E,IAAM,EAGbyxB,iBACE,OAAOC,EAASz9C,OAAOttD,MAIzBkwE,yBAAyBxqE,GACvB,OAAQsyF,EAASgT,yBAAyBtlG,IACxC,KAAK80C,EAAasB,SAClB,KAAKtB,EAAa0e,UAClB,KAAK1e,EAAaC,MAClB,KAAKD,EAAaywD,WAClB,KAAKzwD,EAAaglB,IAClB,KAAKhlB,EAAa4oC,YAClB,KAAK5oC,EAAa0wD,SAClB,KAAK1wD,EAAa2wD,QAClB,KAAK3wD,EAAa4wD,SAAU,OAAOprG,KAAKqrG,eAAe3lG,GAEzD,OAAO,EAIT2lG,eAAe3lG,GAEb,OAAOsyF,EAASsT,wBAAwB5lG,EAAM1F,KAAKq5E,KAGrDl3C,cACEz8B,EACAO,EACAslG,EAAgB,GAChBC,EAAyB,GAEzB,IAAIC,EAASzT,EAAS0T,wBAAwB1rG,KAAKq5E,IAAKpzE,EAAOslG,EAAUC,GACrEtpE,EAAW81D,EAAS2T,+BAA+BF,EAAQ/lG,GAK/D,OAJIw8B,IACFn2B,OAAOwuC,EAAgBrY,IAAYsY,EAAaC,OAChD1uC,OAAOiyC,EAAkB9b,IAAY8b,EAAkBt4C,KAElDw8B,EAKT0iD,iBAAiBjkF,GACf,IAAI+6F,EAAOyN,EAAYxoG,GACnBo5B,EAAMi+D,EAAS4T,oCAAoC5rG,KAAKq5E,IAAKqiB,GAEjE,OADA1D,EAASO,MAAMmD,GACR3hE,EAGT8xE,iBAAiBlyE,GACf,OAAO4tE,EAAWvP,EAAS8T,oCAAoC9rG,KAAKq5E,IAAK1/C,IAG3EoyE,iBACEhJ,EACAr9F,EACAsmG,EACAC,EACAC,GAEAlU,EAASmU,kCAAkCpJ,EAAMr9F,EAAMsmG,EAAWC,EAAYC,IAMlF,SAAgB10D,EAAW40D,GACzB,IAAKA,EAAO,OAAO3xE,EAAQqb,KAC3B,OAAQs2D,EAAM5gG,QACZ,KAAK,EAAG,OAAOivB,EAAQqb,KACvB,KAAK,EAAG,OAAOs2D,EAAM,GAEvB,IAAIhU,EAAOkF,EAAc8O,GACrBryE,EAAMi+D,EAASqU,oBAAoBjU,EAAMgU,EAAM5gG,QAEnD,OADAwsF,EAASO,MAAMH,GACRr+D,EAwBT,SAAgBwgB,EAAgB70C,GAC9B,OAAOsyF,EAASgT,yBAAyBtlG,GAG3C,SAAgBs4C,EAAkBt4C,GAChC,OAAOsyF,EAASgE,2BAA2Bt2F,GAG7C,SAAgB68B,EAAiB78B,GAC/B,OAAOsyF,EAASsU,0BAA0B5mG,GAG5C,SAAgBuyC,EAAoBvyC,GAClC,OAAOsyF,EAASuU,6BAA6B7mG,GAG/C,SAAgBsyC,EAAqBtyC,GACnC,OAAOsyF,EAASwU,8BAA8B9mG,GAGhD,SAAgBu4C,EAAiBv4C,GAC/B,OAAOsyF,EAASyU,0BAA0B/mG,GAG5C,SAAgBw4C,EAAiBx4C,GAC/B,OAAOsyF,EAAS0U,0BAA0BhnG,GAniD5C,WAk7BkB,EAAA+rD,kBAAkC,EA8ClC,EAAAa,iBAAiC,EAygBnD,eAYA,sBAA2B5wD,GACzB,IAAIirG,EAAQ3U,EAAS4U,mBAAmBlrG,GACpC02F,EAAOJ,EAASC,QAAe0U,GAAS,GAC5C3U,EAAS6U,oBAAoBnrG,EAAM02F,GACnC,IAAIgU,EAAQ,IAAIh8F,MAAeu8F,GAC/B,GAAK5nD,WAMH,IAAK,IAAIt5C,EAAS,EAAGA,EAAIkhG,IAASlhG,EAChC2gG,EAAM3gG,GAAKusF,EAASiS,WAAW7R,GAAe3sF,GAAK,QAPtC,CACf,IAAIkyD,EAAMy6B,IAAS,EACnB,IAAK,IAAI3sF,EAAS,EAAGA,EAAIkhG,IAASlhG,EAChC2gG,EAAM3gG,GAAKusF,EAAS+M,QAAQpnC,EAAMlyD,GAQtC,OADAusF,EAASO,MAAMH,GACRgU,GAKT,oBAIA,sBAIA,qBAIA,wBAIA,yBAIA,qBAIA,qBAIA,uBAA4B1mG,GAC1B,GAAI60C,EAAgB70C,IAAS80C,EAAaC,MAAO,OAAO,EACxD,IAAI/4C,EAAOs8C,EAAkBt4C,GAC7B,OAAIhE,GAAQ+4B,EAAQC,IAAsC,GAA1B6H,EAAiB78B,GAC7ChE,GAAQ+4B,EAAQmB,IAAyC,GAA7Bqc,EAAoBvyC,IAA4C,GAA9BsyC,EAAqBtyC,GACnFhE,GAAQ+4B,EAAQwhB,IAAsC,GAA1BgC,EAAiBv4C,GAC7ChE,GAAQ+4B,EAAQ2hB,KAAsC,GAA1B8B,EAAiBx4C,IAInD,4BAAiCA,GAC/B,OAAOsyF,EAAS8U,0BAA0BpnG,IAG5C,4BAAiCA,GAC/B,OAAOsyF,EAAS+U,0BAA0BrnG,IAG5C,4BAAiCA,GAC/B,OAAOsyF,EAASgV,0BAA0BtnG,IAG5C,sBAA2BA,GACzB,OAAOsyF,EAASiV,uBAAuBvnG,IAGzC,4BAAiCA,GAC/B,OAAO6hG,EAAWvP,EAASkV,0BAA0BxnG,KAGvD,uBAA4BA,GAC1B,OAAOsyF,EAASmV,qBAAqBznG,IAGvC,yBAA8BA,GAC5B,OAAOsyF,EAASoV,uBAAuB1nG,IAGzC,0BAA+BA,GAC7B,OAAOsyF,EAASqV,wBAAwB3nG,IAG1C,sBAA2BA,GACzB,OAAOsyF,EAASsV,oBAAoB5nG,IAGtC,yBAA8BA,GAC5B,OAAOsyF,EAASuV,uBAAuB7nG,IAGzC,wBAA6BA,GAC3B,OAAOsyF,EAASwV,sBAAsB9nG,IAGxC,yBAA8BA,GAC5B,OAAOsyF,EAASyV,uBAAuB/nG,IAGzC,sBAA2BA,GACzB,OAAOsyF,EAAS0V,oBAAoBhoG,IAGtC,wBAA6BA,GAC3B,OAAOsyF,EAAS2V,sBAAsBjoG,IAGxC,yBAA8BA,GAC5B,OAAOsyF,EAAS4V,uBAAuBloG,IAGzC,0BAA+BA,GAC7B,OAAOsyF,EAAS6V,wBAAwBnoG,IAG1C,uBAA4BA,GAC1B,OAAOsyF,EAAS8V,qBAAqBpoG,IAGvC,yBAA8BA,GAC5B,OAAOsyF,EAAS+V,uBAAuBroG,IAGzC,wBAA6BA,GAC3B,OAAO6hG,EAAWvP,EAASgW,sBAAsBtoG,KAGnD,8BAAmCA,GACjC,OAAOsyF,EAASiW,6BAA6BvoG,IAG/C,2BAAgCA,EAAqBi0B,GACnD,OAAOq+D,EAASkW,yBAAyBxoG,EAAMi0B,IAGjD,0BAA+Bj0B,GAC7B,OAAOsyF,EAASmW,wBAAwBzoG,IAG1C,qBAA0BA,GACxB,OAAOsyF,EAASoW,qBAAqB1oG,IAGvC,sBAA2BA,GACzB,OAAOsyF,EAASqW,sBAAsB3oG,IAGxC,uBAA4BA,GAC1B,OAAO6hG,EAAWvP,EAASsW,qBAAqB5oG,KAGlD,uBAA4BA,GAC1B,OAAOsyF,EAASuW,qBAAqB7oG,IAGvC,wBAA6BA,GAC3B,OAAO6hG,EAAWvP,EAASwW,sBAAsB9oG,KAGnD,6BAAkCA,GAChC,OAAOsyF,EAASyW,2BAA2B/oG,IAG7C,yBAA8BA,GAC5B,OAAOsyF,EAAS0W,yBAAyBhpG,IAG3C,yBAA8BA,GAC5B,OAAOsyF,EAAS2W,0BAA0BjpG,IAG5C,8BAAmCA,GACjC,OAAOsyF,EAAS4W,4BAA4BlpG,IAG9C,wBAA6BA,GAC3B,OAAOsyF,EAAS6W,sBAAsBnpG,IAGxC,0BAA+BA,GAC7B,OAAOsyF,EAAS8W,wBAAwBppG,IAG1C,yBAA8BA,GAC5B,OAAO6hG,EAAWvP,EAAS+W,uBAAuBrpG,KAGpD,+BAAoCA,GAClC,OAAOsyF,EAASgX,4BAA4BtpG,IAG9C,4BAAiCA,EAAqBi0B,GACpD,OAAOq+D,EAASiX,0BAA0BvpG,EAAMi0B,IAGlD,8BAAmCj0B,GACjC,OAAOsyF,EAASkX,4BAA4BxpG,IAK9C,2BAAgCq9F,GAC9B,OAAO/K,EAASmX,yBAAyBpM,IAG3C,2BAAgCA,GAC9B,OAAOwE,EAAWvP,EAASoX,yBAAyBrM,KAGtD,6BAAkCA,GAChC,OAAO/K,EAASqX,2BAA2BtM,IAG7C,8BAAmCA,GACjC,OAAO/K,EAASsX,4BAA4BvM,IAG9C,2BAAgCA,GAC9B,IAAIjhD,EAAQk2C,EAASuX,4BAA4BxM,GAC7CqJ,EAAQ,IAAIh8F,MAAe0xC,GAC/B,IAAK,IAAIr2C,EAAW,EAAGA,EAAIq2C,IAASr2C,EAClC2gG,EAAM3gG,GAAKusF,EAASwX,wBAAwBzM,EAAMt3F,GAEpD,OAAO2gG,GAKT,yBAA8BrrD,GAC5B,OAAOwmD,EAAWvP,EAASyX,uBAAuB1uD,KAGpD,yBAA8BA,GAC5B,OAAOi3C,EAAS0X,uBAAuB3uD,IAGzC,2BAAgCA,GAC9B,OAAOi3C,EAAS2X,yBAAyB5uD,IAG3C,yBAA8BA,GAC5B,OAAOi3C,EAAS4X,2BAA2B7uD,IAK7C,sBAA2B97C,GACzB,OAAOsiG,EAAWvP,EAAS6X,oBAAoB5qG,KAGjD,wBAA6BA,GAC3B,OAAO+yF,EAAS8X,sBAAsB7qG,IAGxC,yBAA8BA,GAC5B,OAAO+yF,EAAS+X,uBAAuB9qG,IAGzC,MAAa8lG,EACXxqG,YAESZ,EAEA05E,GAFA,KAAA15E,OAAAA,EAEA,KAAA05E,IAAAA,EAGT34E,cAAcf,GACZ,OAAO,IAAIorG,EAASprG,EAAQq4F,EAASgY,gBAAgBrwG,EAAO05E,MAG9D42B,SAAS/nB,GACP,OAAO8P,EAASkY,kBAAkBlwG,KAAKq5E,IAAK6O,GAG9CioB,UACEC,EACAC,EACA1rG,EAA2B,EAC3BujF,EAAsB,GAEtB8P,EAASsY,mBAAmBF,EAAMC,EAAI1rG,EAAWujF,GAGnDqoB,mBAAmBroB,EAAqBvjF,GACtC,OAAOqzF,EAASwY,4BAA4BxwG,KAAKq5E,IAAK6O,EAAMvjF,GAG9D8rG,mBACEL,EACAC,EACAK,EACAxoB,EAAsB,GAEtB,IAAIkQ,EAiJR,SAAuBuY,GACrB,IAAKA,EAAM,OAAO,EAClB,IAAI97F,EAAM87F,EAAKnlG,OACXmyD,EAAMq6B,EAASC,QAAQpjF,GAAO,GAClC,GAAKkwC,WAEE,CACL,IAAI9hB,EAAM06B,EACV,IAAK,IAAIlyD,EAAI,EAAGA,EAAIoJ,IAAOpJ,EAAG,CAC5B,IAAIo5F,EAAM8L,EAAKllG,GACfusF,EAAS8M,YAAY7hE,EAAK4hE,GAC1B5hE,GAAO,QANT+0D,EAAS4Y,OAAOjkG,IAAIgkG,EAAMhzC,IAAQ,GASpC,OAAOA,EA/JMkzC,CAAcH,GACzB1Y,EAAS8Y,4BAA4BV,EAAMC,EAAIjY,EAAMsY,EAAQllG,OAAQ08E,GACrE8P,EAASO,MAAMH,GAGjB2Y,iBAAiBC,EAAyBC,GACxC,OAAOjZ,EAASkZ,0BAA0BlxG,KAAKq5E,IAAK23B,EAAOC,IAzC/D,aA2JA,SAAgB71B,EAAe11E,EAAqB/F,GAClD,OAAOq4F,EAASmZ,kCAAkCzrG,EAAM/F,GAU1D,SAAS04F,EAAa+Y,GACpB,IAAKA,EAAK,OAAO,EACjB,IAAIv8F,EAAMu8F,EAAI5lG,OACVmyD,EAAMq6B,EAASC,QAAQpjF,GAC3B,GAAKkwC,WAGH,IAAK,IAAIt5C,EAAI,EAAGA,EAAIoJ,IAAOpJ,EACzBusF,EAASiB,aAAat7B,EAAMlyD,EAAG2lG,EAAI3lG,SAHrCusF,EAASqS,OAAO19F,IAAIykG,EAAKzzC,GAM3B,OAAOA,EAqCT,SAAgB2/B,EAAc+T,GAC5B,IAAKA,EAAM,OAAO,EAElBtlG,OAAOg5C,YAAc,EAAAsE,OAAOiC,QAC5B,IAAIz2C,EAAMw8F,EAAK7lG,OACXmyD,EAAMq6B,EAASC,QAAQpjF,GAAO,GAClC,GAAKkwC,WAEE,CACL,IAAI9hB,EAAM06B,EACV,IAAK,IAAIlyD,EAAI,EAAGC,EAAImJ,EAAKpJ,EAAIC,IAAKD,EAAG,CACnC,IAAIo5F,EAAMwM,EAAK5lG,GACfusF,EAAS8M,YAAY7hE,EAAU4hE,GAC/B5hE,GAAO,QANT+0D,EAAS+M,QAAQp4F,IAAI0kG,EAAM1zC,IAAQ,GASrC,OAAOA,EAwBT,SAASwrC,EAAYta,GACnB,GAAY,OAARA,EAAc,OAAO,EACzB,IAAIh6E,EAvBN,SAA0Bg6E,GACxB,IAAIh6E,EAAM,EACV,IAAK,IAAIpJ,EAAI,EAAGC,EAAImjF,EAAIrjF,OAAQC,EAAIC,IAAKD,EAAG,CAC1C,IAAI6lG,EAAKziB,EAAI9hF,WAAWtB,KAAO,EAC3B6lG,GAAM,IACRz8F,GAAO,EACEy8F,GAAM,KACfz8F,GAAO,GAEP,IAAA08F,iBAAgBD,IAAO7lG,EAAI,EAAIC,IAC/B,IAAA8lG,gBAAe3iB,EAAI9hF,WAAWtB,EAAI,KAElCA,IACAoJ,GAAO,GAEPA,GAAO,EAGX,OAAOA,EAKG48F,CAAiB5iB,GACvBlxB,EAAMq6B,EAASC,QAAQpjF,EAAM,KAAO,EACpCouB,EAAM06B,EACV,GAAI9oD,IAAQg6E,EAAIrjF,OAEd,GAAKu5C,WAKH,IAAK,IAAIt5C,EAAI,EAAGC,EAAImjF,EAAIrjF,OAAQC,EAAIC,IAAKD,EAAG,CAC1C,IAAIimG,EAAI7iB,EAAI9hF,WAAWtB,KAAO,EAC9BusF,EAASiB,aAAah2D,IAAOyuE,QAN/B,IAAK,IAAIjmG,EAAI,EAAGC,EAAImjF,EAAIrjF,OAAQC,EAAIC,IAAKD,EACvCusF,EAASqS,OAAOpnE,KAAS4rD,EAAI9hF,WAAWtB,QAS5C,IAAK,IAAIA,EAAI,EAAGC,EAAImjF,EAAIrjF,OAAQC,EAAIC,IAAKD,EAAG,CAC1C,IAAkCkmG,EAA9BL,EAAKziB,EAAI9hF,WAAWtB,KAAO,EAC3B6lG,GAAM,IACRtZ,EAASiB,aAAah2D,IAAOquE,GACpBA,GAAM,MACftZ,EAASiB,aAAah2D,IAAQ,IAASquE,IAAO,GAC9CtZ,EAASiB,aAAah2D,IAAQ,IAAsB,GAAbquE,KAEvC,IAAAC,iBAAgBD,IAAO7lG,EAAI,EAAIC,IAC/B,IAAA8lG,gBAAeG,EAAK9iB,EAAI9hF,WAAWtB,EAAI,KAEvC6lG,GAAK,IAAAM,mBAAkBN,EAAIK,KACzBlmG,EACFusF,EAASiB,aAAah2D,IAAQ,IAASquE,IAAO,IAC9CtZ,EAASiB,aAAah2D,IAAQ,IAASquE,IAAO,GAAM,IACpDtZ,EAASiB,aAAah2D,IAAQ,IAASquE,IAAQ,EAAK,IACpDtZ,EAASiB,aAAah2D,IAAQ,IAAsB,GAAbquE,KAEvCtZ,EAASiB,aAAah2D,IAAQ,IAASquE,IAAO,IAC9CtZ,EAASiB,aAAah2D,IAAQ,IAASquE,IAAQ,EAAK,IACpDtZ,EAASiB,aAAah2D,IAAQ,IAAsB,GAAbquE,IAK7C,OADAtZ,EAASiB,aAAah2D,EAAK,GACpB06B,EAeT,SAAgB4pC,EAAW5pC,GACzB,IAAKA,EAAK,OAAO,KAKjB,IAJA,IAEIk0C,EACAC,EAASC,EAASC,EAHlBC,EAAM,IAAI7hG,MAIPyhG,EAAK7Z,EAASoS,cAAczsC,MACjC,GAAW,IAALk0C,EAKN,GADAC,EAAqC,GAAhC9Z,EAASoS,cAAczsC,KACT,MAAT,IAALk0C,GAeL,GAXAE,EAAqC,GAAhC/Z,EAASoS,cAAczsC,KACT,MAAT,IAALk0C,GACHA,GAAY,GAALA,IAAY,GAAOC,GAAM,EAAKC,GAErCC,EAAqC,GAAhCha,EAASoS,cAAczsC,KACT,MAAT,IAALk0C,GACHA,GAAY,EAALA,IAAW,GAAOC,GAAM,GAAOC,GAAM,EAAKC,EAEjDjmG,QAAO,EAAO,4CAGd8lG,EAAK,MACPI,EAAIxgG,KAAKogG,OACJ,CACL,IAAIK,EAAKL,EAAK,MACdI,EAAIxgG,KAAK,EAAA0gG,eAAkBD,IAAO,IAClCD,EAAIxgG,KAAK,EAAA2gG,cAAsB,KAALF,QAnB1BD,EAAIxgG,MAAY,GAALogG,IAAY,EAAKC,QAL5BG,EAAIxgG,KAAKogG,GA4Bb,OAAOrqD,OAAO6qD,cAAcJ,GA9S9B,sBAcE1xG,YAAYZ,EAAgBgF,GANpB,KAAAT,OAAgB,IAAIkM,MACpB,KAAAsgG,QAAiB,IAAItgG,MACrB,KAAArH,MAA2B,IAAIqH,MAC/B,KAAAm0D,cAAqB,EAI3BvkE,KAAKL,OAASA,EACdK,KAAK2E,UAAYA,EAInBy1E,QAAQ52E,EAAY0kF,GAClB,IAAIn/E,EAAQ/I,KAAK+I,MACb4wB,EAAQ5wB,EAAMupG,QAAQpqB,GACtBvuD,EAAQ,IACVA,EAAQ5wB,EAAMyC,OACdzC,EAAM0I,KAAKy2E,IAEbloF,KAAKkE,OAAOuN,KAAKjO,GACjBxD,KAAK0wG,QAAQj/F,KAAKkoB,GAIpB44E,WAAWrqB,GACTn8E,QAA6B,GAAtB/L,KAAKukE,cACZ,IAAIx7D,EAAQ/I,KAAK+I,MACjB/I,KAAKukE,aAAex7D,EAAMyC,OAC1BzC,EAAM0I,KAAKy2E,GAIbvN,OAAOxF,EAAiBq9B,EAAuB,IAC7C,IAAI7yG,EAASK,KAAKL,OACdoJ,EAAQ/I,KAAK+I,MACbk7D,EAAWl7D,EAAMyC,OACrB,IAAKy4D,EACH,OAAOtkE,EAAO+iE,KAAK1iE,KAAK2E,WAE1B,IAAIT,EAASlE,KAAKkE,OACdqrF,EAAYrrF,EAAOsH,OACnBklG,EAAU1wG,KAAK0wG,QACfM,EAAQ,IAAI5gG,MAAqB,EAAIm/E,EAAY,GACjDkjB,EAAS,IAAIriG,MAAc6zD,GAC/B,IAAK,IAAIx4D,EAAI,EAAGA,EAAIw4D,IAAYx4D,EAC9BgnG,EAAOhnG,GAAK,OAASA,EAAEmtB,WAAa45E,EAEtCxB,EAAM,GAAKrxG,EAAOwjE,UAAUgS,EAAYn1E,KAAK2E,WAAW,GACxD,IAAK,IAAI8G,EAAI,EAAGA,EAAI8jF,IAAa9jF,EAAG,CAClC,IAAIkuB,EAAQ+2E,EAAQjlG,GACpBulG,EAAM,EAAIvlG,GAAK9L,EAAO+hE,GAAG+wC,EAAO94E,GAC9Bh6B,EAAOq6B,OAAOC,EAASuqC,MACrB7kE,EAAO66B,UAAU26C,EAAY16C,EAAQC,KACrC/6B,EAAOwZ,IAAIjV,EAAOuH,MAIxB,IAAI84D,EAAevkE,KAAKukE,aACpBmuC,EAAe,UAAYF,EAC/BxB,EAAM,EAAIzhB,GAAa5vF,EAAO+hE,IAC3B6C,EACGkuC,EAAOluC,GACPmuC,GAEN,IAAI/wD,EAAUhiD,EAAOwhD,MAAMsxD,EAAO,GAAIzB,GACtC,IAAK,IAAIvlG,EAAI,EAAGA,EAAIw4D,IAAYx4D,EAAG,CACjC,IAAI01C,EAAQp4C,EAAM0C,EAAI,GACtB01C,EAAMwR,QAAQhR,GACdA,EAAUhiD,EAAOwhD,MAAMsxD,EAAOhnG,GAAI01C,GAEpC,IAAIwxD,EAAW5pG,EAAMk7D,EAAW,GAEhC,OADA0uC,EAAShgD,QAAQhR,GACVhiD,EAAOwhD,OACXojB,EACG,KACAmuC,EACJC,KAKN,SAAYt3B,GACV,mBACA,2BACA,qBACA,+BACA,iCACA,kCACA,oCACA,kCACA,qCACA,iCACA,mCACA,sCACA,8BACA,0BACA,oCACA,+CACA,qBAjBF,CAAYA,EAAA,EAAAA,cAAA,EAAAA,YAAW,KAoBvB,mBAIA,0BAA+B31E,EAAqB/F,GAClD,OAAOy7E,EAAe11E,EAAM/F,IAAW07E,EAAYvlC,MAsDrD,kBAkGA,eAwCA,MAAaq0D,EACX5pG,YAESqyG,EAEAtoD,GAFA,KAAAsoD,OAAAA,EAEA,KAAAtoD,UAAAA,GALX,iBAUA,oCAAgB2W,EAAyBv7D,GAEvC,GAAIsyF,EAASgE,2BAA2Bt2F,IAAS+0B,EAAQ2oD,YACvD,OAAO,EAGT,OAAQ4U,EAASgT,yBAAyBtlG,IACxC,KAAK80C,EAAa4oC,YAClB,KAAK5oC,EAAaijD,OAAQ,OAAO,EACjC,KAAKjjD,EAAaq4D,MAChB,OAAoD,GAA7C7a,EAASyW,2BAA2B/oG,GAE7C,KAAK80C,EAAaqmB,MAChB,IAAKm3B,EAASgW,sBAAsBtoG,GAAO,CACzC,IAAIotG,EAAc9a,EAASiW,6BAA6BvoG,GACxD,OACEotG,EAAc,GACd7xC,EAAyB+2B,EAASkW,yBAAyBxoG,EAAMotG,EAAc,KAKvF,OAAO,I,yGC1rGT,eAMA,SASA,SAMA,SAKA,QA0DA,MAAMC,EACJxyG,YACSyQ,EACA2nB,GADA,KAAA3nB,OAAAA,EACA,KAAA2nB,WAAAA,GAKX,MAAaq6E,UAAe,EAAA/mD,kBAkB1B1rD,YACE2rD,EAA0C,KAC1C+mD,EAA2B,MAE3BhoG,MAAMihD,GAnBR,KAAAgnD,QAAoB,IAAI9iG,MAExB,KAAA+iG,QAAuB,IAAIxrD,IAE3B,KAAAyrD,QAAuB,IAAIzrD,IAE3B,KAAA0rD,UAAmC,KAEnC,KAAAC,cAA+B,KAE/B,KAAAC,UAAmC,IAAI/5D,IAojB/B,KAAAg6D,8BAAqC,EAwgBrC,KAAAC,oBAA4C,KAljClDzzG,KAAKizG,QAAUA,GAAoB,IAAI7iG,MAIzC8mF,UAEEj1F,EAEA2E,EAEAowF,GAGA,IAAI9mF,GAAiB,IAAA8C,eAAcpM,GAC/B6J,GAAe,IAAAC,oBAAmBR,GAGtC,IAAIlQ,KAAKozG,QAAQl4D,IAAIzqC,GAArB,CAKA,GAJAzQ,KAAKozG,QAAQ98F,IAAI7F,GACjBzQ,KAAKmzG,QAAQ78F,IAAI7F,GAGJ,OAATxO,EAAe,CACjB,IAAIsxG,EAAYvzG,KAAKuzG,UACjBG,EAA4B,KAShC,OARIH,EAAUr4D,IAAIzqC,KAAeijG,EAAW3nG,OAAOwnG,EAAUp4D,IAAI1qC,UACjEzQ,KAAKw4B,MACH,EAAAC,eAAey+B,iBACfw8C,EACIA,EAAS/6E,WAAWl4B,MACpB,KACJmG,GAMJ,IAAIoK,EAAS,IAAI,EAAA2iG,OACf3c,EACI,EAAA32F,WAAWgvD,WACXzoD,EAAKqM,WAAW,EAAAE,gBACdvM,EAAK0rG,QAAQ,EAAAzhG,eAAgB,EAAAsC,eAAe3H,QAAU,EACpD,EAAAnL,WAAWgR,cACX,EAAAhR,WAAW+Q,QACb,EAAA/Q,WAAWuzG,KACjB1jG,EACAjO,GAGFjC,KAAKizG,QAAQxhG,KAAKT,GAClBhR,KAAKszG,cAAgBtiG,EAGrB,IAAI6iG,EAAK,IAAI,EAAAC,UAAU9iG,EAAQhR,KAAKksD,aACpC2nD,EAAGR,UAAYrzG,KAAKqzG,UAEpB,IADA,IAAIztG,EAAaoL,EAAOpL,YAChBiuG,EAAGE,KAAK,EAAA3oC,MAAM4oC,YAAY,CAChC,IAAIztG,EAAYvG,KAAKi0G,uBAAuBJ,EAAI,MAC5CttG,EACFX,EAAW6L,KAAKlL,GAEhBvG,KAAKk0G,cAAcL,KAMzBI,uBACEJ,EACAzhC,EAAyC,MAOzC,IALA,IAAInsE,EAAQ,EAAAqG,YAAYC,KACpB4nG,GAAY,EAGZnuG,EAAqC,KAClC6tG,EAAGE,KAAK,EAAA3oC,MAAMgpC,KAAK,CACpBD,EAAW,IAAGA,EAAWN,EAAGQ,UAChC,IAAIr/F,EAAYhV,KAAKs0G,eAAeT,GAC/B7+F,EAIAhP,EACAA,EAAWyL,KAAKuD,GADJhP,EAAa,CAACgP,GAH7BhV,KAAKk0G,cAAcL,GAQvB,IAAIU,EAAc,EACdC,EAAY,EACZC,EAAe,EACfC,EAAa,EACbb,EAAGE,KAAK,EAAA3oC,MAAMr4D,UACZohG,EAAW,IAAGA,EAAWN,EAAGQ,UAChCpuG,GAAS,EAAAqG,YAAYyG,OACrBwhG,EAAcV,EAAGQ,SACjBG,EAAYX,EAAGljG,IACXkjG,EAAGE,KAAK,EAAA3oC,MAAMupC,WAChBF,EAAeZ,EAAGQ,SAClBK,EAAab,EAAGljG,MAIpB,IAAIikG,EAAe,EACfC,EAAa,EACbC,EAAgC,MAAb1iC,GAAqBA,EAAU5lE,GAAG,EAAAF,YAAYmsD,SACjEo7C,EAAGE,KAAK,EAAA3oC,MAAMykB,SACZilB,EACF90G,KAAKw4B,MACH,EAAAC,eAAes8E,gEACflB,EAAGpzG,UAGD0zG,EAAW,IAAGA,EAAWN,EAAGQ,UAChCO,EAAeT,EACfU,EAAahB,EAAGljG,IAChB1K,GAAS,EAAAqG,YAAYujF,QAAU,EAAAvjF,YAAYmsD,SAEpCq8C,IACT7uG,GAAS,EAAAqG,YAAYmsD,SAIvB,IAAIlyD,EAA8B,KAG9Bo5E,EAAQk0B,EAAGmB,OAEf,OADIb,EAAW,IAAGA,EAAWN,EAAGoB,cACxBt1B,GACN,KAAK,EAAAvU,MAAM/W,MACTw/C,EAAGvoG,OACHrF,GAAS,EAAAqG,YAAY+nD,MAEnB9tD,EADEstG,EAAGE,KAAK,EAAA3oC,MAAMtV,MACJ91D,KAAKk1G,UAAUrB,EAAI5tG,EAAOD,EAAYmuG,GAEtCn0G,KAAKm1G,cAActB,EAAI5tG,EAAOD,EAAYmuG,GAExDnuG,EAAa,KACb,MAEF,KAAK,EAAAolE,MAAMlF,IAAKjgE,GAAS,EAAAqG,YAAY45D,IACrC,KAAK,EAAAkF,MAAMgqC,IACTvB,EAAGvoG,OACH/E,EAAYvG,KAAKm1G,cAActB,EAAI5tG,EAAOD,EAAYmuG,GACtDnuG,EAAa,KACb,MAEF,KAAK,EAAAolE,MAAMtV,KACT+9C,EAAGvoG,OACH/E,EAAYvG,KAAKk1G,UAAUrB,EAAI5tG,EAAOD,EAAYmuG,GAClDnuG,EAAa,KACb,MAEF,KAAK,EAAAolE,MAAMj8D,SACT0kG,EAAGvoG,OACH/E,EAAYvG,KAAKq1G,cAAcxB,EAAI5tG,EAAOD,EAAYmuG,GACtDnuG,EAAa,KACb,MAEF,KAAK,EAAAolE,MAAM5P,SAAU,CACnB,IAAI85C,EAAQzB,EAAG0B,OACf1B,EAAGvoG,OACH,IAAIkqG,EAAgB3B,EAAGQ,SACnBoB,EAAc5B,EAAGljG,IACjBrF,EAAOuoG,EAAGmB,MAAK,GACnB,GAAInB,EAAG6B,mBAAoB,CACzB7B,EAAG8B,MAAML,GACT/uG,EAAYvG,KAAK41G,eAAe/B,GAAI,GACpC,MAEF,GAAIvoG,GAAQ,EAAA8/D,MAAMr8D,MAAO,CACnBzD,GAAQ,EAAA8/D,MAAM3P,WAChBz7D,KAAKw4B,MACH,EAAAC,eAAeo9E,6EACfhC,EAAGpzG,MAAM+0G,EAAeC,IAG5B5B,EAAG8B,MAAML,GACT/uG,EAAYvG,KAAK41G,eAAe/B,GAAI,GACpC,MAEAA,EAAGiC,QAAQR,GAEbrvG,GAAS,EAAAqG,YAAYkvD,SAGvB,KAAK,EAAA4P,MAAMr8D,MACX,KAAK,EAAAq8D,MAAM3P,UACTo4C,EAAGvoG,OACH/E,EAAYvG,KAAK+1G,sBAAsBlC,EAAI5tG,EAAOD,EAAYmuG,GAC9DnuG,EAAa,KACb,MAEF,KAAK,EAAAolE,MAAMpV,UAAW,CACpB,IAAIs/C,EAAQzB,EAAG0B,OACf1B,EAAGvoG,OACCuoG,EAAGmB,MAAK,EAAO,EAAAgB,mBAAmBC,SAAW,EAAA7qC,MAAMv+D,YACrDgnG,EAAGiC,QAAQR,GACX/uG,EAAYvG,KAAKk2G,eAAerC,EAAI5tG,EAAOD,EAAYmuG,GACvDnuG,EAAa,OAEb6tG,EAAG8B,MAAML,GACT/uG,EAAYvG,KAAK41G,eAAe/B,GAAI,IAEtC,MAEF,KAAK,EAAAzoC,MAAMr3D,OACT8/F,EAAGvoG,OAGD/E,GAFFN,GAAS,EAAAqG,YAAYyH,QACT,EAAAzH,YAAYyG,OACV/S,KAAKm2G,kBAAkBtC,EAAIM,GAE3Bn0G,KAAKo2G,YAAYvC,GAE/B,MAEF,KAAK,EAAAzoC,MAAMirC,KAAM,CACf,IAAIf,EAAQzB,EAAG0B,OACf1B,EAAGvoG,OACCuoG,EAAGmB,MAAK,EAAO,EAAAgB,mBAAmBC,SAAW,EAAA7qC,MAAMv+D,YACrDgnG,EAAGiC,QAAQR,GACX/uG,EAAYvG,KAAKs2G,qBAAqBzC,EAAI5tG,EAAOD,EAAYmuG,GAC7DnuG,EAAa,OAEb6tG,EAAG8B,MAAML,GACT/uG,EAAYvG,KAAK41G,eAAe/B,GAAI,IAEtC,MAEF,QAGM5tG,EAAQ,EAAAqG,YAAYyG,OAClB2hG,GAAcb,EAAG0C,eAAe,EAAAP,mBAAmBC,SACjDpB,GACF70G,KAAKw4B,MACH,EAAAC,eAAe+9E,2CACf3C,EAAGpzG,MAAMm0G,EAAcC,IAG3BtuG,EAAYvG,KAAKy2G,wBAAwB5C,EAAIM,EAAUM,EAAcC,GACrED,EAAeC,EAAa,GAE5BnuG,EAAYvG,KAAK02G,YAAY7C,EAAIM,EAA2C,IAAhCluG,EAAQ,EAAAqG,YAAYujF,WAK9D2kB,GACFx0G,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAM8zG,EAAaC,GAAY,UAGlCK,GACF70G,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAMm0G,EAAcC,GAAa,WAGnCziC,IACH7rE,EAAYvG,KAAK41G,eAAe/B,GAAI,KAQ5C,GAAI7tG,EACF,IAAK,IAAIyF,EAAI,EAAGC,EAAI1F,EAAWwF,OAAQC,EAAIC,IAAKD,EAC9CzL,KAAKw4B,MACH,EAAAC,eAAem+E,8BACf5wG,EAAWyF,GAAGhL,OAMpB,GAAIi0G,GAA4B,OAAdnuG,EAChB,OAAQA,EAAU/F,MAChB,KAAK,EAAAN,SAASyS,gBACd,KAAK,EAAAzS,SAASyT,oBACd,KAAK,EAAAzT,SAASmS,iBACd,KAAK,EAAAnS,SAAS8T,qBACd,KAAK,EAAA9T,SAASgU,qBACZ,OAAO,EAAA5T,KAAKu2G,6BAAmDtwG,EAAWstG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAElG,QACE3Q,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAMg0G,EAAcC,GAAa,WAK5C,OAAOnuG,EAIT4wF,WACE,IAAI+b,EAAUlzG,KAAKkzG,QACnB,OAAOA,EAAQ1nG,OAASO,OAAOmnG,EAAQ1zD,SAAW,KAIpD43C,YAAY0f,GACV,IAAIvD,EAAYvzG,KAAKuzG,UACrB,GAAIA,EAAUr4D,IAAI47D,GAAY,CAE5B,OADe/qG,OAAOwnG,EAAUp4D,IAAI27D,IACpB9lG,OAAOP,aAEzB,OAAO,KAIT65E,SACE,GAAItqF,KAAKkzG,QAAQ1nG,OAAQ,MAAM,IAAI28C,MAAM,wBACzCnoD,KAAKkzG,QAAU,GACflzG,KAAKmzG,QAAQljD,QACbjwD,KAAKozG,QAAQnjD,QACbjwD,KAAKuzG,UAAUtjD,QAMjB8mD,cACElD,GAOA,IAFA,IAAIl0B,EAAQ,EAAAr/E,KAAKe,qBAAqBwyG,EAAGmD,iBAAkBnD,EAAGpzG,SAC1DkhD,EAAUg+B,EACPk0B,EAAGE,KAAK,EAAA3oC,MAAM6rC,MAAM,CACzB,IAAIpD,EAAGE,KAAK,EAAA3oC,MAAMv+D,YAShB,OAJA7M,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,MAAMozG,EAAGljG,MAEP,KATsB,CAC7B,IAAIrF,EAAO,EAAAhL,KAAKe,qBAAqBwyG,EAAGmD,iBAAkBnD,EAAGpzG,SAC7DkhD,EAAQr2C,KAAOA,EACfq2C,EAAUr2C,GASd,OAAOq0E,EAITw3B,UACEtD,EACAuD,GAA4B,EAC5BC,GAAuB,GAMvB,IAGI31G,EAHA41G,EAAQzD,EAAGvoG,OACX6oG,EAAWN,EAAGQ,SAKlB,GAAIiD,GAAS,EAAAlsC,MAAMmsC,UAAW,CAG5B,IAAIC,EAAsB3D,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAEpClvG,EAAYrI,KAAKy3G,qBAAqB5D,GAC1C,GAAIxrG,EAAW,CACb,GAAImvG,EAAqB,CACvB,IAAK3D,EAAGE,KAAK,EAAA3oC,MAAMssC,YAKjB,OAJA13G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAET,IAAKozG,EAAGE,KAAK,EAAA3oC,MAAMqE,KAKjB,OAJAzvE,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAEJozG,EAAGE,KAAK,EAAA3oC,MAAM/gE,OACjBrK,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,QAGhB4H,EAAUtH,YAAa,EAEzB,OAAOsH,EACF,GAAImvG,GAAuBx3G,KAAKwzG,6BAKrC,OAJAxzG,KAAKw4B,MACH,EAAAC,eAAem/E,iBACf/D,EAAGpzG,SAEE,KAIT,IAAI22G,EAoBF,OAJAp3G,KAAKw4B,MACH,EAAAC,eAAem/E,iBACf/D,EAAGpzG,SAEE,KApBgB,CACvB,IAAIo3G,EAAY73G,KAAKm3G,UAAUtD,GAAI,EAAOwD,GAC1C,IAAKQ,EAAW,OAAO,KACvB,IAAKhE,EAAGE,KAAK,EAAA3oC,MAAMssC,YAOjB,OANKL,GACHr3G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,MAAMozG,EAAGljG,KAAM,KAGf,MAETjP,EAAOm2G,GACFp3G,MAAMyU,MAAQi/F,EACnBzyG,EAAKjB,MAAM+Q,IAAMqiG,EAAGljG,UAUjB,GAAI2mG,GAAS,EAAAlsC,MAAMz2D,KACxBjT,EAAO,EAAApB,KAAKw3G,gBACV,EAAAx3G,KAAKe,qBAAqB,OAAQwyG,EAAGpzG,SAAU,IAAI,EAAOozG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,WAI7E,GAAI2mG,GAAS,EAAAlsC,MAAMvgE,KACxBnJ,EAAO,EAAApB,KAAKw3G,gBACV,EAAAx3G,KAAKe,qBAAqB,OAAQwyG,EAAGpzG,SAAU,IAAI,EAAOozG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,WAI7E,GAAI2mG,GAAS,EAAAlsC,MAAM9gE,MAAQgtG,GAAS,EAAAlsC,MAAM7gE,MAC/C7I,EAAO,EAAApB,KAAKw3G,gBACV,EAAAx3G,KAAKe,qBAAqB,OAAQwyG,EAAGpzG,SAAU,IAAI,EAAOozG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,WAI7E,GAAI2mG,GAAS,EAAAlsC,MAAM/gE,KACxB3I,EAAO,EAAApB,KAAKw3G,gBACV,EAAAx3G,KAAKe,qBAAqB,OAAQwyG,EAAGpzG,SAAU,IAAI,EAAOozG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,WAI7E,GAAI2mG,GAAS,EAAAlsC,MAAM2sC,cACxBlE,EAAGtM,aACH7lG,EAAO,EAAApB,KAAKw3G,gBACV,EAAAx3G,KAAKe,qBAAqB,SAAUwyG,EAAGpzG,SAAU,IAAI,EAAOozG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,UAI/E,IAAI2mG,GAAS,EAAAlsC,MAAMv+D,WAgCxB,OANKwqG,GACHr3G,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfy7C,EAAGpzG,SAGA,KAhC6B,CACpC,IAAIE,EAAOX,KAAK+2G,cAAclD,GAC9B,IAAKlzG,EAAM,OAAO,KAClB,IAAIM,EAAgC,KAGpC,GAAI4yG,EAAGE,KAAK,EAAA3oC,MAAMC,UAAW,CAC3B,EAAG,CACD,IAAI2sC,EAAYh4G,KAAKm3G,UAAUtD,GAAI,EAAMwD,GACzC,IAAKW,EAAW,OAAO,KAClB/2G,EACAA,EAAWwQ,KAAKumG,GADJ/2G,EAAa,CAAE+2G,SAEzBnE,EAAGE,KAAK,EAAA3oC,MAAMp8D,QACvB,IAAK6kG,EAAGE,KAAK,EAAA3oC,MAAMU,aAOjB,OANKurC,GACHr3G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,MAAMozG,EAAGljG,KAAM,KAGf,KAGN1P,IAAYA,EAAa,IAC9BS,EAAO,EAAApB,KAAKw3G,gBAAgBn3G,EAAMM,GAAY,EAAO4yG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,OAW7E,KAAOkjG,EAAGE,KAAK,EAAA3oC,MAAMqE,MAAM,CACzB,IAAIokC,EAAGE,KAAK,EAAA3oC,MAAM/gE,MAEX,CACL,IAAI4tG,EAAepE,EAAGljG,IAClBunG,EAAUl4G,KAAKm3G,UAAUtD,GAAI,GAAO,GAOxC,OANKwD,GACHr3G,KAAKw4B,MACH,EAAAC,eAAek/E,YACfO,EAAUA,EAAQz3G,MAAQozG,EAAGpzG,MAAMw3G,GAAe,QAG/C,KAVPv2G,EAAKX,YAAa,EActB,KAAO8yG,EAAGE,KAAK,EAAA3oC,MAAM+sC,cAAc,CACjC,IAAIC,EAAevE,EAAGQ,SACtB,IAAKR,EAAGE,KAAK,EAAA3oC,MAAMitC,cAOjB,OANKhB,GACHr3G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAGT,KAET,IAAI63G,EAAezE,EAAGpzG,MAAM23G,EAAcvE,EAAGljG,KAGzC4nG,GAAW,EACf,GAAI1E,EAAGE,KAAK,EAAA3oC,MAAMqE,KAAM,CACtB,IAAIokC,EAAGE,KAAK,EAAA3oC,MAAM/gE,MAShB,OANKgtG,GACHr3G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,QAGT,KARP83G,GAAW,EAiBf,GANA72G,EAAO,EAAApB,KAAKw3G,gBACV,EAAAx3G,KAAKe,qBAAqB,QAASi3G,GACnC,CAAE52G,GACF62G,EACA1E,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAEpB4nG,EAAU,MAGhB,OAAO72G,EAOT+1G,qBACE5D,GAKA,IAyHI3yG,EAzHAo0G,EAAQzB,EAAG0B,OACXpB,EAAWN,EAAGQ,SACdpzG,EAAqC,KACrCy1C,EAAiC,KACjC8hE,GAAoB,EACpBC,EAAoD,KACpDC,EAAgC,EAAAvsG,cAAcwoG,QAElD,GAAId,EAAGE,KAAK,EAAA3oC,MAAMssC,YAChBc,GAAc,EACd3E,EAAGiC,QAAQR,GACXr0G,EAAa,OAER,CACLu3G,GAAc,EACd,EAAG,CACD,IAAIG,GAAc,EACdn4G,EAAO,EAAA2L,cAAcwoG,QAOzB,GANId,EAAGE,KAAK,EAAA3oC,MAAMmZ,eAChBo0B,EAAa9E,EAAGQ,SAChBmE,GAAc,EACd3E,EAAGiC,QAAQR,GACX90G,EAAO,EAAA2L,cAAcwjF,MAEnBkkB,EAAGE,KAAK,EAAA3oC,MAAMvgE,MAAO,CAEvB,GADI8tG,EAAa,IAAGA,EAAa9E,EAAGQ,WAChCR,EAAGE,KAAK,EAAA3oC,MAAMwtC,OAiBhB,OAFA/E,EAAG8B,MAAML,GACTt1G,KAAKwzG,8BAA+B,EAC7B,KAjBiB,CACxBgF,GAAc,EACd3E,EAAGiC,QAAQR,GACX,IAAI5zG,EAAO1B,KAAKm3G,UAAUtD,GAAI,GAC9B,IAAKnyG,EAAM,OAAO,KAClB,GAAIA,EAAKlB,MAAQ,EAAAN,SAASkL,UAMxB,OALApL,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfx1G,EAAKjB,OAEPT,KAAKwzG,8BAA+B,EAC7B,KAET98D,EAA0Bh1C,OAMvB,KAAImyG,EAAG0C,iBA2DZ,OATIiC,EACFx4G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAGLozG,EAAG8B,MAAML,GAEXt1G,KAAKwzG,6BAA+BgF,EAC7B,KA3DuB,CAC1BG,EAAa,IAAGA,EAAa9E,EAAGQ,UACpC,IAAI1zG,EAAO,EAAAL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,MAAMozG,EAAGQ,SAAUR,EAAGljG,MAazF,GAZIkjG,EAAGE,KAAK,EAAA3oC,MAAMytC,YAChBL,GAAc,EACd3E,EAAGiC,QAAQR,GACP90G,GAAQ,EAAA2L,cAAcwjF,KACxB3vF,KAAKw4B,MACH,EAAAC,eAAeqgF,oCACfjF,EAAGpzG,SAGLD,EAAO,EAAA2L,cAAcyjF,UAGrBikB,EAAGE,KAAK,EAAA3oC,MAAMwtC,OAAQ,CACxBJ,GAAc,EACd3E,EAAGiC,QAAQR,GACX,IAAI5zG,EAAO1B,KAAKm3G,UAAUtD,GAC1B,IAAKnyG,EAEH,OADA1B,KAAKwzG,6BAA+BgF,EAC7B,KAET,IAAIO,EAAQ,EAAAz4G,KAAK04G,gBAAgBx4G,EAAMG,EAAMe,EAAM,KAAMmyG,EAAGpzG,MAAMk4G,EAAY9E,EAAGljG,MAC5E1P,EACAA,EAAWwQ,KAAKsnG,GADJ93G,EAAa,CAAE83G,QAShC,GANKP,GACC3E,EAAGmB,QAAU,EAAA5pC,MAAMp8D,QACrBwpG,GAAc,EACd3E,EAAGiC,QAAQR,IAGXkD,EAAa,CACf,IAAIO,EAAQ,EAAAz4G,KAAK04G,gBAAgBx4G,EAAMG,EAAM,EAAAL,KAAK24G,kBAAkBpF,EAAGpzG,MAAMozG,EAAGljG,MAAO,KAAMkjG,EAAGpzG,MAAMk4G,EAAY9E,EAAGljG,MAChH1P,EACAA,EAAWwQ,KAAKsnG,GADJ93G,EAAa,CAAE83G,GAEhC/4G,KAAKw4B,MACH,EAAAC,eAAe2/B,cACf2gD,EAAMr3G,KAAKjB,YAEHQ,IAIVw3G,EAAuB93G,EACvB+3G,EAAiBl4G,WAehBqzG,EAAGE,KAAK,EAAA3oC,MAAMp8D,QACvB,IAAK6kG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAUjB,OATIc,EACFx4G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAGdozG,EAAG8B,MAAML,GAEXt1G,KAAKwzG,6BAA+BgF,EAC7B,KAKX,IAAI3E,EAAGE,KAAK,EAAA3oC,MAAM8tC,oBAmChB,OATIV,EACFx4G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,MAGdozG,EAAG8B,MAAML,GAEXt1G,KAAKwzG,6BAA+BgF,EAC7B,KAlCP,IAAKA,IACHA,GAAc,EACd3E,EAAGiC,QAAQR,GACPmD,GAAsB,CACxB,IAAIM,EAAQ,EAAAz4G,KAAK04G,gBACfN,EACAD,EACA,EAAAn4G,KAAK24G,kBAAkBR,EAAqBh4G,MAAM83D,OAClD,KACAkgD,EAAqBh4G,OAElBQ,EACAA,EAAWwQ,KAAKsnG,GADJ93G,EAAa,CAAE83G,GAEhC/4G,KAAKw4B,MACH,EAAAC,eAAe2/B,cACf2gD,EAAMr3G,KAAKjB,OAKjB,OADAS,EAAalB,KAAKm3G,UAAUtD,KAiB9B7zG,KAAKwzG,8BAA+B,EAE/BvyG,IAAYA,EAAa,IAEvB,EAAAX,KAAK64G,mBACVl4G,EACAC,EACAw1C,GACA,EACAm9D,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,QAxBpB3Q,KAAKwzG,6BAA+BgF,EAC7B,MA6BblE,eACET,GAKA,IAAIM,EAAWN,EAAGQ,SAClB,GAAIR,EAAG0C,iBAAkB,CACvB,IAkBI10G,EAlBAlB,EAAOkzG,EAAGmD,iBACVx0G,EAAyB,EAAAlC,KAAKO,2BAA2BF,EAAMkzG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MACzF,KAAOkjG,EAAGE,KAAK,EAAA3oC,MAAM6rC,MAAM,CACzB,IAAIpD,EAAG0C,eAAe,EAAAP,mBAAmBC,QAYvC,OAJAj2G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KAXPE,EAAOkzG,EAAGmD,iBACVx0G,EAAa,EAAAlC,KAAK84G,+BAChB52G,EACA,EAAAlC,KAAKO,2BAA2BF,EAAMkzG,EAAGpzG,SACzCozG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAW5B,IAAIkjG,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAMhB,OAAO,EAAAj3G,KAAK+4G,gBAAgB72G,EAAY,KAAMqxG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAJpE,GADA9O,EAAO7B,KAAKs5G,eAAezF,GACvBhyG,EACF,OAAO,EAAAvB,KAAK+4G,gBAAgB72G,EAAYX,EAAMgyG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,WAMxE3Q,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAGP,OAAO,KAGT00G,cACEtB,EACA5tG,EACAD,EACAmuG,EACAoF,GAAc,GAKd,IAAI9xG,EAAe,IAAI2I,MACvB,EAAG,CACD,IAAIpN,EAAchD,KAAKw5G,yBAAyB3F,EAAI5tG,EAAOD,EAAYuzG,GACvE,IAAKv2G,EAAa,OAAO,KACzByE,EAAagK,KAAKzO,SACX6wG,EAAGE,KAAK,EAAA3oC,MAAMp8D,QAEvB,IAAI+qB,EAAM,EAAAz5B,KAAKm5G,wBAAwBzzG,EAAYyB,EAAcosG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAEvF,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGTy/E,yBACE3F,EACA8F,EACAC,EACAL,GAAc,GAKd,IAAK1F,EAAG0C,iBAKN,OAJAv2G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KAET,IAAIkL,EAAa,EAAArL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,UACrE,IAAAo5G,6BAA4BluG,EAAW1J,OACzCjC,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfvrG,EAAWlL,OAGf,IAAIwF,EAAQ0zG,EACR9F,EAAGE,KAAK,EAAA3oC,MAAM4Y,eAChB/9E,GAAS,EAAAqG,YAAY81E,qBAGvB,IAAI1gF,EAAwB,KACxBmyG,EAAGE,KAAK,EAAA3oC,MAAMwtC,SAChBl3G,EAAO1B,KAAKm3G,UAAUtD,GAAI,IAG5B,IAAIlyG,EAAiC,KACrC,GAAIkyG,EAAGE,KAAK,EAAA3oC,MAAM4B,SAQhB,GAPI/mE,EAAQ,EAAAqG,YAAYmsD,SACtBz4D,KAAKw4B,MACH,EAAAC,eAAeqhF,iDACfjG,EAAGpzG,WAGPkB,EAAc3B,KAAK+5G,gBAAgBlG,EAAI,IACrB,OAAO,UACf0F,IACNtzG,EAAQ,EAAAqG,YAAY+nD,MAChBpuD,EAAQ,EAAAqG,YAAYmsD,SACxBz4D,KAAKw4B,MACH,EAAAC,eAAewtC,wCACft6D,EAAWlL,OAGLiB,GACV1B,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfy7C,EAAGpzG,MAAMozG,EAAGljG,OAIlB,IAAIlQ,EAAQ,EAAAkO,MAAMC,KAAKjD,EAAWlL,MAAOozG,EAAGpzG,SAO5C,OANoB,OAAhBkB,GAAqE,IAA5CsE,EAAQ,EAAAqG,YAAY81E,sBAC/CpiF,KAAKw4B,MACH,EAAAC,eAAeuhF,iEACfv5G,GAGG,EAAAH,KAAK25G,0BACVtuG,EACAiuG,EACA3zG,EACAvE,EACAC,EACAlB,GAIJy0G,UACErB,EACA5tG,EACAD,EACAmuG,GAKA,GAAIN,EAAGvoG,QAAU,EAAA8/D,MAAMv+D,WAKrB,OAJA7M,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KAET,IAAIkL,EAAa,EAAArL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SACzE,GAAIozG,EAAGvoG,QAAU,EAAA8/D,MAAM8uC,UAKrB,OAJAl6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAGT,IADA,IAAI2F,EAAU,IAAIgK,OACVyjG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAAa,CACjC,IAAIljE,EAASj3C,KAAKo6G,eAAevG,EAAI,EAAAvnG,YAAYC,MACjD,IAAK0qC,EAAQ,OAAO,KAEpB,GADA7wC,EAAQqL,KAAKwlC,IACR48D,EAAGE,KAAK,EAAA3oC,MAAMp8D,OAAQ,CACzB,GAAI6kG,EAAGE,KAAK,EAAA3oC,MAAM+uC,YAChB,MAMA,OAJAn6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,MAIb,IAAIs5B,EAAM,EAAAz5B,KAAK+5G,sBACb1uG,EACA3F,EACAC,EACAG,EACAytG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAGxB,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGTqgF,eACEvG,EACA8F,GAKA,IAAK9F,EAAG0C,iBAKN,OAJAv2G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KAET,IAAIkL,EAAa,EAAArL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SACrE+C,EAA2B,KAC/B,OAAIqwG,EAAGE,KAAK,EAAA3oC,MAAM4B,WAChBxpE,EAAQxD,KAAK+5G,gBAAgBlG,EAAI,IACd,KAEd,EAAAvzG,KAAKg6G,2BACV3uG,EACAguG,EACAn2G,EACA,EAAAmL,MAAMC,KAAKjD,EAAWlL,MAAOozG,EAAGpzG,UAIpC85G,YACE1G,GAKA,IAAIM,EAAWN,EAAGQ,SACd3uG,EAA0B,KAC9B,GACEmuG,EAAGmB,MAAK,IAAS,EAAA5pC,MAAMsuC,WACvB7F,EAAG2G,WAAa,EAAApvC,MAAM+uC,aACrBtG,EAAG6B,sBAEEhwG,EAAO1F,KAAK+5G,gBAAgBlG,IAAM,OAAO,KAGjD,IAAI95E,EAAM,EAAAz5B,KAAKm6G,sBAAsB/0G,EAAMmuG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAEjE,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGT2gF,oBACE7G,GAQA,IAHA,IAAI3tG,EAAiB,IAAIkK,MACrBuqG,GAAe,EACfzlG,EAAQ2+F,EAAGQ,UACPR,EAAGE,KAAK,EAAA3oC,MAAMU,cAAc,CAClC,IAAI8uC,EAAgB56G,KAAK66G,mBAAmBhH,GAC5C,IAAK+G,EAAe,OAAO,KAW3B,GAVkC,OAA9BA,EAAcr5G,YAChBo5G,GAAe,EACNA,IACT36G,KAAKw4B,MACH,EAAAC,eAAeqiF,iEACfF,EAAcn6G,OAEhBm6G,EAAcr5G,YAAc,MAE9B2E,EAAeuL,KAAKmpG,IACf/G,EAAGE,KAAK,EAAA3oC,MAAMp8D,OAAQ,CACzB,GAAI6kG,EAAGE,KAAK,EAAA3oC,MAAMU,aAChB,MAMA,OAJA9rE,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,MAUb,OANKyF,EAAesF,QAClBxL,KAAKw4B,MACH,EAAAC,eAAesiF,oCACflH,EAAGpzG,MAAMyU,EAAO2+F,EAAGljG,MAGhBzK,EAGT20G,mBACEhH,GAKA,GAAIA,EAAGvoG,QAAU,EAAA8/D,MAAMv+D,WAAY,CACjC,IAAIlB,EAAa,EAAArL,KAAKO,2BACpBgzG,EAAGmD,iBACHnD,EAAGpzG,SAEDa,EAAoC,KACxC,GAAIuyG,EAAGE,KAAK,EAAA3oC,MAAM4vC,SAAU,CAC1B,IAAIt5G,EAAO1B,KAAKm3G,UAAUtD,GAC1B,IAAKnyG,EAAM,OAAO,KAClB,GAAIA,EAAKlB,MAAQ,EAAAN,SAASkL,UAKxB,OAJApL,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfx1G,EAAKjB,OAEA,KAETa,EAA6BI,EAE/B,IAAIH,EAAoC,KACxC,GAAIsyG,EAAGE,KAAK,EAAA3oC,MAAM4B,QAAS,CACzB,IAAItrE,EAAO1B,KAAKm3G,UAAUtD,GAC1B,IAAKnyG,EAAM,OAAO,KAClB,GAAIA,EAAKlB,MAAQ,EAAAN,SAASkL,UAKxB,OAJApL,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfx1G,EAAKjB,OAEA,KAETc,EAA6BG,EAE/B,OAAO,EAAApB,KAAK26G,oBACVtvG,EACArK,EACAC,EACA,EAAAoN,MAAMC,KAAKjD,EAAWlL,MAAOozG,EAAGpzG,UAQpC,OALET,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAGA,KAKTy6G,gBACErH,EACAt/B,GAAsB,GAKtB,IAAItzE,EAAa,IAAImP,MACjB+qG,EAAiC,KACjCR,GAAe,EACfS,GAAe,EACf1kE,EAA4B,KAIhC,GADA12C,KAAKyzG,oBAAsB,KACvBI,EAAGE,KAAK,EAAA3oC,MAAMvgE,MAAO,CACvB,IAAIgpG,EAAGE,KAAK,EAAA3oC,MAAMwtC,OAgBhB,OAJA54G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAdP,KADAi2C,EAAW12C,KAAKm3G,UAAUtD,IACX,OAAO,KAgBxB,GAfMn9D,EAASl2C,MAAQ,EAAAN,SAASkL,UAC5BpL,KAAKyzG,oBAAqC/8D,EAE1C12C,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfxgE,EAASj2C,QAUVozG,EAAGE,KAAK,EAAA3oC,MAAMp8D,OACjB,OAAI6kG,EAAGE,KAAK,EAAA3oC,MAAMssC,YACTz2G,GAEPjB,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,MAKb,MAAQozG,EAAGE,KAAK,EAAA3oC,MAAMssC,aAAa,CACjC,IAAIqB,EAAQ/4G,KAAKq7G,eAAexH,EAAIt/B,GACpC,IAAKwkC,EAAO,OAAO,KAQnB,OAPiB,OAAboC,GAAsBC,IACxBp7G,KAAKw4B,MACH,EAAAC,eAAe6iF,kDACfH,EAASx6G,KAAKF,OAEhB26G,GAAe,GAETrC,EAAMt3G,eACZ,QACMk5G,GACF36G,KAAKw4B,MACH,EAAAC,eAAe8iF,yDACfxC,EAAMp4G,KAAKF,OAGf,MAEF,KAAK,EAAA0L,cAAcyjF,SACjB+qB,GAAe,EACf,MAEF,KAAK,EAAAxuG,cAAcwjF,KACjBwrB,EAAWpC,EAKf,GADA93G,EAAWwQ,KAAKsnG,IACXlF,EAAGE,KAAK,EAAA3oC,MAAMp8D,OAAQ,CACzB,GAAI6kG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAChB,MAMA,OAJA13G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,MAIb,OAAOQ,EAGTo6G,eACExH,EACAt/B,GAAsB,GAKtB,IAAIinC,GAAS,EACTC,GAAa,EACbC,EAA2B,KAC3BC,EAA2B,EAAArvG,YAAYC,KAC3C,GAAIgoE,IACEs/B,EAAGE,KAAK,EAAA3oC,MAAM0kB,SAChB4rB,EAAa7H,EAAGpzG,QAChBk7G,GAAe,EAAArvG,YAAYwjF,QAClB+jB,EAAGE,KAAK,EAAA3oC,MAAMoW,YACvBk6B,EAAa7H,EAAGpzG,QAChBk7G,GAAe,EAAArvG,YAAYk1E,WAClBqyB,EAAGE,KAAK,EAAA3oC,MAAM9U,WACvBolD,EAAa7H,EAAGpzG,QAChBk7G,GAAe,EAAArvG,YAAYgqD,SAEzBu9C,EAAGmB,QAAU,EAAA5pC,MAAM7W,UAAU,CAC/B,IAAI+gD,EAAQzB,EAAG0B,OACf1B,EAAGvoG,OACCuoG,EAAGmB,QAAU,EAAA5pC,MAAMwtC,OACrB/E,EAAGiC,QAAQR,GACNoG,IAAYA,EAAa7H,EAAGpzG,SACjCk7G,GAAe,EAAArvG,YAAYioD,UAE3Bs/C,EAAG8B,MAAML,GAef,GAXIzB,EAAGE,KAAK,EAAA3oC,MAAMmZ,eACZo3B,EACF37G,KAAKw4B,MACH,EAAAC,eAAemjF,+DACf/H,EAAGpzG,SAGLi7G,EAAa7H,EAAGpzG,QAElB+6G,GAAS,GAEP3H,EAAG0C,iBAAkB,CAClBiF,IAAQE,EAAa7H,EAAGpzG,SAC7B,IAAIkL,EAAa,EAAArL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SACrEiB,EAAwB,KAS5B,IARI+5G,EAAa5H,EAAGE,KAAK,EAAA3oC,MAAMytC,YACzB2C,GACFx7G,KAAKw4B,MACH,EAAAC,eAAeqgF,oCACfntG,EAAWlL,OAIbozG,EAAGE,KAAK,EAAA3oC,MAAMwtC,QAEhB,GADAl3G,EAAO1B,KAAKm3G,UAAUtD,IACjBnyG,EAAM,OAAO,UAElBA,EAAO,EAAApB,KAAK24G,kBAAkBpF,EAAGpzG,MAAMozG,EAAGljG,MAE5C,IAAIhP,EAAiC,KACrC,GAAIkyG,EAAGE,KAAK,EAAA3oC,MAAM4B,UACZwuC,GACFx7G,KAAKw4B,MACH,EAAAC,eAAeojF,4CACflwG,EAAWlL,OAGXg7G,EACFz7G,KAAKw4B,MACH,EAAAC,eAAeqjF,oDACfnwG,EAAWlL,OAGbg7G,GAAa,EAEf95G,EAAc3B,KAAK+5G,gBAAgBlG,EAAI,IAClClyG,GAAa,OAAO,KAE3B,IAAIo3G,EAAQ,EAAAz4G,KAAK04G,gBACfwC,EACI,EAAArvG,cAAcwjF,KACd8rB,EACE,EAAAtvG,cAAcyjF,SACd,EAAAzjF,cAAcwoG,QACpBhpG,EACAjK,EACAC,EACA,EAAAgN,MAAMC,KAAK7C,OAAO2vG,GAAa7H,EAAGpzG,UAGpC,OADAs4G,EAAM9yG,OAAS01G,EACR5C,EAOT,OALE/4G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAGA,KAGT40G,cACExB,EACA5tG,EACAD,EACAmuG,GAUA,IAAKN,EAAG0C,iBAKN,OAJAv2G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,MAAMozG,EAAGljG,MAEP,KAGT,IAAIhQ,EAAO,EAAAL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SAC/Ds7G,GAAkB,EAElB71G,EAA6C,KACjD,GAAI2tG,EAAGE,KAAK,EAAA3oC,MAAMC,UAAW,CAG3B,GAFA0wC,EAAiBlI,EAAGQ,WACpBnuG,EAAiBlG,KAAK06G,oBAAoB7G,IACrB,OAAO,KAC5B5tG,GAAS,EAAAqG,YAAYsnD,QAGvB,IAAKigD,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAKjB,OAJAv3G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,MAAMozG,EAAGljG,KAAM,KAEb,KAGLorG,EAAiB,IACnBA,EAAiBlI,EAAGQ,UAGtB,IAAIpzG,EAAajB,KAAKk7G,gBAAgBrH,GACtC,IAAK5yG,EAAY,OAAO,KACxB,IAAIy1C,EAAW12C,KAAKyzG,oBAEhBuI,EAAwC,IAA5B/1G,EAAQ,EAAAqG,YAAY0vD,KAChCggD,IACuB,GAArB/6G,EAAWuK,QACbxL,KAAKw4B,MACH,EAAAC,eAAewjF,+CACft7G,EAAKF,OAGLQ,EAAWuK,OAAS,GAAmC,OAA9BvK,EAAW,GAAGU,aACzC3B,KAAKw4B,MACH,EAAAC,eAAeyjF,oDACfv7G,EAAKF,QAKPwF,EAAQ,EAAAqG,YAAYyvD,KAClB96D,EAAWuK,QACbxL,KAAKw4B,MACH,EAAAC,eAAe0jF,sCACfx7G,EAAKF,OAKX,IAAIS,EAA8B,KAClC,GAAI2yG,EAAGE,KAAK,EAAA3oC,MAAMwtC,UAChB13G,EAAalB,KAAKm3G,UAAUtD,GAAI,EAAMmI,IACrB,OAAO,KAGrB96G,IACHA,EAAa,EAAAZ,KAAK24G,kBAChBpF,EAAGpzG,MAAMozG,EAAGljG,MAETqrG,GACHh8G,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfl3D,EAAWT,QAKjB,IAAI4H,EAAY,EAAA/H,KAAK64G,mBACnBl4G,EACAC,EACAw1C,GACA,EACAm9D,EAAGpzG,MAAMs7G,EAAgBlI,EAAGljG,MAG1BrI,EAAyB,KAC7B,GAAIurG,EAAGE,KAAK,EAAA3oC,MAAM8uC,YAShB,GARIj0G,EAAQ,EAAAqG,YAAYmsD,SACtBz4D,KAAKw4B,MACH,EAAAC,eAAe2iC,yDACfy4C,EAAGpzG,WAIP6H,EAAOtI,KAAKo8G,oBAAoBvI,GAAI,IACzB,OAAO,UACP5tG,EAAQ,EAAAqG,YAAYmsD,SAC/Bz4D,KAAKw4B,MACH,EAAAC,eAAeijC,gFACfm4C,EAAGpzG,MAAMozG,EAAGljG,MAIhB,IAAIopB,EAAM,EAAAz5B,KAAK+7G,0BACb17G,EACAqF,EACAC,EACAC,EACAmC,EACAC,EAAI,EAEJurG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAGxB,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGTuiF,wBAAwBzI,GACtB,IACIlzG,EADAwzG,EAAWN,EAAGQ,SAEd9rG,EAAY,EAOhB,GAAIsrG,EAAGyD,OAAS,EAAAlsC,MAAMj8D,UAMpB,GAJExO,EADEkzG,EAAG0C,iBACE,EAAAj2G,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SAExD,EAAAH,KAAKi8G,gCAAgC1I,EAAGpzG,MAAMozG,EAAGljG,OAErDkjG,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAKjB,OAJAv3G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,MAAMozG,EAAGljG,KAAM,KAEb,UAQTpI,EAAY,EACZwD,OAAO8nG,EAAGyD,OAAS,EAAAlsC,MAAMmsC,WACzB52G,EAAO,EAAAL,KAAKi8G,gCAAgC1I,EAAGpzG,MAAMozG,EAAGQ,WAK1D,IAAI0H,EAAiBlI,EAAGljG,IACpB1P,EAAajB,KAAKk7G,gBAAgBrH,GACtC,OAAK5yG,EAEEjB,KAAKw8G,8BAA8B3I,EAAIlzG,EAAMM,EAAYjB,KAAKyzG,oBAAqBlrG,EAAW4rG,EAAU4H,GAFvF,KAKlBS,8BACN3I,EACAlzG,EACAM,EACAw7G,EACAl0G,EACA4rG,GAAgB,EAChB4H,GAAsB,GAElB5H,EAAW,IAAGA,EAAWxzG,EAAKF,MAAMyU,OACpC6mG,EAAiB,IAAGA,EAAiB5H,GAEzC,IAAIjzG,EAA8B,KAClC,GAAiB,GAAbqH,GAAuCsrG,EAAGE,KAAK,EAAA3oC,MAAMwtC,QAEvD,KADA13G,EAAalB,KAAKm3G,UAAUtD,IACX,OAAO,UAExB3yG,EAAa,EAAAZ,KAAK24G,kBAAkBpF,EAAGpzG,MAAMozG,EAAGljG,MAGlD,GAAIpI,IACGsrG,EAAGE,KAAK,EAAA3oC,MAAM8tC,oBAKjB,OAJAl5G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,MAAMozG,EAAGljG,KAAM,MAEb,KAIX,IAAItI,EAAY,EAAA/H,KAAK64G,mBACnBl4G,EACAC,EACAu7G,GACA,EACA5I,EAAGpzG,MAAMs7G,EAAgBlI,EAAGljG,MAG1BrI,EAAyB,KAC7B,GAAIC,EACF,GAAIsrG,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAChB5xG,EAAOtI,KAAKo8G,oBAAoBvI,GAAI,OAC/B,CACL,IAAI6I,EAAiB18G,KAAK+5G,gBAAgBlG,EAAI,GAC1C6I,IAAgBp0G,EAAO,EAAAhI,KAAKq8G,0BAA0BD,QAEvD,CACL,IAAK7I,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAKjB,OAJAl6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,MAAMozG,EAAGljG,KAAM,KAEb,KAETrI,EAAOtI,KAAKo8G,oBAAoBvI,GAAI,GAEtC,IAAKvrG,EAAM,OAAO,KAElB,IAAItF,EAAc,EAAA1C,KAAK+7G,0BACrB17G,EACA,KACA,EAAA2L,YAAYC,KACZ,KACAlE,EACAC,EACAC,EACAsrG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAExB,OAAO,EAAArQ,KAAKs8G,yBAAyB55G,GAGvC+yG,sBACElC,EACA5tG,EACAD,EACAmuG,GAUA,IAAInsB,EAAc6rB,EAAGyD,OAAS,EAAAlsC,MAAM3P,UAEpC,IAAKo4C,EAAG0C,iBAKN,OAJAv2G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KAGT,IAAIkL,EAAa,EAAArL,KAAKO,2BACpBgzG,EAAGmD,iBACHnD,EAAGpzG,SAGDyF,EAA6C,KACjD,GAAI2tG,EAAGE,KAAK,EAAA3oC,MAAMC,UAAW,CAE3B,KADAnlE,EAAiBlG,KAAK06G,oBAAoB7G,IACrB,OAAO,KAC5B5tG,GAAS,EAAAqG,YAAYsnD,QAGvB,IAAItyD,EAAoC,KACxC,GAAIuyG,EAAGE,KAAK,EAAA3oC,MAAM4vC,SAAU,CAC1B,IAAIt5G,EAAO1B,KAAKm3G,UAAUtD,GAC1B,IAAKnyG,EAAM,OAAO,KAClB,GAAIA,EAAKlB,MAAQ,EAAAN,SAASkL,UAKxB,OAJApL,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfx1G,EAAKjB,OAEA,KAETa,EAA6BI,EAG/B,IAAIyE,EAA0C,KAC9C,GAAI0tG,EAAGE,KAAK,EAAA3oC,MAAMyxC,YAAa,CACzB70B,GACFhoF,KAAKw4B,MACH,EAAAC,eAAeqkF,oDACfjJ,EAAGpzG,SAGP,EAAG,CACD,IAAIiB,EAAO1B,KAAKm3G,UAAUtD,GAC1B,IAAKnyG,EAAM,OAAO,KAClB,GAAIA,EAAKlB,MAAQ,EAAAN,SAASkL,UAKxB,OAJApL,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfx1G,EAAKjB,OAEA,KAEJunF,IACE7hF,IAAiBA,EAAkB,IACxCA,EAAgBsL,KAAoB/P,UAE/BmyG,EAAGE,KAAK,EAAA3oC,MAAMp8D,QAGzB,IAAK6kG,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAKjB,OAJAl6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAGT,IACIuC,EADAoD,EAAU,IAAIgK,MA0BlB,GAxBI43E,GACFj8E,QAAQ5F,GACRnD,EAAc,EAAA1C,KAAKy8G,2BACjBpxG,EACA3F,EACAC,EACAC,EACA5E,EACA,KACA8E,EACAytG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,OAGxB3N,EAAc,EAAA1C,KAAK08G,uBACjBrxG,EACA3F,EACAC,EACAC,EACA5E,EACA6E,EACAC,EACAytG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,OAGrBkjG,EAAGE,KAAK,EAAA3oC,MAAM+uC,YACjB,EAAG,CACD,IAAIljE,EAASj3C,KAAKi9G,iBAAiBpJ,EAAI7wG,GACvC,GAAIi0C,EACEA,EAAOz2C,MAAQ,EAAAN,SAAS+R,eAC1BjP,EAAYsP,eAAqC2kC,GAEjDlrC,OAAOkrC,aAAkB,EAAAjlC,sBACzB5L,EAAQqL,KAA2BwlC,SAIrC,GADAj3C,KAAKk0G,cAAcL,GACfA,EAAGE,KAAK,EAAA3oC,MAAM4oC,WAKhB,OAJAh0G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,YAGHozG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAG1B,OADAn3G,EAAYvC,MAAM+Q,IAAMqiG,EAAGljG,IACpB3N,EAGTk6G,qBAAqBrJ,GAInB,IACIlzG,EADAwzG,EAAWN,EAAGQ,SASlB,GALE1zG,EADEkzG,EAAG0C,iBACE,EAAAj2G,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SAExD,EAAAH,KAAKi8G,gCAAgC1I,EAAGpzG,MAAMozG,EAAGljG,OAGrDkjG,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAKjB,OAJAl6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,MAAMozG,EAAGljG,KAAM,KAEb,KAGT,IAAIvK,EAAU,IAAIgK,MACdpN,EAAc,EAAA1C,KAAK08G,uBACrBr8G,EACA,KACA,EAAA2L,YAAYC,KACZ,KACA,KACA,KACAnG,EACAytG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAExB,IAAKkjG,EAAGE,KAAK,EAAA3oC,MAAM+uC,YACjB,EAAG,CACD,IAAIljE,EAASj3C,KAAKi9G,iBAAiBpJ,EAAI7wG,GACvC,GAAIi0C,EACEA,EAAOz2C,MAAQ,EAAAN,SAAS+R,eAC1BjP,EAAYsP,eAAqC2kC,GAEjDlrC,OAAO/I,aAAuB,EAAAgP,sBAC9B5L,EAAQqL,KAA2BwlC,SAIrC,GADAj3C,KAAKk0G,cAAcL,GACfA,EAAGE,KAAK,EAAA3oC,MAAM4oC,WAKhB,OAJAh0G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,YAGHozG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAG1B,OADAn3G,EAAYvC,MAAM+Q,IAAMqiG,EAAGljG,IACpB,EAAArQ,KAAK68G,sBAAsBn6G,GAGpCi6G,iBACEpJ,EACA18D,GAWA,IAAI6wC,EAAc7wC,EAAO32C,MAAQ,EAAAN,SAAS8T,qBACtCmgG,EAAW,EACXnuG,EAAqC,KACzC,GAAI6tG,EAAGE,KAAK,EAAA3oC,MAAMgpC,IAAK,CACrBD,EAAWN,EAAGQ,SACd,EAAG,CACD,IAAIr/F,EAAYhV,KAAKs0G,eAAeT,GACpC,IAAK7+F,EAAW,MACXhP,IAAYA,EAAa,IAAIoK,OAClCpK,EAAWyL,KAAKuD,SACT6+F,EAAGE,KAAK,EAAA3oC,MAAMgpC,KACnBpsB,GAA8B,OAAfhiF,GACjBhG,KAAKw4B,MACH,EAAAC,eAAem+E,8BACf,EAAAjoG,MAAMC,KAAK5I,EAAW,GAAGvF,MAAOuF,EAAWA,EAAWwF,OAAS,GAAG/K,QAMxE,IAAIwF,EAAQkxC,EAAOlxC,MAAQ,EAAAqG,YAAYmsD,QAGnCuvB,IAAa/hF,GAAS,EAAAqG,YAAY6jD,SAEtC,IAAIykD,EAAe,EACfC,EAAa,EACbC,EAAmB39D,EAAO3qC,GAAG,EAAAF,YAAYmsD,SACzCo7C,EAAGE,KAAK,EAAA3oC,MAAMykB,UACZ7H,EACFhoF,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,QAAS,WAGVq0G,EACF90G,KAAKw4B,MACH,EAAAC,eAAes8E,gEACflB,EAAGpzG,UAGLwF,GAAS,EAAAqG,YAAYujF,QAAU,EAAAvjF,YAAYmsD,QAC3Cm8C,EAAef,EAAGQ,SAClBQ,EAAahB,EAAGljG,KAGfwjG,IAAUA,EAAWN,EAAGQ,WACpBS,IACT7uG,GAAS,EAAAqG,YAAYmsD,SAGvB,IAAI2kD,EAAc,EACdC,EAAY,EACZxJ,EAAGE,KAAK,EAAA3oC,MAAM0kB,SACZ9H,EACFhoF,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,QAAS,WAGdwF,GAAS,EAAAqG,YAAYwjF,OACrBstB,EAAcvJ,EAAGQ,SACjBgJ,EAAYxJ,EAAGljG,KAEZwjG,IAAUA,EAAWN,EAAGQ,WACpBR,EAAGE,KAAK,EAAA3oC,MAAM9U,UACnB0xB,EACFhoF,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,QAAS,YAGdwF,GAAS,EAAAqG,YAAYgqD,QACrB8mD,EAAcvJ,EAAGQ,SACjBgJ,EAAYxJ,EAAGljG,KAEZwjG,IAAUA,EAAWN,EAAGQ,WACpBR,EAAGE,KAAK,EAAA3oC,MAAMoW,aACnBwG,EACFhoF,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,QAAS,cAGdwF,GAAS,EAAAqG,YAAYk1E,UACrB47B,EAAcvJ,EAAGQ,SACjBgJ,EAAYxJ,EAAGljG,KAEZwjG,IAAUA,EAAWN,EAAGQ,WAG/B,IAAIiJ,EAAc,EACdC,EAAY,EACZ/H,EAAgB,EAChBC,EAAc,EACd5B,EAAGE,KAAK,EAAA3oC,MAAM9W,SACZ0zB,EACFhoF,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,QAAS,WAGdwF,GAAS,EAAAqG,YAAYgoD,OACrBgpD,EAAczJ,EAAGQ,SACjBkJ,EAAY1J,EAAGljG,KAEZwjG,IAAUA,EAAWN,EAAGQ,YAE7BpuG,GAAS,EAAAqG,YAAY8jD,SACjByjD,EAAGE,KAAK,EAAA3oC,MAAM5P,YACZwsB,IAAgB7wC,EAAO3qC,GAAG,EAAAF,YAAYkvD,UACxCx7D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,QAAS,aAGdwF,GAAS,EAAAqG,YAAYkvD,SACrBg6C,EAAgB3B,EAAGQ,SACnBoB,EAAc5B,EAAGljG,KAEdwjG,IAAUA,EAAWN,EAAGQ,WAE3Bl9D,EAAOlxC,MAAQ,EAAAqG,YAAYsnD,UAAS3tD,GAAS,EAAAqG,YAAYkxG,kBAG/D,IAAIC,EAAgB,EAChBC,EAAc,EAClB,GAAI7J,EAAGmB,QAAU,EAAA5pC,MAAM7W,SAAU,CAC/B,IAAI+gD,EAAQzB,EAAG0B,OACf1B,EAAGvoG,OACCuoG,EAAGmB,QAAU,EAAA5pC,MAAMwtC,OACrB/E,EAAGiC,QAAQR,GACXrvG,GAAS,EAAAqG,YAAYioD,SACrBkpD,EAAgB5J,EAAGQ,SACnBqJ,EAAc7J,EAAGljG,IACZwjG,IAAUA,EAAWsJ,IAE1B5J,EAAG8B,MAAML,GAKb,IAAIA,EAAQzB,EAAG0B,OACXhhC,GAAgB,EAChBopC,GAAW,EACXC,EAAW,EACXC,EAAS,EACT7B,GAAW,EACX9oD,EAAW,EACX4qD,EAAS,EACR91B,IACC6rB,EAAGE,KAAK,EAAA3oC,MAAMrP,KACZ83C,EAAGmB,MAAK,EAAM,EAAAgB,mBAAmBC,SAAW,EAAA7qC,MAAMv+D,YAAegnG,EAAG6B,mBAatE7B,EAAG8B,MAAML,IAZTrvG,GAAS,EAAAqG,YAAYyvD,IACrB4hD,GAAW,EACXC,EAAW/J,EAAGQ,SACdwJ,EAAShK,EAAGljG,IACPwjG,IAAUA,EAAWyJ,GACtB33G,EAAQ,EAAAqG,YAAYioD,UACtBv0D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAMg9G,EAAeC,GAAc,aAMnC7J,EAAGE,KAAK,EAAA3oC,MAAMpP,KACnB63C,EAAGmB,MAAK,EAAM,EAAAgB,mBAAmBC,SAAW,EAAA7qC,MAAMv+D,YAAegnG,EAAG6B,mBAatE7B,EAAG8B,MAAML,IAZTrvG,GAAS,EAAAqG,YAAY0vD,IACrBggD,GAAW,EACX9oD,EAAW2gD,EAAGQ,SACdyJ,EAASjK,EAAGljG,IACPwjG,IAAUA,EAAWjhD,GACtBjtD,EAAQ,EAAAqG,YAAYioD,UACtBv0D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAMg9G,EAAeC,GAAc,aAMnC7J,EAAGE,KAAK,EAAA3oC,MAAMn8D,eACvBhJ,GAAS,EAAAqG,YAAY2C,YACrBslE,GAAgB,EACX4/B,IAAUA,EAAWN,EAAGQ,UACzBpuG,EAAQ,EAAAqG,YAAYgoD,QACtBt0D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAM68G,EAAaC,GAAY,UAGlCt3G,EAAQ,EAAAqG,YAAYkvD,UACtBx7D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAM+0G,EAAeC,GAAc,YAGtCxvG,EAAQ,EAAAqG,YAAYioD,UACtBv0D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAMg9G,EAAeC,GAAc,cAM9C,IACI/8G,EADAo9G,EAAmBJ,GAAY3B,EAEnC,GAAIznC,EACF5zE,EAAO,EAAAL,KAAK09G,4BAA4BnK,EAAGpzG,aACtC,CACL,IAAKs9G,GAAoBlK,EAAGE,KAAK,EAAA3oC,MAAM+sC,aAAc,CAC9ChE,IAAUA,EAAWN,EAAGQ,UAEzBpuG,EAAQ,EAAAqG,YAAYwjF,OACtB9vF,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAM28G,EAAaC,GAAY,WAE3Bp3G,EAAQ,EAAAqG,YAAYk1E,WAKpBv7E,EAAQ,EAAAqG,YAAYgqD,UAJ7Bt2D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAM28G,EAAaC,GAAY,aAQlCp3G,EAAQ,EAAAqG,YAAYgoD,QACtBt0D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAM68G,EAAaC,GAAY,UAGlCt3G,EAAQ,EAAAqG,YAAYkvD,UACtBx7D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAM+0G,EAAeC,GAAc,YAG1C,IAAIwI,EAAWj+G,KAAKk+G,oBAAoBrK,EAAI5tG,EAAOD,GACnD,OAAKi4G,GASLpK,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACPuE,IATDh4G,EAAQ,EAAAqG,YAAYioD,UACtBv0D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAMg9G,EAAeC,GAAc,YAGnC,MAKX,IAAK7J,EAAG0C,eAAe,EAAAP,mBAAmBmI,QAKxC,OAJAn+G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KAEJ0zG,IAAUA,EAAWN,EAAGQ,UAC7B1zG,EAAO,EAAAL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SAEjE,IAAIyF,EAA6C,KACjD,GAAI2tG,EAAGE,KAAK,EAAA3oC,MAAMC,UAAW,CAC3B,IAAI+yC,EAAsBvK,EAAGQ,SAE7B,KADAnuG,EAAiBlG,KAAK06G,oBAAoB7G,IACrB,OAAO,KACxBt/B,EACFv0E,KAAKw4B,MACH,EAAAC,eAAe4lF,2DACfxK,EAAGpzG,MAAM29G,EAAqBvK,EAAGljG,MAE1BotG,EACT/9G,KAAKw4B,MACH,EAAAC,eAAe6lF,wCACfzK,EAAGpzG,MAAM29G,EAAqBvK,EAAGljG,MAGnC1K,GAAS,EAAAqG,YAAYsnD,QAKzB,GAAIigD,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAAY,CACxBtxG,EAAQ,EAAAqG,YAAYujF,SACtB7vF,KAAKw4B,MACH,EAAAC,eAAe8lF,yDACf1K,EAAGpzG,MAAMm0G,EAAcC,GAAa,WAIxC,IAAIkH,EAAiBlI,EAAGQ,SACpBpzG,EAAajB,KAAKk7G,gBAAgBrH,EAAIt/B,GAC1C,IAAKtzE,EAAY,OAAO,KACxB,IAAIy1C,EAAW12C,KAAKyzG,oBACpB,GAAIl/B,EACF,IAAK,IAAI9oE,EAAI,EAAGC,EAAIzK,EAAWuK,OAAQC,EAAIC,IAAKD,EAAG,CACjD,IAAIusG,EAAY/2G,EAAWwK,GAC3B,GAAIusG,EAAUtrG,MACZ,EAAAJ,YAAYwjF,OACZ,EAAAxjF,YAAYk1E,UACZ,EAAAl1E,YAAYgqD,QACZ,EAAAhqD,YAAYioD,UACX,CACD,IAAIloD,EAA2B,EAAA/L,KAAKk+G,uBAClCxG,EAAUr3G,KACV,KACAq3G,EAAU/xG,MAAQ,EAAAqG,YAAY8jD,SAC9B4nD,EAAUt2G,KACV,KACAs2G,EAAUv3G,OAEZ4L,EAAyBiH,eAAiB7H,EAC1CusG,EAAU3rG,yBAA2BA,EACrC8qC,EAAO/wC,QAAQqL,KAAKpF,SAGfsxG,EACL18G,EAAWuK,QACbxL,KAAKw4B,MACH,EAAAC,eAAe0jF,sCACfx7G,EAAKF,OAGAu7G,GACgB,GAArB/6G,EAAWuK,QACbxL,KAAKw4B,MACH,EAAAC,eAAewjF,+CACft7G,EAAKF,OAGLQ,EAAWuK,OAAS,GAAmC,OAA9BvK,EAAW,GAAGU,aACzC3B,KAAKw4B,MACH,EAAAC,eAAeyjF,oDACfv7G,EAAKF,QAGa,eAAbE,EAAKsB,MACdjC,KAAKw4B,MACH,EAAAC,eAAegmF,+BACf99G,EAAKF,MAAO,eAIhB,IAAIS,EAA8B,KAClC,GAAI2yG,EAAGE,KAAK,EAAA3oC,MAAMwtC,QAahB,GAZIj4G,EAAKH,MAAQ,EAAAN,SAAS+O,YACxBjP,KAAKw4B,MACH,EAAAC,eAAeimF,2DACf7K,EAAGpzG,SAEIu7G,GACTh8G,KAAKw4B,MACH,EAAAC,eAAekmF,oDACf9K,EAAGpzG,SAGPS,EAAalB,KAAKm3G,UAAUtD,EAAImI,GAAYr7G,EAAKH,MAAQ,EAAAN,SAAS+O,cAC7D/N,EAAY,OAAO,UAExBA,EAAa,EAAAZ,KAAK24G,kBAAkBpF,EAAGpzG,MAAMozG,EAAGljG,MAC3CqrG,GAAYr7G,EAAKH,MAAQ,EAAAN,SAAS+O,aACrCjP,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfl3D,EAAWT,OAKjB,IAAI4H,EAAY,EAAA/H,KAAK64G,mBACnBl4G,EACAC,EACAw1C,GACA,EACAm9D,EAAGpzG,MAAMs7G,EAAgBlI,EAAGljG,MAG1BrI,EAAyB,KAC7B,GAAIurG,EAAGE,KAAK,EAAA3oC,MAAM8uC,YAkBhB,GAjBIj0G,EAAQ,EAAAqG,YAAYmsD,QACtBz4D,KAAKw4B,MACH,EAAAC,eAAe2iC,yDACfy4C,EAAGpzG,SAEIwF,EAAQ,EAAAqG,YAAYkvD,SAC7Bx7D,KAAKw4B,MACH,EAAAC,eAAemmF,qEACf/K,EAAGpzG,QAASE,EAAKsB,MAEV+lF,GACThoF,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAGhB6H,EAAOtI,KAAKo8G,oBAAoBvI,GAAI,IAC/BvrG,EAAM,OAAO,UACR0/E,GAAiB/hF,GAAS,EAAAqG,YAAYmsD,QAAU,EAAAnsD,YAAYkvD,WACtEx7D,KAAKw4B,MACH,EAAAC,eAAeijC,gFACfm4C,EAAGpzG,SAIP,IAAIo+G,EAAY,EAAAv+G,KAAKw+G,wBACnBn+G,EACAqF,EACAC,EACAC,EACAmC,EACAC,EACAurG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAKxB,OAHMq3E,GAAe6rB,EAAGE,KAAK,EAAA3oC,MAAMp8D,QACjC6kG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WAETmF,EAEF,GAAItqC,EACTv0E,KAAKw4B,MACH,EAAAC,eAAesmF,sCACfp+G,EAAKF,WAGF,KAAIs9G,EAOJ,CACD93G,EAAQ,EAAAqG,YAAYujF,SACtB7vF,KAAKw4B,MACH,EAAAC,eAAemnB,kBACfi0D,EAAGpzG,MAAMm0G,EAAcC,GAAa,kBAIpC5uG,EAAQ,EAAAqG,YAAYkvD,UACtBx7D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAM+0G,EAAeC,GAAc,YAItCxvG,EAAQ,EAAAqG,YAAYyvD,KACtB/7D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAMm9G,EAAUC,GAAS,OAI5B53G,EAAQ,EAAAqG,YAAY0vD,KACtBh8D,KAAKw4B,MACH,EAAAC,eAAek+E,gCACf9C,EAAGpzG,MAAMyyD,EAAU4qD,GAAS,OAIhC,IAAIp8G,EAAwB,KAU5B,GATImyG,EAAGE,KAAK,EAAA3oC,MAAMytC,WAChB74G,KAAKw4B,MACH,EAAAC,eAAeumF,sCACfnL,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAGtBkjG,EAAGE,KAAK,EAAA3oC,MAAM4Y,eAChB/9E,GAAS,EAAAqG,YAAY81E,qBAEnByxB,EAAGE,KAAK,EAAA3oC,MAAMwtC,QAEhB,GADAl3G,EAAO1B,KAAKm3G,UAAUtD,IACjBnyG,EAAM,OAAO,UAElB1B,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfy7C,EAAGpzG,SAGP,IAAIkB,EAAiC,KACrC,GAAIkyG,EAAGE,KAAK,EAAA3oC,MAAM4B,UACZ/mE,EAAQ,EAAAqG,YAAYmsD,SACtBz4D,KAAKw4B,MACH,EAAAC,eAAeqhF,iDACfjG,EAAGpzG,SAGPkB,EAAc3B,KAAK+5G,gBAAgBlG,IAC9BlyG,GAAa,OAAO,KAE3B,IAAIlB,EAAQozG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,KAEa,IAA5C1K,EAAQ,EAAAqG,YAAY81E,uBACpB4F,GAA+B,OAAhBrmF,GAAwD,IAA/BsE,EAAQ,EAAAqG,YAAYgoD,SAE7Dt0D,KAAKw4B,MACH,EAAAC,eAAeuhF,iEACfv5G,GAGJ,IAAIw+G,EAAW,EAAA3+G,KAAKk+G,uBAClB79G,EACAqF,EACAC,EACAvE,EACAC,EACAlB,GAKF,OAHMunF,GAAe6rB,EAAGE,KAAK,EAAA3oC,MAAMp8D,QACjC6kG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WAETuF,EAtFPj/G,KAAKw4B,MACH,EAAAC,eAAeijC,gFACf/6D,EAAKF,OAsFT,OAAO,KAGTy9G,oBACErK,EACA5tG,EACAD,GAKmB,OAAfA,GAAuBA,EAAWwF,OAAS,GAC7CxL,KAAKw4B,MACH,EAAAC,eAAem+E,8BACf,EAAAjoG,MAAMC,KAAK5I,EAAW,GAAGvF,MAAOuF,EAAWA,EAAWwF,OAAS,GAAG/K,QAItE,IAAIyU,EAAQ2+F,EAAGQ,SACf,GAAIR,EAAG0C,iBAAkB,CAEvB,GAAU,OADD1C,EAAGmD,iBAEV,GAAInD,EAAGE,KAAK,EAAA3oC,MAAMwtC,OAAQ,CACxB,IAAInwG,EAAUzI,KAAKm3G,UAAUtD,GAC7B,IAAKprG,EAAS,OAAO,KACrB,GAAIA,EAAQjI,MAAQ,EAAAN,SAASkL,UAK3B,OAJApL,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfy7C,EAAGpzG,SAEE,KAET,GAAIozG,EAAGE,KAAK,EAAA3oC,MAAMitC,cAAe,CAC/B,GAAIxE,EAAGE,KAAK,EAAA3oC,MAAMwtC,OAAQ,CACxB,IAAIlwG,EAAY1I,KAAKm3G,UAAUtD,GAC/B,OAAKnrG,EACDA,EAAUlI,MAAQ,EAAAN,SAASkL,WAC7BpL,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfxuG,EAAUjI,OAEL,MAEF,EAAAH,KAAK4+G,qBAAoCz2G,EAASC,EAAWzC,EAAO4tG,EAAGpzG,MAAMyU,EAAO2+F,EAAGljG,MARvE,KAUvB3Q,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,YAIhBT,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAGP,OAAO,KAGTy1G,eACErC,EACA5tG,EACAD,EACAmuG,GAKA,GAAIN,EAAG0C,iBAAkB,CACvB,IAAI5qG,EAAa,EAAArL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SACzE,GAAIozG,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAAY,CAC5B,IAAI9zG,EAAU,IAAIgK,MACdpN,EAAc,EAAA1C,KAAK6+G,2BACrBxzG,EACA3F,EACAC,EACAG,EACAytG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAExB,MAAQkjG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAAa,CACjC,IAAIljE,EAASj3C,KAAKi0G,uBAAuBJ,EAAI7wG,GAC7C,GAAIi0C,EAAQ7wC,EAAQqL,KAAKwlC,QAGvB,GADAj3C,KAAKk0G,cAAcL,GACfA,EAAGE,KAAK,EAAA3oC,MAAM4oC,WAKhB,OAJAh0G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAMb,OAFAuC,EAAYvC,MAAM+Q,IAAMqiG,EAAGljG,IAC3BkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP12G,EAEPhD,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAGP,OAAO,KAGTi2G,YACE7C,EACAM,EACAttG,GAKA,IAAID,EAAuC,KACvC0sG,EAAgBvnG,OAAO/L,KAAKszG,eAChC,GAAIO,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAAY,CAC5B,IAAI9zG,EAAU,IAAIgK,MAClB,MAAQyjG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAAa,CACjC,IAAIljE,EAASj3C,KAAKo/G,kBAAkBvL,GACpC,IAAK58D,EAAQ,OAAO,KAEpB,GADA7wC,EAAQqL,KAAKwlC,IACR48D,EAAGE,KAAK,EAAA3oC,MAAMp8D,OAAQ,CACzB,GAAI6kG,EAAGE,KAAK,EAAA3oC,MAAM+uC,YAChB,MAMA,OAJAn6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,MAIb,GAAIozG,EAAGE,KAAK,EAAA3oC,MAAMi0C,MAAO,CACvB,IAAIxL,EAAGE,KAAK,EAAA3oC,MAAM2sC,eAOhB,OAJA/3G,KAAKw4B,MACH,EAAAC,eAAesiB,wBACf84D,EAAGpzG,SAEE,KANPmG,EAAO,EAAAtG,KAAKg/G,8BAA8BzL,EAAGtM,aAAcsM,EAAGpzG,SASlE,IAAIs5B,EAAM,EAAAz5B,KAAKi/G,sBAAsBn5G,EAASQ,EAAMC,EAAWgtG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MACrF,GAAa,OAAT/J,EAAe,CACjB,IAAI6J,EAAe1E,OAAOguB,EAAItpB,cACzBzQ,KAAKmzG,QAAQj4D,IAAIzqC,KACpBzQ,KAAKuzG,UAAU5mG,IAAI8D,EAAc,IAAIsiG,EAASO,EAAe1sG,IAC7D5G,KAAKkzG,QAAQzhG,KAAKhB,GAClBzQ,KAAKmzG,QAAQ78F,IAAI7F,IAIrB,OADAojG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EACF,GAAI85E,EAAGE,KAAK,EAAA3oC,MAAMsC,UACvB,GAAImmC,EAAGE,KAAK,EAAA3oC,MAAMi0C,MAAO,CACvB,GAAIxL,EAAGE,KAAK,EAAA3oC,MAAM2sC,eAAgB,CAChCnxG,EAAO,EAAAtG,KAAKg/G,8BAA8BzL,EAAGtM,aAAcsM,EAAGpzG,SAC9D,IAAIs5B,EAAM,EAAAz5B,KAAKi/G,sBAAsB,KAAM34G,EAAMC,EAAWgtG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAC9EF,EAAe1E,OAAOguB,EAAItpB,cAC1BO,EAAS6iG,EAAG7iG,OACZV,EAAcU,EAAOV,YAQzB,OAPKA,EACKA,EAAY6mE,SAAS1mE,IAAeH,EAAYmB,KAAKhB,GAD7CO,EAAOV,YAAc,CAAEG,GAEpCzQ,KAAKmzG,QAAQj4D,IAAIzqC,KACpBzQ,KAAKuzG,UAAU5mG,IAAI8D,EAAc,IAAIsiG,EAASO,EAAe1sG,IAC7D5G,KAAKkzG,QAAQzhG,KAAKhB,IAEpBojG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAEP/5B,KAAKw4B,MACH,EAAAC,eAAesiB,wBACf84D,EAAGpzG,cAIPT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,aAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAGhB,OAAO,KAGT2+G,kBACEvL,GAKA,GAAIA,EAAG0C,eAAe,EAAAP,mBAAmBmI,QAAS,CAChD,IAAIxyG,EAAa,EAAArL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SACrE++G,EAA4C,KAChD,GAAI3L,EAAGE,KAAK,EAAA3oC,MAAMX,IAAK,CACrB,IAAIopC,EAAG0C,eAAe,EAAAP,mBAAmBmI,QAOvC,OAJAn+G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KANP++G,EAAe,EAAAl/G,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SAS3E,OAAI++G,EACK,EAAAl/G,KAAKm/G,mBACV9zG,EACA6zG,EACA,EAAA7wG,MAAMC,KAAKjD,EAAWlL,MAAO++G,EAAa/+G,QAGvC,EAAAH,KAAKm/G,mBACV9zG,EACA,KACAA,EAAWlL,OAQf,OALET,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAGA,KAGTg2G,wBACE5C,EACAM,EACAM,EACAC,GAKA,IAAI/zG,EAAOkzG,EAAGmD,iBACVv2G,EAAQozG,EAAGpzG,QACXs5B,EAAM,EAAAz5B,KAAKi/G,sBAAsB,CACnC,EAAAj/G,KAAKm/G,mBACH,EAAAn/G,KAAKO,2BAA2BF,EAAMF,GACtC,EAAAH,KAAKO,2BAA2B,UAAWgzG,EAAGpzG,MAAMg0G,EAAcC,IAClEj0G,IAED,MAAM,EAAOozG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAEtC,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGTq8E,YACEvC,GAOA,IAAIM,EAAWN,EAAGQ,SACdjuG,EAAsC,KACtCuB,EAA6C,KAC7C+3G,GAAW,EACf,GAAI7L,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAEhB,IADA9zG,EAAU,IAAIgK,OACNyjG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAAa,CACjC,IAAIljE,EAASj3C,KAAK2/G,uBAAuB9L,GACzC,IAAK58D,EAAQ,OAAO,KAEpB,GADA7wC,EAAQqL,KAAKwlC,IACR48D,EAAGE,KAAK,EAAA3oC,MAAMp8D,OAAQ,CACzB,GAAI6kG,EAAGE,KAAK,EAAA3oC,MAAM+uC,YAChB,MAMA,OAJAn6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,WAIR,GAAIozG,EAAGE,KAAK,EAAA3oC,MAAMsC,UAAW,CAClC,IAAImmC,EAAGE,KAAK,EAAA3oC,MAAMX,IAehB,OAJAzqE,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,MAEP,KAdP,IAAIozG,EAAG0C,iBAOL,OAJAv2G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KANPkH,EAAgB,EAAArH,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,cAevE,GAAIozG,EAAGE,KAAK,EAAA3oC,MAAMv+D,WAAY,EAAAmpG,mBAAmBC,QAAS,CAC/D,IAAIt1G,EAAOkzG,EAAGmD,iBACVv2G,EAAQozG,EAAGpzG,QAQf,GAPA2F,EAAU,CACR,EAAA9F,KAAKs/G,wBACH,EAAAt/G,KAAKO,2BAA2B,UAAWJ,GAC3C,EAAAH,KAAKO,2BAA2BF,EAAMF,GACtCA,IAGAozG,EAAGE,KAAK,EAAA3oC,MAAMp8D,OAOhB,OALAhP,KAAKw4B,MACH,EAAAC,eAAemnB,kBACfi0D,EAAGpzG,QACH,mCAEK,UAGTi/G,GAAW,EAGb,GAAIA,GAAY7L,EAAGE,KAAK,EAAA3oC,MAAMi0C,MAAO,CACnC,GAAIxL,EAAGE,KAAK,EAAA3oC,MAAM2sC,eAAgB,CAChC,IACIh+E,EADAnzB,EAAO,EAAAtG,KAAKg/G,8BAA8BzL,EAAGtM,aAAcsM,EAAGpzG,SAE9DkH,GACFoE,QAAQ3F,GACR2zB,EAAM,EAAAz5B,KAAKu/G,8BAA8Bl4G,EAAef,EAAMitG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,OAEpFopB,EAAM,EAAAz5B,KAAKw/G,sBAAsB15G,EAASQ,EAAMitG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAExE,IAAIF,EAAespB,EAAItpB,aAMvB,OALKzQ,KAAKmzG,QAAQj4D,IAAIzqC,KACpBzQ,KAAKuzG,UAAU5mG,IAAI8D,EAAc,IAAIsiG,EAAShnG,OAAO/L,KAAKszG,eAAgB1sG,IAC1E5G,KAAKkzG,QAAQzhG,KAAKhB,IAEpBojG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAEP/5B,KAAKw4B,MACH,EAAAC,eAAesiB,wBACf84D,EAAGpzG,cAIPT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,QAGhB,OAAO,KAGTk/G,uBACE9L,GAKA,GAAIA,EAAG0C,eAAe,EAAAP,mBAAmBmI,QAAS,CAChD,IAAIxyG,EAAa,EAAArL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SACrE++G,EAA4C,KAChD,GAAI3L,EAAGE,KAAK,EAAA3oC,MAAMX,IAAK,CACrB,IAAIopC,EAAG0C,iBAOL,OAJAv2G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KANP++G,EAAe,EAAAl/G,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SAS3E,OAAI++G,EACK,EAAAl/G,KAAKs/G,wBACVj0G,EACA6zG,EACA,EAAA7wG,MAAMC,KAAKjD,EAAWlL,MAAO++G,EAAa/+G,QAGvC,EAAAH,KAAKs/G,wBACVj0G,EACA,KACAA,EAAWlL,OAQf,OALET,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAGA,KAGT01G,kBACEtC,EACAM,GAKA,GAAIN,EAAG0C,iBAAkB,CACvB,IAAIiJ,EAAe,EAAAl/G,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SAC3E,GAAIozG,EAAGE,KAAK,EAAA3oC,MAAM4B,QAAS,CACzB,GAAI6mC,EAAG0C,iBAAkB,CACvB,IAAI5qG,EAAa,EAAArL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SACrEs5B,EAAM,EAAAz5B,KAAKy/G,4BAA4Bp0G,EAAY6zG,EAAc3L,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAE3F,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAEP/5B,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,cAIPT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAGP,OAAO,KAGTm1G,eACE/B,EACAmM,GAAiB,GAKjB,IAAI1K,EAAQzB,EAAG0B,OAEXhvG,EAA8B,KAClC,OAFYstG,EAAGvoG,QAGb,KAAK,EAAA8/D,MAAMh5D,MACT7L,EAAYvG,KAAKigH,WAAWpM,GAC5B,MAEF,KAAK,EAAAzoC,MAAM/W,MACT9tD,EAAYvG,KAAKm1G,cAActB,EAAI,EAAAvnG,YAAY+nD,MAAO,KAAMw/C,EAAGQ,UAC/D,MAEF,KAAK,EAAAjpC,MAAM54D,SACTjM,EAAYvG,KAAKkgH,cAAcrM,GAC/B,MAEF,KAAK,EAAAzoC,MAAM34D,GACTlM,EAAYvG,KAAKmgH,iBAAiBtM,GAClC,MAEF,KAAK,EAAAzoC,MAAM53D,IACTjN,EAAYvG,KAAKogH,kBAAkBvM,GACnC,MAEF,KAAK,EAAAzoC,MAAMv3D,GACTtN,EAAYvG,KAAKqgH,iBAAiBxM,GAClC,MAEF,KAAK,EAAAzoC,MAAMlF,IACT3/D,EAAYvG,KAAKm1G,cAActB,EAAI,EAAAvnG,YAAY45D,IAAK,KAAM2tC,EAAGQ,UAC7D,MAEF,KAAK,EAAAjpC,MAAMgqC,IACT7uG,EAAYvG,KAAKm1G,cAActB,EAAI,EAAAvnG,YAAYC,KAAM,KAAMsnG,EAAGQ,UAC9D,MAEF,KAAK,EAAAjpC,MAAM8uC,UACT3zG,EAAYvG,KAAKo8G,oBAAoBvI,EAAImM,GACzC,MAEF,KAAK,EAAA50C,MAAMj3D,OACL6rG,GACFhgH,KAAKw4B,MACH,EAAAC,eAAe6nF,2DACfzM,EAAGpzG,SAGP8F,EAAYvG,KAAKu6G,YAAY1G,GAC7B,MAEF,KAAK,EAAAzoC,MAAMsuC,UACT,OAAO,EAAAp5G,KAAKigH,qBAAqB1M,EAAGpzG,MAAMozG,EAAGQ,WAE/C,KAAK,EAAAjpC,MAAM/2D,OACT9N,EAAYvG,KAAKwgH,qBAAqB3M,GACtC,MAEF,KAAK,EAAAzoC,MAAM92D,MACT/N,EAAYvG,KAAKygH,oBAAoB5M,GACrC,MAEF,KAAK,EAAAzoC,MAAM72D,IACThO,EAAYvG,KAAK0gH,kBAAkB7M,GACnC,MAEF,KAAK,EAAAzoC,MAAMz2D,KACTpO,EAAYvG,KAAK2gH,mBAAmB9M,GACpC,MAEF,KAAK,EAAAzoC,MAAMx2D,MACTrO,EAAYvG,KAAK4gH,oBAAoB/M,GACrC,MAEF,KAAK,EAAAzoC,MAAMirC,KACT,GAAIxC,EAAGmB,MAAK,EAAO,EAAAgB,mBAAmBC,SAAW,EAAA7qC,MAAMv+D,WAAY,CACjEtG,EAAYvG,KAAKs2G,qBAAqBzC,EAAI,EAAAvnG,YAAYC,KAAM,KAAMsnG,EAAGQ,UACrE,MAIJ,QACER,EAAG8B,MAAML,GACT/uG,EAAYvG,KAAK6gH,yBAAyBhN,GAU9C,OANKttG,EAIHstG,EAAGiC,QAAQR,IAHXzB,EAAG8B,MAAML,GACTt1G,KAAKk0G,cAAcL,IAIdttG,EAGT61G,oBACEvI,EACAmM,GAOA,IAFA,IAAI7L,EAAWN,EAAGQ,SACdzuG,EAAa,IAAIwK,OACbyjG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAAa,CACjC,IAAI7E,EAAQzB,EAAG0B,OACXhvG,EAAYvG,KAAK41G,eAAe/B,EAAImM,GACxC,GAAKz5G,EAKHstG,EAAGiC,QAAQR,GACX1vG,EAAW6L,KAAKlL,OANF,CACd,GAAIstG,EAAGyD,OAAS,EAAAlsC,MAAM4oC,UAAW,OAAO,KACxCH,EAAG8B,MAAML,GACTt1G,KAAKk0G,cAAcL,IAMvB,IAAI95E,EAAM,EAAAz5B,KAAKwgH,qBAAqBl7G,EAAYiuG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAEtE,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGTkmF,WACEpM,GAKA,IAAIloG,EAA0C,KAC1CkoG,EAAGmB,MAAK,IAAS,EAAA5pC,MAAMv+D,YAAegnG,EAAG6B,qBAC3C7B,EAAGvoG,KAAK,EAAA0qG,mBAAmBC,QAC3BtqG,EAAa,EAAArL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,UAEvE,IAAIs5B,EAAM,EAAAz5B,KAAKygH,qBAAqBp1G,EAAYkoG,EAAGpzG,SAEnD,OADAozG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGTmmF,cACErM,GAKA,IAAIloG,EAA0C,KAC1CkoG,EAAGmB,MAAK,IAAS,EAAA5pC,MAAMv+D,YAAegnG,EAAG6B,qBAC3C7B,EAAGvoG,KAAK,EAAA0qG,mBAAmBC,QAC3BtqG,EAAa,EAAArL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,UAEvE,IAAIs5B,EAAM,EAAAz5B,KAAK0gH,wBAAwBr1G,EAAYkoG,EAAGpzG,SAEtD,OADAozG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGTomF,iBACEtM,GAKA,IAAIM,EAAWN,EAAGQ,SACd9tG,EAAYvG,KAAK41G,eAAe/B,GACpC,IAAKttG,EAAW,OAAO,KAEvB,GAAIstG,EAAGE,KAAK,EAAA3oC,MAAMx2D,OAEhB,GAAIi/F,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAAY,CAC5B,IAAI5yG,EAAY3E,KAAK+5G,gBAAgBlG,GACrC,IAAKlvG,EAAW,OAAO,KAEvB,GAAIkvG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAAa,CAC7B,IAAI39E,EAAM,EAAAz5B,KAAK2gH,kBAAkB16G,EAAW5B,EAAWkvG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAE7E,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAEP/5B,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,SAGhB,OAAO,KAGTogH,yBACEhN,GAKA,IAAInuG,EAAO1F,KAAK+5G,gBAAgBlG,GAChC,IAAKnuG,EAAM,OAAO,KAElB,IAAIq0B,EAAM,EAAAz5B,KAAKq8G,0BAA0Bj3G,GAEzC,OADAmuG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGTqmF,kBACEvM,GAKA,IAAIM,EAAWN,EAAGQ,SAElB,GAAIR,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAAY,CAC5B,IAAI51G,EAAgC,KAEpC,GAAIkyG,EAAGE,KAAK,EAAA3oC,MAAM/W,OAChB1yD,EAAc3B,KAAKm1G,cAActB,EAAI,EAAAvnG,YAAY+nD,MAAO,KAAMw/C,EAAGQ,UAAU,QACtE,GAAIR,EAAGE,KAAK,EAAA3oC,MAAMlF,KACvBvkE,EAAc3B,KAAKm1G,cAActB,EAAI,EAAAvnG,YAAY45D,IAAK,KAAM2tC,EAAGQ,UAAU,QACpE,GAAIR,EAAGE,KAAK,EAAA3oC,MAAMgqC,KACvBzzG,EAAc3B,KAAKm1G,cAActB,EAAI,EAAAvnG,YAAYC,KAAM,KAAMsnG,EAAGQ,UAAU,QAErE,IAAKR,EAAGE,KAAK,EAAA3oC,MAAMsuC,aACxB/3G,EAAc3B,KAAK6gH,yBAAyBhN,IACvClyG,GAAa,OAAO,KAG3B,GAAIA,EAAa,CACf,GAAIkyG,EAAGE,KAAK,EAAA3oC,MAAM81C,IAAK,CAErB,GAAIv/G,EAAYnB,MAAQ,EAAAN,SAASmT,WAC/B,OAA0B1R,EAAaa,WAAWhC,MAAQ,EAAAN,SAAS2M,YACjE7M,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfv1G,EAAYlB,OAEP,MAEFT,KAAKmhH,oBAAoBtN,EAAIM,EAAUxyG,GAEhD,GAAIA,EAAYnB,MAAQ,EAAAN,SAASwU,SAAU,CACzC,IAAIjN,EAAmC9F,EAAa8F,aACpD,IAAK,IAAIgE,EAAI,EAAGC,EAAIjE,EAAa+D,OAAQC,EAAIC,IAAKD,EAAG,CACnD,IACI9J,EADc8F,EAAagE,GACD9J,YAC1BA,GACF3B,KAAKw4B,MACH,EAAAC,eAAe2oF,0EACfz/G,EAAYlB,OAIlB,OAAOT,KAAKmhH,oBAAoBtN,EAAIM,EAAUxyG,GAMhD,OAJA3B,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfv1G,EAAYlB,OAEP,KAGT,GAAIkB,EAAYnB,MAAQ,EAAAN,SAASwU,SAAU,CACzC,IAAIjN,EAAmC9F,EAAa8F,aACpD,IAAK,IAAIgE,EAAI,EAAGC,EAAIjE,EAAa+D,OAAQC,EAAIC,IAAKD,EAAG,CACnD,IAAIzI,EAAcyE,EAAagE,GAC1BzI,EAAYrB,cACXqB,EAAYiD,MAAQ,EAAAqG,YAAY+nD,MAClCr0D,KAAKw4B,MACH,EAAAC,eAAewtC,wCACfjjE,EAAYrC,KAAKF,OAETuC,EAAYtB,MACtB1B,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfp1D,EAAYrC,KAAKF,MAAM83D,UAQnC,GAAIs7C,EAAGyD,OAAS,EAAAlsC,MAAMsuC,UAAW,CAC/B,IAAI/0G,EAAwC,KAC5C,IAAKkvG,EAAGE,KAAK,EAAA3oC,MAAMsuC,aACjB/0G,EAAY3E,KAAK6gH,yBAAyBhN,IACrClvG,GAAW,OAAO,KAGzB,GAAIkvG,EAAGyD,OAAS,EAAAlsC,MAAMsuC,UAAW,CAC/B,IAAI1xG,EAAiC,KACrC,IAAK6rG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAAa,CAE9B,GADA1vG,EAAchI,KAAK+5G,gBAAgBlG,IAC9B7rG,EAAa,OAAO,KAEzB,IAAK6rG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAKjB,OAJA13G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAIX,IAAI8F,EAAYvG,KAAK41G,eAAe/B,GACpC,OAAKttG,EAEE,EAAAjG,KAAK+gH,mBACV1/G,EACAgD,EACIA,EAAUnC,WACV,KACJwF,EACAzB,EACAstG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MATD,KAavB3Q,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAGhB,OAAO,KAGT0gH,oBACEtN,EACAM,EACAjsG,GAKA,IAAIC,EAAWnI,KAAK+5G,gBAAgBlG,GACpC,IAAK1rG,EAAU,OAAO,KAEtB,IAAK0rG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAKjB,OAJA13G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAGT,IAAI8F,EAAYvG,KAAK41G,eAAe/B,GACpC,OAAKttG,EAEE,EAAAjG,KAAKghH,qBACVp5G,EACAC,EACA5B,EACAstG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAND,KAUzB0vG,iBACExM,GAKA,IAAIM,EAAWN,EAAGQ,SAClB,GAAIR,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAAY,CAC5B,IAAI5yG,EAAY3E,KAAK+5G,gBAAgBlG,GACrC,IAAKlvG,EAAW,OAAO,KACvB,GAAIkvG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAAa,CAC7B,IAAInxG,EAAYvG,KAAK41G,eAAe/B,GACpC,IAAKttG,EAAW,OAAO,KACvB,IAAIg7G,EAAkC,KACtC,OAAI1N,EAAGE,KAAK,EAAA3oC,MAAMo2C,QAChBD,EAAgBvhH,KAAK41G,eAAe/B,IAC/B0N,GAAsB,KAEtB,EAAAjhH,KAAKmhH,kBACV98G,EACA4B,EACAg7G,EACA1N,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAGxB3Q,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAGhB,OAAO,KAGT+/G,qBACE3M,GAKA,IAAIM,EAAWN,EAAGQ,SAClB,GAAIR,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAAY,CAC5B,IAAI5yG,EAAY3E,KAAK+5G,gBAAgBlG,GACrC,IAAKlvG,EAAW,OAAO,KACvB,GAAIkvG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAAa,CAC7B,GAAI7D,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAAY,CAC5B,IAAIwH,EAAc,IAAItxG,MACtB,MAAQyjG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAAa,CACjC,IAAIwH,EAAa3hH,KAAK4hH,gBAAgB/N,GACtC,IAAK8N,EAAY,OAAO,KACxBD,EAAYjwG,KAAKkwG,GAEnB,IAAI5nF,EAAM,EAAAz5B,KAAKuhH,sBAAsBl9G,EAAW+8G,EAAa7N,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAEnF,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAEP/5B,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAGhB,OAAO,KAGTmhH,gBACE/N,GAGA,IACIjuG,EACAW,EAFA4tG,EAAWN,EAAGQ,SAMlB,GAAIR,EAAGE,KAAK,EAAA3oC,MAAM02C,MAAO,CACvB,IAAIh8G,EAAQ9F,KAAK+5G,gBAAgBlG,GACjC,IAAK/tG,EAAO,OAAO,KACnB,GAAI+tG,EAAGE,KAAK,EAAA3oC,MAAMwtC,OAAQ,CAExB,IADAhzG,EAAa,IAAIwK,MAEfyjG,EAAGmB,QAAU,EAAA5pC,MAAM02C,MACnBjO,EAAG2G,WAAa,EAAApvC,MAAMupC,SACtBd,EAAG2G,WAAa,EAAApvC,MAAM+uC,YACtB,CAEA,KADA5zG,EAAYvG,KAAK41G,eAAe/B,IAChB,OAAO,KACvBjuG,EAAW6L,KAAKlL,GAElB,OAAO,EAAAjG,KAAKyhH,iBAAiBj8G,EAAOF,EAAYiuG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAEtE3Q,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAMX,GAAIozG,EAAGE,KAAK,EAAA3oC,MAAMupC,SAAU,CACjC,GAAId,EAAGE,KAAK,EAAA3oC,MAAMwtC,OAAQ,CAExB,IADAhzG,EAAa,IAAIwK,MAEfyjG,EAAGmB,QAAU,EAAA5pC,MAAM02C,MACnBjO,EAAG2G,WAAa,EAAApvC,MAAMupC,SACtBd,EAAG2G,WAAa,EAAApvC,MAAM+uC,YACtB,CAEA,KADA5zG,EAAYvG,KAAK41G,eAAe/B,IAChB,OAAO,KACvBjuG,EAAW6L,KAAKlL,GAElB,OAAO,EAAAjG,KAAKyhH,iBAAiB,KAAMn8G,EAAYiuG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAErE3Q,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAeupF,0BACfnO,EAAGpzG,SAGP,OAAO,KAGTggH,oBACE5M,GAKA,IAAIM,EAAWN,EAAGQ,SACd7xG,EAAaxC,KAAK+5G,gBAAgBlG,GACtC,IAAKrxG,EAAY,OAAO,KACxB,IAAIu3B,EAAM,EAAAz5B,KAAK2hH,qBAAqBz/G,EAAYqxG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAEtE,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGT2mF,kBACE7M,GAQA,IACIv0C,EADA60C,EAAWN,EAAGQ,SAElB,GAAIR,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAAY,CAC5B,IAAIt0G,EAAa,IAAIwK,MACrB,MAAQyjG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAAa,CAEjC,KADA76C,EAAOt/D,KAAK41G,eAAe/B,IAChB,OAAO,KAClBjuG,EAAW6L,KAAK6tD,GAElB,IAAIn2D,EAA6C,KAC7CC,EAAsC,KACtCC,EAAwC,KAC5C,GAAIwqG,EAAGE,KAAK,EAAA3oC,MAAM82C,OAAQ,CACxB,IAAKrO,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAKjB,OAJAv3G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAET,IAAKozG,EAAG0C,iBAKN,OAJAv2G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KAGT,GADA0I,EAAgB,EAAA7I,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,UACnEozG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAKjB,OAJA13G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAET,IAAKozG,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAKjB,OAJAl6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAGT,IADA2I,EAAkB,IACVyqG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAAa,CAEjC,KADA76C,EAAOt/D,KAAK41G,eAAe/B,IAChB,OAAO,KAClBzqG,EAAgBqI,KAAK6tD,IAGzB,GAAIu0C,EAAGE,KAAK,EAAA3oC,MAAM+2C,SAAU,CAC1B,IAAKtO,EAAGE,KAAK,EAAA3oC,MAAM8uC,WAKjB,OAJAl6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAGT,IADA4I,EAAoB,IACZwqG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAAa,CAEjC,KADA76C,EAAOt/D,KAAK41G,eAAe/B,IAChB,OAAO,KAClBxqG,EAAkBoI,KAAK6tD,IAG3B,IAAMl2D,IAAmBC,EAKvB,OAJArJ,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,SAEP,KAET,IAAIs5B,EAAM,EAAAz5B,KAAK8hH,mBACbx8G,EACAuD,EACAC,EACAC,EACAwqG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAGxB,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAOT,OALE/5B,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAGT,KAGT61G,qBACEzC,EACA5tG,EACAD,EACAmuG,GAKA,GAAIN,EAAG0C,iBAAkB,CACvB,IAAI51G,EAAO,EAAAL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SAC/DyF,EAA6C,KACjD,GAAI2tG,EAAGE,KAAK,EAAA3oC,MAAMC,UAAW,CAE3B,GADAnlE,EAAiBlG,KAAK06G,oBAAoB7G,IACrC3tG,EAAgB,OAAO,KAC5BD,GAAS,EAAAqG,YAAYsnD,QAEvB,GAAIigD,EAAGE,KAAK,EAAA3oC,MAAM4B,QAAS,CACzB6mC,EAAGE,KAAK,EAAA3oC,MAAMqE,KACd,IAAI/tE,EAAO1B,KAAKm3G,UAAUtD,GAC1B,IAAKnyG,EAAM,OAAO,KAClB,IAAIq4B,EAAM,EAAAz5B,KAAK+hH,sBACb1hH,EACAqF,EACAC,EACAC,EACAxE,EACAmyG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAGxB,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAEP/5B,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAGP,OAAO,KAGTkgH,mBACE9M,GAKA,IAAIM,EAAWN,EAAGQ,SACd7xG,EAAaxC,KAAK+5G,gBAAgBlG,EAAI,IAC1C,IAAKrxG,EAAY,OAAO,KACxB,IAAIu3B,EAAM,EAAAz5B,KAAKgiH,oBAAoB9/G,EAAYqxG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAErE,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAGT6mF,oBACE/M,GAKA,IAAIM,EAAWN,EAAGQ,SAClB,GAAIR,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAAY,CAC5B,IAAI/0G,EAAaxC,KAAK+5G,gBAAgBlG,GACtC,IAAKrxG,EAAY,OAAO,KACxB,GAAIqxG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAAa,CAC7B,IAAInxG,EAAYvG,KAAK41G,eAAe/B,GACpC,IAAKttG,EAAW,OAAO,KACvB,IAAIwzB,EAAM,EAAAz5B,KAAKiiH,qBAAqB//G,EAAY+D,EAAWstG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAEjF,OADAkjG,EAAGE,KAAK,EAAA3oC,MAAMsuC,WACP3/E,EAEP/5B,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,UAIhBT,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAGhB,OAAO,KAKT+hH,qBACE3O,GAEA,IAAIyD,EAAQzD,EAAGvoG,KAAK,EAAA0qG,mBAAmBC,QACnC9B,EAAWN,EAAGQ,SAClB,OAAQiD,GAGN,KAAK,EAAAlsC,MAAMmZ,YACX,KAAK,EAAAnZ,MAAMq3C,MAGX,KAAK,EAAAr3C,MAAM4Y,YACX,KAAK,EAAA5Y,MAAM8Y,MACX,KAAK,EAAA9Y,MAAM+B,KACX,KAAK,EAAA/B,MAAMmC,MACX,KAAK,EAAAnC,MAAMiZ,OACX,KAAK,EAAAjZ,MAAMz2D,KACX,KAAK,EAAAy2D,MAAMs3C,OAAQ,CACjB,IAAIn9G,EAAUvF,KAAK+5G,gBAAgBlG,EAAI,IACvC,OAAKtuG,EACE,EAAAjF,KAAKqiH,4BAA4BrL,EAAO/xG,EAASsuG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MADzD,KAGvB,KAAK,EAAAy6D,MAAMiY,UACX,KAAK,EAAAjY,MAAMqY,YAAa,CACtB,IAAIl+E,EAAUvF,KAAK+5G,gBAAgBlG,EAAI,IACvC,IAAKtuG,EAAS,OAAO,KACrB,OAAQA,EAAQ/E,MACd,KAAK,EAAAN,SAAS2M,WACd,KAAK,EAAA3M,SAASgP,cACd,KAAK,EAAAhP,SAASyK,eAAgB,MAC9B,QACE3K,KAAKw4B,MACH,EAAAC,eAAemqF,0FACfr9G,EAAQ9E,OAId,OAAO,EAAAH,KAAKqiH,4BAA4BrL,EAAO/xG,EAASsuG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAIhF,KAAK,EAAAy6D,MAAM/7D,IAAK,CACd,IAAKwkG,EAAG0C,iBAKN,OAJAv2G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KAET,IAAIqD,EAAW9D,KAAK+2G,cAAclD,GAClC,IAAK/vG,EAAU,OAAO,KACtB,IAAIhD,EAAmC,KACnC+hH,EAAkC,KACtC,GACEhP,EAAGE,KAAK,EAAA3oC,MAAMmsC,YACsD,QAAnEz2G,EAAgBd,KAAK8iH,qCAAqCjP,KAG3D,GADAgP,EAAa7iH,KAAKs5G,eAAezF,IAC5BgP,EAAY,OAAO,UAExBA,EAAa,GAEf,OAAO,EAAAviH,KAAKyiH,oBACVj/G,EACAhD,EACA+hH,EACAhP,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAK1B,KAAK,EAAAy6D,MAAM/gE,KAAM,OAAO,EAAA/J,KAAK0iH,qBAAqBnP,EAAGpzG,SACrD,KAAK,EAAA2qE,MAAM9gE,KAAM,OAAO,EAAAhK,KAAK2iH,qBAAqBpP,EAAGpzG,SACrD,KAAK,EAAA2qE,MAAM7gE,MAAO,OAAO,EAAAjK,KAAK4iH,sBAAsBrP,EAAGpzG,SACvD,KAAK,EAAA2qE,MAAMvgE,KAAM,OAAO,EAAAvK,KAAK6iH,qBAAqBtP,EAAGpzG,SACrD,KAAK,EAAA2qE,MAAMn8D,YAAa,OAAO,EAAA3O,KAAK09G,4BAA4BnK,EAAGpzG,SAGnE,KAAK,EAAA2qE,MAAMmsC,UAAW,CAGpB,GAAI1D,EAAGE,KAAK,EAAA3oC,MAAMssC,YAChB,OAAO13G,KAAKw8G,8BACV3I,EACA,EAAAvzG,KAAKi8G,gCAAgC1I,EAAGpzG,MAAM0zG,IAC9C,GACA,KAAI,GAIR,IAAImB,EAAQzB,EAAG0B,OACX6N,GAAQ,EACZ,GACE,OAAQvP,EAAGvoG,KAAK,EAAA0qG,mBAAmBC,SAGjC,KAAK,EAAA7qC,MAAMmZ,YAET,OADAsvB,EAAG8B,MAAML,GACFt1G,KAAKs8G,wBAAwBzI,GAGtC,KAAK,EAAAzoC,MAAMv+D,WAET,OADAgnG,EAAGmD,iBACKnD,EAAGvoG,QAGT,KAAK,EAAA8/D,MAAMssC,WACT,IACG7D,EAAGE,KAAK,EAAA3oC,MAAMwtC,SACd/E,EAAGE,KAAK,EAAA3oC,MAAM8tC,oBACf,CACAkK,GAAQ,EACR,MAKJ,KAAK,EAAAh4C,MAAMwtC,MAET,OADA/E,EAAG8B,MAAML,GACFt1G,KAAKs8G,wBAAwBzI,GAGtC,KAAK,EAAAzoC,MAAMytC,SACT,GACEhF,EAAGE,KAAK,EAAA3oC,MAAMwtC,QACd/E,EAAGE,KAAK,EAAA3oC,MAAMp8D,QACd6kG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAGd,OADA7D,EAAG8B,MAAML,GACFt1G,KAAKs8G,wBAAwBzI,GAEtCuP,GAAQ,EACR,MAEF,KAAK,EAAAh4C,MAAMp8D,MACT,MAIF,QACEo0G,GAAQ,EAIZ,MAGF,QACEA,GAAQ,SAILA,GACTvP,EAAG8B,MAAML,GAGT,IAAI+N,EAAQrjH,KAAK+5G,gBAAgBlG,GACjC,OAAKwP,EACAxP,EAAGE,KAAK,EAAA3oC,MAAMssC,aAOnB2L,EAAQ,EAAA/iH,KAAKgjH,8BAA8BD,EAAOxP,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MACjE3Q,KAAKujH,yBAAyB1P,EAAIwP,KAPvCrjH,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,MANU,KAYrB,KAAK,EAAA2qE,MAAM+sC,YAAa,CACtB,IAAI91G,EAAqB,IAAI+N,MAC7B,MAAQyjG,EAAGE,KAAK,EAAA3oC,MAAMitC,eAAe,CACnC,IAAI3yG,EACJ,GAAImuG,EAAGmB,QAAU,EAAA5pC,MAAMp8D,MACrBtJ,EAAO,EAAApF,KAAKkjH,wBAAwB3P,EAAGpzG,MAAMozG,EAAGljG,WAGhD,GADAjL,EAAO1F,KAAK+5G,gBAAgBlG,EAAI,IAC3BnuG,EAAM,OAAO,KAGpB,GADArD,EAAmBoP,KAAK/L,IACnBmuG,EAAGE,KAAK,EAAA3oC,MAAMp8D,OAAQ,CACzB,GAAI6kG,EAAGE,KAAK,EAAA3oC,MAAMitC,cAChB,MAMA,OAJAr4G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,MAIb,OAAO,EAAAH,KAAKmjH,6BAA6BphH,EAAoBwxG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAGrF,KAAK,EAAAy6D,MAAM8uC,UAAW,CACpB,IAGIv5G,EAHAwzG,EAAWN,EAAGQ,SACdpwG,EAAQ,IAAImM,MACZlM,EAAS,IAAIkM,MAEjB,MAAQyjG,EAAGE,KAAK,EAAA3oC,MAAM+uC,aAAa,CACjC,GAAKtG,EAAG0C,iBAWN51G,EAAO,EAAAL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,aAXvC,CACxB,IAAKozG,EAAGE,KAAK,EAAA3oC,MAAM2sC,eAKjB,OAJA/3G,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfrD,EAAGpzG,SAEE,KAETE,EAAO,EAAAL,KAAKO,2BAA2BgzG,EAAGtM,aAAcsM,EAAGpzG,SAC3DE,EAAKwB,UAAW,EAKlB,GADA8B,EAAMwN,KAAK9Q,GACPkzG,EAAGE,KAAK,EAAA3oC,MAAMwtC,OAAQ,CACxB,IAAIp1G,EAAQxD,KAAK+5G,gBAAgBlG,EAAI,GACrC,IAAKrwG,EAAO,OAAO,KACnBU,EAAOuN,KAAKjO,OACP,IAAK7C,EAAKwB,SAOf,OAJAnC,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KANPyD,EAAOuN,KAAK9Q,GAQd,IAAKkzG,EAAGE,KAAK,EAAA3oC,MAAMp8D,OAAQ,CACzB,GAAI6kG,EAAGE,KAAK,EAAA3oC,MAAM+uC,YAChB,MAMA,OAJAn6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,MAIb,OAAO,EAAAH,KAAKojH,8BAA8Bz/G,EAAOC,EAAQ2vG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAGjF,KAAK,EAAAy6D,MAAMC,SAAU,CACnB,IAAI5oE,EAASzC,KAAKm3G,UAAUtD,GAC5B,IAAKpxG,EAAQ,OAAO,KACpB,IAAKoxG,EAAGE,KAAK,EAAA3oC,MAAMU,aAKjB,OAJA9rE,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAET,IAAIiF,EAAO1F,KAAK+5G,gBAAgBlG,EAAI,IACpC,OAAKnuG,EACE,EAAApF,KAAKqjH,0BACV,EAAAr1G,cAAck8D,OACd9kE,EACAjD,EACAoxG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MALN,KAQpB,KAAK,EAAAy6D,MAAMv+D,WAAY,CACrB,IAAI+2G,EAAiB/P,EAAGmD,iBACxB,GAAsB,QAAlB4M,EAA0B,OAAO,EAAAtjH,KAAK0iH,qBAAqBnP,EAAGpzG,SAClE,IAAIkL,EAAa,EAAArL,KAAKO,2BAA2B+iH,EAAgB/P,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MACvF,OAAIkjG,EAAGE,KAAK,EAAA3oC,MAAMy4C,iBACT7jH,KAAK8jH,qBAAqBjQ,EAAIloG,GAEnCkoG,EAAGmB,MAAK,IAAS,EAAA5pC,MAAM8tC,oBAAuBrF,EAAG6B,mBAkB9C11G,KAAKujH,yBAAyB1P,EAAIloG,GAAY,GAjB5C3L,KAAKw8G,8BACV3I,EACA,EAAAvzG,KAAKi8G,gCAAgC1I,EAAGpzG,MAAM0zG,IAC9C,CACE,EAAA7zG,KAAK04G,gBACH,EAAA7sG,cAAcwoG,QACdhpG,EACA,EAAArL,KAAK24G,kBAAkBttG,EAAWlL,MAAM83D,OACxC,KACA5sD,EAAWlL,QAGf,KAAI,EAEJ0zG,GAKN,KAAK,EAAA/oC,MAAMrgE,MAAO,CACZ8oG,EAAGmB,QAAU,EAAA5pC,MAAM6rC,KAAOpD,EAAG2G,WAAa,EAAApvC,MAAMmsC,WAClDv3G,KAAKw4B,MACH,EAAAC,eAAesrF,6DACflQ,EAAGpzG,SAGP,IAAIiF,EAAO,EAAApF,KAAK0jH,sBAAsBnQ,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAC5D,OAAO3Q,KAAKujH,yBAAyB1P,EAAInuG,GAE3C,KAAK,EAAA0lE,MAAM2sC,cACT,OAAO,EAAAz3G,KAAKg/G,8BAA8BzL,EAAGtM,aAAcsM,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAEnF,KAAK,EAAAy6D,MAAMy4C,gBACT,OAAO7jH,KAAK8jH,qBAAqBjQ,GAEnC,KAAK,EAAAzoC,MAAM64C,eAAgB,CACzB,IAAIzgH,EAAQqwG,EAAGqQ,cAEf,OADArQ,EAAGsQ,6CACI,EAAA7jH,KAAK8jH,+BAA+B5gH,EAAOqwG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAE1E,KAAK,EAAAy6D,MAAMi5C,aAAc,CACvB,IAAI7gH,EAAQqwG,EAAGyQ,YAEf,OADAzQ,EAAGsQ,6CACI,EAAA7jH,KAAKikH,6BAA6B/gH,EAAOqwG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAIxE,KAAK,EAAAy6D,MAAM6C,MAAO,CAChB,IAAIu2C,EAAgB3Q,EAAG4Q,oBACvB,OAAK5Q,EAAGE,KAAK,EAAA3oC,MAAM6C,OAOZ,EAAA3tE,KAAKokH,8BACVF,EACA3Q,EAAG8Q,kBACH9Q,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,OATtB3Q,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,MAQX,KAAK,EAAA2qE,MAAMj8D,SAAU,CACnB,IAAIzJ,EAAO1F,KAAKs8G,wBAAwBzI,GACxC,OAAKnuG,EACE1F,KAAKujH,yBAAyB1P,EAAInuG,GADvB,KAGpB,KAAK,EAAA0lE,MAAMr8D,MACT,OAAO/O,KAAKk9G,qBAAqBrJ,GAEnC,QAYE,OAXIyD,GAAS,EAAAlsC,MAAM4oC,UACjBh0G,KAAKw4B,MACH,EAAAC,eAAemsF,uBACf/Q,EAAGpzG,MAAM0zG,IAGXn0G,KAAKw4B,MACH,EAAAC,eAAeosF,oBACfhR,EAAGpzG,SAGA,MAKbqiH,qCACEjP,GAKA,IAAIyB,EAAQzB,EAAG0B,OACf,IAAK1B,EAAGE,KAAK,EAAA3oC,MAAMC,UAAW,OAAO,KACrC,IAAIn2D,EAAQ2+F,EAAGQ,SACXvzG,EAAmC,KACvC,EAAG,CACD,GAAI+yG,EAAGmB,SAAW,EAAA5pC,MAAMU,YACtB,MAEF,IAAIpqE,EAAO1B,KAAKm3G,UAAUtD,GAAI,GAAM,GACpC,IAAKnyG,EAEH,OADAmyG,EAAG8B,MAAML,GACF,KAEJx0G,EACAA,EAAc2Q,KAAK/P,GADJZ,EAAgB,CAAEY,SAE/BmyG,EAAGE,KAAK,EAAA3oC,MAAMp8D,QACvB,GAAI6kG,EAAGE,KAAK,EAAA3oC,MAAMU,aAAc,CAC9B,IAAIt6D,EAAMqiG,EAAGljG,IACb,GAAIkjG,EAAGE,KAAK,EAAA3oC,MAAMmsC,WAOhB,OANKz2G,GACHd,KAAKw4B,MACH,EAAAC,eAAeqsF,mCACfjR,EAAGpzG,MAAMyU,EAAO1D,IAGb1Q,EAIX,OADA+yG,EAAG8B,MAAML,GACF,KAGTgE,eACEzF,GAMA,IADA,IAAIhyG,EAAO,IAAIuO,OACPyjG,EAAGE,KAAK,EAAA3oC,MAAMssC,aAAa,CACjC,IAAIhyG,EAAO1F,KAAK+5G,gBAAgBlG,EAAI,GACpC,IAAKnuG,EAAM,OAAO,KAElB,GADA7D,EAAK4P,KAAK/L,IACLmuG,EAAGE,KAAK,EAAA3oC,MAAMp8D,OAAQ,CACzB,GAAI6kG,EAAGE,KAAK,EAAA3oC,MAAMssC,YAChB,MAMA,OAJA13G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,MAIb,OAAOoB,EAGTk4G,gBACElG,EACAkR,EAAA,GAEAh5G,OAAqB,GAAdg5G,GACP,IAAIr/G,EAAO1F,KAAKwiH,qBAAqB3O,GACrC,IAAKnuG,EAAM,OAAO,KAMlB,IALA,IAIIs/G,EAJA7Q,EAAWzuG,EAAKjF,MAAMyU,OAMvB8vG,EAAiBC,EAAoBpR,EAAGmB,UAAY+P,GACrD,CACA,IAAIzN,EAAQzD,EAAGvoG,OACf,OAAQgsG,GAGN,KAAK,EAAAlsC,MAAMX,GACT,GAAIopC,EAAGE,KAAK,EAAA3oC,MAAM/W,OAChB3uD,EAAO,EAAApF,KAAKqjH,0BACV,EAAAr1G,cAAc+lD,MACd3uD,EACA,KACAmuG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,UAEnB,CACL,IAAIlO,EAASzC,KAAKm3G,UAAUtD,GAC5B,IAAKpxG,EAAQ,OAAO,KACpBiD,EAAO,EAAApF,KAAKqjH,0BACV,EAAAr1G,cAAcm8D,GACd/kE,EACAjD,EACAoxG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAG1B,MAEF,KAAK,EAAAy6D,MAAM4Y,YACTt+E,EAAO,EAAApF,KAAKqjH,0BACV,EAAAr1G,cAAco8D,QACdhlE,EACA,KACAmuG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAExBjL,EAAO1F,KAAKujH,yBAAyB1P,EAAInuG,GACzC,MAGF,KAAK,EAAA0lE,MAAMh8D,WAAY,CACrB,IAAIzL,EAAS3D,KAAKm3G,UAAUtD,GAC5B,IAAKlwG,EAAQ,OAAO,KACpB+B,EAAO,EAAApF,KAAK4kH,2BACVx/G,EACA/B,EACAkwG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAExB,MAGF,KAAK,EAAAy6D,MAAM+sC,YAAa,CACtB,IAAI7sG,EAAOtL,KAAK+5G,gBAAgBlG,GAChC,IAAKvoG,EAAM,OAAO,KAClB,IAAKuoG,EAAGE,KAAK,EAAA3oC,MAAMitC,cAKjB,OAJAr4G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAETiF,EAAO,EAAApF,KAAK6kH,8BACVz/G,EACA4F,EACAuoG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAExBjL,EAAO1F,KAAKujH,yBAAyB1P,EAAInuG,GACzC,MAGF,KAAK,EAAA0lE,MAAMiY,UACX,KAAK,EAAAjY,MAAMqY,YAEP/9E,EAAKlF,MAAQ,EAAAN,SAAS2M,YACtBnH,EAAKlF,MAAQ,EAAAN,SAASgP,eACtBxJ,EAAKlF,MAAQ,EAAAN,SAASyK,gBAEtB3K,KAAKw4B,MACH,EAAAC,eAAemqF,0FACfl9G,EAAKjF,OAGTiF,EAAO,EAAApF,KAAK8kH,6BACV9N,EACA5xG,EACAmuG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAExB,MAGF,KAAK,EAAAy6D,MAAMytC,SAAU,CACnB,IAAIj0G,EAAS5E,KAAK+5G,gBAAgBlG,GAClC,IAAKjvG,EAAQ,OAAO,KACpB,IAAKivG,EAAGE,KAAK,EAAA3oC,MAAMwtC,OAKjB,OAJA54G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAET,IAAIoE,EAAS7E,KAAK+5G,gBAAgBlG,EAAIkR,EAAa,EAC/C,EACA,GAEJ,IAAKlgH,EAAQ,OAAO,KACpBa,EAAO,EAAApF,KAAK+kH,wBACV3/G,EACAd,EACAC,EACAgvG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAExB,MAGF,KAAK,EAAAy6D,MAAMp8D,MAAO,CAChB,IAAIs2G,EAA2B,CAAE5/G,GACjC,EAAG,CAED,KADAA,EAAO1F,KAAK+5G,gBAAgBlG,EAAI,IACrB,OAAO,KAClByR,EAAW7zG,KAAK/L,SACTmuG,EAAGE,KAAK,EAAA3oC,MAAMp8D,QACvBtJ,EAAO,EAAApF,KAAKilH,sBAAsBD,EAAYzR,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MACpE,MAGF,KAAK,EAAAy6D,MAAM6rC,IACT,GAAIpD,EAAG0C,eAAe,EAAAP,mBAAmBmI,QAAS,CAChD,IAAI7yG,EAAO,EAAAhL,KAAKO,2BAA2BgzG,EAAGmD,iBAAkBnD,EAAGpzG,SACnEiF,EAAO,EAAApF,KAAK84G,+BACV1zG,EACA4F,EACAuoG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,UAEnB,CACL,IAAIrF,EAAOtL,KAAK+5G,gBAAgBlG,EAAImR,EAAiB,GACrD,IAAK15G,EAAM,OAAO,KAClB,GAAIA,EAAK9K,MAAQ,EAAAN,SAASwK,KAQxB,OAJA1K,KAAKw4B,MACH,EAAAC,eAAey+E,oBACf5rG,EAAK7K,OAEA,KANP,KADAiF,EAAO1F,KAAKwlH,iBAAiB3R,EAAIM,EAAUzuG,EAAsB4F,IACtD,OAAO,KAStB,GAAIuoG,EAAGE,KAAK,EAAA3oC,MAAMy4C,kBAEhB,KADAn+G,EAAO1F,KAAK8jH,qBAAqBjQ,EAAInuG,IAC1B,OAAO,UAElBA,EAAO1F,KAAKujH,yBAAyB1P,EAAInuG,GAAM,GAEjD,MAGF,KAAK,EAAA0lE,MAAM4B,OACX,KAAK,EAAA5B,MAAM8B,YACX,KAAK,EAAA9B,MAAMkC,aACX,KAAK,EAAAlC,MAAMwC,yBACX,KAAK,EAAAxC,MAAMqC,gBACX,KAAK,EAAArC,MAAM4C,aACX,KAAK,EAAA5C,MAAM+C,eACX,KAAK,EAAA/C,MAAMmD,yBACX,KAAK,EAAAnD,MAAMwD,+BACX,KAAK,EAAAxD,MAAM4D,2CACX,KAAK,EAAA5D,MAAMgE,iBACX,KAAK,EAAAhE,MAAMwE,aACX,KAAK,EAAAxE,MAAMoE,WACX,KAAK,EAAApE,MAAMyC,kBAAmB,CAC5B,IAAIviE,EAAOtL,KAAK+5G,gBAAgBlG,EAAImR,GACpC,IAAK15G,EAAM,OAAO,KAClB5F,EAAO,EAAApF,KAAKmlH,uBAAuBnO,EAAO5xG,EAAM4F,EAAMuoG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAC5E,MAGF,KAAK,EAAAy6D,MAAMC,SACX,KAAK,EAAAD,MAAMU,YACX,KAAK,EAAAV,MAAMa,gBACX,KAAK,EAAAb,MAAMgB,mBACX,KAAK,EAAAhB,MAAMoB,cACX,KAAK,EAAApB,MAAMmB,qBACX,KAAK,EAAAnB,MAAMwB,0BACX,KAAK,EAAAxB,MAAMyB,mBACX,KAAK,EAAAzB,MAAM+B,KACX,KAAK,EAAA/B,MAAMmC,MACX,KAAK,EAAAnC,MAAMsC,SACX,KAAK,EAAAtC,MAAM6C,MACX,KAAK,EAAA7C,MAAMgD,QACX,KAAK,EAAAhD,MAAMoD,kBACX,KAAK,EAAApD,MAAMyD,wBACX,KAAK,EAAAzD,MAAM6D,oCACX,KAAK,EAAA7D,MAAMiE,UACX,KAAK,EAAAjE,MAAMqE,IACX,KAAK,EAAArE,MAAMyE,MACX,KAAK,EAAAzE,MAAM4E,oBACX,KAAK,EAAA5E,MAAM+E,QAAS,CAClB,IAAI7kE,EAAOtL,KAAK+5G,gBAAgBlG,EAAImR,EAAiB,GACrD,IAAK15G,EAAM,OAAO,KAClB5F,EAAO,EAAApF,KAAKmlH,uBAAuBnO,EAAO5xG,EAAM4F,EAAMuoG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAC5E,MAEF,QAAS5E,QAAO,IAGpB,OAAOrG,EAGDo+G,qBAAqBjQ,EAAe5uG,EAAyB,MAEnE,IAAIkvG,EAAWlvG,EAAMA,EAAIxE,MAAMyU,MAAQ2+F,EAAGQ,SACtCnvG,EAAQ,IAAIkL,MACZjL,EAAW,IAAIiL,MACf4sC,EAAQ,IAAI5sC,MAGhB,IAFAlL,EAAMuM,KAAKoiG,EAAGtM,WAAW,EAAU,MAAPtiG,IAC5BE,EAASsM,KAAKoiG,EAAG7iG,OAAO/O,KAAK8O,UAAU8iG,EAAG6R,gBAAiB7R,EAAG8R,gBACvD9R,EAAG+R,uBAAuB,CAC/B,IAAIlgH,EAAO1F,KAAK+5G,gBAAgBlG,GAChC,IAAKnuG,EAAM,OAAO,KAElB,GADAs3C,EAAMvrC,KAAK/L,IACNmuG,EAAGE,KAAK,EAAA3oC,MAAM+uC,YAKjB,OAJAn6G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEP,KAETyE,EAAMuM,KAAKoiG,EAAGtM,WAAW,GAA0B,MAAPtiG,IAC5CE,EAASsM,KAAKoiG,EAAG7iG,OAAO/O,KAAK8O,UAAU8iG,EAAG6R,gBAAiB7R,EAAG8R,gBAEhE,OAAO,EAAArlH,KAAKulH,gCAAgC5gH,EAAKC,EAAOC,EAAU63C,EAAO62D,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAGzF60G,iBACN3R,EACAM,EACAzuG,EACAkwC,GAEA,IAAI0gC,EAAS1gC,EAAKpzC,WAClB,OAAQ8zE,EAAO91E,MACb,KAAK,EAAAN,SAAS2M,WACZ+oC,EAAKpzC,WAAa,EAAAlC,KAAK84G,+BACrB1zG,EACsB4wE,EACtBu9B,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,MAExB,MAEF,KAAK,EAAAzQ,SAASwK,KAAM,CAClB,IAAI24G,EAAQrjH,KAAKwlH,iBAAiB3R,EAAIM,EAAUzuG,EAAsB4wE,GACtE,IAAK+sC,EAAO,OAAO,KACnBztE,EAAKpzC,WAAa6gH,EAClBztE,EAAKn1C,MAAQozG,EAAGpzG,MAAM0zG,EAAUN,EAAGljG,KACnC,MAEF,QAKE,OAJA3Q,KAAKw4B,MACH,EAAAC,eAAey+E,oBACfthE,EAAKn1C,OAEA,KAGX,OAAOm1C,EAGD2tE,yBACN1P,EACAnuG,EACAogH,GAA2B,GAG3B,IADA,IAAIhlH,EAAmC,KAErC+yG,EAAGE,KAAK,EAAA3oC,MAAMmsC,YACduO,GACoE,QAAnEhlH,EAAgBd,KAAK8iH,qCAAqCjP,KAC3D,CACA,IAAIhyG,EAAO7B,KAAKs5G,eAAezF,GAC/B,IAAKhyG,EAAM,MACX6D,EAAO,EAAApF,KAAK81E,qBACV1wE,EACA5E,EACAe,EACAgyG,EAAGpzG,MAAMiF,EAAKjF,MAAMyU,MAAO2+F,EAAGljG,MAEhCm1G,GAAqB,EAEvB,OAAOpgH,EAITwuG,cAAcL,GAGZ,IAFAA,EAAGmB,MAAK,GACJnB,EAAG6B,oBAAoB7B,EAAGvoG,SAC3B,CACD,IAAIkvG,EAAY3G,EAAGmB,MAAK,GACxB,GACEwF,GAAa,EAAApvC,MAAM4oC,WACnBwG,GAAa,EAAApvC,MAAMsuC,UACnB,CACA7F,EAAGvoG,OACH,MAEF,GAAIuoG,EAAG6B,mBAAoB,MAC3B,OAAQ7B,EAAGvoG,QACT,KAAK,EAAA8/D,MAAMv+D,WACTgnG,EAAGmD,iBACH,MAEF,KAAK,EAAA5rC,MAAM2sC,cACX,KAAK,EAAA3sC,MAAMy4C,gBACThQ,EAAGtM,aACH,MAEF,KAAK,EAAAn8B,MAAM64C,eACTpQ,EAAGqQ,cACHrQ,EAAGsQ,6CACH,MAEF,KAAK,EAAA/4C,MAAMi5C,aACTxQ,EAAGyQ,YACHzQ,EAAGsQ,6CACH,MAEF,KAAK,EAAA/4C,MAAM8uC,UACTl6G,KAAK+lH,UAAUlS,IAKrBA,EAAG+R,uBAAwB,EAI7BG,UAAUlS,GAER,IAAImS,EAAQ,EACR5C,GAAQ,EACZ,GACE,OAAQvP,EAAGvoG,QACT,KAAK,EAAA8/D,MAAM4oC,UACTh0G,KAAKw4B,MACH,EAAAC,eAAek/E,YACf9D,EAAGpzG,QAAS,KAEd2iH,GAAQ,EACR,MAEF,KAAK,EAAAh4C,MAAM8uC,YACP8L,EACF,MAEF,KAAK,EAAA56C,MAAM+uC,aACP6L,IACU5C,GAAQ,GACpB,MAEF,KAAK,EAAAh4C,MAAMv+D,WACTgnG,EAAGmD,iBACH,MAEF,KAAK,EAAA5rC,MAAM2sC,cACTlE,EAAGtM,aACH,MAEF,KAAK,EAAAn8B,MAAMy4C,gBAET,IADAhQ,EAAGtM,aACGsM,EAAG+R,uBACP5lH,KAAK+lH,UAAUlS,GACfA,EAAGtM,WAAW,IAEhB,MAEF,KAAK,EAAAn8B,MAAM64C,eACTpQ,EAAGqQ,cACHrQ,EAAGsQ,6CACH,MAEF,KAAK,EAAA/4C,MAAMi5C,aACTxQ,EAAGyQ,YACHzQ,EAAGsQ,oDAIAf,IA+Bb,SAAS6B,EAAoBzkH,GAC3B,OAAQA,GACN,KAAK,EAAA4qE,MAAMp8D,MAAO,OAAO,EACzB,KAAK,EAAAo8D,MAAM4B,OACX,KAAK,EAAA5B,MAAM8B,YACX,KAAK,EAAA9B,MAAMkC,aACX,KAAK,EAAAlC,MAAMwC,yBACX,KAAK,EAAAxC,MAAMqC,gBACX,KAAK,EAAArC,MAAM4C,aACX,KAAK,EAAA5C,MAAM+C,eACX,KAAK,EAAA/C,MAAMmD,yBACX,KAAK,EAAAnD,MAAMwD,+BACX,KAAK,EAAAxD,MAAM4D,2CACX,KAAK,EAAA5D,MAAMgE,iBACX,KAAK,EAAAhE,MAAMwE,aACX,KAAK,EAAAxE,MAAMoE,WAAY,OAAO,EAC9B,KAAK,EAAApE,MAAMytC,SAAU,OAAO,EAC5B,KAAK,EAAAztC,MAAM+E,QAAS,OAAO,EAC3B,KAAK,EAAA/E,MAAM4E,oBAAqB,OAAO,EACvC,KAAK,EAAA5E,MAAMqE,IAAK,OAAO,EACvB,KAAK,EAAArE,MAAMyE,MAAO,OAAO,EACzB,KAAK,EAAAzE,MAAMiE,UAAW,OAAO,GAC7B,KAAK,EAAAjE,MAAMoB,cACX,KAAK,EAAApB,MAAMyB,mBACX,KAAK,EAAAzB,MAAMmB,qBACX,KAAK,EAAAnB,MAAMwB,0BAA2B,OAAO,GAC7C,KAAK,EAAAxB,MAAMX,GACX,KAAK,EAAAW,MAAM66C,GACX,KAAK,EAAA76C,MAAMh8D,WACX,KAAK,EAAAg8D,MAAMC,SACX,KAAK,EAAAD,MAAMU,YACX,KAAK,EAAAV,MAAMa,gBACX,KAAK,EAAAb,MAAMgB,mBAAoB,OAAO,GACtC,KAAK,EAAAhB,MAAMoD,kBACX,KAAK,EAAApD,MAAMyD,wBACX,KAAK,EAAAzD,MAAM6D,oCAAqC,OAAO,GACvD,KAAK,EAAA7D,MAAM+B,KACX,KAAK,EAAA/B,MAAMmC,MAAO,OAAO,GACzB,KAAK,EAAAnC,MAAMsC,SACX,KAAK,EAAAtC,MAAM6C,MACX,KAAK,EAAA7C,MAAMgD,QAAS,OAAO,GAC3B,KAAK,EAAAhD,MAAMyC,kBAAmB,OAAO,GACrC,KAAK,EAAAzC,MAAMiY,UACX,KAAK,EAAAjY,MAAMqY,YAAa,OAAO,GAC/B,KAAK,EAAArY,MAAM6rC,IACX,KAAK,EAAA7rC,MAAM+sC,YACX,KAAK,EAAA/sC,MAAM4Y,YAAa,OAAO,GAEjC,OAAO,EA3vIT,WAirIA,SAAkBkiC,GAChB,mBACA,qBACA,uBACA,qBACA,+BACA,iCACA,+BACA,iCACA,+BACA,iCACA,kCACA,4BACA,gCACA,sBACA,4BACA,wCACA,sCACA,oCACA,sCACA,oBACA,oCACA,4BAtBF,CAAkB,EAAAA,aAAA,EAAAA,WAAU,M,oGCjxI5B,eAQA,SAKA,MAAMC,UAA8B,EAAAC,QAGlC7lH,YAAY8lH,EAAiB,IAAI1+D,KAC/B18C,QACAjL,KAAKqmH,KAAOA,EAIdC,cAAcC,GACZvmH,KAAKqmH,KAAK/vG,KAAS,IAAAw2F,2BAA0ByZ,IAI/CC,cAAcC,GACZzmH,KAAKqmH,KAAK/vG,KAAS,IAAAy2F,2BAA0B0Z,KAIjD,IAAIC,EAA0C,KAG9C,0BACEhhH,EACA2gH,EAAiB,IAAI1+D,KAErB,IAAIg/D,EAAUD,EAId,OAHKC,EACAA,EAAQN,KAAOA,EADNK,EAAYC,EAAU,IAAIR,EAAsBE,GAE9DM,EAAQ19D,MAAMvjD,GACP2gH,I,mHC3CT,eAUA,SAwKA,MAAsBD,EAAtB,cAEU,KAAAj0B,MAAyB,IAAI/hF,MAQrC,KAAAw2G,mBAAoC,EALhCC,wBACF,IAAIA,EAAoB7mH,KAAK4mH,mBAC7B,IAAKC,EAAmB,MAAM,IAAI1+D,MAAM,2BACxC,OAAO0+D,EAKLC,6BACF,IAAI30B,EAAQnyF,KAAKmyF,MACb3mF,EAAS2mF,EAAM3mF,OACnB,OAAOA,EAAS2mF,EAAM3mF,EAAS,GAAK,EAKtCu7G,WAAWrhH,IAIXshH,QAAQthH,IAIRuhH,UAAUvhH,IAIVwhH,WAAWxhH,IAIXyhH,YAAYzhH,IAIZ0hH,aAAa1hH,IAIb2hH,UAAU3hH,IAIV4hH,qBAAqB5hH,IAIrB6hH,kBAAkB7hH,IAIlB4gH,cAAc5gH,IAId8gH,cAAc9gH,IAId8hH,eAAe9hH,IAIf+hH,eAAe/hH,IAIfgiH,UAAUhiH,IAIViiH,WAAWjiH,IAIXkiH,WAAWliH,IAIXmiH,WAAWniH,IAIXoiH,YAAYpiH,IAIZqiH,YAAYriH,IAIZsiH,UAAUtiH,IAIVuiH,YAAYviH,IAIZwiH,gBAAgBxiH,IAIhByiH,gBAAgBziH,IAIhB0iH,SAAS1iH,IAIT2iH,iBAAiB3iH,IAIjB4iH,eAAe5iH,IAIf6iH,mBAAmB7iH,IAInB8iH,gBAAgB9iH,IAIhB+iH,kBAAkB/iH,IAIlBgjH,iBAAiBhjH,IAIjBijH,iBAAiBjjH,IAIjBkjH,iBAAiBljH,IAIjBmjH,iBAAiBnjH,IAIjBojH,iBAAiBpjH,IAIjBqjH,eAAerjH,IAIfsjH,cAActjH,IAIdujH,uBAAuBvjH,IAIvBwjH,gBAAgBxjH,IAIhByjH,cAAczjH,IAId0jH,gBAAgB1jH,IAIhB2jH,gBAAgB3jH,IAIhB4jH,SAAS5jH,IAIT6jH,aAAa7jH,IAIb8jH,WAAW9jH,IAIX+jH,aAAa/jH,IAIbgkH,WAAWhkH,IAIXikH,SAASjkH,IAITkkH,WAAWlkH,IAIXmkH,aAAankH,IAIbokH,eAAepkH,IAIfqkH,kBAAkBrkH,IAIlBskH,YAAYtkH,IAIZukH,YAAYvkH,IAIZwkH,aAAaxkH,IAIbykH,aAAazkH,IAIb0kH,aAAa1kH,IAIb2kH,UAAU3kH,IAIV4kH,cAAc5kH,IAId6kH,YAAY7kH,IAIZ8kH,eAAe9kH,IAIf+kH,eAAe/kH,IAIfglH,eAAehlH,IAIfilH,cAAcjlH,IAIdklH,cAAcllH,IAIdmlH,cAAcnlH,IAIdolH,cAAcplH,IAIdqlH,WAAWrlH,IAMXslH,UAAUrqH,IAIVsqH,WAAWtqH,IAIXuqH,WAAWvxF,IAIXwxF,SAASxqH,IAOTsoD,MAAMvjD,GACJ,IAAI0lH,EAAqBprH,KAAK4mH,mBAE9B,OADA5mH,KAAK4mH,mBAAqB76G,OAAOrG,IACzB,IAAAslG,0BAAyBtlG,IAC/B,KAAK,EAAA80C,aAAaqmB,MAAO,CACvB7gE,KAAKmyF,MAAM1gF,KAAK/L,GAChB,IAAI/E,GAAO,IAAAqtG,uBAAsBtoG,GAC7B/E,GAAMX,KAAKirH,WAAWtqH,GAC1B,IAAK,IAAI8K,EAAW,EAAGuuE,GAAI,IAAAi0B,8BAA6BvoG,GAAO+F,EAAIuuE,IAAKvuE,EACtEzL,KAAKipD,OAAM,IAAAilD,0BAAyBxoG,EAAM+F,IAE5CM,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK+mH,WAAWrhH,GAChB,MAEF,KAAK,EAAA80C,aAAas5C,GAAI,CACpB9zF,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAklD,yBAAwBzoG,IACnC1F,KAAKipD,OAAM,IAAAmlD,sBAAqB1oG,IAChC,IAAI6B,GAAU,IAAA8mG,uBAAsB3oG,GAChC6B,GAASvH,KAAKipD,MAAM1hD,GACxBwE,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKgnH,QAAQthH,GACb,MAEF,KAAK,EAAA80C,aAAa6wE,KAAM,CACtBrrH,KAAKmyF,MAAM1gF,KAAK/L,GAChB,IAAI/E,GAAO,IAAA2tG,sBAAqB5oG,GAC5B/E,GAAMX,KAAKirH,WAAWtqH,GAC1BX,KAAKipD,OAAM,IAAAslD,sBAAqB7oG,IAChCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKinH,UAAUvhH,GACf,MAEF,KAAK,EAAA80C,aAAaq4D,MAAO,CACvB7yG,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKirH,YAAW,IAAAzc,uBAAsB9oG,IACtC,IAAIf,GAAY,IAAA8pG,4BAA2B/oG,GACvCf,GAAW3E,KAAKipD,MAAMtkD,GAC1B,IAAInB,GAAQ,IAAA8nH,wBAAuB5lH,GAC/BlC,GAAOxD,KAAKipD,MAAMzlD,GACtBuI,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKknH,WAAWxhH,GAChB,MAEF,KAAK,EAAA80C,aAAa+wE,OAAQ,CACxBvrH,KAAKmyF,MAAM1gF,KAAK/L,GAChB,IAAI44F,GAAc,IAAAktB,+BAA8B9lH,GAC5C44F,GAAat+F,KAAKirH,WAAW3sB,GACjC,IAAIrlB,GAAW,IAAAwyC,4BAA2B/lH,GAC1C,IAAK,IAAI+F,EAAW,EAAGA,EAAIwtE,IAAYxtE,EACrCzL,KAAKirH,YAAW,IAAAS,0BAAyBhmH,EAAM+F,IAEjDzL,KAAKipD,OAAM,IAAA0iE,6BAA4BjmH,IACvC,IAAIlC,GAAQ,IAAAooH,yBAAwBlmH,GAChClC,GAAOxD,KAAKipD,MAAMzlD,GACtBuI,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKmnH,YAAYzhH,GACjB,MAEF,KAAK,EAAA80C,aAAa+6C,KAAM,CACtBv1F,KAAKonH,aAAa1hH,GAClB1F,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKgrH,WAAU,IAAAjc,wBAAuBrpG,IACtC,IAAIm5B,GAAc,IAAAmwE,6BAA4BtpG,GAC9C,IAAK,IAAI+F,EAAW,EAAGA,EAAIozB,IAAepzB,EACxCzL,KAAKipD,OAAM,IAAAgmD,2BAA0BvpG,EAAM+F,IAE7CM,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKqnH,UAAU3hH,GACf,MAEF,KAAK,EAAA80C,aAAaqxE,aAChB7rH,KAAKsnH,qBAAqB5hH,GAC1B1F,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA6iE,gCAA+BpmH,IAC1C,IAAK,IAAI+F,EAAW,EAAGC,GAAI,IAAAqgH,qCAAoCrmH,GAAO+F,EAAIC,IAAKD,EAC7EzL,KAAKipD,OAAM,IAAA+iE,mCAAkCtmH,EAAM+F,IAErDM,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKunH,kBAAkB7hH,GACvB,MAEF,KAAK,EAAA80C,aAAasB,SAChB97C,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKkrH,YAAW,IAAApe,2BAA0BpnG,IAC1CqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKsmH,cAAc5gH,GACnB,MAEF,KAAK,EAAA80C,aAAak5C,SAChB1zF,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKkrH,YAAW,IAAAne,2BAA0BrnG,IAC1C1F,KAAKipD,OAAM,IAAA+jD,2BAA0BtnG,IACrCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKwmH,cAAc9gH,GACnB,MAEF,KAAK,EAAA80C,aAAa0e,UAChBl5D,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKgrH,WAAU,IAAA9d,2BAA0BxnG,IACzCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKwnH,eAAe9hH,GACpB,MAEF,KAAK,EAAA80C,aAAayxE,UAChBjsH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKgrH,WAAU,IAAAkB,2BAA0BxmH,IACzC1F,KAAKipD,OAAM,IAAAkjE,4BAA2BzmH,IACtCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKynH,eAAe/hH,GACpB,MAEF,KAAK,EAAA80C,aAAaw6C,KAChBh1F,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAykD,qBAAoBhoG,IAC/BqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK0nH,UAAUhiH,GACf,MAEF,KAAK,EAAA80C,aAAa4xE,MAChBpsH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA6kD,sBAAqBpoG,IAChC1F,KAAKipD,OAAM,IAAA8kD,wBAAuBroG,IAClCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK2nH,WAAWjiH,GAChB,MAEF,KAAK,EAAA80C,aAAaC,MAChBz6C,KAAK4nH,WAAWliH,GAChB,MAEF,KAAK,EAAA80C,aAAa05C,MAChBl0F,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAskD,wBAAuB7nG,IAClCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK6nH,WAAWniH,GAChB,MAEF,KAAK,EAAA80C,aAAa65C,OAChBr0F,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAmkD,wBAAuB1nG,IAClC1F,KAAKipD,OAAM,IAAAokD,yBAAwB3nG,IACnCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK8nH,YAAYpiH,GACjB,MAEF,KAAK,EAAA80C,aAAa46C,OAChBp1F,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAylD,0BAAyBhpG,IACpC1F,KAAKipD,OAAM,IAAA0lD,2BAA0BjpG,IACrC1F,KAAKipD,OAAM,IAAA2lD,6BAA4BlpG,IACvCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK+nH,YAAYriH,GACjB,MAEF,KAAK,EAAA80C,aAAa6xE,KAChBrsH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA4lD,uBAAsBnpG,IACjCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKgoH,UAAUtiH,GACf,MAEF,KAAK,EAAA80C,aAAaijD,OAAQ,CACxB,IAAIj6F,GAAQ,IAAAsrG,yBAAwBppG,GAChClC,IACFxD,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,MAAMzlD,GACXuI,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,IAE7B1F,KAAKioH,YAAYviH,GACjB,MAEF,KAAK,EAAA80C,aAAaywD,WAChBjrG,KAAKkoH,gBAAgBxiH,GACrB,MAEF,KAAK,EAAA80C,aAAa8xE,WAChBtsH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAimD,6BAA4BxpG,IACvCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKmoH,gBAAgBziH,GACrB,MAEF,KAAK,EAAA80C,aAAaglB,IAChBx/D,KAAKooH,SAAS1iH,GACd,MAEF,KAAK,EAAA80C,aAAa4oC,YAChBpjF,KAAKqoH,iBAAiB3iH,GACtB,MAEF,KAAK,EAAA80C,aAAa+xE,UAChBvsH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAujE,0BAAyB9mH,IACpC1F,KAAKipD,OAAM,IAAAwjE,4BAA2B/mH,IACtCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKsoH,eAAe5iH,GACpB,MAEF,KAAK,EAAA80C,aAAakyE,cAChB1sH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA0jE,8BAA6BjnH,IACxC1F,KAAKipD,OAAM,IAAA2jE,mCAAkClnH,IAC7C1F,KAAKipD,OAAM,IAAA4jE,sCAAqCnnH,IAChDqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKuoH,mBAAmB7iH,GACxB,MAEF,KAAK,EAAA80C,aAAasyE,WAChB9sH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA8jE,2BAA0BrnH,IACrC1F,KAAKipD,OAAM,IAAA+jE,gCAA+BtnH,IAC1C1F,KAAKipD,OAAM,IAAAgkE,+BAA8BvnH,IACzCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKwoH,gBAAgB9iH,GACrB,MAEF,KAAK,EAAA80C,aAAa0yE,aAChBltH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAkkE,6BAA4BznH,IACvC1F,KAAKipD,OAAM,IAAAmkE,qCAAoC1nH,IAC/CqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKyoH,kBAAkB/iH,GACvB,MAEF,KAAK,EAAA80C,aAAa6yE,YAChBrtH,KAAK0oH,iBAAiBhjH,GACtB,MAEF,KAAK,EAAA80C,aAAa8yE,YAChBttH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAskE,4BAA2B7nH,IACtCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK2oH,iBAAiBjjH,GACtB,MAEF,KAAK,EAAA80C,aAAagzE,YAChBxtH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAwkE,4BAA2B/nH,IACtC1F,KAAKipD,OAAM,IAAAykE,8BAA6BhoH,IACxCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK4oH,iBAAiBljH,GACtB,MAEF,KAAK,EAAA80C,aAAamzE,YAChB3tH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA2kE,6BAA4BloH,IACvC1F,KAAKipD,OAAM,IAAA4kE,8BAA6BnoH,IACxCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK6oH,iBAAiBnjH,GACtB,MAEF,KAAK,EAAA80C,aAAaszE,YAChB9tH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA8kE,0BAAyBroH,IACpC1F,KAAKipD,OAAM,IAAA+kE,0BAAyBtoH,IACpC1F,KAAKipD,OAAM,IAAAglE,0BAAyBvoH,IACpCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK8oH,iBAAiBpjH,GACtB,MAEF,KAAK,EAAA80C,aAAa0zE,UAChBluH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAklE,0BAAyBzoH,IACpC1F,KAAKipD,OAAM,IAAAmlE,4BAA2B1oH,IACtCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK+oH,eAAerjH,GACpB,MAEF,KAAK,EAAA80C,aAAa6zE,SAChBruH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAqlE,yBAAwB5oH,IACnCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKgpH,cAActjH,GACnB,MAEF,KAAK,EAAA80C,aAAa+zE,kBAChBvuH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAulE,kCAAiC9oH,IAC5C1F,KAAKipD,OAAM,IAAAwlE,kCAAiC/oH,IAC5CqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKipH,uBAAuBvjH,GAC5B,MAEF,KAAK,EAAA80C,aAAak0E,WAChB1uH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA0lE,4BAA2BjpH,IACtC1F,KAAKipD,OAAM,IAAA2lE,8BAA6BlpH,IACxC1F,KAAKipD,OAAM,IAAA4lE,4BAA2BnpH,IACtCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKkpH,gBAAgBxjH,GACrB,MAEF,KAAK,EAAA80C,aAAa0wD,SAChBlrG,KAAKmpH,cAAczjH,GACnB,MAEF,KAAK,EAAA80C,aAAas0E,WAChB9uH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA8lE,4BAA2BrpH,IACtC1F,KAAKipD,OAAM,IAAA+lE,8BAA6BtpH,IACxC1F,KAAKipD,OAAM,IAAAgmE,4BAA2BvpH,IACtCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKopH,gBAAgB1jH,GACrB,MAEF,KAAK,EAAA80C,aAAa00E,WAChBlvH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAkmE,4BAA2BzpH,IACtC1F,KAAKipD,OAAM,IAAAmmE,6BAA4B1pH,IACvC1F,KAAKipD,OAAM,IAAAomE,4BAA2B3pH,IACtCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKqpH,gBAAgB3jH,GACrB,MAEF,KAAK,EAAA80C,aAAa80E,IAChBtvH,KAAKspH,SAAS5jH,GACd,MAEF,KAAK,EAAA80C,aAAa2wD,QAChBnrG,KAAKupH,aAAa7jH,GAClB,MAEF,KAAK,EAAA80C,aAAa+0E,MAChBvvH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAAumE,wBAAuB9pH,IAClCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKwpH,WAAW9jH,GAChB,MAEF,KAAK,EAAA80C,aAAai1E,QAChBzvH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKgrH,WAAU,IAAA0E,yBAAwBhqH,IACvCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKypH,aAAa/jH,GAClB,MAEF,KAAK,EAAA80C,aAAam1E,MAChB3vH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA2mE,uBAAsBlqH,IACjC1F,KAAKipD,OAAM,IAAA4mE,wBAAuBnqH,IAClCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK0pH,WAAWhkH,GAChB,MAEF,KAAK,EAAA80C,aAAas1E,IAAK,CACrB9vH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA8mE,qBAAoBrqH,IAC/B,IAAIsqH,GAAiB,IAAAC,+BAA8BvqH,GACnD,IAAK,IAAI+F,EAAW,EAAGA,EAAIukH,IAAkBvkH,EAC3CzL,KAAKipD,OAAM,IAAAinE,4BAA2BxqH,EAAM+F,IAE9CM,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK2pH,SAASjkH,GACd,MAEF,KAAK,EAAA80C,aAAakjD,MAAO,CACvB19F,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKmrH,UAAS,IAAAgF,sBAAqBzqH,IACnC,IAAIm5B,GAAc,IAAAuxF,8BAA6B1qH,GAC/C,IAAK,IAAI+F,EAAW,EAAGA,EAAIozB,IAAepzB,EACxCzL,KAAKipD,OAAM,IAAAonE,4BAA2B3qH,EAAM+F,IAE9CM,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK4pH,WAAWlkH,GAChB,MAEF,KAAK,EAAA80C,aAAa81E,QAChBtwH,KAAK6pH,aAAankH,GAClB,MAEF,KAAK,EAAA80C,aAAa+1E,UAAW,CAC3B,IAAI1xF,GAAc,IAAA2xF,kCAAiC9qH,GACnD,GAAIm5B,EAAa,CACf7+B,KAAKmyF,MAAM1gF,KAAK/L,GAChB,IAAK,IAAI+F,EAAW,EAAGA,EAAIozB,IAAepzB,EACxCzL,KAAKipD,OAAM,IAAAwnE,gCAA+B/qH,EAAM+F,IAElDM,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAE7B1F,KAAK8pH,eAAepkH,GACpB,MAEF,KAAK,EAAA80C,aAAak2E,aAChB1wH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA0nE,+BAA8BjrH,IACzCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK+pH,kBAAkBrkH,GACvB,MAEF,KAAK,EAAA80C,aAAao2E,OAChB5wH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA4nE,yBAAwBnrH,IACnCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKgqH,YAAYtkH,GACjB,MAEF,KAAK,EAAA80C,aAAas2E,OAChB9wH,KAAKmyF,MAAM1gF,KAAK/L,GAChB1F,KAAKipD,OAAM,IAAA8nE,uBAAsBrrH,IACjCqG,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKiqH,YAAYvkH,GACjB,MAEF,KAAK,EAAA80C,aAAaw2E,QAChBhxH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKkqH,aAAaxkH,GAClB,MAEF,KAAK,EAAA80C,aAAay2E,QAChBjxH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKmqH,aAAazkH,GAClB,MAEF,KAAK,EAAA80C,aAAa02E,QAChBlxH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKoqH,aAAa1kH,GAClB,MAEF,KAAK,EAAA80C,aAAa22E,KAChBnxH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKqqH,UAAU3kH,GACf,MAEF,KAAK,EAAA80C,aAAa4wD,SAChBprG,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKsqH,cAAc5kH,GACnB,MAEF,KAAK,EAAA80C,aAAa42E,OAChBpxH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKuqH,YAAY7kH,GACjB,MAEF,KAAK,EAAA80C,aAAa62E,UAChBrxH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKwqH,eAAe9kH,GACpB,MAEF,KAAK,EAAA80C,aAAa82E,UAChBtxH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAKyqH,eAAe/kH,GACpB,MAEF,KAAK,EAAA80C,aAAa+2E,UAChBvxH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK0qH,eAAehlH,GACpB,MAEF,KAAK,EAAA80C,aAAag3E,SAChBxxH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK2qH,cAAcjlH,GACnB,MAEF,KAAK,EAAA80C,aAAai3E,SAChBzxH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK4qH,cAAcllH,GACnB,MAEF,KAAK,EAAA80C,aAAak3E,SAChB1xH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK6qH,cAAcnlH,GACnB,MAEF,KAAK,EAAA80C,aAAam3E,SAChB3xH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK8qH,cAAcplH,GACnB,MAEF,KAAK,EAAA80C,aAAao3E,MAChB5xH,KAAKmyF,MAAM1gF,KAAK/L,GAChBqG,QAAO,GACPA,OAAO/L,KAAKmyF,MAAM9a,OAAS3xE,GAC3B1F,KAAK+qH,WAAWrlH,GAChB,MAEF,QAAS,MAAM,IAAIyiD,MAAM,8BAE3BnoD,KAAK4mH,mBAAqBwE,GA/yB9B,YAw4BA,SAAgByG,EAEd16E,EAEA26E,EAEAp1B,GAEA,QAAQ,IAAAsO,0BAAyB7zD,IAC/B,KAAK,EAAAqD,aAAaqmB,MAAO,CACvB,IAAIiyC,GAAc,IAAA7E,8BAA6B92D,GAC/C,IAAK,IAAI1rC,EAAW,EAAGA,EAAIqnG,IAAernG,EAAG,CAC3C,IAAIsmH,GAAQ,IAAA7jB,0BAAyB/2D,EAAQ1rC,GAC7C,GAAIsmH,GAASD,EAEX,OADA,IAAAE,0BAAyB76E,EAAQ1rC,EAAGixF,GAC7Bq1B,EAGX,MAEF,KAAK,EAAAv3E,aAAas5C,GAAI,CACpB,IAAInvF,GAAY,IAAAwpG,yBAAwBh3D,GACxC,GAAIxyC,GAAamtH,EAEf,OADA,IAAAG,yBAAwB96E,EAAQulD,GACzB/3F,EAET,IAAI2C,GAAS,IAAA8mG,sBAAqBj3D,GAClC,GAAI7vC,GAAUwqH,EAEZ,OADA,IAAAI,sBAAqB/6E,EAAQulD,GACtBp1F,EAET,IAAIC,GAAU,IAAA8mG,uBAAsBl3D,GACpC,GAAI5vC,GAAWuqH,EAEb,OADA,IAAAK,uBAAsBh7E,EAAQulD,GACvBn1F,EAET,MAEF,KAAK,EAAAizC,aAAa6wE,KAAM,CACtB,IAAI/iH,GAAO,IAAAimG,sBAAqBp3D,GAChC,GAAI7uC,GAAQwpH,EAEV,OADA,IAAAM,sBAAqBj7E,EAAQulD,GACtBp0F,EAET,MAEF,KAAK,EAAAkyC,aAAaq4D,MAAO,CACvB,IAAIluG,GAAY,IAAA8pG,4BAA2Bt3D,GAC3C,GAAIxyC,GAAamtH,EAEf,OADA,IAAAO,4BAA2Bl7E,EAAQulD,GAC5B/3F,EAET,IAAInB,GAAQ,IAAA8nH,wBAAuBn0E,GACnC,GAAI3zC,GAASsuH,EAEX,OADA,IAAAQ,wBAAuBn7E,EAAQulD,GACxBl5F,EAET,MAEF,KAAK,EAAAg3C,aAAa+wE,OAAQ,CACxB,IAAI5mH,GAAY,IAAAgnH,6BAA4Bx0E,GAC5C,GAAIxyC,GAAamtH,EAEf,OADA,IAAAS,6BAA4Bp7E,EAAQulD,GAC7B/3F,EAET,IAAInB,GAAQ,IAAAooH,yBAAwBz0E,GACpC,GAAI3zC,GAASsuH,EAEX,OADA,IAAAU,yBAAwBr7E,EAAQulD,GACzBl5F,EAET,MAEF,KAAK,EAAAg3C,aAAa+6C,KAAM,CACtB,IAAI12D,GAAc,IAAAmwE,6BAA4B73D,GAC9C,IAAK,IAAI1rC,EAAW,EAAGA,EAAIozB,IAAepzB,EAAG,CAC3C,IAAIlG,GAAU,IAAA0pG,2BAA0B93D,EAAQ1rC,GAChD,GAAIlG,GAAWusH,EAEb,OADA,IAAAW,2BAA0Bt7E,EAAQ1rC,EAAGixF,GAC9Bn3F,EAGX,MAEF,KAAK,EAAAi1C,aAAaqxE,aAAc,CAC9B,IAAIniE,GAAS,IAAAoiE,gCAA+B30E,GAC5C,GAAIuS,GAAUooE,EAEZ,OADA,IAAAY,gCAA+Bv7E,EAAQulD,GAChChzC,EAET,IAAI7qB,GAAc,IAAAktF,qCAAoC50E,GACtD,IAAK,IAAI1rC,EAAW,EAAGA,EAAIozB,IAAepzB,EAAG,CAC3C,IAAIlG,GAAU,IAAAymH,mCAAkC70E,EAAQ1rC,GACxD,GAAIlG,GAAWusH,EAEb,OADA,IAAAa,mCAAkCx7E,EAAQ1rC,EAAGixF,GACtCn3F,EAGX,MAEF,KAAK,EAAAi1C,aAAasB,SAChB,MAEF,KAAK,EAAAtB,aAAak5C,SAAU,CAC1B,IAAIlwF,GAAQ,IAAAwpG,2BAA0B71D,GACtC,GAAI3zC,GAASsuH,EAEX,OADA,IAAAc,2BAA0Bz7E,EAAQulD,GAC3Bl5F,EAET,MAEF,KAAK,EAAAg3C,aAAa0e,UAChB,MAEF,KAAK,EAAA1e,aAAayxE,UAAW,CAC3B,IAAIzoH,GAAQ,IAAA2oH,4BAA2Bh1E,GACvC,GAAI3zC,GAASsuH,EAEX,OADA,IAAAe,4BAA2B17E,EAAQulD,GAC5Bl5F,EAET,MAEF,KAAK,EAAAg3C,aAAaw6C,KAAM,CACtB,IAAIr3B,GAAM,IAAA+vC,qBAAoBv2D,GAC9B,GAAIwmB,GAAOm0D,EAET,OADA,IAAAgB,qBAAoB37E,EAAQulD,GACrB/+B,EAET,MAEF,KAAK,EAAAnjB,aAAa4xE,MAAO,CACvB,IAAIzuD,GAAM,IAAAmwC,sBAAqB32D,GAC/B,GAAIwmB,GAAOm0D,EAET,OADA,IAAAiB,sBAAqB57E,EAAQulD,GACtB/+B,EAET,IAAIn6D,GAAQ,IAAAuqG,wBAAuB52D,GACnC,GAAI3zC,GAASsuH,EAEX,OADA,IAAAkB,wBAAuB77E,EAAQulD,GACxBl5F,EAET,MAEF,KAAK,EAAAg3C,aAAaC,MAChB,MAEF,KAAK,EAAAD,aAAa05C,MAAO,CACvB,IAAI1wF,GAAQ,IAAA+pG,wBAAuBp2D,GACnC,GAAI3zC,GAASsuH,EAEX,OADA,IAAAmB,wBAAuB97E,EAAQulD,GACxBl5F,EAET,MAEF,KAAK,EAAAg3C,aAAa65C,OAAQ,CACxB,IAAIzxF,GAAO,IAAAwqG,wBAAuBj2D,GAClC,GAAIv0C,GAAQkvH,EAEV,OADA,IAAAoB,wBAAuB/7E,EAAQulD,GACxB95F,EAET,IAAIC,GAAQ,IAAAwqG,yBAAwBl2D,GACpC,GAAIt0C,GAASivH,EAEX,OADA,IAAAqB,yBAAwBh8E,EAAQulD,GACzB75F,EAET,MAEF,KAAK,EAAA23C,aAAa46C,OAAQ,CACxB,IAAI9tF,GAAS,IAAAonG,0BAAyBv3D,GACtC,GAAI7vC,GAAUwqH,EAEZ,OADA,IAAAsB,0BAAyBj8E,EAAQulD,GAC1Bp1F,EAET,IAAIC,GAAU,IAAAonG,2BAA0Bx3D,GACxC,GAAI5vC,GAAWuqH,EAEb,OADA,IAAAuB,2BAA0Bl8E,EAAQulD,GAC3Bn1F,EAET,IAAI5C,GAAY,IAAAiqG,6BAA4Bz3D,GAC5C,GAAIxyC,GAAamtH,EAEf,OADA,IAAAwB,6BAA4Bn8E,EAAQulD,GAC7B/3F,EAET,MAEF,KAAK,EAAA61C,aAAa6xE,KAAM,CACtB,IAAI7oH,GAAQ,IAAAqrG,uBAAsB13D,GAClC,GAAI3zC,GAASsuH,EAEX,OADA,IAAAyB,uBAAsBp8E,EAAQulD,GACvBl5F,EAET,MAEF,KAAK,EAAAg3C,aAAaijD,OAAQ,CACxB,IAAIj6F,GAAQ,IAAAsrG,yBAAwB33D,GACpC,GAAI3zC,GAASsuH,EAEX,OADA,IAAA0B,yBAAwBr8E,EAAQulD,GACzBl5F,EAET,MAEF,KAAK,EAAAg3C,aAAaywD,WAChB,MAEF,KAAK,EAAAzwD,aAAa8xE,WAAY,CAC5B,IAAI/wB,GAAQ,IAAA2T,6BAA4B/3D,GACxC,GAAIokD,GAASu2B,EAEX,OADA,IAAA2B,6BAA4Bt8E,EAAQulD,GAC7BnB,EAET,MAEF,KAAK,EAAA/gD,aAAaglB,IAGlB,KAAK,EAAAhlB,aAAa4oC,YAChB,MAEF,KAAK,EAAA5oC,aAAa+xE,UAAW,CAC3B,IAAI5uD,GAAM,IAAA6uD,0BAAyBr1E,GACnC,GAAIwmB,GAAOm0D,EAET,OADA,IAAA4B,0BAAyBv8E,EAAQulD,GAC1B/+B,EAET,IAAIn6D,GAAQ,IAAAipH,4BAA2Bt1E,GACvC,GAAI3zC,GAASsuH,EAEX,OADA,IAAA6B,4BAA2Bx8E,EAAQulD,GAC5Bl5F,EAET,MAEF,KAAK,EAAAg3C,aAAakyE,cAAe,CAC/B,IAAI/uD,GAAM,IAAAgvD,8BAA6Bx1E,GACvC,GAAIwmB,GAAOm0D,EAET,OADA,IAAA8B,8BAA6Bz8E,EAAQulD,GAC9B/+B,EAET,IAAI9kB,GAAW,IAAA+zE,mCAAkCz1E,GACjD,GAAI0B,GAAYi5E,EAEd,OADA,IAAA+B,mCAAkC18E,EAAQulD,GACnC7jD,EAET,IAAIi7E,GAAO,IAAAjH,sCAAqC11E,GAChD,GAAI28E,GAAQhC,EAEV,OADA,IAAAiC,sCAAqC58E,EAAQulD,GACtCo3B,EAET,MAEF,KAAK,EAAAt5E,aAAasyE,WAAY,CAC5B,IAAInvD,GAAM,IAAAovD,2BAA0B51E,GACpC,GAAIwmB,GAAOm0D,EAET,OADA,IAAAkC,2BAA0B78E,EAAQulD,GAC3B/+B,EAET,IAAI9kB,GAAW,IAAAm0E,gCAA+B71E,GAC9C,GAAI0B,GAAYi5E,EAEd,OADA,IAAAmC,gCAA+B98E,EAAQulD,GAChC7jD,EAET,IAAI+jD,GAAU,IAAAqwB,+BAA8B91E,GAC5C,GAAIylD,GAAWk1B,EAEb,OADA,IAAAoC,+BAA8B/8E,EAAQulD,GAC/BE,EAET,MAEF,KAAK,EAAApiD,aAAa0yE,aAAc,CAC9B,IAAIvvD,GAAM,IAAAwvD,6BAA4Bh2E,GACtC,GAAIwmB,GAAOm0D,EAET,OADA,IAAAqC,6BAA4Bh9E,EAAQulD,GAC7B/+B,EAET,IAAIm/B,GAAc,IAAAswB,qCAAoCj2E,GACtD,GAAI2lD,GAAeg1B,EAEjB,OADA,IAAAsC,qCAAoCj9E,EAAQulD,GACrCI,EAET,MAEF,KAAK,EAAAtiD,aAAa6yE,YAChB,MAEF,KAAK,EAAA7yE,aAAa8yE,YAAa,CAC7B,IAAI1sB,GAAM,IAAA2sB,4BAA2Bp2E,GACrC,GAAIypD,GAAOkxB,EAET,OADA,IAAAuC,4BAA2Bl9E,EAAQulD,GAC5BkE,EAET,MAEF,KAAK,EAAApmD,aAAagzE,YAAa,CAC7B,IAAI5sB,GAAM,IAAA6sB,4BAA2Bt2E,GACrC,GAAIypD,GAAOkxB,EAET,OADA,IAAAwC,4BAA2Bn9E,EAAQulD,GAC5BkE,EAET,IAAIp9F,GAAQ,IAAAkqH,8BAA6Bv2E,GACzC,GAAI3zC,GAASsuH,EAEX,OADA,IAAAyC,8BAA6Bp9E,EAAQulD,GAC9Bl5F,EAET,MAEF,KAAK,EAAAg3C,aAAamzE,YAAa,CAC7B,IAAI/qH,GAAO,IAAAgrH,6BAA4Bz2E,GACvC,GAAIv0C,GAAQkvH,EAEV,OADA,IAAA0C,6BAA4Br9E,EAAQulD,GAC7B95F,EAET,IAAIC,GAAQ,IAAAgrH,8BAA6B12E,GACzC,GAAIt0C,GAASivH,EAEX,OADA,IAAA2C,8BAA6Bt9E,EAAQulD,GAC9B75F,EAET,MAEF,KAAK,EAAA23C,aAAaszE,YAAa,CAC7B,IAAIvzC,GAAI,IAAAwzC,0BAAyB52E,GACjC,GAAIojC,GAAKu3C,EAEP,OADA,IAAA4C,0BAAyBv9E,EAAQulD,GAC1BniB,EAET,IAAIC,GAAI,IAAAwzC,0BAAyB72E,GACjC,GAAIqjC,GAAKs3C,EAEP,OADA,IAAA6C,0BAAyBx9E,EAAQulD,GAC1BliB,EAET,IAAI0mB,GAAI,IAAA+sB,0BAAyB92E,GACjC,GAAI+pD,GAAK4wB,EAEP,OADA,IAAA8C,0BAAyBz9E,EAAQulD,GAC1BwE,EAET,MAEF,KAAK,EAAA1mD,aAAa0zE,UAAW,CAC3B,IAAIttB,GAAM,IAAAutB,0BAAyBh3E,GACnC,GAAIypD,GAAOkxB,EAET,OADA,IAAA+C,0BAAyB19E,EAAQulD,GAC1BkE,EAET,IAAIphD,GAAQ,IAAA4uE,4BAA2Bj3E,GACvC,GAAIqI,GAASsyE,EAEX,OADA,IAAAgD,4BAA2B39E,EAAQulD,GAC5Bl9C,EAET,MAEF,KAAK,EAAAhF,aAAa6zE,SAAU,CAC1B,IAAI1wD,GAAM,IAAA2wD,yBAAwBn3E,GAClC,GAAIwmB,GAAOm0D,EAET,OADA,IAAAiD,yBAAwB59E,EAAQulD,GACzB/+B,EAET,MAEF,KAAK,EAAAnjB,aAAa+zE,kBAAmB,CACnC,IAAI5wD,GAAM,IAAA6wD,kCAAiCr3E,GAC3C,GAAIwmB,GAAOm0D,EAET,OADA,IAAAkD,kCAAiC79E,EAAQulD,GAClC/+B,EAGT,IADU,IAAA8wD,kCAAiCt3E,IAChC26E,EAET,OADA,IAAAmD,kCAAiC99E,EAAQulD,GAClC/+B,EAET,MAEF,KAAK,EAAAnjB,aAAak0E,WAAY,CAC5B,IAAItvB,GAAO,IAAAuvB,4BAA2Bx3E,GACtC,GAAIioD,GAAQ0yB,EAEV,OADA,IAAAoD,4BAA2B/9E,EAAQulD,GAC5B0C,EAET,IAAIziD,GAAS,IAAAiyE,8BAA6Bz3E,GAC1C,GAAIwF,GAAUm1E,EAEZ,OADA,IAAAqD,8BAA6Bh+E,EAAQulD,GAC9B//C,EAET,IAAIriB,GAAO,IAAAu0F,4BAA2B13E,GACtC,GAAI7c,GAAQw3F,EAEV,OADA,IAAAsD,4BAA2Bj+E,EAAQulD,GAC5BpiE,EAET,MAEF,KAAK,EAAAkgB,aAAa0wD,SAChB,MAEF,KAAK,EAAA1wD,aAAas0E,WAAY,CAC5B,IAAI1vB,GAAO,IAAA2vB,4BAA2B53E,GACtC,GAAIioD,GAAQ0yB,EAEV,OADA,IAAAuD,4BAA2Bl+E,EAAQulD,GAC5B0C,EAET,IAAIpuF,GAAS,IAAAg+G,8BAA6B73E,GAC1C,GAAInmC,GAAU8gH,EAEZ,OADA,IAAAwD,8BAA6Bn+E,EAAQulD,GAC9B1rF,EAET,IAAIspB,GAAO,IAAA20F,4BAA2B93E,GACtC,GAAI7c,GAAQw3F,EAEV,OADA,IAAAyD,4BAA2Bp+E,EAAQulD,GAC5BpiE,EAET,MAEF,KAAK,EAAAkgB,aAAa00E,WAAY,CAC5B,IAAI9vB,GAAO,IAAA+vB,4BAA2Bh4E,GACtC,GAAIioD,GAAQ0yB,EAEV,OADA,IAAA0D,4BAA2Br+E,EAAQulD,GAC5B0C,EAET,IAAI57F,GAAQ,IAAA4rH,6BAA4Bj4E,GACxC,GAAI3zC,GAASsuH,EAEX,OADA,IAAA2D,6BAA4Bt+E,EAAQulD,GAC7Bl5F,EAET,IAAI82B,GAAO,IAAA+0F,4BAA2Bl4E,GACtC,GAAI7c,GAAQw3F,EAEV,OADA,IAAA4D,4BAA2Bv+E,EAAQulD,GAC5BpiE,EAET,MAEF,KAAK,EAAAkgB,aAAa80E,IAGlB,KAAK,EAAA90E,aAAa2wD,QAChB,MAEF,KAAK,EAAA3wD,aAAa+0E,MAAO,CACvB,IAAI/rH,GAAQ,IAAAgsH,wBAAuBr4E,GACnC,GAAI3zC,GAASsuH,EAEX,OADA,IAAA6D,wBAAuBx+E,EAAQulD,GACxBl5F,EAET,MAEF,KAAK,EAAAg3C,aAAai1E,QAChB,MAEF,KAAK,EAAAj1E,aAAam1E,MAAO,CACvB,IAAI/sH,GAAO,IAAAgtH,uBAAsBz4E,GACjC,GAAIv0C,GAAQkvH,EAEV,OADA,IAAA8D,uBAAsBz+E,EAAQulD,GACvB95F,EAET,IAAIC,GAAQ,IAAAgtH,wBAAuB14E,GACnC,GAAIt0C,GAASivH,EAEX,OADA,IAAA+D,wBAAuB1+E,EAAQulD,GACxB75F,EAET,MAEF,KAAK,EAAA23C,aAAas1E,IAAK,CACrB,IAAIxnH,GAAO,IAAAynH,qBAAoB54E,GAC/B,GAAI7uC,GAAQwpH,EAEV,OADA,IAAAgE,qBAAoB3+E,EAAQulD,GACrBp0F,EAET,IAAI0nH,GAAiB,IAAAC,+BAA8B94E,GACnD,IAAK,IAAI1rC,EAAW,EAAGA,EAAIukH,IAAkBvkH,EAAG,CAC9C,IAAIsqH,GAAY,IAAA7F,4BAA2B/4E,EAAQ1rC,GACnD,GAAIsqH,GAAajE,EAEf,OADA,IAAAkE,4BAA2B7+E,EAAQ1rC,EAAGixF,GAC/Bq5B,EAGX,MAEF,KAAK,EAAAv7E,aAAakjD,MAAO,CACvB,IAAI7+D,GAAc,IAAAuxF,8BAA6Bj5E,GAC/C,IAAK,IAAI1rC,EAAW,EAAGA,EAAIozB,IAAepzB,EAAG,CAC3C,IAAIlG,GAAU,IAAA8qH,4BAA2Bl5E,EAAQ1rC,GACjD,GAAIlG,GAAWusH,EAEb,OADA,IAAAmE,4BAA2B9+E,EAAQ1rC,EAAGixF,GAC/Bn3F,EAGX,MAEF,KAAK,EAAAi1C,aAAa81E,QAChB,MAEF,KAAK,EAAA91E,aAAa+1E,UAAW,CAC3B,IAAI1xF,GAAc,IAAA2xF,kCAAiCr5E,GACnD,IAAK,IAAI1rC,EAAW,EAAGA,EAAIozB,IAAepzB,EAAG,CAC3C,IAAIlG,GAAU,IAAAkrH,gCAA+Bt5E,EAAQ1rC,GACrD,GAAIlG,GAAWusH,EAEb,OADA,IAAAoE,gCAA+B/+E,EAAQ1rC,EAAGixF,GACnCn3F,EAGX,MAEF,KAAK,EAAAi1C,aAAak2E,aAAc,CAC9B,IAAIhwB,GAAQ,IAAAiwB,+BAA8Bx5E,GAC1C,GAAIupD,GAASoxB,EAEX,OADA,IAAAqE,+BAA8Bh/E,EAAQulD,GAC/BgE,EAET,MAEF,KAAK,EAAAlmD,aAAao2E,OAAQ,CACxB,IAAIptH,GAAQ,IAAAqtH,yBAAwB15E,GACpC,GAAI3zC,GAASsuH,EAEX,OADA,IAAAsE,yBAAwBj/E,EAAQulD,GACzBl5F,EAET,MAEF,KAAK,EAAAg3C,aAAas2E,OAAQ,CACxB,IAAIuF,GAAU,IAAAtF,uBAAsB55E,GACpC,GAAIk/E,GAAWvE,EAEb,OADA,IAAAwE,uBAAsBn/E,EAAQulD,GACvB25B,EAET,MAEF,KAAK,EAAA77E,aAAaw2E,QAIlB,KAAK,EAAAx2E,aAAay2E,QAIlB,KAAK,EAAAz2E,aAAa02E,QAIlB,KAAK,EAAA12E,aAAa22E,KAIlB,KAAK,EAAA32E,aAAa4wD,SAIlB,KAAK,EAAA5wD,aAAa42E,OAIlB,KAAK,EAAA52E,aAAa62E,UAIlB,KAAK,EAAA72E,aAAa82E,UAIlB,KAAK,EAAA92E,aAAa+2E,UAIlB,KAAK,EAAA/2E,aAAag3E,SAIlB,KAAK,EAAAh3E,aAAai3E,SAIlB,KAAK,EAAAj3E,aAAak3E,SAIlB,KAAK,EAAAl3E,aAAam3E,SAIlB,KAAK,EAAAn3E,aAAao3E,MAChB7lH,QAAO,GACP,MAEF,QAAS,MAAM,IAAIo8C,MAAM,4BAE3B,OAAO,EAtpBT,qBAAmCi+D,EAmBjC7lH,YAAqBZ,GACnBsL,QADmB,KAAAtL,OAAAA,EAXb,KAAA42H,iBAAgC,EAQhC,KAAAC,eAA4B,EAbhCC,sBACF,IAAIA,EAAkBz2H,KAAKu2H,iBAC3B,IAAKE,EAAiB,MAAM,IAAItuE,MAAM,0BACtC,OAAOsuE,EAKLC,oBACF,IAAIA,EAAgB12H,KAAKw2H,eACzB,IAAKE,EAAe,MAAM,IAAIvuE,MAAM,wBACpC,OAAOuuE,EAYTvjE,aACEnzD,KAAK22H,gBACL32H,KAAK42H,cAIPD,gBACE,IAAIE,EAAY72H,KAAKL,OAAO05E,IAC5B,IAAK,IAAI5tE,EAAW,EAAGC,GAAI,IAAAorH,0BAAyBD,GAAYprH,EAAIC,IAAKD,EACvEzL,KAAK+2H,cAAa,IAAAC,6BAA4BH,EAAWprH,IAK7DsrH,aAAah0B,GACX,IAAIz6F,GAAO,IAAA6mG,0BAAyBpM,GAChCz6F,IACFtI,KAAKu2H,iBAAmBxzB,EACxB/iG,KAAKipD,MAAM3gD,GACXtI,KAAKu2H,iBAAmB,GAK5BK,cACE,IAAIC,EAAY72H,KAAKL,OAAO05E,IAC5B,IAAK,IAAI5tE,EAAW,EAAGC,GAAI,IAAAurH,wBAAuBJ,GAAYprH,EAAIC,IAAKD,EACrEzL,KAAKk3H,YAAW,IAAAC,2BAA0BN,EAAWprH,IAKzDyrH,WAAWn2E,GACT/gD,KAAKw2H,eAAiBz1E,EACtB,IAAIq2E,GAAO,IAAAxnB,4BAA2B7uD,GAClCq2E,GAAMp3H,KAAKipD,MAAMmuE,GACrBp3H,KAAKw2H,eAAiB,EAMxBa,eAAe36B,GACb,IAAIo1B,EAAS9xH,KAAK6mH,kBACd9jB,EAAO/iG,KAAKy2H,gBAEhB,IADW,IAAAtnB,0BAAyBpM,IACxB+uB,GACV,IAAAwF,0BAAyBv0B,EAAMrG,OAC1B,CACL,IAAIvlD,EAASprC,OAAO/L,KAAK8mH,wBAEzB,IADe+K,EAAa16E,EAAQ26E,EAAQp1B,GAC7B,MAAMv0C,MAAM,iCAC3B,IAAAovE,6BAA4BpgF,MAMlC,kB,kGCrjCA,eAQA,SAMA,SASA,MAAakc,UAAqB,EAAAmkE,KAMhCj3H,YAAYk3B,GACVxsB,MAAMwsB,EAAS93B,QALjB,KAAA83H,YAAmB,EAMjBz3H,KAAK03H,QAAUjgG,EAASY,QAAQsD,YAGlCg8F,UAEE,OADmB33H,KAAKL,OAAOgrG,kBAAiB,IAAAyE,0BAAyBpvG,KAAKy2H,kBAC1DxjH,WAAW,YAIjC00G,WAAWjwG,GACT,IAAI/X,EAASK,KAAKL,OACdg+D,GAAM,IAAAmwC,sBAAqBp2F,GAC3BilC,GAAS,IAAAkxD,yBAAwBn2F,GACjCuqB,GAAQ,IAAA2rE,wBAAuBl2F,IAEnC,IAAAq7G,sBAAqBr7G,EACnB/X,EAAOi2C,KAAK,WAAY,CACtB+nB,EACAh+D,EAAOwZ,IAAIwjC,GACXh9C,EAAOwZ,IAAI8oB,GACXtiC,EAAOwZ,IAAIA,IAAInZ,KAAK23H,aACnB33H,KAAK03H,UAEV13H,KAAKy3H,YAAa,EAMpBtkE,aACEloD,MAAMkoD,aACFnzD,KAAKy3H,YACPz3H,KAAKL,OAAO27D,kBAAkB,WAAY,SAAU,WAClD,IAAA9jB,YAAW,CAAEx3C,KAAK03H,QAAS,EAAAj9F,QAAQC,IAAK,EAAAD,QAAQC,IAAK,EAAAD,QAAQC,MAC7D16B,KAAK03H,UA1Cb,kB,qGCiDA,eAIA,SAoCA,SAwBA,SAUA,SAASE,EAAaj4H,EAAgB+F,GACpC,OACE,IAAAslG,0BAAyBtlG,IAAS,EAAA80C,aAAa+6C,MAC/C51F,EAAOgrG,kBAAiB,IAAAoE,wBAAuBrpG,KAAU,EAAAuP,aAAa2gB,SAEtE7pB,OAA4C,IAArC,IAAAijG,6BAA4BtpG,KAC5B,IAAAupG,2BAA0BvpG,EAAM,IAElC,EAIT,SAASmyH,EAAUl4H,EAAgB6D,GACjC,QAAQ,IAAAwnG,0BAAyBxnG,IAE/B,KAAK,EAAAg3C,aAAaC,MAAO,QAAQ,IAAAogC,aAAYr3E,GAE7C,KAAK,EAAAg3C,aAAasB,SAClB,KAAK,EAAAtB,aAAak5C,SAAU,OAAO,EAErC,OAAO,EAIT,MAAa9kC,UAAwB,EAAA4oE,KAUnCj3H,YAAYk3B,GACVxsB,MAAMwsB,EAAS93B,QATjB,KAAAm4H,SAAsC,IAAIt+E,IAE1C,KAAAu+E,SAAsC,IAAIv+E,IAE1C,KAAAw+E,UAA+B,IAAIx+E,IA8H3B,KAAAy+E,uBAA8B,EA8D9B,KAAAC,eAAsB,EAEtB,KAAAC,cAAuB,IAAI/nH,MAxLjCpQ,KAAKy3B,SAAWA,EAIdY,cAAqB,OAAOr4B,KAAKy3B,SAASY,QAE1Cq/F,cAAqB,OAAO13H,KAAKq4B,QAAQsD,YAEzCy8F,cAAiB,OAAOp4H,KAAK03H,SAAW,EAAAj9F,QAAQmB,IAAM,EAAI,EAE1Dy8F,mBAA2B,OAAOr4H,KAAK03H,SAAW,EAAAj9F,QAAQmB,IAAM,EAAA3B,SAASwB,OAAS,EAAAxB,SAASoB,OAE3Fi9F,mBAA2B,OAAOt4H,KAAK03H,SAAW,EAAAj9F,QAAQmB,IAAM,EAAA3B,SAAS4nB,OAAS,EAAA5nB,SAASU,OAG/F49F,SAAS/0H,GACP,OAAOxD,KAAK03H,SAAW,EAAAj9F,QAAQmB,IAC3B57B,KAAKL,OAAOyZ,IAAI5V,GAChBxD,KAAKL,OAAOwZ,IAAI3V,GAItBg1H,SAASz1B,EAAmB5tB,GAC1B,IAAIsjD,EACJ,GAAIz4H,KAAK83H,SAAS58E,IAAI6nD,IAEpB,GADA01B,EAAU1uH,WAAoB/J,KAAK83H,SAAS38E,IAAI4nD,IAC5C01B,EAAQv9E,IAAIi6B,GACd,OAAOprE,WAAgB0uH,EAAQt9E,IAAIg6B,SAGrCsjD,EAAU,IAAIj/E,IACdx5C,KAAK83H,SAASnrH,IAAIo2F,EAAM01B,GAE1B,IAAIC,EAAYD,EAAQn+F,KAExB,OADAm+F,EAAQ9rH,IAAIwoE,EAAYujD,GACjBA,EAIT3jE,WAAWp0D,EAAcg4H,GAClBA,EAAsBntH,QAC3BxL,KAAKg4H,UAAUrrH,IAAIhM,EAAMg4H,GAI3BC,cAAc71B,EAAmBrhG,GAC/B,IAAIm3H,EACJ,GAAI74H,KAAK+3H,SAAS78E,IAAI6nD,IAEpB,GADA81B,EAAU9uH,WAAoB/J,KAAK+3H,SAAS58E,IAAI4nD,IAC5C81B,EAAQ39E,IAAIx5C,GACd,OAAOqI,WAAkB8uH,EAAQ19E,IAAIz5C,SAGvCm3H,EAAU,IAAIr/E,IACdx5C,KAAK+3H,SAASprH,IAAIo2F,EAAM81B,GAE1B,IACI1jD,GADY,IAAA2jD,+BAA8B/1B,GACjB81B,EAAQv+F,KAErC,OADAu+F,EAAQlsH,IAAIjL,EAAMyzE,GACXA,EAIT4jD,gBAAgBp8E,GACd5wC,OAAiB,GAAV4wC,GACP,IAAIh9C,EAASK,KAAKL,OACd+F,EAAO/F,EAAO4yD,WAAW,EAAAt9C,aAAasgB,cACxC51B,EAAOq6B,OAAO2iB,GAAU,EAAI38C,KAAKq4H,aAAer4H,KAAKs4H,aACnD34H,EAAOuhD,WAAW,EAAAjsC,aAAasgB,cAAev1B,KAAK03H,SACnD13H,KAAKu4H,SAASxhH,IAAI4lC,MAGtB,OAAIA,EAAS,EAAUj3C,EAChB/F,EAAOwhD,MAAM,KAAM,CACxBz7C,EACA1F,KAAKg5H,kBACJ,EAAAv+F,QAAQqb,MAIbmjF,cAAcC,EAAgBr2E,GAC5B92C,OAAOmtH,EAAY,GACnB,IAAIv5H,EAASK,KAAKL,OAClB,GAAIK,KAAKq4B,QAAQkgB,WAAW,IAAwB2gF,EAAY,GAC9Dr2E,EAAMpxC,KACJ9R,EAAO22B,YACL32B,EAAOuhD,WAAW,EAAAjsC,aAAasgB,cAAev1B,KAAK03H,SACnD/3H,EAAOwZ,IAAI,GACXnZ,KAAKu4H,SAASW,SAGb,CACL,IAAIC,EAASD,EACb,KAAOC,GAAU,GAEft2E,EAAMpxC,KACJ9R,EAAO+X,MAAM,EACX/X,EAAOuhD,WAAW,EAAAjsC,aAAasgB,cAAev1B,KAAK03H,SACnD/3H,EAAOyZ,IAAI,GACX,EAAAqhB,QAAQmB,IACRs9F,EAAYC,IAGhBA,GAAU,EAERA,IACFptH,OAAiB,GAAVotH,GAEPt2E,EAAMpxC,KACJ9R,EAAO+X,MAAM,EACX/X,EAAOuhD,WAAW,EAAAjsC,aAAasgB,cAAev1B,KAAK03H,SACnD/3H,EAAOwZ,IAAI,GACX,EAAAshB,QAAQC,IACRw+F,EAAYC,MAUtBH,iBACE,IAAIr5H,EAASK,KAAKL,OAgBlB,OAfKK,KAAKi4H,wBACRj4H,KAAKi4H,uBAAwB,EAC7Bt4H,EAAO43C,YAAY,eAAgB,EAAA9c,QAAQqb,KAAM,EAAArb,QAAQqb,KAAM,KAC7Dn2C,EAAO23C,GACL33C,EAAOq6B,OAAO,EAAAC,SAASyC,MACrB/8B,EAAOuhD,WAAW,EAAAjsC,aAAasgB,cAAev1B,KAAK03H,SACnD/3H,EAAOuhD,WAAW,EAAAjsC,aAAaqgB,SAAUt1B,KAAK03H,UAEhD13H,KAAKy3B,SAASwuD,gBACZjmF,KAAKy3B,SAASgkB,mBAAmB,kBACjCz7C,KAAKy3B,SAAS+d,QAAQ4jF,iBAKvBz5H,EAAOi2C,KAAK,eAAgB,KAAM,EAAAnb,QAAQqb,MAG3CujF,mBAAmBvhG,GACzB,IAAIn4B,EAASK,KAAKL,OACd25H,EAAW,EACf,IAAK,IAAI7tH,EAAI,EAAGC,EAAIosB,EAAStsB,OAAQC,EAAIC,IAAKD,EAAG,CAC/C,IACI8tH,EAAQ3B,EAAaj4H,EADXm4B,EAASrsB,IAEvB,IAAK8tH,EAAO,SACZ,IAAK1B,EAAUl4H,EAAQ45H,GAAQ,CAC7BzhG,EAASrsB,GAAK8tH,EACd,SAEF,IAAI9C,EAAkBz2H,KAAKy2H,gBACvB/+D,GAAY,IAAAohE,+BAA8BrC,GAC1CiC,EAAY14H,KAAKw4H,SAAS/B,EAAiB/+D,EAAY13D,KAAKk4H,eAAiBzsH,GAC7EywC,EAAOl8C,KAAK44H,cAAcnC,EAAiBz2H,KAAK03H,SAChD70E,EAAQ,IAAIzyC,MAEhByyC,EAAMpxC,KACJ9R,EAAOwjE,UAAUjnB,EAAMq9E,GAAO,IAGhC12E,EAAMpxC,KACJ9R,EAAO+X,MAAM1X,KAAKo4H,QAChBz4H,EAAOuhD,WAAW,EAAAjsC,aAAasgB,cAAev1B,KAAK03H,SACnD/3H,EAAO66B,UAAU0hB,EAAMl8C,KAAK03H,SAC5B13H,KAAK03H,QAASgB,EAAY14H,KAAKo4H,UAInCv1E,EAAMpxC,KACJ9R,EAAO66B,UAAU0hB,EAAMl8C,KAAK03H,UAE9B5/F,EAASrsB,GAAK9L,EAAOwhD,MAAM,KAAM0B,EAAO7iD,KAAK03H,WAC3C4B,EAEJ,OAAOA,EASTlS,aAAaxxE,GACX,IAAI/W,GAAc,IAAAmwE,6BAA4Bp5D,GAC1C9d,EAAW,IAAI1nB,MAAqByuB,GACxC,IAAK,IAAIpzB,EAAW,EAAGA,EAAIozB,IAAepzB,EACxCqsB,EAASrsB,IAAK,IAAAwjG,2BAA0Br5D,EAAMnqC,GAEhD,IAAI6tH,EAAWt5H,KAAKq5H,mBAAmBvhG,GACvC,IAAK,IAAIrsB,EAAI,EAAGC,EAAIosB,EAAStsB,OAAQC,EAAIC,IAAKD,GAC5C,IAAAgnH,2BAA0B78E,EAAMnqC,EAAGqsB,EAASrsB,IAE1C6tH,IAEFt5H,KAAKk4H,gBAAkBoB,GAEzBt5H,KAAKm4H,cAAc1mH,KAAK6nH,GAI1BjS,UAAUzxE,GACR,IAAI0jF,EAAWt5H,KAAKm4H,cAAc9gD,MAC9BiiD,IAAUt5H,KAAKk4H,gBAAkBoB,GAIvChS,qBAAqBkS,GACnB,IAAI36F,GAAc,IAAAktF,qCAAoCyN,GAClD1hG,EAAW,IAAI1nB,MAAqByuB,GACxC,IAAK,IAAIpzB,EAAW,EAAGA,EAAIozB,IAAepzB,EACxCqsB,EAASrsB,IAAK,IAAAugH,mCAAkCwN,EAAc/tH,GAEhE,IAAI6tH,EAAWt5H,KAAKq5H,mBAAmBvhG,GACvC,IAAK,IAAIrsB,EAAI,EAAGC,EAAIosB,EAAStsB,OAAQC,EAAIC,IAAKD,GAC5C,IAAAknH,mCAAkC6G,EAAc/tH,EAAGqsB,EAASrsB,IAE1D6tH,IAEFt5H,KAAKk4H,gBAAkBoB,GAEzBt5H,KAAKm4H,cAAc1mH,KAAK6nH,GAI1B/R,kBAAkBiS,GAChB,IAAIF,EAAWt5H,KAAKm4H,cAAc9gD,MAC9BiiD,IAAUt5H,KAAKk4H,gBAAkBoB,GAIvC9S,cAAcC,GACZ,IAAI9mH,EAASK,KAAKL,OAEd45H,EAAQ3B,EAAaj4H,GADb,IAAAqtG,2BAA0ByZ,IAEtC,IAAK8S,EAAO,OACZ,IAAK1B,EAAUl4H,EAAQ45H,GAErB,YADA,IAAA3G,2BAA0BnM,EAAU8S,GAGtC,IAAI5/F,GAAQ,IAAAozE,2BAA0B0Z,GAClCiS,EAAY14H,KAAKw4H,SAASx4H,KAAKy2H,gBAAiB98F,GAChDkpB,EAAQ,IAAIzyC,MAEhByyC,EAAMpxC,KACJ9R,EAAO+X,MAAM1X,KAAKo4H,QAChBz4H,EAAOuhD,WAAW,EAAAjsC,aAAasgB,cAAev1B,KAAK03H,SACnD/3H,EAAOy6B,UAAUT,EAAO4/F,GAAO,GAC/Bv5H,KAAK03H,QAASgB,EAAY14H,KAAKo4H,WAG/B,IAAAnrB,wBAAuBwZ,IAEzB5jE,EAAMpxC,KACJ9R,EAAO66B,UAAUb,EAAO35B,KAAK03H,UAE/B13H,KAAKq3H,eAAe13H,EAAO83C,QAAQoL,EAAO7iD,KAAK03H,WAE/C13H,KAAKq3H,eAAe13H,EAAO83C,QAAQoL,EAAO,EAAApoB,QAAQqb,OAKtD2jF,eAAe7mE,GACb,IAAIjyD,GAAO,IAAAyuG,0BAAyBx8C,GAChCksC,GAAS,IAAAuQ,4BAA2Bz8C,GACpCmsC,GAAU,IAAAuQ,6BAA4B18C,GACtCtqD,EAAOyD,QAAO,IAAAojG,0BAAyBv8C,IACvC8mE,GAAU,IAAAnqB,6BAA4B38C,GACtC+mE,EAAO,IAAIvpH,MACf,IAAK,IAAI3E,EAAW,EAAGA,EAAIiuH,IAAWjuH,EACpCkuH,EAAKluH,IAAK,IAAA+jG,yBAAwB58C,EAASnnD,GAE7C,IAAIssH,EAAW/3H,KAAK+3H,SACpB,GAAIA,EAAS78E,IAAI0X,GAAU,CACzB,IAAIimE,EAAU9uH,WAAoBguH,EAAS58E,IAAIyX,IAC/C,IAAK,IAAItR,EAAQC,SAASs3E,GAAUptH,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EACpEkuH,EAAKloH,KAAK6vC,EAAM71C,IAGpB,IAAIorH,EAAY72H,KAAKL,OAAO05E,KAC5B,IAAAopB,yBAAwBo0B,EAAWl2H,GACnC,IAAIy3F,GAAO,IAAAkF,eAAcq8B,IACzB,IAAAp3B,sBAAqBs0B,EAAWl2H,EAAMm+F,EAAQC,EAAS3G,EAAMuhC,EAAKnuH,OAAQlD,IAC1E,IAAAiwF,OAAMH,GAIRwhC,aAAaC,EAAsBlB,GACjC,IAAIh5H,EAASK,KAAKL,OACdk3H,EAAYl3H,EAAO05E,IACvBttE,QAAO,IAAA+tH,wBAAuBD,IAAc,EAAAtiC,aAAarhE,UAEzD,IAAI6jG,GAAkB,IAAAC,yBAAwBH,GAC1ChkF,EAAel2C,EAAOgrG,iBAAiBovB,GACvCE,GAAkB,IAAAC,wBAAuBL,GACzCjnE,GAAU,IAAA4vC,sBAAqBq0B,EAAWkD,GAC1Cj7B,GAAS,IAAAuQ,4BAA2Bz8C,GACpCgwC,GAAa,IAAAu3B,YAAWr7B,GACxBs7B,EAAYx3B,EAAWp3F,OACvBuzF,GAAU,IAAAuQ,6BAA4B18C,GACtC8E,EAAY0iE,EACZT,EAAO,IAAIvpH,MACXkpH,EAAWvtH,OAAO4sH,EAAsBntH,QACxC0tH,EAAYI,EAAWt5H,KAAKo4H,QAC5BiC,EAAc,UAAYxkF,EAC1BykF,EAAiB36H,EAAOg8F,kBAAkB0+B,GAE9C,GAAuD,IAAnD,IAAA73B,sBAAqBq0B,EAAWyD,GAAsB,CACxD,IAAIz3E,EAAQ,IAAIzyC,MAEhByyC,EAAMpxC,KACJzR,KAAK+4H,iBAAiBG,IAExB,IAAK,IAAIR,EAAY,EAAGA,EAAYY,IAAYZ,EAE9C71E,EAAMpxC,KACJ9R,EAAO+X,MAAM1X,KAAKo4H,QAChBz4H,EAAOuhD,WAAW,EAAAjsC,aAAasgB,cAAev1B,KAAK03H,SACnD/3H,EAAO66B,UAAUm+F,EAAsBD,GAAY14H,KAAK03H,SACxD13H,KAAK03H,QAASgB,EAAY14H,KAAKo4H,UAIrC,IAAIt/C,EAAoB,IAAI1oE,MAAqBgqH,GACjD,IAAK,IAAI3uH,EAAI,EAAGA,EAAI2uH,IAAa3uH,EAC/BqtE,EAAkBrtE,GAAK9L,EAAO66B,UAAU/uB,EAAGm3F,EAAWn3F,IAExD,GAAIszF,GAAW,EAAAtkE,QAAQqb,KAAM,CAC3B,IAAIwjC,EAAY5hB,IAChBiiE,EAAKloH,KAAKstF,GAEVl8C,EAAMpxC,KACJ9R,EAAOwjE,UAAUmW,EACf35E,EAAOi2C,KAAKC,EAAcijC,EAAmBimB,IAC7C,IAIJl8C,EAAMpxC,KACJzR,KAAK+4H,iBAAiBG,IAGxBr2E,EAAMpxC,KACJ9R,EAAO66B,UAAU8+C,EAAWylB,SAI9Bl8C,EAAMpxC,KACJ9R,EAAOi2C,KAAKC,EAAcijC,EAAmBimB,IAG/Cl8C,EAAMpxC,KACJzR,KAAK+4H,iBAAiBG,IAG1B,IAAI9gC,GAAO,IAAAkF,eAAcq8B,IACzB,IAAAp3B,sBAAqBs0B,EAAWyD,EAAgBx7B,EAAQC,EAAS3G,EAAMuhC,EAAKnuH,OAC1E7L,EAAOwhD,MAAM,KAAM0B,EAAOk8C,KAE5B,IAAAxG,OAAMH,IAER,IAAAqL,uBAAsBozB,EAAWoD,IACjC,IAAAh3B,4BAA2B4zB,EAAWyD,EAAgBL,GAIxD9mE,aAEEloD,MAAMkoD,aAGN,IAAIxzD,EAASK,KAAKL,OACd46H,EAAoB,IAAIC,EAAkBx6H,MAC9C,IAAK,IAAIshD,EAAQC,SAASvhD,KAAK83H,UAAWrsH,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CAC7E,IAAIs3F,EAAOzhD,EAAM71C,GAEbytH,EADUnvH,WAAoB/J,KAAK83H,SAAS38E,IAAI4nD,IAC5BzoE,KAAOt6B,KAAKo4H,QAGpCmC,EAAkBrB,UAAYA,EAC9BqB,EAAkBxD,aAAah0B,GAG/B,IAAIlgD,EAAQ,IAAIzyC,MAEhByyC,EAAMpxC,KACJzR,KAAK+4H,iBAAiBG,IAGxBl5H,KAAKi5H,cAAcC,EAAWr2E,GAG9B,IAAIv6C,GAAO,IAAA6mG,0BAAyBpM,GAChC03B,GAAW,IAAAz+B,4BAA2B1zF,GAC1C,GAAImyH,GAAY,EAAAhgG,QAAQ2oD,YAEtBvgC,EAAMpxC,KACJnJ,QAEG,GAAImyH,GAAY,EAAAhgG,QAAQqb,KAE7B+M,EAAMpxC,KACJnJ,GAGFu6C,EAAMpxC,KACJzR,KAAK+4H,iBAAiBG,QAEnB,CACL,IAAIh9E,EAAOl8C,KAAK44H,cAAc71B,EAAM03B,GAEpC53E,EAAMpxC,KACJ9R,EAAOwjE,UAAUjnB,EAAM5zC,GAAM,IAG/Bu6C,EAAMpxC,KACJzR,KAAK+4H,iBAAiBG,IAGxBr2E,EAAMpxC,KACJ9R,EAAO66B,UAAU0hB,EAAMu+E,KAG3B,IAAAnD,0BAAyBv0B,EAAMpjG,EAAO83C,QAAQoL,EAAO43E,IAKvD,IAAK,IAAIn5E,EAAQC,SAASvhD,KAAK+3H,UAAWtsH,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAC1EzL,KAAKy5H,eAAen4E,EAAM71C,IAI5B,IAAIusH,EAAYh4H,KAAKg4H,UACrB,IAAK,IAAI12E,EAAQC,SAASy2E,GAAYvsH,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CACzE,IAAI+oD,EAAalT,EAAM71C,GACnBouH,GAAY,IAAAn2B,oBAAmB/jG,EAAO05E,IAAK15E,EAAOg8F,kBAAkBnnC,IACpEmkE,EAAwB5uH,WAAkBiuH,EAAU78E,IAAIqZ,IAC5Dx0D,KAAK45H,aAAaC,EAAWlB,KAvcnC,oBA6cA,MAAM6B,UAA0B,EAAAhD,KAM9Bj3H,YAAYouD,GACV1jD,MAAM0jD,EAAYhvD,QAHpB,KAAAu5H,UAAiB,EAIfl5H,KAAK06H,WAAa/rE,EAIpBs5D,YAAYluF,GACVhuB,OAAO/L,KAAKk5H,WACZ,IAAIv5H,EAASK,KAAKL,OACd6D,GAAQ,IAAAsrG,yBAAwB/0E,GAChC8oB,EAAQ,IAAIzyC,MAChB,GAAI5M,EAAO,CACT,IAAItC,GAAa,IAAA86F,4BAA2Bx4F,GACxC04C,EAAOl8C,KAAK06H,WAAW9B,cAAc54H,KAAKy2H,gBAAiBv1H,GAE/D2hD,EAAMpxC,KACJ9R,EAAOwjE,UAAUjnB,EAAM14C,GAAO,IAGhCq/C,EAAMpxC,KACJzR,KAAK06H,WAAW3B,iBAAiB/4H,KAAKk5H,aAGxC,IAAA1F,yBAAwBz5F,EAAKp6B,EAAO66B,UAAU0hB,EAAMh7C,SAGpD2hD,EAAMpxC,KACJzR,KAAK06H,WAAW3B,iBAAiB/4H,KAAKk5H,YAI1Cr2E,EAAMpxC,KACJsoB,GAEF/5B,KAAKq3H,eAAe13H,EAAO83C,QAAQoL,EAAO,EAAApoB,QAAQ2oD,iB,0iBCnoBtD,eAoBA,SAMA,SAOA,SAKA,QA8CA,SAYA,SAIA,SAIA,SAIA,SAMMu3C,EAAUC,GAGhB,MAAMC,EACJt6H,YAESu6H,EAEAC,EAEAC,EAEAC,EAEAC,GARA,KAAAJ,UAAAA,EAEA,KAAAC,gBAAAA,EAEA,KAAAC,kBAAAA,EAEA,KAAAC,YAAAA,EAEA,KAAAC,eAAAA,GAKX,MAAMC,EACJ56H,YAESw6H,EAEAC,EAEAC,EAEAC,GANA,KAAAH,gBAAAA,EAEA,KAAAC,kBAAAA,EAEA,KAAAC,YAAAA,EAEA,KAAAC,eAAAA,GAKX,MAAME,EAEJ76H,YAES06H,EAEAC,EAEAG,GAJA,KAAAJ,YAAAA,EAEA,KAAAC,eAAAA,EAEA,KAAAG,YAAAA,GAKX,IAAY7vD,EA23EAr1B,EAwCAyF,GAn6EZ,SAAY4vB,GACV,yBAGA,iCACA,iCACA,qDACA,qDAGA,iBACA,iBACA,iBACA,iBACA,iBACA,kBACA,kCACA,gCACA,kCACA,kCACA,kCACA,sCACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBAGA,oBACA,sBACA,kBACA,kCACA,gCACA,gCAGA,kCACA,kCAvCF,CAAYA,EAAA,EAAAA,eAAA,EAAAA,aAAY,KA+CxB,SAAiBA,GAGC,EAAA8vD,cAAhB,SAA8BvtH,EAA8Bs4E,GAE1D,OADAt6E,OAAOs6E,EAAI76E,QACHuC,GACN,KAAK,EAAA5N,cAAcmN,SACnB,KAAK,EAAAnN,cAAcwN,gBACjB,OAAQ04E,EAAIt5E,WAAW,IACrB,KAAK,GACH,GAAW,MAAPs5E,EAAa,OAAO7a,EAAawI,YACrC,GAAW,OAAPqS,EAAc,OAAO7a,EAAauI,YACtC,MAEF,KAAK,IACH,GAAW,MAAPsS,EAAa,OAAO7a,EAAa+vD,sBACrC,GAAW,OAAPl1C,EAAc,OAAO7a,EAAagwD,sBACtC,MAEF,KAAK,GACH,GAAW,KAAPn1C,EAAY,OAAO7a,EAAa4B,IACpC,MAEF,KAAK,GACH,GAAW,KAAPiZ,EAAY,OAAO7a,EAAagC,IACpC,MAEF,KAAK,GACH,GAAW,KAAP6Y,EAAY,OAAO7a,EAAamC,IACpC,GAAW,MAAP0Y,EAAa,OAAO7a,EAAasC,IACrC,MAEF,KAAK,GACH,GAAW,KAAPuY,EAAY,OAAO7a,EAAa0C,IACpC,MAEF,KAAK,GACH,GAAW,KAAPmY,EAAY,OAAO7a,EAAa6C,IACpC,MAEF,KAAK,GACH,GAAW,KAAPgY,EAAY,OAAO7a,EAAa8D,YACpC,MAEF,KAAK,IACH,GAAW,KAAP+W,EAAY,OAAO7a,EAAakE,WACpC,MAEF,KAAK,GACH,GAAW,KAAP2W,EAAY,OAAO7a,EAAasE,YACpC,MAEF,KAAK,GACH,GAAW,MAAPuW,EAAa,OAAO7a,EAAaiB,GACrC,MAEF,KAAK,GACH,GAAW,MAAP4Z,EAAa,OAAO7a,EAAasB,GACrC,MAEF,KAAK,GACH,GAAW,KAAPuZ,EAAY,OAAO7a,EAAaO,GACpC,GAAW,MAAPsa,EAAa,OAAO7a,EAAaa,GACrC,GAAW,MAAPga,EAAa,OAAO7a,EAAasD,YACrC,GAAW,OAAPuX,EAAc,OAAO7a,EAAa0D,cACtC,MAEF,KAAK,GACH,GAAW,KAAPmX,EAAY,OAAO7a,EAAaC,GACpC,GAAW,MAAP4a,EAAa,OAAO7a,EAAaU,GACrC,GAAW,MAAPma,EAAa,OAAO7a,EAAakD,YAIzC,MAEF,KAAK,EAAAvuE,cAAcyN,gBACjB,OAAQy4E,EAAIt5E,WAAW,IACrB,KAAK,GACH,GAAW,KAAPs5E,EAAY,OAAO7a,EAAa2B,KACpC,GAAW,MAAPkZ,EAAa,OAAO7a,EAAasY,WACrC,MAEF,KAAK,GACH,GAAW,KAAPuC,EAAY,OAAO7a,EAAa+B,MACpC,GAAW,MAAP8Y,EAAa,OAAO7a,EAAauY,WACrC,MAEF,KAAK,GACH,GAAW,KAAPsC,EAAY,OAAO7a,EAAayY,IACpC,MAEF,KAAK,IACH,GAAW,KAAPoC,EAAY,OAAO7a,EAAa2Y,YAIxC,MAEF,KAAK,EAAAhkF,cAAc0N,iBACjB,OAAQw4E,EAAIt5E,WAAW,IACrB,KAAK,GACH,GAAW,MAAPs5E,EAAa,OAAO7a,EAAa8X,YACrC,MAEF,KAAK,GACH,GAAW,MAAP+C,EAAa,OAAO7a,EAAakY,aAO7C,OAAOlY,EAAaiwD,SAIN,EAAAC,gBAAhB,SAAgCpkB,GAC9B,OAAQA,GACN,KAAK,EAAAlsC,MAAM+B,KACX,KAAK,EAAA/B,MAAM8B,YAAa,OAAO1B,EAAa4B,IAC5C,KAAK,EAAAhC,MAAMmC,MACX,KAAK,EAAAnC,MAAMkC,aAAc,OAAO9B,EAAagC,IAC7C,KAAK,EAAApC,MAAMsC,SACX,KAAK,EAAAtC,MAAMqC,gBAAiB,OAAOjC,EAAamC,IAChD,KAAK,EAAAvC,MAAM6C,MACX,KAAK,EAAA7C,MAAM4C,aAAc,OAAOxC,EAAa0C,IAC7C,KAAK,EAAA9C,MAAMgD,QACX,KAAK,EAAAhD,MAAM+C,eAAgB,OAAO3C,EAAa6C,IAC/C,KAAK,EAAAjD,MAAMyC,kBACX,KAAK,EAAAzC,MAAMwC,yBAA0B,OAAOpC,EAAasC,IACzD,KAAK,EAAA1C,MAAMiE,UACX,KAAK,EAAAjE,MAAMgE,iBAAkB,OAAO5D,EAAa8D,YACjD,KAAK,EAAAlE,MAAMqE,IACX,KAAK,EAAArE,MAAMoE,WAAY,OAAOhE,EAAakE,WAC3C,KAAK,EAAAtE,MAAMyE,MACX,KAAK,EAAAzE,MAAMwE,aAAc,OAAOpE,EAAasE,YAC7C,KAAK,EAAA1E,MAAMoD,kBACX,KAAK,EAAApD,MAAMmD,yBAA0B,OAAO/C,EAAakD,YACzD,KAAK,EAAAtD,MAAMyD,wBACX,KAAK,EAAAzD,MAAMwD,+BAAgC,OAAOpD,EAAasD,YAC/D,KAAK,EAAA1D,MAAM6D,oCACX,KAAK,EAAA7D,MAAM4D,2CAA4C,OAAOxD,EAAa0D,cAC3E,KAAK,EAAA9D,MAAMoB,cAAe,OAAOhB,EAAaiB,GAC9C,KAAK,EAAArB,MAAMyB,mBAAoB,OAAOrB,EAAasB,GACnD,KAAK,EAAA1B,MAAMU,YAAa,OAAON,EAAaO,GAC5C,KAAK,EAAAX,MAAMgB,mBAAoB,OAAOZ,EAAaa,GACnD,KAAK,EAAAjB,MAAMC,SAAU,OAAOG,EAAaC,GACzC,KAAK,EAAAL,MAAMa,gBAAiB,OAAOT,EAAaU,GAElD,OAAOV,EAAaiwD,SAIN,EAAAE,qBAAhB,SAAqCrkB,GACnC,OAAQA,GACN,KAAK,EAAAlsC,MAAM+B,KAAM,OAAO3B,EAAa2B,KACrC,KAAK,EAAA/B,MAAMmC,MAAO,OAAO/B,EAAa+B,MACtC,KAAK,EAAAnC,MAAM4Y,YAAa,OAAOxY,EAAayY,IAC5C,KAAK,EAAA7Y,MAAM8Y,MAAO,OAAO1Y,EAAa2Y,YACtC,KAAK,EAAA/Y,MAAMiY,UAAW,OAAO7X,EAAasY,WAC1C,KAAK,EAAA1Y,MAAMqY,YAAa,OAAOjY,EAAauY,WAE9C,OAAOvY,EAAaiwD,SAIN,EAAAG,sBAAhB,SAAsCtkB,GACpC,OAAQA,GACN,KAAK,EAAAlsC,MAAMiY,UAAW,OAAO7X,EAAa8X,YAC1C,KAAK,EAAAlY,MAAMqY,YAAa,OAAOjY,EAAakY,YAE9C,OAAOlY,EAAaiwD,SA5KxB,CAAiBjwD,EAAA,EAAAA,eAAA,EAAAA,aAAY,KAiL7B,MAAaqrB,UAAgB,EAAA5qC,kBAG3B1rD,YAES83B,EAEP6zB,EAA0C,MAE1CjhD,MAAMihD,GAJC,KAAA7zB,QAAAA,EAmBT,KAAA46E,QAAoB,GAEpB,KAAAnc,kBAAyB,EAQzB,KAAA+kC,YAAmB,EAEnB,KAAAC,gBAAuB,EAEvB,KAAAC,aAAoB,EAKpB,KAAA5sE,YAAgC,IAAI3V,IAEpC,KAAAsH,eAAsC,IAAItH,IAE1C,KAAAwiF,sBAAmE,IAAIxiF,IAEvE,KAAAg8C,gBAAuC,IAAIh8C,IAE3C,KAAAyiF,eAAkC,IAAIziF,IAEtC,KAAA4H,eAAiC,IAAI5H,IAErC,KAAA0iF,iBAAgC,IAAI9rH,MAAiB,GAU7C,KAAA+rH,yBAAyC,KAQzC,KAAAC,qBAAqC,KAQrC,KAAAC,gBAAyC,KAQzC,KAAAC,sBAA+C,KAQ/C,KAAAC,cAAuC,KAQvC,KAAAC,cAAuC,KAQvC,KAAAC,mBAA4C,KAQ5C,KAAAC,oBAA6C,KAQ7C,KAAAC,qBAA8C,KAQ9C,KAAAC,qBAA8C,KAQ9C,KAAAC,qBAA8C,KAQ9C,KAAAC,qBAA8C,KAQ9C,KAAAC,4BAAqD,KAQrD,KAAAC,sBAA+C,KAQ/C,KAAAC,sBAA+C,KAQ/C,KAAAC,sBAA+C,KAQ/C,KAAAC,uBAAgD,KAQhD,KAAAC,uBAAgD,KAQhD,KAAAC,gBAAgC,KAQhC,KAAAC,gBAAgC,KAQhC,KAAAC,8BAA8C,KAiB9C,KAAAC,eAAkC,KAQlC,KAAAC,iBAAoC,KAQpC,KAAAC,cAAiC,KAQjC,KAAAC,aAAgC,KAQhC,KAAAC,eAAkC,KAQlC,KAAAC,cAAiC,KAQjC,KAAAC,iBAAoC,KAQpC,KAAAC,eAAkC,KAQlC,KAAAC,kBAAqC,KAQrC,KAAAC,oBAAuC,KAQvC,KAAAC,mBAAsC,KAQtC,KAAAC,kBAAqC,KAQrC,KAAAC,eAA+B,KAQ/B,KAAAC,gBAAgC,KAwGhC,KAAAC,qBAAgD,KAxbtD,IAAIlF,EAAe,IAAI,EAAAzlB,OAAO,EAAAtzG,WAAWgR,cAAe,EAAAH,cAAgB,QAAS,iBACjFlR,KAAKo5H,aAAeA,EACpBp5H,KAAKi3F,OAAS,IAAI,EAAA+b,OAAOhzG,KAAKksD,YAAalsD,KAAKizG,SAChDjzG,KAAKq2C,SAAW,IAAI,EAAAkoF,SAASv+H,MAC7B,IAAIw+H,EAAa,IAAIC,EAAKz+H,KAAMo5H,GAChCp5H,KAAKw+H,WAAaA,EAClBx+H,KAAKmvD,YAAYxiD,IAAI6xH,EAAW3oF,aAAc2oF,GAc5Cv+C,kBAAuB,OAAOjgF,KAAKo5H,aAAa34H,MA8BhDwhD,8BACF,IAAIyoD,EAAS1qG,KAAKm8H,yBAElB,OADKzxB,IAAQ1qG,KAAKm8H,yBAA2BzxB,EAAS1qG,KAAK0+H,aAAa,EAAAn7E,YAAYqE,kBAC7E8iD,EAKLtsC,0BACF,IAAIssC,EAAS1qG,KAAKo8H,qBAElB,OADK1xB,IAAQ1qG,KAAKo8H,qBAAuB1xB,EAAS1qG,KAAK0+H,aAAa,EAAAn7E,YAAYsE,cACzE6iD,EAKLzwD,qBACF,IAAIywD,EAAS1qG,KAAKq8H,gBAElB,OADK3xB,IAAQ1qG,KAAKq8H,gBAAkB3xB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAYnzC,MAAO+lC,EAAY6d,kBAClG02C,EAKLroD,2BACF,IAAIqoD,EAAS1qG,KAAKs8H,sBAElB,OADK5xB,IAAQ1qG,KAAKs8H,sBAAwB5xB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAYmE,YAAavR,EAAY6d,kBAC9G02C,EAKLvoD,mBACF,IAAIuoD,EAAS1qG,KAAKu8H,cAElB,OADK7xB,IAAQ1qG,KAAKu8H,cAAgB7xB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAYoE,IAAKxR,EAAY6d,kBAC9F02C,EAKLtoD,mBACF,IAAIsoD,EAAS1qG,KAAKw8H,cAElB,OADK9xB,IAAQ1qG,KAAKw8H,cAAgB9xB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAY/J,IAAKrD,EAAY6d,kBAC9F02C,EAKLtrD,wBACF,IAAIsrD,EAAS1qG,KAAKy8H,mBAElB,OADK/xB,IAAQ1qG,KAAKy8H,mBAAqB/xB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAYrtB,SAAUigB,EAAY6d,kBACxG02C,EAKLi0B,yBACF,IAAIj0B,EAAS1qG,KAAK08H,oBAElB,OADKhyB,IAAQ1qG,KAAK08H,oBAAsBhyB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAY/sB,UAAW2f,EAAY6d,kBAC1G02C,EAKLk0B,0BACF,IAAIl0B,EAAS1qG,KAAK28H,qBAElB,OADKjyB,IAAQ1qG,KAAK28H,qBAAuBjyB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAY5sB,WAAYwf,EAAY6d,kBAC5G02C,EAKLm0B,0BACF,IAAIn0B,EAAS1qG,KAAK48H,qBAElB,OADKlyB,IAAQ1qG,KAAK48H,qBAAuBlyB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAY1sB,WAAYsf,EAAY6d,kBAC5G02C,EAKLo0B,0BACF,IAAIp0B,EAAS1qG,KAAK68H,qBAElB,OADKnyB,IAAQ1qG,KAAK68H,qBAAuBnyB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAYxsB,WAAYof,EAAY6d,kBAC5G02C,EAKLq0B,0BACF,IAAIr0B,EAAS1qG,KAAK88H,qBAElB,OADKpyB,IAAQ1qG,KAAK88H,qBAAuBpyB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAY9sB,WAAY0f,EAAY6d,kBAC5G02C,EAKLs0B,iCACF,IAAIt0B,EAAS1qG,KAAK+8H,4BAElB,OADKryB,IAAQ1qG,KAAK+8H,4BAA8BryB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAY7sB,kBAAmByf,EAAY6d,kBAC1H02C,EAKLu0B,2BACF,IAAIv0B,EAAS1qG,KAAKg9H,sBAElB,OADKtyB,IAAQ1qG,KAAKg9H,sBAAwBtyB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAY3sB,YAAauf,EAAY6d,kBAC9G02C,EAKLw0B,2BACF,IAAIx0B,EAAS1qG,KAAKi9H,sBAElB,OADKvyB,IAAQ1qG,KAAKi9H,sBAAwBvyB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAYzsB,YAAaqf,EAAY6d,kBAC9G02C,EAKLy0B,2BACF,IAAIz0B,EAAS1qG,KAAKk9H,sBAElB,OADKxyB,IAAQ1qG,KAAKk9H,sBAAwBxyB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAYvsB,YAAamf,EAAY6d,kBAC9G02C,EAKL00B,4BACF,IAAI10B,EAAS1qG,KAAKm9H,uBAElB,OADKzyB,IAAQ1qG,KAAKm9H,uBAAyBzyB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAYtsB,aAAckf,EAAY6d,kBAChH02C,EAKL20B,4BACF,IAAI30B,EAAS1qG,KAAKo9H,uBAElB,OADK1yB,IAAQ1qG,KAAKo9H,uBAAyB1yB,EAAyB1qG,KAAKJ,QAAQ,EAAA2jD,YAAYrsB,aAAcif,EAAY6d,kBAChH02C,EAKL3wD,qBACF,IAAI2wD,EAAS1qG,KAAKq9H,gBAElB,OADK3yB,IAAQ1qG,KAAKq9H,gBAAkB3yB,EAAS1qG,KAAK0+H,aAAa,EAAAn7E,YAAYiE,SACpEkjD,EAKL40B,qBACF,IAAI50B,EAAS1qG,KAAKs9H,gBAElB,OADK5yB,IAAQ1qG,KAAKs9H,gBAAkB5yB,EAAS1qG,KAAK0+H,aAAa,EAAAn7E,YAAYkE,SACpEijD,EAKLhrB,mCACF,IAAIgrB,EAAS1qG,KAAKu9H,8BAElB,OADK7yB,IAAQ1qG,KAAKu9H,8BAAgC7yB,EAAS1qG,KAAK0+H,aAAa,EAAAn7E,YAAY2E,uBAClFwiD,EAKL3kB,oBACF,IAAIptC,EAAY34C,KAAKozD,OAAO,EAAA7P,YAAYjuC,OACxC,OAAKqjC,GAAaA,EAAUn4C,MAAQ21C,EAAYC,mBACzCp2C,KAAKq2C,SAASC,gBAAmCqC,EAAW,MADQ,KAOzE6sC,oBACF,IAAIklB,EAAS1qG,KAAKw9H,eAElB,OADK9yB,IAAQ1qG,KAAKw9H,eAAiB9yB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAYiF,QACtEkiD,EAKL60B,sBACF,IAAI70B,EAAS1qG,KAAKy9H,iBAElB,OADK/yB,IAAQ1qG,KAAKy9H,iBAAmB/yB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAYkF,UACxEiiD,EAKL80B,mBACF,IAAI90B,EAAS1qG,KAAK09H,cAElB,OADKhzB,IAAQ1qG,KAAK09H,cAAgBhzB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAYmF,OACrEgiD,EAKLjlB,kBACF,IAAIilB,EAAS1qG,KAAK29H,aAElB,OADKjzB,IAAQ1qG,KAAK29H,aAAejzB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAYoF,OACpE+hD,EAKL+0B,oBACF,IAAI/0B,EAAS1qG,KAAK49H,eAElB,OADKlzB,IAAQ1qG,KAAK49H,eAAiBlzB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAYqF,QACtE8hD,EAKLxtC,mBACF,IAAIwtC,EAAS1qG,KAAK69H,cAElB,OADKnzB,IAAQ1qG,KAAK69H,cAAgBnzB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAYsF,OACrE6hD,EAKLg1B,sBACF,IAAIh1B,EAAS1qG,KAAK89H,iBAElB,OADKpzB,IAAQ1qG,KAAK89H,iBAAmBpzB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAYuF,UACxE4hD,EAKLh1D,oBACF,IAAIg1D,EAAS1qG,KAAK+9H,eAElB,OADKrzB,IAAQ1qG,KAAK+9H,eAAiBrzB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAY0F,QACtEyhD,EAKLi1B,uBACF,IAAIj1B,EAAS1qG,KAAKg+H,kBAElB,OADKtzB,IAAQ1qG,KAAKg+H,kBAAoBtzB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAYwF,WACzE2hD,EAKL9nD,yBACF,IAAI8nD,EAAS1qG,KAAKi+H,oBAElB,OADKvzB,IAAQ1qG,KAAKi+H,oBAAsBvzB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAYyF,cAC3E0hD,EAKL9pB,wBACF,IAAI8pB,EAAS1qG,KAAKk+H,mBAElB,OADKxzB,IAAQ1qG,KAAKk+H,mBAAqBxzB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAY2F,YAC1EwhD,EAKLhqB,uBACF,IAAIgqB,EAAS1qG,KAAKm+H,kBAElB,OADKzzB,IAAQ1qG,KAAKm+H,kBAAoBzzB,EAAS1qG,KAAKyvD,gBAAgB,EAAAlM,YAAY4F,WACzEuhD,EAKLk1B,oBACF,IAAIl1B,EAAS1qG,KAAKo+H,eAElB,OADK1zB,IAAQ1qG,KAAKo+H,eAAiB1zB,EAAS1qG,KAAK0+H,aAAa,EAAAn7E,YAAYpxC,QACnEu4F,EAKLrsC,qBACF,IAAIqsC,EAAS1qG,KAAKq+H,gBAElB,OADK3zB,IAAQ1qG,KAAKq+H,gBAAkB3zB,EAAS1qG,KAAK0+H,aAAa,EAAAn7E,YAAYj0C,SACpEo7F,EAOLh4C,aACF,OAAO1yD,KAAK8gD,eAAe5F,IAAI,EAAAqI,YAAYiC,UAI7CuxC,UAAUtmF,GACR,IAAIwiG,EAAUjzG,KAAKizG,QACnB,IAAK,IAAIxnG,EAAI,EAAGA,EAAIwnG,EAAQznG,SAAUC,EAAG,CACvC,IAAIuF,EAASiiG,EAAQxnG,GACrB,GAAIuF,EAAOP,cAAgBA,EAAc,OAAOO,EAAO/O,KAEzD,OAAO,KAIL49H,oBAGF,OAAO7/H,KAAK4/H,cAAcvkF,iBAIxBykF,qBAGF,OAAQ9/H,KAAKq+D,eAAehjB,iBAAmBr7C,KAAK6/H,cAAgBlF,GAAW,GAI7E78D,oBAGF,OAAO99D,KAAK6/H,cAAgB7/H,KAAK8/H,eAInCC,kBAAkBC,GAChB,IAAIH,EAAgB7/H,KAAK6/H,cACzB,OAASG,EAAgBH,EAAgBlF,GAAW,IAAYkF,EAIlEpiE,oBAAoBuiE,GAClB,IAAIH,EAAgBjlF,QAAQ56C,KAAK6/H,eACjC,OAAOzjH,QAAQ40C,UAAUh1C,QAAQgkH,EAAeH,GA1pBpC,IA0pB8DA,GAI5EI,iBAAiBC,EAAkB9pH,GAE7BA,IAAW8pH,GAAelgI,KAAK8/H,gBAInC,IAAIK,EAAYngI,KAAK+/H,kBAAkBG,GAEnCL,EAAgB7/H,KAAK6/H,cACrBO,GAAiB,EAAIpgI,KAAKq4B,QAAQkD,UAAUyD,SAAW6gG,EAAgBlF,GAAW,IAAYkF,EAC9FM,EAAYC,IAAcD,EAAYC,GAG1C,GAAID,GAFiB,GAAK,IAEiC,IAD1C,EACiBA,GAChC,MAAM,IAAIh4E,MAAM,sBAElB,OAAOg4E,EAITE,8BAEE1/H,EAEAsF,EAAqB,EAAAqG,YAAYC,MAEjC,IAAI9L,EAAQT,KAAKo5H,aAAa34H,MAC9B,OAAO,EAAAH,KAAK25G,0BACV,EAAA35G,KAAKO,2BAA2BF,EAAMF,GACtC,KAAMwF,EAAO,KAAM,KAAMxF,GAK7B6/H,0BAEE3/H,EAEAsF,EAAqB,EAAAqG,YAAYC,MAEjC,IAAI9L,EAAQT,KAAKo5H,aAAa34H,MAC1BkL,EAAa,EAAArL,KAAKO,2BAA2BF,EAAMF,GACvD,OAAO,EAAAH,KAAK+hH,sBACV12G,EACA,KAAM1F,EAAO,KACb,EAAA3F,KAAK24G,kBAAkBx4G,GACvBA,GAQJshF,8BAEEphF,EAEAsF,EAAqB,EAAAqG,YAAYC,MAEjC,IAAI9L,EAAQT,KAAKo5H,aAAa34H,MAC1B4H,EAAYrI,KAAKs+H,qBAUrB,OATKj2H,IACHrI,KAAKs+H,qBAAuBj2H,EAAY,EAAA/H,KAAK64G,mBAAmB,GAC9D,EAAA74G,KAAKw3G,gBACH,EAAAx3G,KAAKe,qBAAqB,EAAAkiD,YAAYU,MAAOxjD,GAC7C,MAAM,EAAOA,GAEf,MAAM,EAAOA,IAGV,EAAAH,KAAK+7G,0BACV,EAAA/7G,KAAKO,2BAA2BF,EAAMF,GACtC,KAAMwF,EAAO,KAAMoC,EAAW,KAAM,EAAgB5H,GAKxD8/H,+BAEE5/H,EAEAsF,EAAqB,EAAAqG,YAAYC,MAEjC,IAAI9L,EAAQT,KAAKo5H,aAAa34H,MAC9B,OAAO,EAAAH,KAAK6+G,2BACV,EAAA7+G,KAAKO,2BAA2BF,EAAMF,GACtC,KAAMwF,EAAO,GAAIxF,GAKrB+tD,mBAEE7tD,EAEA0H,EAEA8uC,EAAkBn3C,KAAKw+H,WAEvBv4H,EAAqB,EAAAqG,YAAYC,KAEjCi0H,EAAiC5kF,EAAervC,MAEhD,OAAO,IAAI2pB,EACTv1B,EACA,IAAIo7E,EACFp7E,EACAw2C,EACAn3C,KAAK+hF,8BAA8BphF,EAAMsF,GACzCu6H,GAEF,KACAn4H,GAKJ82D,wBAAwBn8D,GACtB,IAAIg5H,EAAwBh8H,KAAKg8H,sBACjC,OAAOA,EAAsB9gF,IAAIl4C,GAC7B+I,OAAOiwH,EAAsB7gF,IAAIn4C,IACjC,KAIN+rD,aACE,IAAI/uD,KAAK+7H,YAAT,CACA/7H,KAAK+7H,aAAc,EAEnB,IAAI1jG,EAAUr4B,KAAKq4B,QAGnBr4B,KAAKygI,mBAAmB,EAAAl9E,YAAYtqC,GAAI,EAAA8e,KAAK9e,IAC7CjZ,KAAKygI,mBAAmB,EAAAl9E,YAAYrqC,IAAK,EAAA6e,KAAK7e,KAC9ClZ,KAAKygI,mBAAmB,EAAAl9E,YAAYpqC,IAAK,EAAA4e,KAAK5e,KAC9CnZ,KAAKygI,mBAAmB,EAAAl9E,YAAYnqC,IAAK,EAAA2e,KAAK3e,KAC9CpZ,KAAKygI,mBAAmB,EAAAl9E,YAAYlqC,MAAOgf,EAAQwnB,WACnD7/C,KAAKygI,mBAAmB,EAAAl9E,YAAYjqC,GAAI,EAAAye,KAAKze,IAC7CtZ,KAAKygI,mBAAmB,EAAAl9E,YAAYhqC,IAAK,EAAAwe,KAAKxe,KAC9CvZ,KAAKygI,mBAAmB,EAAAl9E,YAAY/pC,IAAK,EAAAue,KAAKve,KAC9CxZ,KAAKygI,mBAAmB,EAAAl9E,YAAY9pC,IAAK,EAAAse,KAAKte,KAC9CzZ,KAAKygI,mBAAmB,EAAAl9E,YAAY7pC,MAAO2e,EAAQkD,WACnDv7B,KAAKygI,mBAAmB,EAAAl9E,YAAY5pC,KAAM,EAAAoe,KAAKpe,MAC/C3Z,KAAKygI,mBAAmB,EAAAl9E,YAAY3pC,IAAK,EAAAme,KAAKne,KAC9C5Z,KAAKygI,mBAAmB,EAAAl9E,YAAY1pC,IAAK,EAAAke,KAAKle,KAC9C7Z,KAAKygI,mBAAmB,EAAAl9E,YAAYU,MAAO,EAAAlsB,KAAKsH,MAChDr/B,KAAKygI,mBAAmB,EAAAl9E,YAAYW,OAAQ,EAAAnsB,KAAKle,KACjD7Z,KAAKygI,mBAAmB,EAAAl9E,YAAYY,QAAS,EAAApsB,KAAKpe,MAClD3Z,KAAKw+H,WAAWloH,IAAI,EAAAitC,YAAYc,OAAQ,IAAIq8E,EAC1C,EAAAn9E,YAAYc,OACZrkD,KAAKw+H,WACLx+H,KAAKsgI,0BAA0B,EAAA/8E,YAAYc,OAAQ,EAAA/3C,YAAYyG,OAAS,EAAAzG,YAAYsnD,SACpFhY,EAAe5uC,UAEjBhN,KAAKw+H,WAAWloH,IAAI,EAAAitC,YAAYe,QAAS,IAAIo8E,EAC3C,EAAAn9E,YAAYe,QACZtkD,KAAKw+H,WACLx+H,KAAKsgI,0BAA0B,EAAA/8E,YAAYe,QAAS,EAAAh4C,YAAYyG,OAAS,EAAAzG,YAAYsnD,SACrFhY,EAAe5uC,UAEjBhN,KAAKw+H,WAAWloH,IAAI,EAAAitC,YAAYgB,QAAS,IAAIm8E,EAC3C,EAAAn9E,YAAYgB,QACZvkD,KAAKw+H,WACLx+H,KAAKsgI,0BAA0B,EAAA/8E,YAAYgB,QAAS,EAAAj4C,YAAYyG,OAAS,EAAAzG,YAAYsnD,SACrFhY,EAAe5uC,UAEjBhN,KAAKw+H,WAAWloH,IAAI,EAAAitC,YAAYiB,SAAU,IAAIk8E,EAC5C,EAAAn9E,YAAYiB,SACZxkD,KAAKw+H,WACLx+H,KAAKsgI,0BAA0B,EAAA/8E,YAAYiB,SAAU,EAAAl4C,YAAYyG,OAAS,EAAAzG,YAAYsnD,SACtFhY,EAAe5uC,UAEjBhN,KAAKw+H,WAAWloH,IAAI,EAAAitC,YAAYkB,QAAS,IAAIi8E,EAC3C,EAAAn9E,YAAYkB,QACZzkD,KAAKw+H,WACLx+H,KAAKsgI,0BAA0B,EAAA/8E,YAAYkB,QAAS,EAAAn4C,YAAYyG,OAAS,EAAAzG,YAAYsnD,SACrFhY,EAAe5uC,UAMjBhN,KAAKygI,mBAAmB,EAAAl9E,YAAYzpC,KAAM,EAAAie,KAAKje,MAC/C9Z,KAAKygI,mBAAmB,EAAAl9E,YAAYC,QAAS,EAAAzrB,KAAKyrB,SAClDxjD,KAAKygI,mBAAmB,EAAAl9E,YAAYE,UAAW,EAAA1rB,KAAK0rB,WACpDzjD,KAAKygI,mBAAmB,EAAAl9E,YAAYG,OAAQ,EAAA3rB,KAAK2rB,QACjD1jD,KAAKygI,mBAAmB,EAAAl9E,YAAYI,MAAO,EAAA5rB,KAAK4rB,OAChD3jD,KAAKygI,mBAAmB,EAAAl9E,YAAY/F,OAAQ,EAAAzlB,KAAKylB,QACjDx9C,KAAKygI,mBAAmB,EAAAl9E,YAAYK,QAAS,EAAA7rB,KAAK6rB,SAGlD5jD,KAAK2gI,wBAAwB,EAAAp9E,YAAYwB,WAAY,EAAAhtB,KAAK5e,IACxDyhC,QAAQviB,EAAQC,SAAW,EAAA+wB,OAAOiC,OAAS,EAAAjC,OAAOM,SACpD3pD,KAAK2gI,wBAAwB,EAAAp9E,YAAYyB,YAAa,EAAAjtB,KAAK5e,IACzDyhC,QAAQviB,EAAQuxB,UAClB5pD,KAAK2gI,wBAAwB,EAAAp9E,YAAY0B,cAAe,EAAAltB,KAAKpe,KAC3DihC,QAAQviB,EAAQwlB,SAAW,EAAI,EAAG,IACpC79C,KAAK2gI,wBAAwB,EAAAp9E,YAAY2B,gBAAiB,EAAAntB,KAAK5e,IAC7DyhC,QAAQviB,EAAQmyB,WAAY,IAC9BxqD,KAAK2gI,wBAAwB,EAAAp9E,YAAY4B,eAAgB,EAAAptB,KAAK5e,IAC5DyhC,QAAQviB,EAAQoyB,UAAW,IAC7BzqD,KAAK2gI,wBAAwB,EAAAp9E,YAAY6B,mBAAoB,EAAArtB,KAAK5e,IAChEyhC,QAAQviB,EAAQ+yB,kBAAmB,IACrCprD,KAAK2gI,wBAAwB,EAAAp9E,YAAY8B,iBAAkB,EAAAttB,KAAK5e,IAC9DyhC,QAAQviB,EAAQgzB,gBAAiB,IACnCrrD,KAAK2gI,wBAAwB,EAAAp9E,YAAY+B,qBAAsB,EAAAvtB,KAAK5e,IAClEyhC,QAAQviB,EAAQyyB,eAAgB,IAClC9qD,KAAK2gI,wBAAwB,EAAAp9E,YAAYgC,mBAAoB,EAAAxtB,KAAKpe,KAChEihC,QAAQviB,EAAQ0yB,cAAgB,EAAI,EAAG,IACzC/qD,KAAK2gI,wBAAwB,EAAAp9E,YAAY8C,kBAAmB,EAAAtuB,KAAK5e,IAC/DyhC,QAAQviB,EAAQ4yB,qBAClBjrD,KAAK2gI,wBAAwB,EAAAp9E,YAAY+C,kBAAmB,EAAAvuB,KAAK5e,IAC/DyhC,QAAQviB,EAAQ6yB,qBAClBlrD,KAAK2gI,wBAAwB,EAAAp9E,YAAYgD,kBAAmB,EAAAxuB,KAAK5e,IAC/DyhC,QAAQviB,EAAQ8yB,qBAGlBnrD,KAAK2gI,wBAAwB,EAAAp9E,YAAYkC,2BAA4B,EAAA1tB,KAAKpe,KACxEihC,QAAQviB,EAAQkgB,WAAW,GAA0B,EAAI,EAAG,IAC9Dv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAYmC,4BAA6B,EAAA3tB,KAAKpe,KACzEihC,QAAQviB,EAAQkgB,WAAW,GAA2B,EAAI,EAAG,IAC/Dv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAYoC,4BAA6B,EAAA5tB,KAAKpe,KACzEihC,QAAQviB,EAAQkgB,WAAW,GAA2B,EAAI,EAAG,IAC/Dv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAYqC,wBAAyB,EAAA7tB,KAAKpe,KACrEihC,QAAQviB,EAAQkgB,WAAW,GAAuB,EAAI,EAAG,IAC3Dv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAYsC,iBAAkB,EAAA9tB,KAAKpe,KAC9DihC,QAAQviB,EAAQkgB,WAAW,IAAgB,EAAI,EAAG,IACpDv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAYuC,oBAAqB,EAAA/tB,KAAKpe,KACjEihC,QAAQviB,EAAQkgB,WAAW,IAAmB,EAAI,EAAG,IACvDv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAYwC,+BAAgC,EAAAhuB,KAAKpe,KAC5EihC,QAAQviB,EAAQkgB,WAAW,IAA8B,EAAI,EAAG,IAClEv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAYyC,uBAAwB,EAAAjuB,KAAKpe,KACpEihC,QAAQviB,EAAQkgB,WAAW,KAAsB,EAAI,EAAG,IAC1Dv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAY0C,4BAA6B,EAAAluB,KAAKpe,KACzEihC,QAAQviB,EAAQkgB,WAAW,KAA2B,EAAI,EAAG,IAC/Dv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAY2C,wBAAyB,EAAAnuB,KAAKpe,KACrEihC,QAAQviB,EAAQkgB,WAAW,KAAuB,EAAI,EAAG,IAC3Dv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAY4C,eAAgB,EAAApuB,KAAKpe,KAC5DihC,QAAQviB,EAAQkgB,WAAW,MAAc,EAAI,EAAG,IAClDv4C,KAAK2gI,wBAAwB,EAAAp9E,YAAY6C,qBAAsB,EAAAruB,KAAKpe,KAClEihC,QAAQviB,EAAQkgB,WAAW,MAAoB,EAAI,EAAG,IAGxD,IAAIqoF,EAAgB,IAAIxwH,MACpBywH,EAAgB,IAAIrnF,IACpBsnF,EAAoB,IAAItnF,IACxBunF,EAAgB,IAAI3wH,MACpB4wH,EAAmB,IAAI5wH,MAG3B,IAAK,IAAI3E,EAAI,EAAGC,EAAI1L,KAAKizG,QAAQznG,OAAQC,EAAIC,IAAKD,EAAG,CACnD,IAAIuF,EAAShR,KAAKizG,QAAQxnG,GACtB2jD,EAAO,IAAIqvE,EAAKz+H,KAAMgR,GAC1BhR,KAAKmvD,YAAYxiD,IAAIyiD,EAAKvZ,aAAcuZ,GACxC,IAAIxpD,EAAaoL,EAAOpL,WACxB,IAAK,IAAIoxC,EAAI,EAAGtlC,EAAI9L,EAAW4F,OAAQwrC,EAAItlC,IAAKslC,EAAG,CACjD,IAAIzwC,EAAYX,EAAWoxC,GAC3B,OAAQzwC,EAAU/F,MAChB,KAAK,EAAAN,SAAS6S,OACZ/S,KAAKihI,kBAAmC16H,EAAW6oD,EAAMyxE,EAAeC,GACxE,MAEF,KAAK,EAAA5gI,SAASkT,cACZpT,KAAKkhI,wBAAgD36H,EAAW6oD,EAAM2xE,EAAeC,GACrF,MAEF,KAAK,EAAA9gI,SAAS6T,OACZ/T,KAAKmhI,kBAAmC56H,EAAW6oD,EAAMwxE,EAAeC,GACxE,MAEF,KAAK,EAAA3gI,SAASwU,SACZ1U,KAAKohI,oBAAuC76H,EAAW6oD,GACvD,MAEF,KAAK,EAAAlvD,SAASmS,iBACZrS,KAAKqhI,gBAAkC96H,EAAW6oD,EAAM2xE,EAAeC,GACvE,MAEF,KAAK,EAAA9gI,SAASyS,gBACZ3S,KAAKshI,eAAgC/6H,EAAW6oD,GAChD,MAEF,KAAK,EAAAlvD,SAASyT,oBACZ3T,KAAKuhI,mBAAwCh7H,EAAW6oD,GACxD,MAEF,KAAK,EAAAlvD,SAAS8T,qBACZhU,KAAKwhI,oBAA0Cj7H,EAAW6oD,EAAM2xE,GAChE,MAEF,KAAK,EAAA7gI,SAASgU,qBACZlU,KAAKyhI,oBAA0Cl7H,EAAW6oD,EAAM2xE,EAAeC,GAC/E,MAEF,KAAK,EAAA9gI,SAASsU,gBACZxU,KAAK0hI,yBAA0Cn7H,EAAW6oD,KASlE,IAAK,IAAI9N,EAAQC,SAASu/E,GAAoBr1H,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CACjF,IAAI2jD,EAAO9N,EAAM71C,GACbk2H,EAAc51H,OAAO+0H,EAAkB3lF,IAAIiU,IAC/C,IAAK,IAAIpY,EAAI,EAAGtlC,EAAIiwH,EAAYn2H,OAAQwrC,EAAItlC,IAAKslC,EAAG,CAClD,IAAI8f,EAAahlD,UAAU6vH,EAAY3qF,IACnC4qF,EAAc5hI,KAAK6hI,kBAAkB/qE,EAAWmkE,YAAankE,EAAWokE,gBACvE0G,EAOLxyE,EAAK0yE,iBAAiBF,GANpB5hI,KAAKw4B,MACH,EAAAC,eAAey+B,iBACfJ,EAAWukE,YAAY56H,MAAOq2D,EAAWukE,YAAY73H,QAU7D,OAAG,CACD,IAAIiI,EAAI,EAAGs2H,GAAe,EAC1B,KAAOt2H,EAAIm1H,EAAcp1H,QAAQ,CAC/B,IAAIw2H,EAAepB,EAAcn1H,GAC7BsvH,EAAkBiH,EAAajH,gBAC/BC,EAAoBgH,EAAahH,kBAEjC4G,EAAc71H,OAAO/L,KAAK6hI,kBAAkBG,EAAa/G,YAAa+G,EAAa9G,iBACvF,GAAIF,EAAmB,CACrB,IAAI7gF,EAAUn6C,KAAKiiI,cACjBjH,EAAkB/4H,KAClB2/H,EACAf,GAEE1mF,GACF6nF,EAAalH,UAAUxkH,IACrBykH,EAAgB94H,KAChBk4C,EACA4gF,GAEF6F,EAAcsB,OAAOz2H,EAAG,GACxBs2H,GAAe,KAEbt2H,MAEC,CACL,IAAIqvH,EAAYkH,EAAalH,UACzB5zH,EAAY6zH,EAAgB94H,KAChC64H,EAAUxkH,IACRpP,EACA06H,EAAYO,iBACVj7H,EACA4zH,EACAC,GAEFA,GAEF6F,EAAcsB,OAAOz2H,EAAG,GACxBs2H,GAAe,GAGnB,IAAKA,EAAc,CAEjB,IAAK,IAAI/qF,EAAI,EAAGtlC,EAAIkvH,EAAcp1H,OAAQwrC,EAAItlC,IAAKslC,EAAG,CACpD,IAAIgrF,EAAepB,EAAc5pF,GAC7BgkF,EAAoBgH,EAAahH,kBACjCA,GACFh7H,KAAKw4B,MACH,EAAAC,eAAe2pG,kCACfpH,EAAkBv6H,MAAOuhI,EAAa/G,YAAaD,EAAkB/4H,MAI3E,OAMJ,IAAK,IAAIq/C,EAAQC,SAASs/E,GAAgBp1H,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CAC7E,IAAI2jD,EAAOt9C,UAAUwvC,EAAM71C,IACvB/L,EAAUqM,OAAO80H,EAAc1lF,IAAIiU,IAEvC,IAAK,IAAIizE,EAAc9gF,SAAS7hD,GAAUs3C,EAAI,EAAGtlC,EAAI2wH,EAAY72H,OAAQwrC,EAAItlC,IAAKslC,EAAG,CACnF,IAAIwd,EAAa1iD,UAAUuwH,EAAYrrF,IACnCsrF,EAAev2H,OAAOrM,EAAQy7C,IAAIqZ,IAClCttD,EAAYo7H,EAAavH,gBAAgB94H,KACzCg5H,EAAcqH,EAAarH,YAC/B,GAAIA,EAAa,CAEf,IAAI2G,EAAc71H,OAAO/L,KAAK6hI,kBAAkB5G,EAAalvH,OAAOu2H,EAAapH,kBAC7E/gF,EAAUn6C,KAAKiiI,cAAc/6H,EAAW06H,EAAaf,GACrD1mF,EACFiV,EAAKmzE,aAAa/tE,EAAYra,GAE9Bn6C,KAAKw4B,MACH,EAAAC,eAAe2pG,kCACfE,EAAavH,gBAAgBt6H,MAC7Bw6H,EAAa/zH,OAGZ,CACL,IAAIizC,EAAUiV,EAAKlZ,UAAUhvC,GAC7B,GAAIizC,EACFiV,EAAKmzE,aAAa/tE,EAAYra,OACzB,CACL,IAAIqoF,EAAgBxiI,KAAKozD,OAAOlsD,GACV,OAAlBs7H,GAA0BC,EAAkBD,EAAchiI,MAC5D4uD,EAAKmzE,aAAa/tE,EAA6BguE,GAE/CxiI,KAAKw4B,MACH,EAAAC,eAAe2pG,kCACfE,EAAatH,kBAAkBv6H,MAC/B2uD,EAAKvZ,aAAcysF,EAAatH,kBAAkB/4H,SAS9D8J,OAAsC,GAA/B/L,KAAKo+D,oBAAoB1iB,IAChC3vC,OAAiC,GAA1B/L,KAAK+5C,eAAe2B,IAC3B3vC,OAA0C,GAAnC/L,KAAKiiD,wBAAwBvG,IAGpC17C,KAAK0iI,qBAAqB,EAAA3qG,KAAK9e,GAAI,EAAAsqC,YAAYiD,IAC/CxmD,KAAK0iI,qBAAqB,EAAA3qG,KAAK7e,IAAK,EAAAqqC,YAAYkD,KAChDzmD,KAAK0iI,qBAAqB,EAAA3qG,KAAK5e,IAAK,EAAAoqC,YAAY7oB,KAChD16B,KAAK0iI,qBAAqB,EAAA3qG,KAAK3e,IAAK,EAAAmqC,YAAY3nB,KAChD57B,KAAK0iI,qBAAqBrqG,EAAQwnB,UAAW,EAAA0D,YAAYmD,OACzD1mD,KAAK0iI,qBAAqB,EAAA3qG,KAAKze,GAAI,EAAAiqC,YAAYoD,IAC/C3mD,KAAK0iI,qBAAqB,EAAA3qG,KAAKxe,IAAK,EAAAgqC,YAAYqD,KAChD5mD,KAAK0iI,qBAAqB,EAAA3qG,KAAKve,IAAK,EAAA+pC,YAAYsD,KAChD7mD,KAAK0iI,qBAAqB,EAAA3qG,KAAKte,IAAK,EAAA8pC,YAAYuD,KAChD9mD,KAAK0iI,qBAAqBrqG,EAAQkD,UAAW,EAAAgoB,YAAYwD,OACzD/mD,KAAK0iI,qBAAqB,EAAA3qG,KAAKpe,KAAM,EAAA4pC,YAAYyD,MACjDhnD,KAAK0iI,qBAAqB,EAAA3qG,KAAKne,IAAK,EAAA2pC,YAAYtH,KAChDj8C,KAAK0iI,qBAAqB,EAAA3qG,KAAKle,IAAK,EAAA0pC,YAAYnH,KAC5C/jB,EAAQkgB,WAAW,KAAev4C,KAAK0iI,qBAAqB,EAAA3qG,KAAKje,KAAM,EAAAypC,YAAY0D,MACnF5uB,EAAQkgB,WAAW,OACrBv4C,KAAK0iI,qBAAqB,EAAA3qG,KAAKyrB,QAAS,EAAAD,YAAY2D,SACpDlnD,KAAK0iI,qBAAqB,EAAA3qG,KAAK0rB,UAAW,EAAAF,YAAY4D,WAClD9uB,EAAQkgB,WAAW,QACrBv4C,KAAK0iI,qBAAqB,EAAA3qG,KAAK2rB,OAAQ,EAAAH,YAAY6D,QACnDpnD,KAAK0iI,qBAAqB,EAAA3qG,KAAK4rB,MAAO,EAAAJ,YAAY8D,OAClDrnD,KAAK0iI,qBAAqB,EAAA3qG,KAAKylB,OAAQ,EAAA+F,YAAY+D,QACnDtnD,KAAK0iI,qBAAqB,EAAA3qG,KAAK6rB,QAAS,EAAAL,YAAYgE,WAKxD,IAAIlR,EAAWr2C,KAAKq2C,SACpB,IAAK,IAAI5qC,EAAI,EAAGC,EAAIq1H,EAAcv1H,OAAQC,EAAIC,IAAKD,EAAG,CACpD,IAAIk3H,EAAgB5B,EAAct1H,GAC9Bw8E,EAAcl8E,OAAO42H,EAAc16C,aACnC26C,EAAcvsF,EAASqnC,gBAAgBuK,EAAYtnF,KAAMgiI,EAAcxrF,QAC3E,GAAKyrF,EACL,GAAID,EAAcniI,MAAQ21C,EAAY6d,gBACpC,GAAI4uE,EAAYpiI,MAAQ21C,EAAY6d,gBAAiB,CACnD,IAAI6uE,EAAgCD,EAChCC,EAAclnF,aAAaC,EAAe1uC,QAC5ClN,KAAKw4B,MACH,EAAAC,eAAeqqG,wCACf76C,EAAYxnF,MAAOoiI,EAAc9uE,eAAe9xD,MAIlD4gI,EAAclnF,aAAaC,EAAeruC,YAC1Co1H,EAAchnF,aAAaC,EAAeruC,YAE1CvN,KAAKw4B,MACH,EAAAC,eAAesqG,+DACf,EAAAp0H,MAAMC,KAAK+zH,EAAc5uE,eAAetzD,MAAOwnF,EAAYxnF,QAG/DkiI,EAAcE,cAAgBA,OAE9B7iI,KAAKw4B,MACH,EAAAC,eAAeuqG,sCACf/6C,EAAYxnF,YAGPkiI,EAAcniI,MAAQ21C,EAAY4f,sBACvC6sE,EAAYpiI,MAAQ21C,EAAY4f,oBAClC4sE,EAAcE,cAAoCD,EAElD5iI,KAAKw4B,MACH,EAAAC,eAAewqG,0CACfh7C,EAAYxnF,QAOpB,IAAK,IAAIgL,EAAI,EAAGC,EAAIs1H,EAAiBx1H,OAAQC,EAAIC,IAAKD,EAAG,CACvD,IAAIk3H,EAAgB3B,EAAiBv1H,GACjCy3H,EAAkBn3H,OAAO42H,EAAcO,iBAC3C,IAAK,IAAIlsF,EAAI,EAAGtlC,EAAIwxH,EAAgB13H,OAAQwrC,EAAItlC,IAAKslC,EAAG,CACtD,IAAImsF,EAAiBD,EAAgBlsF,GACjCosF,EAAmB/sF,EAASqnC,gBAAgBylD,EAAexiI,KAAMgiI,EAAcxrF,QACnF,GAAKisF,EACL,GAAIA,EAAiB5iI,MAAQ21C,EAAY4f,oBAAqB,CAC5D,IAAIstE,EAAyCD,EACzCE,EAAsBX,EAAcW,oBACnCA,IAAqBX,EAAcW,oBAAsBA,EAAsB,IAAIlzH,OACxFkzH,EAAoB7xH,KAAK4xH,QAEzBrjI,KAAKw4B,MACH,EAAAC,eAAe8qG,wCACfJ,EAAe1iI,QAOvB,IAAK,IAAIgL,EAAI,EAAGC,EAAIq1H,EAAcv1H,OAAQC,EAAIC,IAAKD,EAAG,CACpD,IAAIk3H,EAAgB5B,EAAct1H,GAC9Bo3H,EAAgBF,EAAcE,cAC9BA,GACF7iI,KAAKwjI,aAAab,EAAeE,GAGrC,IAAK,IAAIp3H,EAAI,EAAGC,EAAIs1H,EAAiBx1H,OAAQC,EAAIC,IAAKD,EAAG,CACvD,IAAIk3H,EAAgB3B,EAAiBv1H,GACjCo3H,EAAgBF,EAAcE,cAC9BS,EAAsBX,EAAcW,oBAIxC,GAHIT,GACF7iI,KAAKwjI,aAAab,EAAeE,GAE/BS,EACF,IAAK,IAAItsF,EAAI,EAAGtlC,EAAI4xH,EAAoB93H,OAAQwrC,EAAItlC,IAAKslC,EACvDh3C,KAAKwjI,aAAab,EAAeW,EAAoBtsF,IAM3D,CACE,IAAI0T,EAAgBryB,EAAQqyB,cACvBA,IAAeA,EAAgB,IAAIlR,KACxC,IAAIkZ,EAAS1yD,KAAK0yD,OACbhI,EAAcxP,IAAI,EAAAqI,YAAYjuC,QACjCo1C,EAAc/9C,IAAI,EAAA42C,YAAYjuC,MAC5Bo9C,EACI,EAAAz9C,aAAamiB,UACb,EAAAniB,aAAaK,OAGhBo1C,EAAcxP,IAAI,EAAAqI,YAAYhuC,QACjCm1C,EAAc/9C,IAAI,EAAA42C,YAAYhuC,MAC5Bm9C,EACI,EAAAz9C,aAAaoiB,UACb,EAAApiB,aAAaM,OAGhBm1C,EAAcxP,IAAI,EAAAqI,YAAY/tC,OACjCk1C,EAAc/9C,IAAI,EAAA42C,YAAY/tC,KAC5Bk9C,EACI,EAAAz9C,aAAaqiB,SACb,EAAAriB,aAAaO,MAGhBk1C,EAAcxP,IAAI,EAAAqI,YAAYuE,OACjC4C,EAAc/9C,IAAI,EAAA42C,YAAYuE,KAAM,EAAAvE,YAAYyE,YAE7C0C,EAAcxP,IAAI,EAAAqI,YAAYwE,QACjC2C,EAAc/9C,IAAI,EAAA42C,YAAYwE,MAAO,EAAAxE,YAAY0E,aAGnD,IAAK,IAAI3G,EAAQC,SAASmJ,GAAgBj/C,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CAC7E,IAAIoqF,EAAQ/jF,UAAUwvC,EAAM71C,IACxB9K,EAAOoJ,WAAmB2gD,EAAcvP,IAAI06C,IAEhD,GADA9pF,OAAe,MAARpL,IACFA,EAAK6K,OAAQ,CAChBxL,KAAK8gD,eAAeqX,OAAO09B,GAC3B,SAEF,IAAI4tC,EAAY9iI,EAAKoM,WAAW,GAChC,GAAI02H,GAAa,IAAeA,GAAa,GAC3CzjI,KAAK2gI,wBAAwB9qC,EAAO,EAAA99D,KAAK5e,IAAKyhC,QAAa8oF,SAAS/iI,EAAM,UACrE,CACL,IAAImgD,EAAiB9gD,KAAK8gD,eAC1B,IAAIA,EAAe5F,IAAIv6C,GAGrB,MAAM,IAAIwnD,MAAM,2BAA6BxnD,GAF7CmgD,EAAen0C,IAAIkpF,EAAO9pF,OAAO+0C,EAAe3F,IAAIx6C,OAU5D,IAAK,IAAIm2C,EAAUC,WAAW/2C,KAAKmvD,aAAc1jD,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CACtF,IAAI2jD,EAAOt9C,UAAUglC,EAAQrrC,IACzB2jD,EAAKp+C,OAAOf,YAAc,EAAA5P,WAAWgvD,YACvCrvD,KAAK2jI,kBAAkBv0E,KAMrBo0E,aAAab,EAA+BE,GAElD,IAAIe,EAAsBjB,EAAchmE,gBACxC,GAAIinE,EACF,OAAG,CACD,IAAIC,EAAsBhB,EAAclmE,gBACxC,GAAIknE,EACF,IAAK,IAAI/sF,EAAUC,WAAW6sF,GAAsB5sF,EAAI,EAAGtlC,EAAIolC,EAAQtrC,OAAQwrC,EAAItlC,IAAKslC,EAAG,CACzF,IAAI8sF,EAAahtF,EAAQE,GACzB,IACG8sF,EAAWp3H,MAAM,EAAAJ,YAAY2C,YAAc,EAAA3C,YAAYgqD,UACxDutE,EAAoB3oF,IAAI4oF,EAAWnjI,MACnC,CACA,IAAIojI,EAAah4H,OAAO83H,EAAoB1oF,IAAI2oF,EAAWnjI,OAC3D,GACEmjI,EAAWtjI,MAAQ21C,EAAYC,oBAC/B2tF,EAAWvjI,MAAQ21C,EAAYC,mBAC/B,CACA,IAAI4tF,EAAgCF,EAChCG,EAAgCF,EAC/BC,EAAWE,iBAAiBD,IAC/BjkI,KAAKgmE,aACH,EAAAvtC,eAAe0rG,4DACfH,EAAWjwE,eAAetzD,MAAOwjI,EAAWlwE,eAAetzD,OAG/DsjI,EAAWp3H,IAAI,EAAAL,YAAY6jD,SAC3B,IAAIi0E,EAAYH,EAAWG,UACtBA,IAAWH,EAAWG,UAAYA,EAAY,IAAIz8E,KACvDy8E,EAAU9tH,IAAuBwtH,GACjC,IAAIO,EAAsBJ,EAAWnhF,UACrC,GAAIuhF,EACF,IAAK,IAAIvtF,EAAUC,WAAWstF,GAAsB9pD,EAAI,EAAGC,EAAI1jC,EAAQtrC,OAAQ+uE,EAAIC,IAAKD,EAAG,CAChEzjC,EAAQyjC,GACd5tE,IAAI,EAAAL,YAAY6jD,eAGlC,GACL2zE,EAAWtjI,MAAQ21C,EAAYge,oBAC/B4vE,EAAWvjI,MAAQ21C,EAAYge,mBAC/B,CACA,IAAImwE,EAAkCR,EAClCS,EAAkCR,EACjCO,EAAaJ,iBAAiBK,IACjCvkI,KAAKgmE,aACH,EAAAvtC,eAAe0rG,4DACfG,EAAavwE,eAAetzD,MAAO8jI,EAAaxwE,eAAetzD,OAGnE8jI,EAAa53H,IAAI,EAAAL,YAAY6jD,SAC7B,IAAIq0E,EAAaD,EAAaE,gBAC9B,GAAID,EAAY,CACdA,EAAW73H,IAAI,EAAAL,YAAY6jD,SAC3B,IAAIu0E,EAAaJ,EAAaG,gBAC9B,GAAIC,EAAY,CACd,IAAIN,EAAYI,EAAWJ,UACtBA,IAAWI,EAAWJ,UAAYA,EAAY,IAAIz8E,KACvDy8E,EAAU9tH,IAAIouH,GAEhB,IAAIC,EAAsBH,EAAW1hF,UACrC,GAAI6hF,EACF,IAAK,IAAI7tF,EAAUC,WAAW4tF,GAAsBpqD,EAAI,EAAGC,EAAI1jC,EAAQtrC,OAAQ+uE,EAAIC,IAAKD,EAAG,CAChEzjC,EAAQyjC,GACd5tE,IAAI,EAAAL,YAAY6jD,UAIzC,IAAIy0E,EAAaL,EAAaM,gBAC9B,GAAmB,OAAfD,GAAwD,OAAjCN,EAAaO,gBAA0B,CAChED,EAAWj4H,IAAI,EAAAL,YAAY6jD,SAC3B,IAAI20E,EAAaR,EAAaO,gBAC9B,GAAIC,EAAY,CACd,IAAIV,EAAYQ,EAAWR,UACtBA,IAAWQ,EAAWR,UAAYA,EAAY,IAAIz8E,KACvDy8E,EAAU9tH,IAAIwuH,GAEhB,IAAIC,EAAsBH,EAAW9hF,UACrC,GAAIiiF,EACF,IAAK,IAAIjuF,EAAUC,WAAWguF,GAAsBxqD,EAAI,EAAGC,EAAI1jC,EAAQtrC,OAAQ+uE,EAAIC,IAAKD,EAAG,CAChEzjC,EAAQyjC,GACd5tE,IAAI,EAAAL,YAAY6jD,aAQjD,IAAI60E,EAAgBnC,EAAcA,cAClC,IAAKmC,EAAe,MACpBnC,EAAgBmC,GAMtB5xE,OAAOzyD,GACL,IAAIwtF,EAAWnuF,KAAK8gD,eACpB,OAAIqtC,EAASjzC,IAAIv6C,GAAcoL,OAAOoiF,EAAShzC,IAAIx6C,IAC5C,KAIDf,QAAQe,EAAcH,GAC5B,IAAI25C,EAAUn6C,KAAKozD,OAAOzyD,GAC1B,IAAKw5C,EAAS,MAAM,IAAIgO,MAAM,uCAAyCxnD,GACvE,GAAIw5C,EAAQ35C,MAAQA,EAAM,MAAM2nD,MAAM,4CAA8CxnD,GACpF,OAAOw5C,EAITyV,cAAcjvD,GACZ,OAAeX,KAAKJ,QAAQe,EAAMw1C,EAAYhpC,QAIhDuxH,aAAa/9H,GACX,IAAIg4C,EAAY34C,KAAKJ,QAAQe,EAAMw1C,EAAY6d,iBAC3CknB,EAAWl7E,KAAKq2C,SAASqgB,aAA6B/d,EAAW,MACrE,IAAKuiC,EAAU,MAAM,IAAI/yB,MAAM,mCAAqCxnD,GACpE,OAAOu6E,EAITzrB,gBAAgB9uD,EAAcG,EAA+B,MAC3D,IAAI63C,EAA+B34C,KAAKJ,QAAQe,EAAMw1C,EAAYC,oBAC9D8kC,EAAWl7E,KAAKq2C,SAASC,gBAAgBqC,EAAW73C,GACxD,IAAKo6E,EAAU,MAAM,IAAI/yB,MAAM,sCAAwCxnD,GACvE,OAAOu6E,EAIDyoD,kBAAkBv0E,GACxB,IAAI1vD,EAAU0vD,EAAK1vD,QACnB,GAAIA,EAEF,IAAK,IAAIo3C,EAAUC,WAAWr3C,GAAUs3C,EAAI,EAAGtlC,EAAIolC,EAAQtrC,OAAQwrC,EAAItlC,IAAKslC,EAAG,CAC7E,IAAImD,EAAUroC,UAAUglC,EAAQE,IAChCh3C,KAAKilI,iBAAiB9qF,GAG1B,IAAIqZ,EAAcpE,EAAKoE,YACvB,GAAIA,EACF,IAAK,IAAI/nD,EAAI,EAAGC,EAAI8nD,EAAYhoD,OAAQC,EAAIC,IAAKD,EAC/CzL,KAAK2jI,kBAAkBnwE,EAAY/nD,IAMjCw5H,iBAAiB9qF,GAEvB,OADAA,EAAQxtC,IAAI,EAAAL,YAAYmuD,eAChBtgB,EAAQ35C,MACd,KAAK21C,EAAY6d,gBAAiB,CAChC,IAAI2I,EAAmCxiB,EAASwiB,gBAChD,GAAIA,EAEF,IAAK,IAAI7lB,EAAUC,WAAW4lB,GAAkBlxD,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CACrF,IAAIwrC,EAASnlC,UAAUglC,EAAQrrC,IAC/BzL,KAAKilI,iBAAiBhuF,GAG1B,MAEF,KAAKd,EAAYge,mBAAoB,CACnC,IAAIwf,EAAuCx5B,EACvCsqF,EAAkB9wD,EAAkB8wD,gBACpCA,GAAiBzkI,KAAKilI,iBAAiBR,GAC3C,IAAII,EAAkBlxD,EAAkBkxD,gBACpCA,GAAiB7kI,KAAKilI,iBAAiBJ,GAC3C,MAEF,KAAK1uF,EAAY8e,SACjB,KAAK9e,EAAYhnC,SACjB,KAAKgnC,EAAYe,MACjB,KAAKf,EAAYpnC,MAAOhD,QAAO,GAEjC,IAAI2wD,EAAgBviB,EAAQ/zC,QAC5B,GAAIs2D,EAEF,IAAK,IAAI5lB,EAAUC,WAAW2lB,GAAgBjxD,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CACnF,IAAIwrC,EAASnlC,UAAUglC,EAAQrrC,IAC/BzL,KAAKilI,iBAAiBhuF,IAMpBwpF,mBAAmB9/H,EAAce,GACvC,IAAIy4C,EAAU,IAAIumF,EAChB//H,EACAX,KAAKw+H,WACLx+H,KAAKsgI,0BAA0B3/H,EAAM,EAAA2L,YAAYyG,QACjD6oC,EAAe5uC,SAEjBmtC,EAAQke,QAAQ32D,GAChB1B,KAAKw+H,WAAWloH,IAAI3V,EAAMw5C,GAIpBuoF,qBAAqBhhI,EAAYwjI,GACvC,IAAIjJ,EAAiBj8H,KAAKi8H,eAC1BlwH,QAAQrK,EAAK65C,sBAAwB0gF,EAAe/gF,IAAIx5C,IACxD,IAAIy4C,EAAUpuC,OAAO/L,KAAKozD,OAAO8xE,IACjCn5H,OAAOouC,EAAQ35C,MAAQ21C,EAAY6d,iBACnC,IAAImxE,EAAep5H,OAAO/L,KAAKq2C,SAASqgB,aAA6Bvc,EAAS,OAC9EgrF,EAAaC,YAAc1jI,EAC3Bu6H,EAAetvH,IAAIjL,EAAMyjI,GAI3BxE,wBAAwBhgI,EAAce,EAAY8B,GAChDuI,OAAOrK,EAAK2jI,wBACZ,IAAItkF,EAAS,IAAIukF,EACf3kI,EACAX,KAAKw+H,WACL5iF,EAAervC,KACfvM,KAAKqgI,8BAA8B1/H,EAAM,EAAA2L,YAAY+nD,MAAQ,EAAA/nD,YAAYyG,SAE3EguC,EAAOyZ,wBAAwBh3D,EAAO9B,GACtC1B,KAAKw+H,WAAWloH,IAAI3V,EAAMogD,GAIpBwkF,sBAAsB5kI,EAAce,EAAY8B,GACtDuI,OAAOrK,EAAKg4C,cACZ,IAAIqH,EAAS,IAAIukF,EACf3kI,EACAX,KAAKw+H,WACL5iF,EAAervC,KACfvM,KAAKqgI,8BAA8B1/H,EAAM,EAAA2L,YAAY+nD,MAAQ,EAAA/nD,YAAYyG,SAE3EguC,EAAO8kB,sBAAsBriE,EAAO9B,GACpC1B,KAAKw+H,WAAWloH,IAAI3V,EAAMogD,GAI5BykF,aAAa7kI,EAAcw5C,GACzB,IAAI2G,EAAiB9gD,KAAK8gD,eAC1B,GAAIA,EAAe5F,IAAIv6C,GAAO,CAC5B,IAAIolE,EAAWh6D,OAAO+0C,EAAe3F,IAAIx6C,IAMzC,GAAIolE,IAAa5rB,EAAS,CACxB,IAAIsrF,EAASC,EAAS3/D,EAAU5rB,GAChC,IAAKsrF,EAcH,OAbIhD,EAAkB18D,EAASvlE,MAC7BR,KAAKgmE,aACH,EAAAvtC,eAAesiC,uBACf5gB,EAAQ4Z,eAAetzD,MACLslE,EAAU/iE,YAAYrC,KAAKF,MAC7CE,GAGFX,KAAKw4B,MACH,EAAAC,eAAesiC,uBACf5gB,EAAQ4Z,eAAetzD,MAAOE,GAG3Bw5C,EAETA,EAAUsrF,GAId,OADA3kF,EAAen0C,IAAIhM,EAAMw5C,GAClBA,EAID0nF,kBAEN5G,EAEAC,GAEA,IAAI/rE,EAAcnvD,KAAKmvD,YACvB,OAAOA,EAAYjU,IAAI+/E,GACnBlvH,OAAOojD,EAAYhU,IAAI8/E,IACvB9rE,EAAYjU,IAAIggF,GACdnvH,OAAOojD,EAAYhU,IAAI+/E,IACvB,KAIA+G,cAENr6H,EAEAg6H,EAEAf,GAEA,OAAG,CAED,IAAI1mF,EAAUynF,EAAY+D,aAAa/9H,GACvC,GAAIuyC,EAAS,OAAOA,EAGpB,GAAI0mF,EAAc3lF,IAAI0mF,GAAc,CAClC,IAAIgE,EAAoB75H,OAAO80H,EAAc1lF,IAAIymF,IACjD,GAAIgE,EAAkB1qF,IAAItzC,GAAc,CACtC,IAAI06H,EAAev2H,OAAO65H,EAAkBzqF,IAAIvzC,IAC5Ci+H,EAA0BvD,EAAarH,YAG3C,GAAI4K,EAAyB,CAC3B,IAAIC,EAAY9lI,KAAK6hI,kBAAkBgE,EAAyB95H,OAAOu2H,EAAapH,iBACpF,IAAK4K,EAAW,OAAO,KACvBl+H,EAAc06H,EAAavH,gBAAgB94H,KAC3C2/H,EAAckE,EACd,SAKF,GADA3rF,EAAUynF,EAAY1rF,UAAUosF,EAAavH,gBAAgB94H,MACzDk4C,EAAS,OAAOA,GAGxB,MAIF,IAAIqZ,EAAcouE,EAAYpuE,YAC9B,GAAIA,EACF,IAAK,IAAI/nD,EAAI,EAAGC,EAAI8nD,EAAYhoD,OAAQC,EAAIC,IAAKD,EAAG,CAClD,IAAI0uC,EAAUn6C,KAAKiiI,cAAcr6H,EAAa4rD,EAAY/nD,GAAIo1H,GAC9D,GAAI1mF,EAAS,OAAOA,EAGxB,OAAO,KAID4rF,gBAEN//H,EAEAggI,GAEA,IAAI//H,EAAQ21C,EAAervC,KAC3B,GAAIvG,EACF,IAAK,IAAIyF,EAAI,EAAGC,EAAI1F,EAAWwF,OAAQC,EAAIC,IAAKD,EAAG,CACjD,IAAIuJ,EAAYhP,EAAWyF,GACvBjL,EAAO,EAAAL,cAAc4B,SAASiT,EAAUrU,MACxC8L,EAAOmvC,EAAeqqF,SAASzlI,GAC/BiM,IACEA,GAAQmvC,EAAe5uC,QACnBg5H,EAAgBv5H,GAAUuI,EAAUvU,MAAMuQ,OAAOG,UAMrDlL,GAASwG,EALTzM,KAAKw4B,MACH,EAAAC,eAAemhC,8BACf5kD,EAAUvU,MAAOuU,EAAUrU,KAAKF,MAAMm4B,YAK/BotG,EAAgBv5H,EAKlBxG,EAAQwG,EACjBzM,KAAKw4B,MACH,EAAAC,eAAeytG,oBACflxH,EAAUvU,OAGZwF,GAASwG,EAVTzM,KAAKw4B,MACH,EAAAC,eAAemhC,8BACf5kD,EAAUvU,MAAOuU,EAAUrU,KAAKF,MAAMm4B,aAahD,OAAO3yB,EAIDo7H,gBAENr+H,EAEAm0C,EAEA4pF,EAEAC,GAEA,IAAIrgI,EAAOqC,EAAYrC,KAAKsB,KACxBk4C,EAAU,IAAIgsF,EAChBxlI,EACAw2C,EACAn0C,EACAhD,KAAK+lI,gBAAgB/iI,EAAYgD,WAC/B41C,EAAezuC,OACfyuC,EAAe1uC,MACf0uC,EAAeruC,YAGnB,IAAK4pC,EAAO7gC,IAAI3V,EAAMw5C,GAAU,OAAO,KAGvC,IAAIh0C,EAAkBnD,EAAYmD,gBAClC,GAAIA,EAAiB,CACnB,IAAIkpF,EAAqBlpF,EAAgBqF,OACrC6jF,IAEEl1C,EAAQwB,aAAaC,EAAeruC,WACtCvN,KAAKw4B,MACH,EAAAC,eAAe2tG,8CACf,EAAAz3H,MAAMC,KACJ5L,EAAYrC,KAAKF,MACjB0F,EAAgBkpF,EAAqB,GAAG5uF,QAI5CugI,EAAiBvvH,KAAK0oC,IAMxBn3C,EAAY1B,aAAay/H,EAActvH,KAAK0oC,GAGhD,IAAIksF,EAAqBrjI,EAAYoD,QACrC,IAAK,IAAIqF,EAAI,EAAGC,EAAI26H,EAAmB76H,OAAQC,EAAIC,IAAKD,EAAG,CACzD,IAAI66H,EAAoBD,EAAmB56H,GAC3C,OAAQ66H,EAAkB9lI,MACxB,KAAK,EAAAN,SAASqT,iBACZvT,KAAKumI,gBAAkCD,EAAmBnsF,GAC1D,MAEF,KAAK,EAAAj6C,SAAS+T,kBAAmB,CAC/B,IAAIuyH,EAAuCF,EAC3C,GAAIA,EAAkB55H,MAAM,EAAAJ,YAAYyvD,IAAM,EAAAzvD,YAAY0vD,KACxDh8D,KAAKymI,mBAAmBD,EAAmBrsF,OACtC,CACL,IAAIusF,EAAS1mI,KAAK2mI,iBAAiBH,EAAmBrsF,GACvC,OAAXusF,GAAmBF,EAAkB7lI,KAAKH,MAAQ,EAAAN,SAAS+O,cAC7DkrC,EAAQ6mC,qBAAuB0lD,GAGnC,MAEF,KAAK,EAAAxmI,SAAS+R,eAAgB,MAC9B,QAASlG,QAAO,IAGpB,OAAOouC,EAIDosF,gBAENvjI,EAEAm0C,GAEA,IAEIgD,EAFAx5C,EAAOqC,EAAYrC,KAAKsB,KACxB+D,EAAahD,EAAYgD,WAEzBggI,EAAgCpqF,EAAepuC,OAInD,GAHI2pC,EAAO3qC,GAAG,EAAAF,YAAYmsD,WACxButE,GAAiBpqF,EAAe3uC,UAE9BjK,EAAYwJ,GAAG,EAAAF,YAAYgoD,SAY7B,GAXAvoD,OAAOorC,EAAO32C,MAAQ21C,EAAY4f,qBAClCiwE,GAAiBpqF,EAAevuC,KAC5BrK,EAAYwJ,GAAG,EAAAF,YAAYioD,YAC7ByxE,GAAiBpqF,EAAexuC,QAElC+sC,EAAU,IAAImrF,EACZ3kI,EACAw2C,EACAn3C,KAAK+lI,gBAAgB//H,EAAYggI,GACjChjI,IAEGm0C,EAAO7gC,IAAI3V,EAAMw5C,GAAU,YAShC,GAPApuC,QAAQ/I,EAAY0J,MAAM,EAAAJ,YAAYkvD,SAAW,EAAAlvD,YAAYyvD,IAAM,EAAAzvD,YAAY0vD,MAC/E7hB,EAAU,IAAIysF,EACZjmI,EACAw2C,EACAn0C,EACAhD,KAAK+lI,gBAAgB//H,EAAYggI,KAE9B7uF,EAAO0vF,YAAYlmI,EAAMw5C,GAAU,OAKpCwsF,iBAEN3jI,EAEAm0C,GAEA,IAAIx2C,EAAOqC,EAAYrC,KAAKsB,KACxBg7C,EAAWj6C,EAAYwJ,GAAG,EAAAF,YAAYgoD,QACtC0xE,EAAgBpqF,EAAexuC,OAASwuC,EAAepuC,OACtDxK,EAAYwJ,GAAG,EAAAF,YAAYsnD,WAC9BoyE,GAAiBpqF,EAAejuC,gBACfiuC,EAAehuC,gBACfguC,EAAe/tC,kBAE9BspC,EAAO3qC,GAAG,EAAAF,YAAYmsD,WACxButE,GAAiBpqF,EAAe3uC,UAElC,IAAIktC,EAAU,IAAI4hC,EAChBp7E,EACAw2C,EACAn0C,EACAhD,KAAK+lI,gBAAgB/iI,EAAYgD,WAAYggI,IAE/C,GAAI/oF,GAEF,GADAlxC,OAAO/I,EAAYrC,KAAKH,MAAQ,EAAAN,SAAS+O,cACpCkoC,EAAO7gC,IAAI3V,EAAMw5C,GAAU,OAAO,UAEvC,IAAKhD,EAAO0vF,YAAYlmI,EAAMw5C,GAAU,OAAO,KAGjD,OADAn6C,KAAK8mI,uBAAuB9jI,EAAYgD,WAAYm0C,EAAShD,GACtDgD,EAID2sF,uBAEN9gI,EAEA2yC,EAEAsb,GAEA,GAAIjuD,EACF,IAAK,IAAIyF,EAAI,EAAGC,EAAI1F,EAAWwF,OAAQC,EAAIC,IAAKD,EAAG,CACjD,IAAIuJ,EAA2BhP,EAAWyF,GAC1C,OAAQuJ,EAAUjH,eAChB,KAAK,EAAA5N,cAAcmN,SACnB,KAAK,EAAAnN,cAAcwN,gBACnB,KAAK,EAAAxN,cAAcyN,gBACnB,KAAK,EAAAzN,cAAc0N,iBAAkB,CACnC,IAAIhM,EAAOmT,EAAUnT,KACjBysF,EAAUzsF,EAAOA,EAAK2J,OAAS,EACnC,GAAe,GAAX8iF,EAAc,CAChB,IAAIy4C,EAA0B/xH,EAAUnT,KAAM,GAC9C,GAAIklI,EAASn9H,cAAc,EAAAxJ,YAAYgK,QAAS,CAC9C,IAAInI,EAAiC8kI,EAAUvjI,MAC3ChD,EAAOgrE,EAAa8vD,cAActmH,EAAUjH,cAAe9L,GAC/D,GAAIzB,GAAQgrE,EAAaiwD,QACvBz7H,KAAKw4B,MACH,EAAAC,eAAeuuG,2BACfD,EAAStmI,MAAOwB,OAEb,CACL,IAAImiI,EAAYnwE,EAAegzE,mBAC3B7C,EAAUlpF,IAAI16C,GAChBR,KAAKw4B,MACH,EAAAC,eAAeyuG,kCACfH,EAAStmI,QAGXk4C,EAAUwuF,aAAe3mI,EACzB4jI,EAAUz3H,IAAInM,EAAMm4C,UAIxB34C,KAAKw4B,MACH,EAAAC,eAAesiB,wBACfgsF,EAAStmI,YAIbT,KAAKw4B,MACH,EAAAC,eAAeqf,+BACf9iC,EAAUvU,MAAO,IAAK6tF,EAAQ11D,eAUpCwuG,eAENpkI,EAEAm0C,GAEA,IAAIx2C,EAAOqC,EAAYrC,KAAKsB,KAC5B,GAAIe,EAAYwJ,GAAG,EAAAF,YAAYgoD,QAAS,CACtC,IAAI+yE,EAAgBlwF,EAAO/wC,QAC3B,GAAsB,OAAlBihI,IAA0BA,EAAcnsF,IAAIv6C,GAGzC,CACL,IAAIw5C,EAAU,IAAImtF,EAAkB3mI,EAAMw2C,EAAQn0C,GAClD,OAAKm0C,EAAO7gC,IAAI3V,EAAMw5C,GACfA,EADgC,KALc,CACrD,IAAIA,EAAUpuC,OAAOs7H,EAAclsF,IAAIx6C,IACvC,GAAIw5C,EAAQ35C,MAAQ21C,EAAYge,mBAAoB,OAA0Bha,OAM3E,CACL,IAAIktF,EAAgBlwF,EAAOwlB,gBAC3B,GAAsB,OAAlB0qE,IAA0BA,EAAcnsF,IAAIv6C,GAGzC,CACL,IAAIw5C,EAAU,IAAImtF,EAAkB3mI,EAAMw2C,EAAQn0C,GAClD,OAAKm0C,EAAO0vF,YAAYlmI,EAAMw5C,GACvBA,EADwC,KALM,CACrD,IAAIA,EAAUpuC,OAAOs7H,EAAclsF,IAAIx6C,IACvC,GAAIw5C,EAAQ35C,MAAQ21C,EAAYge,mBAAoB,OAA0Bha,GAWlF,OAJAn6C,KAAKw4B,MACH,EAAAC,eAAe8uG,qBACfvkI,EAAYrC,KAAKF,MAAOE,GAEnB,KAID8lI,mBAENzjI,EAEAm0C,GAEA,IAAI7yC,EAAWtE,KAAKonI,eAAepkI,EAAam0C,GAChD,GAAK7yC,EAAL,CACA,IAAI3D,EAAOqC,EAAYrC,KAAKsB,KACxB07G,EAAW36G,EAAYwJ,GAAG,EAAAF,YAAYyvD,KAC1C,GAAI4hD,GACF,GAAIr5G,EAASmgI,gBAKX,YAJAzkI,KAAKw4B,MACH,EAAAC,eAAe8uG,qBACfvkI,EAAYrC,KAAKF,MAAOE,QAK5B,GAAI2D,EAASugI,gBAKX,YAJA7kI,KAAKw4B,MACH,EAAAC,eAAe8uG,qBACfvkI,EAAYrC,KAAKF,MAAOE,GAK9B,IAAIw5C,EAAU,IAAI4hC,GACf4hC,EAAW,EAAA36D,cAAgB,EAAAC,eAAiBtiD,EAC7C2D,EACAtB,EACAhD,KAAK+lI,gBAAgB/iI,EAAYgD,WAC/B41C,EAAexuC,OAASwuC,EAAepuC,SAGvCmwG,EACFr5G,EAASmgI,gBAAkBtqF,EAE3B71C,EAASugI,gBAAkB1qF,GAKvBmnF,eAENt+H,EAEAm0C,GAEA,IAAIx2C,EAAOqC,EAAYrC,KAAKsB,KACxBk4C,EAAU,IAAIqtF,EAChB7mI,EACAw2C,EACAn0C,EACAhD,KAAK+lI,gBAAgB/iI,EAAYgD,WAC/B41C,EAAezuC,OACfyuC,EAAexuC,OACfwuC,EAAevuC,OAGnB,IAAK8pC,EAAO7gC,IAAI3V,EAAMw5C,GAAU,OAAO,KACvC,IAAIj2C,EAASlB,EAAYkB,OACzB,IAAK,IAAIuH,EAAI,EAAGC,EAAIxH,EAAOsH,OAAQC,EAAIC,IAAKD,EAC1CzL,KAAKynI,oBAAoBvjI,EAAOuH,GAAI0uC,GAEtC,OAAOA,EAIDstF,oBAENzkI,EAEAm0C,GAEA,IAAIx2C,EAAOqC,EAAYrC,KAAKsB,KACxBk4C,EAAU,IAAIutF,EAChB/mI,EACAw2C,EACAn0C,EACAhD,KAAK+lI,gBAAgB/iI,EAAYgD,WAC/B41C,EAAervC,OAGd4qC,EAAO7gC,IAAI3V,EAAMw5C,GAIhB8mF,kBAEN16H,EAEA4wC,EAEA0pF,EAEAC,GAEA,IAAI16H,EAAUG,EAAUH,QACxB,GAAIA,EACF,IAAK,IAAIqF,EAAI,EAAGC,EAAItF,EAAQoF,OAAQC,EAAIC,IAAKD,EAC3CzL,KAAK2nI,iBAAiBvhI,EAAQqF,GAAI0rC,EAAQ5wC,EAAUkK,aAAcowH,OAE/D,CACL,IAAI+G,EACA9G,EAAkB5lF,IAAI/D,GAASywF,EAAS77H,OAAO+0H,EAAkB3lF,IAAIhE,IACpE2pF,EAAkBn0H,IAAIwqC,EAAQywF,EAAS,IAC5C,IAAI3M,EAAc10H,EAAUkK,aAC5Bm3H,EAAOn2H,KAAK,IAAI2pH,EACdH,EACAA,EAAY4M,SAAS,EAAAxkF,cACjB43E,EAAYlqH,UAAU,EAAGkqH,EAAYzvH,OAAS,EAAA63C,aAAa73C,QAC3DyvH,EAAc,EAAA53E,aAClBt3C,OAAOxF,EAAUK,SAMf+gI,iBAEN1wF,EAEA6jF,EAEAG,EAEA4F,GAEA,IAAI35H,EAAY+vC,EAAO/vC,UAAUjF,KAC7B2F,EAAcqvC,EAAO9vC,aAAalF,KAGlCk4C,EAAU2gF,EAAU6K,aAAa/9H,GACrC,GAAIuyC,EACFn6C,KAAKw4B,MACH,EAAAC,eAAeqvG,4DACf7wF,EAAO9vC,aAAa1G,MAAOmH,QAK/B,GAAoB,OAAhBqzH,EAGF,GAAI9gF,EAAU2gF,EAAU5kF,UAAUhvC,GAChC4zH,EAAUyH,aAAa36H,EAAauyC,OAG/B,CACL,IAAIytF,EACA/G,EAAc3lF,IAAI4/E,GAAY8M,EAAS77H,OAAO80H,EAAc1lF,IAAI2/E,IAC/D+F,EAAcl0H,IAAImuH,EAAW8M,EAAS,IAAIpuF,KAC/CouF,EAAOj7H,IAAI/E,EAAa,IAAIuzH,EAC1BlkF,EAAO/vC,UACP+vC,EAAO9vC,aACP,KAAM,WAKL,CACL,IAAIygI,EACA/G,EAAc3lF,IAAI4/E,GAAY8M,EAAS77H,OAAO80H,EAAc1lF,IAAI2/E,IAC/D+F,EAAcl0H,IAAImuH,EAAW8M,EAAS,IAAIpuF,KAC/CouF,EAAOj7H,IAAI/E,EAAa,IAAIuzH,EAC1BlkF,EAAO/vC,UACP+vC,EAAO9vC,aACP8zH,EACAA,EAAY4M,SAAS,EAAAxkF,cACjB43E,EAAYlqH,UAAU,EAAGkqH,EAAYzvH,OAAS,EAAA63C,aAAa73C,QAC3DyvH,EAAc,EAAA53E,gBAKhB69E,wBAEN36H,EAEA4wC,EAEA4pF,EAEAC,GAEA,IAAIh+H,EAAcuD,EAAUvD,YACxBm3C,EAAkC,KACtC,OAAQn3C,EAAYxC,MAClB,KAAK,EAAAN,SAASyS,gBACZwnC,EAAUn6C,KAAKshI,eAAgCt+H,EAAam0C,GAC5D,MAEF,KAAK,EAAAj3C,SAASyT,oBACZwmC,EAAUn6C,KAAKuhI,mBAAwCv+H,EAAam0C,GACpE,MAEF,KAAK,EAAAj3C,SAASmS,iBACZ8nC,EAAUn6C,KAAKqhI,gBAAkCr+H,EAAam0C,EAAQ4pF,EAAeC,GACrF,MAEF,KAAK,EAAA9gI,SAAS8T,qBACZmmC,EAAUn6C,KAAKwhI,oBAA0Cx+H,EAAam0C,EAAQ4pF,GAC9E,MAEF,KAAK,EAAA7gI,SAASgU,qBACZimC,EAAUn6C,KAAKyhI,oBAA0Cz+H,EAAam0C,EAAQ4pF,EAAeC,GAC7F,MAEF,QAASj1H,QAAO,GAElB,GAAIouC,EAAS,CACX,IAAIz6C,EAAUy3C,EAAOz3C,QACrB,GAAKA,GAEH,GAAIA,EAAQw7C,IAAI,WAAY,CAC1B,IAAI6qB,EAAWh6D,OAAOrM,EAAQy7C,IAAI,YAOlC,YANAn7C,KAAKgmE,aACH,EAAAvtC,eAAesiC,uBACf/3D,EAAYrC,KAAKF,MACjBslE,EAAS/iE,YAAYrC,KAAKF,MAC1B,iBARQ02C,EAAOz3C,QAAUA,EAAU,IAAI85C,IAa7C95C,EAAQiN,IAAI,UAAWwtC,IAKnBgnF,kBAEN56H,EAEA4wC,EAEAypF,EAEAC,GAEA,IAAIp5H,EAAelB,EAAUkB,aAC7B,GAAIA,EACF,IAAK,IAAIgE,EAAI,EAAGC,EAAIjE,EAAa+D,OAAQC,EAAIC,IAAKD,EAChDzL,KAAK+nI,iBACHtgI,EAAagE,GACb0rC,EACA5wC,EAAUkK,aACVmwH,EACAC,OAGC,CACL,IAAIl5H,EAAgBpB,EAAUoB,cAC1BA,GACFi5H,EAAcnvH,KAAK,IAAIopH,EACrB1jF,EACAxvC,EACA,KACApB,EAAUkK,aACVlK,EAAUkK,aAAe,EAAA4yC,gBASzB0kF,iBAEN/kI,EAEAm0C,EAEA8jF,EAEA2F,EAEAC,GAEA,IAAI3F,EAAiBD,EAAY4M,SAAS,EAAAxkF,cACtC43E,EAAYlqH,UAAU,EAAGkqH,EAAYzvH,OAAS,EAAA63C,aAAa73C,QAC3DyvH,EAAc,EAAA53E,aAGdu+E,EAAc5hI,KAAK6hI,kBAAkB5G,EAAaC,GACtD,GAAI0G,EAAa,CACf,IAAIznF,EAAUn6C,KAAKiiI,cAAcj/H,EAAY4E,YAAY3F,KAAM2/H,EAAaf,GAC5E,GAAI1mF,EAEF,YADAhD,EAAO7gC,IAAItT,EAAYrC,KAAKsB,KAAMk4C,EAASn3C,EAAYrC,MAM3DigI,EAAcnvH,KAAK,IAAIopH,EACrB1jF,EACAn0C,EAAYrC,KACZqC,EAAY4E,YACZqzH,EACAC,IAKIqG,mBAENv+H,EAEAm0C,GAEA,IAAIx2C,EAAOqC,EAAYrC,KAAKsB,KACxB+lI,EAAkBpsF,EAAepuC,OAASouC,EAAe5uC,QACzDhK,EAAYwJ,GAAG,EAAAF,YAAYmsD,SAC7BuvE,GAAmBpsF,EAAe3uC,UAElC+6H,GAAmBpsF,EAAexuC,QAC9BpK,EAAYvC,MAAMuQ,OAAOG,WAAanO,EAAYwJ,GAAG,EAAAF,YAAYyG,WACnEi1H,GAAmBpsF,EAAevuC,OAGjCrK,EAAYwJ,GAAG,EAAAF,YAAY8jD,WAC1BjZ,EAAO32C,MAAQ21C,EAAY6d,kBAC7Bg0E,GAAmBpsF,EAAezuC,QAGtC,IAAIgtC,EAAU,IAAI4hC,EAChBp7E,EACAw2C,EACAn0C,EACAhD,KAAK+lI,gBAAgB/iI,EAAYgD,WAAYgiI,IAE/C,OAAK7wF,EAAO7gC,IAAI3V,EAAMw5C,GACfA,EADgC,KAKjCqnF,oBAENx+H,EAEAm0C,EAEA4pF,GAEA,IAAIpgI,EAAOqC,EAAYrC,KAAKsB,KACxBk4C,EAAU,IAAI8tF,EAChBtnI,EACAw2C,EACAn0C,EACAhD,KAAK+lI,gBAAgB/iI,EAAYgD,WAC/B41C,EAAezuC,SAGnB,IAAKgqC,EAAO7gC,IAAI3V,EAAMw5C,GAAU,OAAO,KAGnCn3C,EAAY1B,aAAay/H,EAActvH,KAAK0oC,GAEhD,IAAIksF,EAAqBrjI,EAAYoD,QACrC,IAAK,IAAIqF,EAAI,EAAGC,EAAI26H,EAAmB76H,OAAQC,EAAIC,IAAKD,EAAG,CACzD,IAAI66H,EAAoBD,EAAmB56H,GAC3C,OAAQ66H,EAAkB9lI,MACxB,KAAK,EAAAN,SAASqT,iBACZvT,KAAKkoI,0BAA4C5B,EAAmBnsF,GACpE,MAEF,KAAK,EAAAj6C,SAAS+T,kBAAmB,CAC/B,IAAIuyH,EAAuCF,EACvCA,EAAkB55H,MAAM,EAAAJ,YAAYyvD,IAAM,EAAAzvD,YAAY0vD,KACxDh8D,KAAKymI,mBAAmBD,EAAmBrsF,GAE3Cn6C,KAAK2mI,iBAAiBH,EAAmBrsF,GAE3C,MAEF,QAASpuC,QAAO,IAGpB,OAAOouC,EAID+tF,0BAENllI,EAEAm0C,GAEA,IAAI2gB,EAAW90D,EAAYtB,KACtBo2D,IAAUA,EAAW,EAAAx3D,KAAK24G,kBAAkBj2G,EAAYrC,KAAKF,MAAM83D,QACxEv4D,KAAKymI,mBACH,EAAAnmI,KAAKw+G,wBACH97G,EAAYrC,KACZqC,EAAYgD,WACZhD,EAAYiD,MAAQ,EAAAqG,YAAYyvD,IAChC,KACA,EAAAz7D,KAAK64G,mBACH,GACArhD,EACA,MACA,EACA90D,EAAYvC,OAEd,KACAuC,EAAYvC,OAEd02C,GAEGn0C,EAAYwJ,GAAG,EAAAF,YAAYioD,WAC9Bv0D,KAAKymI,mBACH,EAAAnmI,KAAKw+G,wBACH97G,EAAYrC,KACZqC,EAAYgD,WACZhD,EAAYiD,MAAQ,EAAAqG,YAAY0vD,IAChC,KACA,EAAA17D,KAAK64G,mBACH,CACE,EAAA74G,KAAK04G,gBACH,EAAA7sG,cAAcwoG,QACd3xG,EAAYrC,KACZm3D,EACA,KACA90D,EAAYrC,KAAKF,QAGrB,EAAAH,KAAK24G,kBAAkBj2G,EAAYrC,KAAKF,MAAM83D,OAC9C,MACA,EACAv1D,EAAYvC,OAEd,KACAuC,EAAYvC,OAEd02C,GAMEsqF,oBAENz+H,EAEAm0C,EAEA4pF,EAEAC,GAEA,IAAIrgI,EAAOqC,EAAYrC,KAAKsB,KACxBi2E,EAAW,IAAIiwD,EACjBxnI,EACAw2C,EACAn0C,EACAhD,KAAK+lI,gBAAgB/iI,EAAYgD,WAAY41C,EAAezuC,SAE9D,IAAKgqC,EAAO7gC,IAAI3V,EAAMu3E,GAAW,OAAO,KACxC,IAAI/9B,EAAUpuC,OAAOorC,EAAOjB,UAAUv1C,IAClCyF,EAAUpD,EAAYoD,QAC1B,IAAK,IAAIqF,EAAI,EAAGC,EAAItF,EAAQoF,OAAQC,EAAIC,IAAKD,EAAG,CAC9C,IAAIwrC,EAAS7wC,EAAQqF,GACrB,OAAQwrC,EAAOz2C,MACb,KAAK,EAAAN,SAASmS,iBACZrS,KAAKqhI,gBAAkCpqF,EAAQihC,EAAU6oD,EAAeC,GACxE,MAEF,KAAK,EAAA9gI,SAASyS,gBACZ3S,KAAKshI,eAAgCrqF,EAAQihC,GAC7C,MAEF,KAAK,EAAAh4E,SAASyT,oBACZ3T,KAAKuhI,mBAAwCtqF,EAAQihC,GACrD,MAEF,KAAK,EAAAh4E,SAAS8T,qBACZhU,KAAKwhI,oBAA0CvqF,EAAQihC,EAAU6oD,GACjE,MAEF,KAAK,EAAA7gI,SAASgU,qBACZlU,KAAKyhI,oBAA0CxqF,EAAQihC,EAAU6oD,EAAeC,GAChF,MAEF,KAAK,EAAA9gI,SAASsU,gBACZxU,KAAK0hI,yBAA0CzqF,EAAQihC,GACvD,MAEF,KAAK,EAAAh4E,SAASwU,SACZ1U,KAAKohI,oBAAuCnqF,EAAQihC,GACpD,MAEF,QAASnsE,QAAO,IAIpB,OADImsE,GAAY/9B,GAASiuF,EAAYlwD,EAAU/9B,GACxCA,EAIDunF,yBAEN1+H,EAEAm0C,GAEA,IAAIx2C,EAAOqC,EAAYrC,KAAKsB,KACxBk4C,EAAU,IAAIumF,EAChB//H,EACAw2C,EACAn0C,EACAhD,KAAK+lI,gBAAgB/iI,EAAYgD,WAAY41C,EAAervC,OAE9D4qC,EAAO7gC,IAAI3V,EAAMw5C,GAIXinF,oBAEN76H,EAEA4wC,GAEA,IAAI1vC,EAAelB,EAAUkB,aAC7B,IAAK,IAAIgE,EAAI,EAAGC,EAAIjE,EAAa+D,OAAQC,EAAIC,IAAKD,EAAG,CACnD,IAAIzI,EAAcyE,EAAagE,GAC3B9K,EAAOqC,EAAYrC,KAAKsB,KACxB+jI,EAAgBpqF,EAAezuC,OAASyuC,EAAevuC,KACvDrK,EAAYwJ,GAAG,EAAAF,YAAYujF,WAC7Bm2C,GAAiBpqF,EAAe3uC,UAE9BjK,EAAYwJ,GAAG,EAAAF,YAAY+nD,SAC7B2xE,GAAiBpqF,EAAexuC,QAElC,IAAI+sC,EAAU,IAAImrF,EAChB3kI,EACAw2C,EACAn3C,KAAK+lI,gBAAgB/iI,EAAYgD,WAAYggI,GAC7ChjI,GAEGm0C,EAAO7gC,IAAI3V,EAAMw5C,KA1nE5B,YA2pEA,SAAYhE,GAEV,uBAEA,qBAEA,mBAEA,6BAEA,+CAEA,2BAEA,yCAEA,qBAEA,iDAEA,6BAEA,0CAEA,sBAEA,gDAEA,4BAEA,8BAEA,oBAEA,wCAEA,wCApCF,CAAYA,EAAA,EAAAA,cAAA,EAAAA,YAAW,KAwCvB,SAAYyF,GAEV,mBAEA,uBAEA,yCAEA,yCAEA,2CAEA,8BAEA,sBAEA,wBAEA,6BAEA,2BAEA,qBAEA,0BAxBF,CAAYA,EAAA,EAAAA,iBAAA,EAAAA,eAAc,KA2B1B,SAAiBA,GAGC,EAAAqqF,SAAhB,SAAyBzlI,GACvB,OAAQA,GACN,KAAK,EAAAL,cAAcgN,OAAQ,OAAOyuC,EAAezuC,OACjD,KAAK,EAAAhN,cAAcmN,SACnB,KAAK,EAAAnN,cAAcwN,gBAAiB,OAAOiuC,EAAejuC,gBAC1D,KAAK,EAAAxN,cAAcyN,gBAAiB,OAAOguC,EAAehuC,gBAC1D,KAAK,EAAAzN,cAAc0N,iBAAkB,OAAO+tC,EAAe/tC,iBAC3D,KAAK,EAAA1N,cAAcoN,UAAW,OAAOquC,EAAeruC,UACpD,KAAK,EAAApN,cAAc+M,MAAO,OAAO0uC,EAAe1uC,MAChD,KAAK,EAAA/M,cAAciN,OAAQ,OAAOwuC,EAAexuC,OACjD,KAAK,EAAAjN,cAAc8M,SAAU,OAAO2uC,EAAe3uC,SACnD,KAAK,EAAA9M,cAAc6M,QAAS,OAAO4uC,EAAe5uC,QAClD,KAAK,EAAA7M,cAAckN,KAAM,OAAOuuC,EAAevuC,KAC/C,KAAK,EAAAlN,cAAcqN,OAAQ,OAAOouC,EAAepuC,OACjD,QAAS,OAAOouC,EAAervC,OAjBrC,CAAiBqvC,EAAA,EAAAA,iBAAA,EAAAA,eAAc,KAuB/B,MAAsBysF,EAcpB,YAES7nI,EAEAG,EAEAk1C,EAEAL,EAEP2B,GARO,KAAA32C,KAAAA,EAEA,KAAAG,KAAAA,EAEA,KAAAk1C,aAAAA,EAEA,KAAAL,QAAAA,EAjBT,KAAAvvC,MAAqB,EAAAqG,YAAYC,KAEjC,KAAAi0H,eAAiC5kF,EAAervC,KAEhD,KAAAnG,QAA8C,KAE9C,KAAAkiI,WAAoC,KAelCtoI,KAAKw1C,QAAUA,EACfx1C,KAAKW,KAAOA,EACZX,KAAK61C,aAAeA,EAChBsB,EACFn3C,KAAKm3C,OAASA,GAEdprC,OAAO/L,KAAKQ,MAAQ21C,EAAYoyF,MAChCvoI,KAAKm3C,OAASn3C,MAKdovD,WAEF,IADA,IAAIzN,EAAmB3hD,OAGrB,IADA2hD,EAAUA,EAAQxK,QACN32C,MAAQ21C,EAAYoyF,KAAM,OAAa5mF,EAKvDn1C,GAAGC,GAA2B,OAAQzM,KAAKiG,MAAQwG,IAASA,EAE5DC,MAAMzG,GAA4B,OAA+B,IAAvBjG,KAAKiG,MAAQA,GAEvD0G,IAAIF,GAA2BzM,KAAKiG,OAASwG,EAE7CiyC,MAAMjyC,GAA0BzM,KAAKiG,QAAUwG,EAE/CkvC,aAAalvC,GAA8B,OAAQzM,KAAKwgI,eAAiB/zH,IAASA,EAGlFypC,UAAUv1C,GACR,IAAIyF,EAAUpG,KAAKoG,QACnB,OAAIA,GAAWA,EAAQ80C,IAAIv6C,GAAcoL,OAAO3F,EAAQ+0C,IAAIx6C,IACrD,KAITyyD,OAAOzyD,EAAcgD,GAAe,GAClC,OAAO3D,KAAKm3C,OAAOic,OAAOzyD,EAAMgD,GAIlC2S,IAAI3V,EAAcw5C,EAA0BquF,EAAuD,MACjG,IAAIC,EAAsBtuF,EAAQn3C,YAC9BoD,EAAUpG,KAAKoG,QACnB,GAAKA,GACA,GAAIA,EAAQ80C,IAAIv6C,GAAO,CAC1B,IAAIolE,EAAWh6D,OAAO3F,EAAQ+0C,IAAIx6C,IAClC,GAAIolE,EAAS5uB,SAAWn3C,UAEjB,CACL,IAAIylI,EAASC,EAAS3/D,EAAU5rB,GAChC,IAAIsrF,EAEG,CACL,IAAIiD,EAAqBF,GAErBruF,EAAQ4Z,eAcZ,OAbI0uE,EAAkB18D,EAASvlE,MAC7BR,KAAKw1C,QAAQwwB,aACX,EAAAvtC,eAAesiC,uBACf2tE,EAAmBjoI,MACDslE,EAAUhS,eAAetzD,MAC3CioI,EAAmBzmI,MAGrBjC,KAAKw1C,QAAQhd,MACX,EAAAC,eAAesiC,uBACf2tE,EAAmBjoI,MAAOioI,EAAmBzmI,OAG1C,EAlBPk4C,EAAUsrF,SARFzlI,KAAKoG,QAAUA,EAAU,IAAIozC,IA8B3CpzC,EAAQuG,IAAIhM,EAAMw5C,GAClB,IAAI3E,EAAUx1C,KAAKw1C,QAMnB,OALI2E,EAAQ35C,MAAQ21C,EAAYC,oBAA2C+D,EAASwuF,UAElFnzF,EAAQsL,eAAen0C,IAAIwtC,EAAQtE,aAAcsE,GACjD3E,EAAQwmF,sBAAsBrvH,IAAI87H,EAAqBtuF,KAElD,EAILyuF,eACF,OAAQ5oI,KAAK0M,MAAM,EAAAJ,YAAYgqD,QAAU,EAAAhqD,YAAYk1E,WAInDqnD,yBACF,OAAO7oI,KAAK4oI,WAAa5oI,KAAKwM,GAAG,EAAAF,YAAYwjF,QAI/Co0C,iBAAiBn7C,GACf,GAAI/oF,KAAK4oI,UAAY7/C,EAAM6/C,SAAU,OAAO,EAC5C,MAAME,EAAM,EAAAx8H,YAAYgqD,QAAU,EAAAhqD,YAAYk1E,UAC9C,OAAQxhF,KAAKiG,MAAQ6iI,KAAS//C,EAAM9iF,MAAQ6iI,GAI9ClwG,WACE,OAAO54B,KAAK61C,aAAe,UAAY71C,KAAKQ,KAAKo4B,YApIrD,YAyIA,IAAImwG,EAAmB,IAAIphF,IAG3B,SAAgB86E,EAAkBjiI,GAChC,OAAOuoI,EAAiB7tF,IAAI16C,GAD9B,sBAKA,MAAsBwoI,UAAwBX,EAG5C,YAEE7nI,EAEAG,EAEAk1C,EAEAL,EAEA2B,EAEOn0C,GAEPiI,MAAMzK,EAAMG,EAAMk1C,EAAcL,EAAS2B,GAFlC,KAAAn0C,YAAAA,EAGP+lI,EAAiBzyH,IAAI9V,GAOrBR,KAAKgD,YAAcA,EACnBhD,KAAKiG,MAAQjD,EAAYiD,MAIvB+vC,0BACF,OAAOh2C,KAAKgD,YAAYvC,MAAMuQ,OAAOG,UAInC4iD,qBACF,OAAO/zD,KAAKgD,YAAYrC,KAItB0kF,kCACF,IAAIriF,EAAchD,KAAKgD,YACnB+wD,EAAiB/wD,EAAYrC,KACjC,GAAIqC,EAAYxC,MAAQ,EAAAN,SAASyT,qBAAuB3Q,EAAYxC,MAAQ,EAAAN,SAAS+T,kBAAmB,CACtG,IAAIioE,EAAsCl5E,EAAaqF,UACvD,OAAO,EAAAsG,MAAMC,KAAKmlD,EAAetzD,MAAOy7E,EAAcz7E,OAExD,OAAOszD,EAAetzD,MAIpBq5D,qBACF,OAAO95D,KAAKgD,YAAYgD,WAI1BijI,qBAAqBtzF,GACnB,IAAI51C,EAAwBC,KACxBQ,EAAOT,EAAKS,KAChB,GAAIA,GAAQm1C,EAAKn1C,KACf,OAAQA,GACN,KAAK21C,EAAYhnC,SACf,OAAkBpP,EAAMsI,UAAUyxC,eAA0BnE,EAAMttC,WAA0B,GAE9F,KAAK8tC,EAAY8e,SAAU,CACzB,IAAIi0E,EAAyBnpI,EACzBwkI,EAAyB5uF,EACzBwzF,EAAaD,EAAah0E,eAC1BsvE,EAAaD,EAAarvE,eAC9B,GAAIi0E,GACF,IAAK3E,IAAe2E,EAAW9gI,UAAUyxC,eAAe0qF,EAAWn8H,WAAW,GAC5E,OAAO,OAEJ,GAAIm8H,EACT,OAAO,EAET,IAAI4E,EAAaF,EAAa/zE,eAC1ByvE,EAAaL,EAAapvE,eAC9B,GAAIi0E,GACF,IAAKxE,IAAewE,EAAW/gI,UAAUyxC,eAAe8qF,EAAWv8H,WAAW,GAC5E,OAAO,OAEJ,GAAIu8H,EACT,OAAO,EAET,OAAO,GAIb,OAAO,GAzFX,oBA8FA,IAAIyE,EAAgB,IAAI1hF,IAGxB,0BAA+BnnD,GAC7B,OAAO6oI,EAAcnuF,IAAI16C,IAI3B,MAAsB8oI,UAAqBN,EAKzCzoI,YAEEC,EAEAG,EAEAk1C,EAEAL,EAEA2B,EAEAn0C,GAEAiI,MAAMzK,EAAMG,EAAMk1C,EAAcL,EAAS2B,EAAQn0C,GAhBnD,KAAAtB,KAAa,EAAAq2B,KAAKsH,KAiBhBgqG,EAAc/yH,IAAI9V,GAIpB63D,QAAQ32D,GACNqK,QAAQ/L,KAAKwM,GAAG,EAAAF,YAAY0rD,WAC5Bh4D,KAAK0B,KAAOA,EACZ1B,KAAK2M,IAAI,EAAAL,YAAY0rD,WA3BzB,iBAgCA,MAAaymE,UAAa4J,EAYxB9nI,YAEEi1C,EAEOxkC,GAEP/F,MACEkrC,EAAYoyF,KACZv3H,EAAOd,eACPc,EAAOP,aACP+kC,EACA,MAPK,KAAAxkC,OAAAA,EAbT,KAAAtR,QAA8C,KAE9C,KAAA8zD,YAA6B,KAI7B,KAAA+1E,gBAAoC,IAAIn5H,MAgBtCpQ,KAAKgR,OAASA,EACdjF,QAAQypC,EAAQ2Z,YAAYjU,IAAIl7C,KAAK61C,eACrCL,EAAQ2Z,YAAYxiD,IAAI3M,KAAK61C,aAAc71C,MAC3C,IAAIm3D,EAAgBn3D,KAAKw1C,QAAQgZ,mBAC/B,SAAWxuD,KAAK61C,aAChB,IAAI,EAAA4Y,UAAUjZ,EAAS,KAAM,EAAAzd,KAAKsH,MAClCr/B,MAEFm3D,EAActhB,aAAeshB,EAAcx2D,KAC3CX,KAAKm3D,cAAgBA,EAIvB7gD,IAAI3V,EAAcw5C,EAA0BquF,EAAuD,MAIjG,OAHIruF,EAAQwB,aAAaC,EAAezuC,UACtCgtC,EAAUn6C,KAAKw1C,QAAQgwF,aAAa7kI,EAAMw5C,MAEvClvC,MAAMqL,IAAI3V,EAAMw5C,EAASquF,MAC9BruF,EAAUpuC,OAAO/L,KAAKk2C,UAAUv1C,KACpB6L,GAAG,EAAAF,YAAYyG,UAAYy1H,GACrCxoI,KAAKuiI,aACHpoF,EAAQx5C,KACRw5C,IAGG,GAITjE,UAAUv1C,GACR,IAAIw5C,EAAUlvC,MAAMirC,UAAUv1C,GAC9B,GAAIw5C,EAAS,OAAOA,EACpB,IAAIqZ,EAAcxzD,KAAKwzD,YACvB,GAAIA,EACF,IAAK,IAAI/nD,EAAI,EAAGC,EAAI8nD,EAAYhoD,OAAQC,EAAIC,IAAKD,EAC/C,GAAI0uC,EAAUqZ,EAAY/nD,GAAGyqC,UAAUv1C,GAAO,OAAOw5C,EAGzD,OAAO,KAITiZ,OAAOzyD,EAAcgD,GAAe,GAClC,IAAIw2C,EAAUn6C,KAAKk2C,UAAUv1C,GAC7B,OAAIw5C,GACGn6C,KAAKw1C,QAAQ4d,OAAOzyD,GAI7B4hI,aAAa5hI,EAAcw5C,GACzB,IAAIz6C,EAAUM,KAAKN,QACdA,IAASM,KAAKN,QAAUA,EAAU,IAAI85C,KAC3C95C,EAAQiN,IAAIhM,EAAMw5C,GACdn6C,KAAKgR,OAAOf,YAAc,EAAA5P,WAAWgR,eAAerR,KAAKw1C,QAAQgwF,aAAa7kI,EAAMw5C,GAGxF,IAAI,IAAI1uC,EAAI,EAAGA,EAAIzL,KAAKupI,gBAAgB/9H,OAAQC,IAAK,CAC1CzL,KAAKupI,gBAAgB99H,GAC3B6K,IAAI3V,EAAMw5C,IAKjB2nF,iBAAiB1yE,GACf,IAAIoE,EAAcxzD,KAAKwzD,YACvB,GAAKA,GACA,GAAIA,EAAY2jB,SAAS/nB,GAAO,YADnBpvD,KAAKwzD,YAAcA,EAAc,GAEnDA,EAAY/hD,KAAK29C,GAInBu2E,aAAahlI,GACX,IAAIjB,EAAUM,KAAKN,QACnB,GAAgB,OAAZA,GAAoBA,EAAQw7C,IAAIv6C,GAAO,OAAOoL,OAAOrM,EAAQy7C,IAAIx6C,IACrE,IAAI6yD,EAAcxzD,KAAKwzD,YACvB,GAAIA,EACF,IAAK,IAAI/nD,EAAI,EAAGC,EAAI8nD,EAAYhoD,OAAQC,EAAIC,IAAKD,EAAG,CAClD,IAAI0uC,EAAUqZ,EAAY/nD,GAAGk6H,aAAahlI,GAC1C,GAAIw5C,EAAS,OAAOA,EAGxB,OAAO,KAITgoF,iBACExhI,EACAw2C,EACA4jF,GAEA,IAAI/3H,EAAchD,KAAKw1C,QAAQ+qF,+BAA+B5/H,GAC9DqC,EAAYrC,KAAOo6H,EACnB,IAAIyO,EAAK,IAAIrB,EAAUxnI,EAAMw2C,EAAQn0C,GAOrC,OANAwmI,EAAG78H,IAAI,EAAAL,YAAY8pD,QACnBp2D,KAAKypI,uBAAuBD,GAI5BxpI,KAAKupI,gBAAgB93H,KAAK+3H,GACnBA,EAIDC,uBAAuBD,GAC7B,IAAI9pI,EAAUM,KAAKN,QACnB,GAAIA,EAEF,IAAK,IAAI4hD,EAAQC,SAAS7hD,GAAU+L,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CACvE,IAAI4qD,EAAavkD,UAAUwvC,EAAM71C,IAC7BwrC,EAASlrC,OAAOrM,EAAQy7C,IAAIkb,IAChCmzE,EAAGlzH,IAAI+/C,EAAYpf,GAGvB,IAAIuc,EAAcxzD,KAAKwzD,YACvB,GAAIA,EACF,IAAK,IAAI/nD,EAAI,EAAGC,EAAI8nD,EAAYhoD,OAAQC,EAAIC,IAAKD,EAC/C+nD,EAAY/nD,GAAGg+H,uBAAuBD,IA7I9C,SAoJA,MAAa9I,UAAuB4I,EAGlC/oI,YAEEI,EAEAw2C,EAEAn0C,EAEAw9H,EAAiC5kF,EAAervC,MAEhDtB,MACEkrC,EAAY8f,eACZt1D,EACAylF,EAAmBzlF,EAAMw2C,GAAQ,GACjCA,EAAO3B,QACP2B,EACAn0C,GAEFhD,KAAKwgI,eAAiBA,EAIpBr1H,yBACF,OAAyBnL,KAAKgD,YAAakD,eAIzC4xD,eACF,OAAyB93D,KAAKgD,YAAatB,MA/B/C,mBAoCA,MAAaymI,UAAkBa,EAG7BzoI,YAEEI,EAEAw2C,EAEAn0C,EAEAw9H,EAAiC5kF,EAAervC,MAEhDtB,MACEkrC,EAAY6f,UACZr1D,EACAylF,EAAmBzlF,EAAMw2C,GAAQ,GACjCA,EAAO3B,QACP2B,EACAn0C,GAEFhD,KAAKwgI,eAAiBA,EAIxBptE,OAAOzyD,EAAcgD,GAAe,GAClC,IAAIszC,EAASj3C,KAAKk2C,UAAUv1C,GAC5B,OAAIs2C,GACGhsC,MAAMmoD,OAAOzyD,EAAMgD,IA5B9B,cAiCA,MAAa6jI,UAAa8B,EAGxB/oI,YAEEI,EAEAw2C,EAEAn0C,EAEAw9H,EAAiC5kF,EAAervC,MAEhDtB,MACEkrC,EAAY2f,KACZn1D,EACAylF,EAAmBzlF,EAAMw2C,GAAQ,GACjCA,EAAO3B,QACP2B,EACAn0C,GAEFhD,KAAKwgI,eAAiBA,EACtBxgI,KAAKq4D,QAAQ,EAAAtgC,KAAK5e,KAIpBi6C,OAAOzyD,EAAcgD,GAAe,GAClC,IAAIszC,EAASj3C,KAAKk2C,UAAUv1C,GAC5B,OAAIs2C,GACGhsC,MAAMmoD,OAAOzyD,EAAMgD,IA7B9B,SAkCA,SAAkB+lI,GAEhB,mBAEA,yBAEA,qBANF,CAAkB,EAAAA,oBAAA,EAAAA,kBAAiB,KAUnC,MAAsBC,UAA4BL,EAUhD,YAEE9oI,EAEAG,EAEAw2C,EAEAn0C,EAAgDm0C,EAAO3B,QAAQ6qF,8BAA8B1/H,IAE7FsK,MACEzK,EACAG,EACAylF,EAAmBzlF,EAAMw2C,EAAQn0C,EAAYwJ,GAAG,EAAAF,YAAY8jD,WAC5DjZ,EAAO3B,QACP2B,EACAn0C,GAvBJ,KAAAy2D,kBAAiB,EAEjB,KAAAxY,qBAA4B2lB,SAE5B,KAAAlN,mBAA0B,EAqBxB15D,KAAKiG,MAAQjD,EAAYiD,MAIvB6xD,eACF,OAA0C93D,KAAKgD,YAAatB,KAI1Dq2D,sBACF,OAA0C/3D,KAAKgD,YAAarB,YAI9D64D,wBAAwBh3D,EAAY9B,GAClCqK,OAAOrK,EAAK2jI,wBACZrlI,KAAK0B,KAAOA,EACZ1B,KAAKy5D,kBAAoB,EACzBz5D,KAAKihD,qBAAuBz9C,EAC5BxD,KAAK2M,IAAI,EAAAL,YAAY+nD,MAAQ,EAAA/nD,YAAY00C,QAAU,EAAA10C,YAAY0rD,UAIjE6N,sBAAsBriE,EAAY9B,GAChCqK,OAAOrK,EAAKg4C,cACZ15C,KAAK0B,KAAOA,EACZ1B,KAAKy5D,kBAAoB,EACzBz5D,KAAK05D,mBAAqBl2D,EAC1BxD,KAAK2M,IAAI,EAAAL,YAAY+nD,MAAQ,EAAA/nD,YAAY00C,QAAU,EAAA10C,YAAY0rD,WAxDnE,wBA6DA,MAAa0vE,UAAkBiC,EAG7BppI,YAEEI,EAEAw2C,EAEAn0C,EAEAw9H,EAAiC5kF,EAAervC,MAEhDtB,MACEkrC,EAAYue,UACZ/zD,EACAw2C,EACAn0C,GAOJ,KAAA4xD,aAAoB,EALlB50D,KAAKwgI,eAAiBA,EACtBxgI,KAAKq4D,QAAQ,EAAAtgC,KAAK5e,KAOhBihD,gBACF,OAA8Bp6D,KAAKgD,YAAarB,aA5BpD,cAiCA,MAAa2jI,UAAeqE,EAG1BppI,YAEEI,EAEAw2C,EAEAqpF,EAEAx9H,EAAgDm0C,EAAO3B,QAAQ6qF,8BAA8B1/H,IAE7FsK,MACEkrC,EAAYhpC,OACZxM,EACAw2C,EACAn0C,GAEFhD,KAAKwgI,eAAiBA,GAnB1B,WAwBA,kBAEEjgI,YAESI,EAEAe,EAEAC,EAAiC,MAJjC,KAAAhB,KAAAA,EAEA,KAAAe,KAAAA,EAEA,KAAAC,YAAAA,IAKX,MAAagkE,UAAcgkE,EAMzBppI,YAEEI,EAEOg5B,EAEPj4B,EAEAy1C,EAEAn0C,EAAgDm0C,EAAO3B,QAAQ6qF,8BAA8B1/H,IAE7FsK,MACEkrC,EAAYq9B,MACZ7yE,EACAw2C,EACAn0C,GAZK,KAAA22B,MAAAA,EAcP35B,KAAK6nF,aAAelnF,EACpBX,KAAK25B,MAAQA,EACb5tB,OAAOrK,GAAQ,EAAAq2B,KAAKsH,MACpBr/B,KAAKq4D,QAAQ32D,GAIf6vF,iBAAiB5wF,GACfX,KAAKW,KAAOA,EACZX,KAAK61C,aAAeuwC,EAAmBzlF,EAAMX,KAAKm3C,QAAQ,GAI5Dk6C,qBACE,IAAI1wF,EAAOX,KAAK6nF,aAChB7nF,KAAKW,KAAOA,EACZX,KAAK61C,aAAeuwC,EAAmBzlF,EAAMX,KAAKm3C,QAAQ,IAxC9D,UA6CA,MAAa4kC,UAA0BitD,EAarCzoI,YAEEI,EAEAw2C,EAEAn0C,EAEAw9H,EAAiC5kF,EAAervC,MAEhDtB,MACEkrC,EAAYC,mBACZz1C,EACAylF,EAAmBzlF,EAAMw2C,EAAQn0C,EAAYwJ,GAAG,EAAAF,YAAY8jD,WAC5DjZ,EAAO3B,QACP2B,EACAn0C,GA1BJ,KAAAmkI,aAA6B37D,EAAaiwD,QAE1C,KAAA34E,UAAyC,KAEzC,KAAAshF,UAA2C,KAGnC,KAAAwF,gBAAuD,KAqB7D5pI,KAAKwgI,eAAiBA,EAIpBr1H,yBACF,OAA6BnL,KAAKgD,YAAakD,eAI7C2F,uBACF,OAA6B7L,KAAKgD,YAAaqF,UAI7C4yD,eACF,OAA6Bj7D,KAAKgD,YAAasF,KAI7CC,gBACF,OAA6BvI,KAAKgD,YAAauF,UAI7CogI,cACF,IAAIxxF,EAASn3C,KAAKm3C,OACd0yF,EAAa1yF,EAAO32C,KAExB,OADIqpI,GAAc1zF,EAAYge,qBAAoB01E,EAAa1yF,EAAOA,OAAO32C,MACtEqpI,GAAc1zF,EAAYpnC,OAAS86H,GAAc1zF,EAAYslB,UAItEquE,QAAQhrF,GACN/yC,OAAO/L,KAAKwM,GAAG,EAAAF,YAAY8jD,WAC3BrkD,QAAQ/L,KAAK2oI,SACb,IAAIiB,EAAkB5pI,KAAK4pI,gBAC3B,GAAKA,GACA,GAAIA,EAAgB1uF,IAAI4D,GAAgB,OAAO/yC,OAAO69H,EAAgBzuF,IAAI2D,SADzD9+C,KAAK4pI,gBAAkBA,EAAkB,IAAIpwF,IAEnE,IAAIx2C,EAAchD,KAAKgD,YACvB+I,OAAO/I,EAAYxC,MAAQ,EAAAN,SAAS+T,mBACpC,IAAI81H,EAAQ,IAAIhuD,EACd/7E,KAAKW,KACLm+C,EACmB97C,EACnBhD,KAAKwgI,gBAOP,OALAuJ,EAAM9jI,MAAQjG,KAAKiG,MACnB8jI,EAAM5C,aAAennI,KAAKmnI,aAC1B4C,EAAM3F,UAAYpkI,KAAKokI,UAEvBwF,EAAgBj9H,IAAImyC,EAAeirF,GAC5BA,EAITC,oBAAoBC,GAClB,IAAInnF,EAAY9iD,KAAK8iD,UACrB,OAAkB,OAAdA,GAAsBA,EAAU5H,IAAI+uF,GAAqBl+H,OAAO+2C,EAAU3H,IAAI8uF,IAC3E,KAITjoD,oBAAoBioD,EAAqB30F,GACvC,IAAIwN,EAAY9iD,KAAK8iD,UAChBA,EACA/2C,QAAQ+2C,EAAU5H,IAAI+uF,IADXjqI,KAAK8iD,UAAYA,EAAY,IAAItJ,IAEjDsJ,EAAUn2C,IAAIs9H,EAAa30F,IAjG/B,sBAsGA,MAAapf,UAAiBozG,EAqC5B/oI,YAEE2pI,EAEAvxF,EAEA73C,EAEAuH,EAEAg9D,EAAmD,MAEnDp6D,MACEkrC,EAAYhnC,SACZ+6H,EACA9jD,EAAmB8jD,EAAwBvxF,EAAUxB,OAAQwB,EAAUnsC,GAAG,EAAAF,YAAY8jD,WACtFzX,EAAUnD,QACVmD,EAAUxB,OACVwB,EAAU31C,aAhDd,KAAA4uF,aAAkC,IAAIp4C,IAEtC,KAAAie,cAAyB,GAEzB,KAAAzE,iBAA2B,GAQ3B,KAAA8xB,eAA0B,GAE1B,KAAAzL,IAAmB,EAEnB,KAAAjB,YAA+B,KAE/B,KAAAgB,YAA+B,KAE/B,KAAApa,cAAsC,KAKtC,KAAAqxB,aAAoB,EAEpB,KAAArU,gBAAuB,EAkIvB,KAAA0U,SAA2B,KAC3B,KAAAC,SAA2B,KAC3B,KAAAC,SAA2B,KAC3B,KAAAC,SAA2B,KAC3B,KAAAC,UAA4B,KAC5B,KAAAC,aAA+B,KAC/B,KAAAC,eAAiC,KACjC,KAAAC,YAA8B,KAC9B,KAAAC,WAA6B,KAC7B,KAAAC,YAA8B,KAC9B,KAAAC,aAA+B,KAG/B,KAAAc,YAAmB,EACnB,KAAAE,WAA2B,KAC3B,KAAA5wB,WAA4B,KA1H1BxhE,KAAK24C,UAAYA,EACjB34C,KAAKc,cAAgBA,EACrBd,KAAKqI,UAAYA,EACjBrI,KAAKiG,MAAQ0yC,EAAU1yC,MAAQ,EAAAqG,YAAY0rD,SAC3Ch4D,KAAKwgI,eAAiB7nF,EAAU6nF,eAChCxgI,KAAKqlE,wBAA0BA,EAC/BrlE,KAAKk4E,SAAWl4E,KAChB,IAAIw1C,EAAUmD,EAAUnD,QAExB,GADAx1C,KAAK0B,KAAO2G,EAAU3G,MACjBi3C,EAAUnsC,GAAG,EAAAF,YAAYmsD,SAAU,CACtC,IAAI0c,EAAa,EACbz+B,EAAWruC,EAAUquC,SACzB,GAAIA,EAAU,CACZ,IAAIgvB,EAAQ,IAAIC,EACd,EAAApiB,YAAYsB,MACZswB,IACAz+B,EACA12C,MAEFA,KAAK4xF,aAAajlF,IAAI,EAAA42C,YAAYsB,MAAO6gB,GACzC1lE,KAAKy3D,cAAciO,EAAM/rC,OAAS+rC,EAEpC,IAAI/uB,EAAiBtuC,EAAUsuC,eAC/B,IAAK,IAAIlrC,EAAI,EAAGC,EAAIirC,EAAenrC,OAAQC,EAAIC,IAAKD,EAAG,CACrD,IAAI0+H,EAAgBxzF,EAAelrC,GAC/B2+H,EAAgBpqI,KAAK83E,iBAAiBrsE,GACtCi6D,EAAQ,IAAIC,EACdykE,EACAj1D,IACAg1D,EACAnqI,MAEFA,KAAK4xF,aAAajlF,IAAIy9H,EAAe1kE,GACrC1lE,KAAKy3D,cAAciO,EAAM/rC,OAAS+rC,GAGtC1lE,KAAKq5B,KAAO,EAAAspC,KAAK0nE,aAAarqI,MAC9BsqI,EAAwB90F,EAASx1C,MAInC83E,iBAAiBn+C,GACf,IAAI14B,EAAmCjB,KAAKgD,YAAaqF,UAAUpH,WACnE,OAAOA,EAAWuK,OAASmuB,EACvB14B,EAAW04B,GAAOh5B,KAAKsB,KACvBsoI,EAAwB5wG,GAI9BwgD,sBACE,IAAIhjC,EAASn3C,KAAKm3C,OAElB,OADIA,EAAO32C,MAAQ21C,EAAY8e,WAAU9d,EAASA,EAAOA,QACrDA,EAAO32C,MAAQ21C,EAAYpnC,OAASooC,EAAO32C,MAAQ21C,EAAYslB,UACnDtkB,EAET,KAIT6hC,QAAQwxD,GACN,IAAIryD,EAAO,IAAIjiD,EACbl2B,KAAKk4E,SAASv3E,KAAO,EAAA2iD,eAAiBknF,EACtCxqI,KAAK24C,UACL34C,KAAKc,cACLd,KAAKqI,UAAUuL,QACf5T,KAAKqlE,yBAIP,OAFA8S,EAAKD,SAAWl4E,KAAKk4E,SACrBC,EAAKxrE,IAAI3M,KAAKiG,OAAS,EAAAqG,YAAYyD,SAAW,EAAAzD,YAAYyyD,MACnDoZ,EAIT5R,SAAS7kE,EAAYf,EAAsB,KAAMqC,EAA0C,MAEzF,IAAImyE,EAAan1E,KAAKqI,UAAUsuC,eAAenrC,OAASxL,KAAKgzD,iBAAiBxnD,OAC1ExL,KAAKwM,GAAG,EAAAF,YAAY8jD,aAAa+kB,EACrC,IAAIjuE,EAAqB,OAATvG,EACZA,EACA,OAASw0E,EAAWv8C,WACnB51B,IAAaA,EAAchD,KAAKw1C,QAAQ6qF,8BAA8Bn5H,IAC3E,IAAIw+D,EAAQ,IAAIC,EACdz+D,EACAiuE,EACAzzE,EACA1B,KACAgD,GAEF,GAAIrC,EAAM,CACR,GAAIX,KAAK4xF,aAAa12C,IAAIv6C,GAAO,MAAM,IAAIwnD,MAAM,wBACjDnoD,KAAK4xF,aAAajlF,IAAIhM,EAAM+kE,GAI9B,OAFA1lE,KAAKy3D,cAAciO,EAAM/rC,OAAS+rC,EAClC1lE,KAAKgzD,iBAAiBvhD,KAAK/P,GACpBgkE,EAITtS,OAAOzyD,EAAcgD,GAAe,GAClC,IAAKA,EAAQ,CACX,IAAI6zD,EAASx3D,KAAK4xF,aAClB,GAAIp6B,EAAOtc,IAAIv6C,GAAO,OAAOoL,OAAOyrD,EAAOrc,IAAIx6C,IAEjD,OAAOsK,MAAMmoD,OAAOzyD,EAAMgD,GAsB5BsvD,SAAStzD,EAAgB05E,GACvBr5E,KAAKq5E,IAAMA,EACX,IAAI+Y,EAAapyF,KAAKoyF,WAKtB,GAJArmF,QAAQqmF,IAAeA,EAAW5mF,QAClCxL,KAAKoyF,WAAaA,EAAa,KAC/BpyF,KAAKwhE,WAAa,KAClBxhE,KAAK0wF,SAAW1wF,KAAK2wF,SAAW3wF,KAAK4wF,SAAW5wF,KAAK6wF,SAAW,KAC5D7wF,KAAKw1C,QAAQnd,QAAQiyB,UAAW,CAClC,IAAIw6B,EAAiB9kF,KAAK8kF,eAC1B,IAAK,IAAIr5E,EAAI,EAAGC,EAAIo5E,EAAet5E,OAAQC,EAAIC,IAAKD,EAAG,CACrD,IAAIhL,EAAQqkF,EAAer5E,GACvBuF,EAASvQ,EAAMuQ,OACnBrR,EAAOosG,iBACL1yB,EACA54E,EAAMokF,aACN7zE,EAAOX,eACPW,EAAOM,OAAO7Q,EAAMyU,OACpBlE,EAAOe,WAAa,MAvM9B,aA+MA,MAAa60H,UAAuBoC,EAGlCzoI,YAEEI,EAEAw2C,EAEAn0C,EAEAw9H,EAAiC5kF,EAAervC,MAEhDtB,MACEkrC,EAAYs0F,gBACZ9pI,EACAylF,EAAmBzlF,EAAMw2C,EAAQprC,OAAO/I,EAAYwJ,GAAG,EAAAF,YAAY8jD,YACnEjZ,EAAO3B,QACP2B,EACAn0C,GAEFhD,KAAKwgI,eAAiBA,EAIpB1oE,eACF,OAA0B93D,KAAKgD,YAAatB,KAI1Cq2D,sBACF,OAA0B/3D,KAAKgD,YAAarB,YAI1C2R,qBACF,OAA0BtT,KAAKgD,YAAasQ,gBApChD,mBAyCA,sBAA2Bq2H,EAYzBppI,YAEEo4C,EAEAxB,EAEAz1C,GAEAuJ,MACEkrC,EAAYe,MACZyB,EAAUh4C,KACVw2C,EACkCwB,EAAU31C,aAnBhD,KAAAq0C,cAAqB,EAErB,KAAAwlB,UAAyB,EAEzB,KAAAG,UAAyB,EAsCjB,KAAA0tE,oBAAqC,KAQrC,KAAAC,oBAAqC,KAQrC,KAAAC,yBAA6C,KAQ7C,KAAAC,yBAA6C,KA7CnD7qI,KAAK24C,UAAYA,EACjB34C,KAAKiG,MAAQ0yC,EAAU1yC,MACvBjG,KAAKwgI,eAAiB7nF,EAAU6nF,eAChCz0H,OAAOrK,GAAQ,EAAAq2B,KAAKsH,MACpBr/B,KAAKq4D,QAAQ32D,GACb4oI,EAAwBtqI,KAAKw1C,QAASx1C,MAIpC02C,eACF,IAAIS,EAASn3C,KAAKm3C,OAElB,OADAprC,OAAOorC,EAAO32C,MAAQ21C,EAAYpnC,OACnBooC,EAAQz1C,KAIrB6zD,yBACF,IAAIm1C,EAAS1qG,KAAK0qI,oBAElB,OADe,OAAXhgC,IAAiB1qG,KAAK0qI,oBAAsBhgC,EAAS1qG,KAAKm3C,OAAOtB,aAAe,EAAAqN,mBAAqB,EAAAF,cAAgBhjD,KAAKW,MACvH+pG,EAKL/0C,yBACF,IAAI+0C,EAAS1qG,KAAK2qI,oBAElB,OADe,OAAXjgC,IAAiB1qG,KAAK2qI,oBAAsBjgC,EAAS1qG,KAAKm3C,OAAOtB,aAAe,EAAAqN,mBAAqB,EAAAD,cAAgBjjD,KAAKW,MACvH+pG,EAKLl1C,8BACF,IAAIk1C,EAAS1qG,KAAK4qI,yBAElB,OADKlgC,IAAQ1qG,KAAK4qI,yBAA2BlgC,EAAS,IAAI,EAAAj8C,UAAUzuD,KAAKw1C,QAAS,KAAMx1C,KAAK0B,KAAM1B,KAAK02C,WACjGg0D,EAKL90C,8BACF,IAAI80C,EAAS1qG,KAAK6qI,yBAElB,OADKngC,IAAQ1qG,KAAK4qI,yBAA2BlgC,EAAS,IAAI,EAAAj8C,UAAUzuD,KAAKw1C,QAAS,CAAEx1C,KAAK0B,MAAQ,EAAAq2B,KAAKsH,KAAMr/B,KAAK02C,WAC1Gg0D,IAMX,MAAa48B,UAA0B0B,EAarCzoI,YAEEI,EAEAw2C,EAEAu4C,GAEAzkF,MACEkrC,EAAYge,mBACZxzD,EACAylF,EAAmBzlF,EAAMw2C,EAAQu4C,EAAiBljF,GAAG,EAAAF,YAAY8jD,WACjEjZ,EAAO3B,QACP2B,EACAu4C,GAxBJ,KAAA+0C,gBAA4C,KAE5C,KAAAI,gBAA4C,KAE5C,KAAAvvF,SAA4B,KAGpB,KAAAs0F,gBAAuD,KAmB7D5pI,KAAKiG,SAAW,EAAAqG,YAAYyvD,IAAM,EAAAzvD,YAAY0vD,KAI5C2sE,cACF,OAAQ3oI,KAAKm3C,OAAO32C,MAClB,KAAK21C,EAAYpnC,MACjB,KAAKonC,EAAYslB,UAAW,OAAO,EAErC,OAAO,EAITquE,QAAQhrF,GACN/yC,OAAO/L,KAAKwM,GAAG,EAAAF,YAAY8jD,WAC3BrkD,QAAQ/L,KAAK2oI,SACb,IAAIiB,EAAkB5pI,KAAK4pI,gBAC3B,GAAKA,GACA,GAAIA,EAAgB1uF,IAAI4D,GAAgB,OAAO/yC,OAAO69H,EAAgBzuF,IAAI2D,SADzD9+C,KAAK4pI,gBAAkBA,EAAkB,IAAIpwF,IAEnE,IAAIk2C,EAAmB1vF,KAAKgD,YAC5B+I,OAAO2jF,EAAiBlvF,MAAQ,EAAAN,SAAS+T,mBACzC,IAAI81H,EAAQ,IAAIzC,EACdtnI,KAAKW,KACLm+C,EACmB4wC,GAErBq6C,EAAM9jI,MAAQjG,KAAKiG,MACnB,IAAIw+H,EAAkBzkI,KAAKykI,gBACvBA,IACFsF,EAAMtF,gBAAkBA,EAAgBqF,QAAQhrF,IAElD,IAAI+lF,EAAkB7kI,KAAK6kI,gBAK3B,OAJIA,IACFkF,EAAMlF,gBAAkBA,EAAgBiF,QAAQhrF,IAElD8qF,EAAgBj9H,IAAImyC,EAAeirF,GAC5BA,GAjEX,sBAsEA,yBAA8BJ,EAU5BppI,YAEEo4C,EAEAxB,GAEAlsC,MACEkrC,EAAY8e,SACZtc,EAAUh4C,KACVw2C,EACA,EAAA72C,KAAK25G,0BACHthE,EAAUob,eACV,KACApb,EAAUnsC,GAAG,EAAAF,YAAY8jD,UACrB,EAAA9jD,YAAY8jD,SACZ,EAAA9jD,YAAYC,KAChB,KAAM,KACNosC,EAAUob,eAAetzD,QAtB/B,KAAAy0D,eAAkC,KAElC,KAAAC,eAAkC,KAuBhCn1D,KAAK24C,UAAYA,EACjB34C,KAAKiG,MAAQ0yC,EAAU1yC,MACvBjG,KAAKwgI,eAAiB7nF,EAAU6nF,eAC5BxgI,KAAKwM,GAAG,EAAAF,YAAY8jD,WACtBk6E,EAAwBtqI,KAAKw1C,QAASx1C,QAM5C,+BAAoCspI,EAGlC/oI,YAEE42C,GAEAlsC,MACEkrC,EAAYlkC,eACZ,KACAklC,EAAOtB,aAAe,KACtBsB,EAAO3B,QACP2B,EACAA,EAAO3B,QAAQ6qF,8BAA8B,OAKjDyK,kBAAkBj3D,GAChB,OAAe7zE,KAAKm3C,OAAQo0B,eAAeC,EAAawI,YAAaH,GAIvEk3D,kBAAkBl3D,GAChB,OAAe7zE,KAAKm3C,OAAQo0B,eAAeC,EAAauI,YAAaF,KAKzE,MAAasyD,UAAuB6C,EAiBlCzoI,YAEEI,EAEAw2C,EAEAn0C,EAEAw9H,EAAiC5kF,EAAervC,KAChDy+H,GAAqB,GAErB//H,MACE+/H,EAAe70F,EAAY4f,oBAAsB5f,EAAY6d,gBAC7DrzD,EACAylF,EAAmBzlF,EAAMw2C,EAAQn0C,EAAYwJ,GAAG,EAAAF,YAAY8jD,WAC5DjZ,EAAO3B,QACP2B,EACAn0C,GA/BJ,KAAA25D,gBAAsD,KAEtD,KAAAkmE,cAAuC,KAEvC,KAAAS,oBAAmD,KAEnD,KAAAtiD,qBAAiD,KAEjD,KAAAimD,mBAA2D,IAAIztF,IAE/D,KAAAsJ,UAAsC,KAEtC,KAAAu3B,UAAiC,IAAI1yB,IAqBnC3nD,KAAKwgI,eAAiBA,EAIpBr1H,yBACF,OAA0BnL,KAAKgD,YAAakD,eAG1C+hF,kBACF,OAA0BjoF,KAAKgD,YAAa1B,YAG1C4hI,sBACF,OAA0BljI,KAAKgD,YAAamD,gBAI1C8kI,qBACF,IAAIhpF,EAA0BjiD,KAAKw1C,QAAQyM,wBAC3C,OAAmC,OAA5BA,GACAjiD,KAAKg6C,QAAQiI,EAAwBtJ,WAI9CqB,QAAQkxF,GACN,IAAIvpF,EAAiC3hD,KACjCwmF,EAAO,IAAI7+B,IACf,EAAG,CAED,GAAI6+B,EAAKtrC,IAAIyG,GAAU,MAEvB,GADA6kC,EAAKlwE,IAAIqrC,GACLA,IAAYupF,EAAe,OAAO,EACtCvpF,EAAUA,EAAQkhF,oBACXlhF,GACT,OAAO,EAITklF,YAAYlmI,EAAcw5C,GACxB,IAAIsuF,EAAsBtuF,EAAQn3C,YAC9B25D,EAAkB38D,KAAK28D,gBAC3B,GAAKA,GACA,GAAIA,EAAgBzhB,IAAIv6C,GAAO,CAClC,IAAIolE,EAAWh6D,OAAO4wD,EAAgBxhB,IAAIx6C,IACtC8kI,EAASC,EAAS3/D,EAAU5rB,GAChC,IAAKsrF,EAcH,OAbIhD,EAAkB18D,EAASvlE,MAC7BR,KAAKw1C,QAAQwwB,aACX,EAAAvtC,eAAesiC,uBACf5gB,EAAQ4Z,eAAetzD,MACLslE,EAAU/iE,YAAYrC,KAAKF,MAC7C05C,EAAQ4Z,eAAe9xD,MAGzBjC,KAAKw1C,QAAQhd,MACX,EAAAC,eAAesiC,uBACf5gB,EAAQ4Z,eAAetzD,MAAO05C,EAAQ4Z,eAAe9xD,OAGlD,EAETk4C,EAAUsrF,QApBUzlI,KAAK28D,gBAAkBA,EAAkB,IAAInjB,IA2BnE,OALAmjB,EAAgBhwD,IAAIhM,EAAMw5C,GACtBA,EAAQ3tC,GAAG,EAAAF,YAAYyG,SAAW/S,KAAKwM,GAAG,EAAAF,YAAYmuD,gBACxDtgB,EAAQxtC,IAAI,EAAAL,YAAYmuD,eAE1Bz6D,KAAKw1C,QAAQwmF,sBAAsBrvH,IAAI87H,EAAqBtuF,IACrD,EAIT6vF,oBAAoBC,GAClB,IAAInnF,EAAY9iD,KAAK8iD,UACrB,OAAkB,OAAdA,GAAsBA,EAAU5H,IAAI+uF,GAA4BnnF,EAAU3H,IAAI8uF,GAC3E,KAITjoD,oBAAoBioD,EAAqB30F,GACvC,IAAIwN,EAAY9iD,KAAK8iD,UAChBA,EACA/2C,QAAQ+2C,EAAU5H,IAAI+uF,IADXjqI,KAAK8iD,UAAYA,EAAY,IAAItJ,IAEjDsJ,EAAUn2C,IAAIs9H,EAAa30F,IAvH/B,mBA4HA,MAAa61F,UAAc7B,EA8DzB/oI,YAEE2pI,EAEAvxF,EAEA73C,EAA+B,KAC/BkqI,GAAqB,GAErB//H,MACE+/H,EAAe70F,EAAYslB,UAAYtlB,EAAYpnC,MACnDm7H,EACA9jD,EAAmB8jD,EAAwBvxF,EAAUxB,OAAQwB,EAAUnsC,GAAG,EAAAF,YAAY8jD,WACtFzX,EAAUnD,QACVmD,EAAUxB,OACVwB,EAAU31C,aAtEd,KAAA2yC,KAAqB,KAErB,KAAAy1F,WAAoC,KAEpC,KAAA/lE,wBAAmD,KAEnD,KAAAhqB,iBAAwB,EAExB,KAAAumC,oBAAuC,KAEvC,KAAAwiD,UAA+C,KAE/C,KAAA9xH,eAAwC,KAEhC,KAAA+4H,IAAW,EAEnB,KAAA5oF,UAAiB,EAEjB,KAAA2iF,YAA2B,KAE3B,KAAA/qD,UAA+B,KAE/B,KAAAixD,aAAkC,KAElC,KAAAppD,6BAAoC,EAEpC,KAAA3sC,SAAwB,EA8CtB,IAAIC,EAAUx1C,KAAKw1C,QACnBx1C,KAAK24C,UAAYA,EACjB34C,KAAKiG,MAAQ0yC,EAAU1yC,MACvBjG,KAAKwgI,eAAiB7nF,EAAU6nF,eAChCxgI,KAAKc,cAAgBA,EACrB,IAAIy6B,EAAYia,EAAQnd,QAAQkD,UAC5B75B,EAAO,IAAI,EAAAq2B,KAAKwD,EAAU/6B,MAAwB,IAAlB+6B,EAAUt1B,MAA2B,IAAqBs1B,EAAUjB,MAIxG,GAHA54B,EAAKk4C,eAAiB55C,KACtBA,KAAKq4D,QAAQ32D,IAER1B,KAAK27C,aAAaC,EAAeruC,WAAY,CAChD,IAAImuC,EAAKlG,EAAQqmF,cACjB77H,KAAKqrI,IAAM3vF,EACXlG,EAAQ4L,eAAez0C,IAAI+uC,EAAI17C,MAIjC,IAAIkG,EAAiByyC,EAAUxtC,mBAC/B,GAAIrK,EAAe,CACjB,IAAI4N,EAAmB5N,EAAc0K,OACrC,IAAKtF,GAAkBwI,GAAoBxI,EAAesF,OACxD,MAAM,IAAI28C,MAAM,gCAElB,GAAIz5C,EAAkB,CACpB,IAAI22D,EAA0BrlE,KAAKqlE,wBAC9BA,IAAyBrlE,KAAKqlE,wBAA0BA,EAA0B,IAAI7rB,KAC3F,IAAK,IAAI/tC,EAAI,EAAGA,EAAIiD,IAAoBjD,EACtC45D,EAAwB14D,IAAIzG,EAAeuF,GAAG9K,KAAKsB,KAAMnB,EAAc2K,UAGtE,GAAuB,OAAnBvF,GAA2BA,EAAesF,OAAS,EAC5D,MAAM,IAAI28C,MAAM,gCAElBmiF,EAAwB90F,EAASx1C,MA5E/B07C,SACF,OAAO17C,KAAKqrI,IAIVJ,qBACF,OAAOjrI,KAAK24C,UAAUsyF,eAIpBj1H,kBACF,GAAIhW,KAAKirI,eAAgB,OAAO,EAChC,IAAIM,EAAcvrI,KAAKk2C,UAAU,UACjC,OAAuB,OAAhBq1F,IACLA,EAAY/qI,MAAQ21C,EAAYe,OAE9Bq0F,EAAY/qI,MAAQ21C,EAAYge,oBACqB,OAAjCo3E,EAAa9G,mBAGe,OAAlDzkI,KAAKurE,eAAeC,EAAawI,cAC2B,OAA5Dh0E,KAAKurE,eAAeC,EAAa+vD,wBA2DrCiQ,QAAQ71F,GACN5pC,QAAQ/L,KAAK21C,MACb31C,KAAK21C,KAAOA,EACZ,IAAI0kC,EAAY1kC,EAAK0kC,UAChBA,IAAW1kC,EAAK0kC,UAAYA,EAAY,IAAI1yB,KACjD0yB,EAAU/jE,IAAItW,MAGd,IAAIyrI,EAAyB91F,EAAK0vB,wBAClC,GAAIomE,EAAwB,CAC1B,IAAIpmE,EAA0BrlE,KAAKqlE,wBAEnC,IAAK,IAAI/jB,EAAQC,SAASkqF,GAAyBhgI,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CACtF,IAAIigI,EAAW55H,UAAUwvC,EAAM71C,IAC3BkgI,EAAW5/H,OAAO0/H,EAAuBtwF,IAAIuwF,IAC5CrmE,EAGOA,EAAwBnqB,IAAIwwF,IACtCrmE,EAAwB14D,IAAI++H,EAAUC,IAHtC3rI,KAAKqlE,wBAA0BA,EAA0B,IAAI7rB,IAC7D6rB,EAAwB14D,IAAI++H,EAAUC,MAS9CC,aAAaC,GACX,IAAIT,EAAaprI,KAAKorI,WACjBA,IAAYprI,KAAKorI,WAAaA,EAAa,IAAIzjF,KACpDyjF,EAAW90H,IAAIu1H,GACf,IAAIP,EAAeO,EAAMP,aACpBA,IAAcO,EAAMP,aAAeA,EAAe,IAAI3jF,KAC3D2jF,EAAah1H,IAAItW,MAInB85C,eAAe4P,GACb,IAAI/H,EAAwB3hD,KAC5B,EAAG,CACD,GAAI2hD,GAAW+H,EAAQ,OAAO,EAC9B,GAAIA,EAAOlpD,MAAQ21C,EAAYslB,UAAW,CACxC,IAAI2vE,EAAazpF,EAAQypF,WACzB,GAAIA,EACF,IAAK,IAAIt0F,EAAUkZ,WAAWo7E,GAAa3/H,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CAEhF,GADYqrC,EAAQrrC,GACVquC,eAAe4P,GAAS,OAAO,GAI/C/H,EAAUA,EAAQhM,WACXgM,GACT,OAAO,EAIT4pB,eAAe/qE,EAAoBsR,GAAkB,GACnD,GAAIA,EACF,OAAQtR,GACN,KAAKgrE,EAAawI,YAAa,CAC7B,IAAI83D,EAAoB9rI,KAAKurE,eAAeC,EAAa+vD,uBACzD,GAAIuQ,EAAmB,OAAOA,EAC9B,MAEF,KAAKtgE,EAAauI,YAAa,CAC7B,IAAI+3D,EAAoB9rI,KAAKurE,eAAeC,EAAagwD,uBACzD,GAAIsQ,EAAmB,OAAOA,EAC9B,MAEF,QAAS//H,QAAO,GAGpB,IAAIupC,EAAyBt1C,KAC7B,EAAG,CACD,IAAIokI,EAAY9uF,EAAS8uF,UACzB,GAAiB,MAAbA,GAAqBA,EAAUlpF,IAAI16C,GACrC,OAAOuL,OAAOq4H,EAAUjpF,IAAI36C,IAE9B80C,EAAWA,EAASK,WACbL,GACT,OAAO,KAIT6pC,UAAUx+E,EAAcG,EAA+B,MACrD,IAAIm2C,EAASj3C,KAAKk2C,UAAUv1C,GAC5B,OAAIs2C,GAAUA,EAAOz2C,MAAQ21C,EAAYC,mBAChCp2C,KAAKw1C,QAAQa,SAASC,gBAAmCW,EAAQn2C,GAEnE,KAIT2X,SAASuiC,GACP,IAAI/D,EAASlrC,OAAO/L,KAAKk2C,UAAU8E,IAEnC,OADAjvC,OAAOkrC,EAAOz2C,MAAQ21C,EAAYe,OACnBD,EAAQI,aAIzB2mB,aAAa+tE,EAAgB,GAC3B,IAAIv2F,EAAUx1C,KAAKw1C,QACf0qF,EAAclgI,KAAKq7C,iBAAmB0wF,EACtC5L,EAAY3qF,EAAQyqF,iBAAiBC,GAAa,GAClD7iE,EAAS,IAAI5mC,WAAW+e,EAAQqqF,cAAgBM,GAChD7wH,EAASkmC,EAAQ6oB,eAMrB,OALA/uD,EAAOgvD,WAAW,SAAU6hE,EAAW9iE,EAAQ,GAC/C/tD,EAAOgvD,WAAW,SAAU,EAAGjB,EAAQ,GACvC/tD,EAAOgvD,WAAW,UAAW,EAAGjB,EAAQ,GACxC/tD,EAAOgvD,WAAW,OAAQt+D,KAAK07C,GAAI2hB,EAAQ,GAC3C/tD,EAAOgvD,WAAW,SAAU4hE,EAAa7iE,EAAQ,GAC1CA,EAITiB,WAAc39D,EAAc6C,EAAU65D,EAAoB2uE,EAAkBhsI,KAAKw1C,QAAQsoB,eACvF,IAAI7mB,EAASj3C,KAAKk2C,UAAUv1C,GAC5B,GAAe,OAAXs2C,GAAmBA,EAAOz2C,MAAQ21C,EAAYe,MAAO,CACvD,IAAIke,EAAuBne,EACvB0F,EAASqvF,EAAa52E,EAAc/d,aACpC40F,EAAW72E,EAAc1zD,KAAKlB,KAClC,OAAQyrI,GACN,KAAK,EACL,KAAK,EAGH,OAFAlgI,QAAQ+sF,OAAOt1F,KACf,IAAA8+B,SAAQnpB,IAAI3V,GAAQ65D,EAAQ1gB,GACrB,EAET,KAAK,EACL,KAAK,EAGH,OAFA5wC,QAAQ+sF,OAAOt1F,KACf,IAAAs8C,UAAS3mC,IAAI3V,GAAQ65D,EAAQ1gB,GACtB,EAET,KAAK,EACL,KAAK,EAGH,OAFA5wC,QAAQ+sF,OAAOt1F,KACf,IAAAu8C,UAAS5mC,IAAI3V,GAAQ65D,EAAQ1gB,GACtB,EAET,KAAK,EACL,KAAK,EACH,OAAI38C,KAAKw1C,QAAQnd,QAAQC,UACnBwgE,OAAOt1F,IACT,IAAA06D,UAAS16D,EAAO65D,EAAQ1gB,IAExB,IAAAuvF,eAAc/yH,IAAI3V,GAAQ65D,EAAQ1gB,EAAoB,GAAZsvF,GAErC,IAEHnzC,OAAOt1F,IACT,IAAA2oI,eAAc3oI,EAAO65D,EAAQ1gB,EAAoB,GAAZsvF,IAErC,IAAAlsF,UAAS5mC,IAAI3V,GAAQ65D,EAAQ1gB,GAExB,GAGX,KAAK,EACL,KAAK,EAMH,OALIm8C,OAAOt1F,IACT,IAAA06D,UAAS16D,EAAO65D,EAAQ1gB,IAExB,IAAAuvF,eAAc/yH,IAAI3V,GAAQ65D,EAAQ1gB,EAAoB,GAAZsvF,GAErC,EAET,KAAK,GAGH,OAFAlgI,QAAQ+sF,OAAOt1F,KACf,IAAAw8C,UAASpmC,IAAIpW,GAAQ65D,EAAQ1gB,GACtB,EAET,KAAK,GAGH,OAFA5wC,QAAQ+sF,OAAOt1F,KACf,IAAAy8C,UAASpmC,IAAIrW,GAAQ65D,EAAQ1gB,GACtB,GAKb,OADA5wC,QAAO,GACA,EAITiuC,QAAQrB,GACN,OAAO34C,KAAK24C,UAAUqB,QAAQrB,GAIhC6J,mBAAmB4pF,GACjB,IAAIzqF,EAAwB3hD,KAC5B,EAAG,CACD,GAAI2hD,EAAQhJ,YAAcyzF,EAAmB,OAAOzqF,EAAQ7gD,cAC5D6gD,EAAUA,EAAQhM,WACXgM,GACT,OAAO,KAITY,oBACE,IAAIZ,EAAiB3hD,KACjBw1C,EAAUx1C,KAAKw1C,QACfyE,EAAiBzE,EAAQyE,eAC7B,GAAIj6C,KAAKg6C,QAAQC,GACf,OAAOj6C,KAAKwiD,mBAAmBvI,GAAiB,GAElD,IAAIoI,EAAuB7M,EAAQ6M,qBACnC,GAAIriD,KAAKg6C,QAAQqI,GACf,OAAOriD,KAAKwiD,mBAAmBH,GAAuB,GAGxD,IADA,IAAIL,EAAcxM,EAAQyM,wBACnBN,EAAQhM,OAASqM,GACtBL,EAAU51C,OAAO41C,EAAQhM,MAE3B,IAAIgD,EAAYgJ,EAAQhJ,UACxB,OAAQA,EAAUh4C,KAAKoM,WAAW,IAChC,KAAK,GACH,GAAI4rC,GAAanD,EAAQ4pF,sBAAuB,OAAO,EAAArnG,KAAKne,IAC5D,GAAI++B,GAAanD,EAAQ6pF,sBAAuB,OAAO,EAAAtnG,KAAKle,IAC5D,MAEF,KAAK,GACH,GAAI8+B,GAAanD,EAAQmpF,mBAAoB,OAAO,EAAA5mG,KAAK9e,GACzD,GAAI0/B,GAAanD,EAAQopF,oBAAqB,OAAO,EAAA7mG,KAAK7e,IAC1D,GAAIy/B,GAAanD,EAAQqpF,oBAAqB,OAAO,EAAA9mG,KAAK5e,IAC1D,GAAIw/B,GAAanD,EAAQspF,oBAAqB,OAAO,EAAA/mG,KAAK3e,IAC1D,MAEF,KAAK,GACH,GAAIu/B,GAAanD,EAAQupF,oBAAqB,OAAO,EAAAhnG,KAAKze,GAC1D,GAAIq/B,GAAanD,EAAQwpF,2BAA4B,OAAO,EAAAjnG,KAAKze,GACjE,GAAIq/B,GAAanD,EAAQypF,qBAAsB,OAAO,EAAAlnG,KAAKxe,IAC3D,GAAIo/B,GAAanD,EAAQ0pF,qBAAsB,OAAO,EAAAnnG,KAAKve,IAC3D,GAAIm/B,GAAanD,EAAQ2pF,qBAAsB,OAAO,EAAApnG,KAAKte,IAK/D,OADA1N,QAAO,GACA,EAAAgsB,KAAKsH,KAIVoiB,oBACF,IAAIjM,EAAUx1C,KAAKw1C,QAEfmnB,EAAkB38D,KAAKoG,QAC3B,GAAIu2D,EAAiB,CAGnB,IAAK,IAAI7lB,EAAUC,WAAW4lB,GAAkBlxD,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CACrF,IAAIwrC,EAASnlC,UAAUglC,EAAQrrC,IAC/B,GAAIwrC,EAAOz2C,MAAQ21C,EAAYe,MAAO,CAEpC,GADwBD,EAAQv1C,KAClB0U,UAAW,OAAO,GAKpC,GAAIumD,EAAgBzhB,IAAI,EAAAqI,YAAY0F,OAAQ,CAC1C,IAAItQ,EAAY34C,KAAK24C,UACrB,GACEA,GAAanD,EAAQyE,gBACrBtB,GAAanD,EAAQ6M,sBACrB1J,GAAanD,EAAQ2M,cACrBxJ,GAAanD,EAAQ4M,aACrB,CAGA,IAAIthD,EAAgBiL,OAAO/L,KAAKwiD,mBAAmB7J,IACnD,IAAK,IAAIltC,EAAI,EAAGC,EAAI5K,EAAc0K,OAAQC,EAAIC,IAAKD,EACjD,GAAI3K,EAAc2K,GAAG2K,UAAW,OAAO,EAEzC,OAAO,EAET,OAAO,GAGX,OAAO,EAITkkE,gBAAgB+xD,EAAgC,KAAM7zC,EAAkB,IAAI7wC,KAC1E,IAAI0yB,EAAYr6E,KAAKq6E,UACrB,GAAIA,EACF,IAAK,IAAIvjC,EAAUkZ,WAAWqqB,GAAY5uE,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CAC/E,IAAIgvE,EAAW3jC,EAAQrrC,GACvB,GAAI4gI,EAAgB,CAClB,IAAI1vE,EAAkB8d,EAAS9hC,UAAUgkB,gBACzC,GAAwB,OAApBA,GAA4BA,EAAgBzhB,IAAImxF,GAAiB,SAEvE7zC,EAAIliF,IAAImkE,GACRA,EAASH,gBAAgB+xD,EAAgB7zC,GAG7C,OAAOA,GAzZX,UA8ZA,MAAayvC,UAA2B9B,EAGtC5lI,YACEI,EACAw2C,EACAn0C,EACAw9H,GAEAv1H,MACEtK,EACAw2C,EACAn0C,EACAw9H,GACA,IAdN,uBAyCA,SAAS8J,EAAwB90F,EAAkB2E,GACjDpuC,QAAQypC,EAAQggD,gBAAgBt6C,IAAIf,EAAQtE,eAC5CL,EAAQggD,gBAAgB7oF,IAAIwtC,EAAQtE,aAAcsE,GAIpD,SAASurF,EAAS4G,EAAgBC,GAIhC,GADAxgI,OAAOugI,EAAM92F,UAAY+2F,EAAM/2F,SAC3B+2F,EAAMnmI,QAAS,OAAO,KAC1B,IAAIq/H,EAAiC,KACrC,OAAQ6G,EAAM9rI,MACZ,KAAK21C,EAAYC,mBACf,OAAQm2F,EAAM/rI,MACZ,KAAK21C,EAAY6f,UACfoyE,EAAYmE,EAAOD,GACnB7G,EAA0B6G,EAC1B,MAEF,KAAKn2F,EAAY8f,eACVq2E,EAAMhE,aACTgE,EAAMhE,WAA6BiE,EACnCnE,EAAYmE,EAAOD,GACnB7G,EAA0B6G,GAKhC,MAEF,KAAKn2F,EAAY6d,gBACjB,KAAK7d,EAAY2f,KACf,GAAIy2E,EAAM/rI,MAAQ21C,EAAY6f,UAAW,CACvCoyE,EAAYmE,EAAOD,GACnB7G,EAA0B6G,EAC1B,MAEF,MAEF,KAAKn2F,EAAY6f,UACf,OAAQu2E,EAAM/rI,MACZ,KAAK21C,EAAY2f,KACjB,KAAK3f,EAAY6d,gBACjB,KAAK7d,EAAYC,mBACfgyF,EAAYkE,EAAOC,GACnB9G,EAA0B8G,EAC1B,MAEF,KAAKp2F,EAAY6f,UACfoyE,EAAYmE,EAAOD,GACnB7G,EAA0B6G,EAC1B,MAEF,KAAKn2F,EAAY8f,eACVq2E,EAAMhE,aACTgE,EAAMhE,WAA6BiE,EACnCnE,EAAYmE,EAAOD,GACnB7G,EAA0B6G,GAKhC,MAEF,KAAKn2F,EAAYhpC,OACXo/H,EAAM/rI,MAAQ21C,EAAY8f,iBACvBq2E,EAAMhE,aACTgE,EAAMhE,WAA6BiE,EACnCnE,EAAYmE,EAAOD,GACnB7G,EAA0B6G,IAG9B,MAEF,KAAKn2F,EAAY8f,eACf,OAAQs2E,EAAM/rI,MACZ,KAAK21C,EAAYhpC,OACjB,KAAKgpC,EAAYC,mBACjB,KAAKD,EAAY6f,UACVu2E,EAAMjE,aACTiE,EAAMjE,WAA6BgE,EACnClE,EAAYkE,EAAOC,GACnB9G,EAA0B8G,IAQpC,GAAI9G,EAAQ,EACU6G,EAAM9/H,GAAG,EAAAF,YAAYyG,SAAWu5H,EAAM3wF,aAAaC,EAAezuC,WAClEo/H,EAAM//H,GAAG,EAAAF,YAAYyG,SAAWw5H,EAAM5wF,aAAaC,EAAezuC,UAEpFm/H,EAAM92F,QAAQhd,MACZ,EAAAC,eAAe+zG,kFACf/G,EAAO1xE,eAAetzD,MAAOglI,EAAO1xE,eAAe9xD,MAIzD,OAAOwjI,EAIT,SAAS2C,EAAYqE,EAAcrtC,GACjC,IAAIstC,EAAaD,EAAIrmI,QACrB,GAAIsmI,EAAY,CACd,IAAIC,EAAcvtC,EAAKh5F,QAClBumI,IAAavtC,EAAKh5F,QAAUumI,EAAc,IAAInzF,KAEnD,IAAK,IAAI8H,EAAQC,SAASmrF,GAAajhI,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CAC1E,IAAI4qD,EAAavkD,UAAUwvC,EAAM71C,IAC7BwrC,EAASlrC,OAAO2gI,EAAWvxF,IAAIkb,IACnCs2E,EAAYhgI,IAAI0pD,EAAYpf,KAMlC,SAAgBmvC,EAAmBzlF,EAAcw2C,EAAiBqhC,EAAkBo0D,GAAiB,GACnG,OAAQz1F,EAAO32C,MACb,KAAK21C,EAAYoyF,KACf,OAAIqE,EAAiBjsI,EACdw2C,EAAOtB,aAAe,EAAAhlC,eAAiBlQ,EAEhD,KAAKw1C,EAAYhnC,SACf,OAAIy9H,EAAiBjsI,GACrBoL,QAAQysE,GACDrhC,EAAOtB,aAAe,EAAAuN,gBAAkBziD,GAEjD,KAAKw1C,EAAYge,mBACjB,KAAKhe,EAAY8e,SACf9d,EAASA,EAAOA,OAGlB,QACE,OAAOivC,EAAmBjvC,EAAOx2C,KAAMw2C,EAAOA,OAAQA,EAAO3qC,GAAG,EAAAF,YAAY8jD,UAAWw8E,IAC/Ep0D,EAAa,EAAAt1B,mBAAqB,EAAAC,kBAAoBxiD,GA/JpE,0BAA+BwqI,EAG7B5qI,YAEE2pI,EAEAvxF,EAEA73C,EAA+B,MAE/BmK,MACEi/H,EACAvxF,EACA73C,GACA,KA8HN,uBAwBA,IAAI+rI,EAAwC,GAG5C,SAAgBtC,EAAwB5wG,GACtC,IAAK,IAAIluB,EAAIohI,EAA4BrhI,OAAQC,GAAKkuB,IAASluB,EAC7DohI,EAA4Bp7H,KAAK,IAAMhG,EAAEmtB,YAE3C,OAAOi0G,EAA4BlzG,GAJrC,6B,2GCpmJA,eAKA,SA4BA,SAIA,QAkCA,SAOA,SAKA,SAKA,SAKA,SAKA,IAAY0gB,GAAZ,SAAYA,GAEV,uBAEA,yBAJF,CAAYA,EAAA,EAAAA,aAAA,EAAAA,WAAU,KAQtB,MAAakkF,UAAiB,EAAAtyE,kBAa5B1rD,YAEEi1C,GAEAvqC,MAAMuqC,EAAQ0W,aAXhB,KAAAqkB,sBAA2C,KAE3C,KAAAC,yBAA+C,KAE/C,KAAAhgB,oBAA2B,EA4rFnB,KAAAs8E,oBAAkC,IAAInlF,IAprF5C3nD,KAAKw1C,QAAUA,EAMjB0iB,YAEEztD,EAEAsiI,EAEAC,EAAoC,KAEpCC,EAAyB5yF,EAAWoqC,QAEpC,OAAQh6E,EAAKjK,MACX,KAAK,EAAAN,SAASkL,UACZ,OAAOpL,KAAKktI,iBACKziI,EACfsiI,EACAC,EACAC,GAGJ,KAAK,EAAA/sI,SAAS0L,aACZ,OAAO5L,KAAKmtI,oBACQ1iI,EAClBsiI,EACAC,EACAC,GAGJ,QAASlhI,QAAO,GAElB,OAAO,KAIDmhI,iBAENziI,EAEAsiI,EAEAC,EAAoC,KAEpCC,EAAyB5yF,EAAWoqC,QAEpC,IAAI73E,EAAWnC,EAAK9J,KAChB4K,EAAoBd,EAAK3J,cACzBssI,GAAgBxgI,EAAStB,KAG7B,GAAI8hI,EAAc,CAChB,IAAIC,EAAazgI,EAASjB,WAAW1J,KACrC,GAAiB,OAAb+qI,GAAqBA,EAAS9xF,IAAImyF,GAAa,CACjD,IAAI3rI,EAAOqK,OAAOihI,EAAS7xF,IAAIkyF,IAS/B,GAR0B,OAAtB9hI,GAA8BA,EAAkBC,OAAS,GACvDyhI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAemgB,sBACfnuC,EAAKhK,MAAOiB,EAAKk3B,YAInBnuB,EAAK1J,WAAY,CACnB,GAAIW,EAAK65C,oBAAqB,OAAO75C,EAAKi7E,aACtCswD,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe60G,0BACf7iI,EAAKhK,MAAOiB,EAAKk3B,YAIvB,OAAOl3B,GAKX,IAAIy4C,EAAUn6C,KAAK09E,gBAAgB9wE,EAAUmgI,EAAYE,GACzD,IAAK9yF,EAAS,OAAO,KAGrB,IAAImuF,EAAanuF,EAAQmuF,WACzB,GAAIA,EACFnuF,EAAUmuF,MAEL,CAGL,GAAInuF,EAAQ35C,MAAQ,EAAA21C,YAAY2f,KAiB9B,OAhB0B,OAAtBvqD,GAA8BA,EAAkBC,OAAS,GACvDyhI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAemgB,sBACfnuC,EAAKhK,MAAO05C,EAAQtE,cAItBprC,EAAK1J,YACHksI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe60G,0BACf7iI,EAAKhK,MAAO05C,EAAQx5C,KAAO,QAI1B,EAAAo3B,KAAK5e,IAId,GACEghC,EAAQ35C,MAAQ,EAAA21C,YAAY6d,iBAC5B7Z,EAAQ35C,MAAQ,EAAA21C,YAAY4f,oBAC5B,CACA,IAAIzgB,EAAWt1C,KAAK2hF,8BACFxnC,EAChB5uC,EACAwhI,GACA,IAAA3nE,WAAuB4nE,GACvBviI,EACAwiI,GAEF,OAAK33F,EACE7qC,EAAK1J,WAAau0C,EAAS5zC,KAAKi7E,aAAernC,EAAS5zC,KADzC,MAM1B,GAAIy4C,EAAQ35C,MAAQ,EAAA21C,YAAY8f,eAAgB,CAC9C,IAAIs3E,EAAiCpzF,EAGrC,GAAIA,EAAQ3tC,GAAG,EAAAF,YAAY0rD,UAAW,CACV,OAAtBzsD,GAA8BA,EAAkBC,OAAS,GACvDyhI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAemgB,sBACfnuC,EAAKhK,MAAO05C,EAAQtE,cAI1B,IAAIn0C,EAAO6rI,EAAe7rI,KAC1B,GAAI+I,EAAK1J,WAAY,CACnB,GAAIW,EAAK65C,oBAAqB,OAAO75C,EAAKi7E,aACtCswD,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe60G,0BACf1gI,EAASnM,MAAOmM,EAASjB,WAAW1J,MAI1C,OAAOP,EAIT,GAAI0rI,EAAc,CAChB,IAAInrI,EAAO2K,EAASjB,WAAW1J,KAC/B,GAAIA,GAAQ,EAAAshD,YAAYc,OAAQ,OAAOrkD,KAAKwtI,yBAAyB/iI,EAAMsiI,EAAYC,EAAUC,GACjG,GAAIhrI,GAAQ,EAAAshD,YAAYe,QAAS,OAAOtkD,KAAKytI,0BAA0BhjI,EAAMsiI,EAAYC,EAAUC,GACnG,GAAIhrI,GAAQ,EAAAshD,YAAYgB,QAAS,OAAOvkD,KAAK0tI,0BAA0BjjI,EAAMsiI,EAAYC,EAAUC,GACnG,GAAIhrI,GAAQ,EAAAshD,YAAYiB,SAAU,OAAOxkD,KAAK2tI,6BAA6BljI,EAAMsiI,EAAYC,EAAUC,GACvG,GAAIhrI,GAAQ,EAAAshD,YAAYkB,QAAS,OAAOzkD,KAAK4tI,8BAA8BnjI,EAAMsiI,EAAYC,EAAUC,GAIzG,IAAI9hI,EAAqBoiI,EAAepiI,mBACpCrK,EAA+B,KACnC,GAAIqK,GASF,GARArK,EAAgBd,KAAKq2E,qBACnBlrE,EACAI,EACAwhI,EACAC,GAAW,IAAA5nE,WAAU4nE,GACrBviI,EACAwiI,IAEGnsI,EAAe,OAAO,UACI,OAAtByK,GAA8BA,EAAkBC,OAAS,GAClExL,KAAKw4B,MACH,EAAAC,eAAemgB,sBACfnuC,EAAKhK,MAAOmM,EAASjB,WAAW1J,MAGpC,IAAIP,EAAO1B,KAAKk4D,YACdq1E,EAAez1E,SACf3d,EACA6yF,EACAC,GAEF,IAAKvrI,EAAM,OAAO,KAClB,GAAI+I,EAAK1J,WAAY,CACnB,GAAIW,EAAK65C,oBAAqB,OAAO75C,EAAKi7E,aACtCswD,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe60G,0BACf1gI,EAASnM,MAAOmM,EAASjB,WAAW1J,MAI1C,OAAOP,EAQT,OANIurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey5C,mBACftlE,EAASnM,MAAOmM,EAASjB,WAAW1J,MAGjC,KAIDkrI,oBAEN1iI,EAEAsiI,EAEAC,EAAoC,KAEpCC,EAAyB5yF,EAAWoqC,QAEpC,IAAItjF,EAAmBsJ,EAAKtJ,iBACxBu1C,EAAwB,KAC5B,GAAIv1C,KACFu1C,EAAW12C,KAAKk4D,YACd/2D,EACA4rI,EACAC,EACAC,IAEa,OAAO,KAExB,IAAInhI,EAAiBrB,EAAKxJ,WACtB05D,EAAgB7uD,EAAeN,OAC/BmrC,EAAiB,IAAIvmC,MAAYuqD,GACjCrb,EAAqB,EACrBu3B,GAAU,EACd,IAAK,IAAIprE,EAAI,EAAGA,EAAIkvD,IAAiBlvD,EAAG,CACtC,IAAI2wE,EAAgBtwE,EAAeL,GACnC,OAAQ2wE,EAAc36E,eACpB,KAAK,EAAA0K,cAAcwoG,QACjBr1D,EAAqB7zC,EAAI,EACzB,MAEF,KAAK,EAAAU,cAAcwjF,KACjB5jF,OAAON,GAAKkvD,GACZkc,GAAU,EAId,IAAIg3D,EAAoBzxD,EAAc16E,KACtC,IAAI,IAAA26E,eAAcwxD,GAOhB,OANIZ,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfy1E,EAAkBptI,OAGf,KAET,IAAI0pI,EAAgBnqI,KAAKk4D,YACvB21E,EACAd,EACAC,EACAC,GAEF,IAAK9C,EAAe,OAAO,KAC3BxzF,EAAelrC,GAAK0+H,EAEtB,IACIjpI,EADA4sI,EAAiBrjI,EAAKvJ,WAE1B,IAAI,IAAAm7E,eAAcyxD,GACZb,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe2/B,cACf01E,EAAertI,OAGnBS,EAAa,EAAA62B,KAAKsH,UAQlB,KANAn+B,EAAalB,KAAKk4D,YAChB41E,EACAf,EACAC,EACAC,IAEe,OAAO,KAE1B,IAAI5kI,EAAY,IAAI,EAAAomD,UAAUzuD,KAAKw1C,QAASmB,EAAgBz1C,EAAYw1C,GAGxE,OAFAruC,EAAUi3C,mBAAqBA,EAC/Bj3C,EAAUwuE,QAAUA,EACbpsE,EAAK1J,WAAasH,EAAU3G,KAAKi7E,aAAet0E,EAAU3G,KAG3D8rI,yBAEN/iI,EAEAsiI,EAEAC,EAAoC,KAEpCC,EAAyB5yF,EAAWoqC,QAEpC,MAAMspD,EAAmB/tI,KAAKguI,sBAAsBvjI,EAAMwiI,GAC1D,IAAKc,EAAkB,OAAO,KAC9B,IAAIE,EAAejuI,KAAKk4D,YAAY61E,EAAkBhB,EAAYC,EAAUC,GAC5E,IAAKgB,EAAc,OAAO,KAC1B,OAAQA,EAAaztI,MACnB,KAAK,EACL,KAAK,EACL,KAAK,EAAc,OAAO,EAAAu3B,KAAK5e,IAC/B,KAAK,EAAgB,IAAKnZ,KAAKw1C,QAAQnd,QAAQC,SAAU,OAAO,EAAAP,KAAK5e,IACrE,KAAK,EAAc,OAAO,EAAA4e,KAAK3e,IAC/B,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,GAAe,OAAO,EAAA2e,KAAKve,IAChC,KAAK,EAAgB,IAAKxZ,KAAKw1C,QAAQnd,QAAQC,SAAU,OAAO,EAAAP,KAAKve,IACrE,KAAK,EAAc,OAAO,EAAAue,KAAKte,IAC/B,KAAK,GAAc,OAAO,EAAAse,KAAKne,IAC/B,KAAK,GAAc,OAAO,EAAAme,KAAKle,IAC/B,KAAK,GAAe,OAAO,EAAAke,KAAKje,KAChC,KAAK,GAAe,OAAO,EAAAie,KAAKsH,KAChC,QAAStzB,QAAO,GAElB,OAAO,KAGD0hI,0BAENhjI,EAEAsiI,EAEAC,EAAoC,KAEpCC,EAAyB5yF,EAAWoqC,QAEpC,MAAMspD,EAAmB/tI,KAAKguI,sBAAsBvjI,EAAMwiI,GAC1D,IAAKc,EAAkB,OAAO,KAC9B,IAAIE,EAAejuI,KAAKk4D,YAAY61E,EAAkBhB,EAAYC,EAAUC,GAC5E,IAAKgB,EAAc,OAAO,KAC1B,IAAIr0F,EAAiBq0F,EAAar0F,eAClC,IAAKA,EAOH,OANIqzF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey7C,qCACf65D,EAAiBttI,MAAOwtI,EAAar1G,YAGlC,KAET,IAAI0yC,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAawI,aAC1D,OAAI1I,EACEA,EAAS9+D,GAAG,EAAAF,YAAYgoD,SAC1BvoD,OAAmD,GAA5Cu/D,EAASjjE,UAAUsuC,eAAenrC,QAClC8/D,EAASjjE,UAAUsuC,eAAe,KAEzC5qC,OAAmD,GAA5Cu/D,EAASjjE,UAAUsuC,eAAenrC,QAClC8/D,EAASjjE,UAAUsuC,eAAe,KAGzCs2F,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey7C,qCACf65D,EAAiBttI,MAAOwtI,EAAar1G,YAGlC,MAGD80G,0BAENjjI,EAEAsiI,EAEAC,EAAoC,KAEpCC,EAAyB5yF,EAAWoqC,QAEpC,MAAMspD,EAAmB/tI,KAAKguI,sBAAsBvjI,EAAMwiI,GAC1D,IAAKc,EAAkB,OAAO,KAC9B,IAAIE,EAAejuI,KAAKk4D,YAAY61E,EAAkBhB,EAAYC,EAAUC,GAC5E,IAAKgB,EAAc,OAAO,KAC1B,IAAIr0F,EAAiBq0F,EAAapzF,kBAAkB76C,KAAKw1C,SACzD,GAAIoE,EAAgB,CAClB,IAAI0xB,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAawI,aAC1D,GAAI1I,EAAU,OAAOA,EAASjjE,UAAUnH,WAQ1C,OANI+rI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey7C,qCACf65D,EAAiBttI,MAAOwtI,EAAar1G,YAGlC,KAGD+0G,6BAENljI,EAEAsiI,EAEAC,EAAoC,KAEpCC,EAAyB5yF,EAAWoqC,QAEpC,MAAMspD,EAAmB/tI,KAAKguI,sBAAsBvjI,EAAMwiI,GAC1D,IAAKc,EAAkB,OAAO,KAC9B,IAAIE,EAAejuI,KAAKk4D,YAAY61E,EAAkBhB,EAAYC,EAAUC,GAC5E,IAAKgB,EAAc,OAAO,KAC1B,IAAIvzF,EAAqBuzF,EAAazyF,eACtC,OAAId,EAA2BA,EAAmBx5C,YAC9C+rI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAekiB,8BACfozF,EAAiBttI,MAAOwtI,EAAar1G,YAGlC,MAGDg1G,8BAENnjI,EAEAsiI,EAEAC,EAAoC,KAEpCC,EAAyB5yF,EAAWoqC,QAEpC,MAAMspD,EAAmB/tI,KAAKguI,sBAAsBvjI,EAAMwiI,GAC1D,IAAKc,EAAkB,OAAO,KAC9B,IAAIE,EAAejuI,KAAKk4D,YAAY61E,EAAkBhB,EAAYC,EAAUC,GAC5E,OAAKgB,EACAA,EAAa/zF,oBACX+zF,EAAarwF,gBAD0BqwF,EADpB,KAM5BvwD,gBAEEjzE,EAEAsiI,EAEAE,EAAyB5yF,EAAWoqC,QAEpC,IAAItqC,EAAU4yF,EAAW35E,OAAO3oD,EAAKkB,WAAW1J,MAAM,GACtD,IAAKk4C,EAOH,OANI8yF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey5C,mBACfznE,EAAKhK,MAAOgK,EAAKkB,WAAW1J,MAGzB,KAIT,IAFA,IAAIisI,EAAOzjI,EACPa,EAAOb,EAAKa,KACTA,GAAM,CACX,KAAM6uC,EAAUA,EAAQjE,UAAU5qC,EAAKK,WAAW1J,OAOhD,OANIgrI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe6oD,oCACfh2E,EAAK7K,MAAO6K,EAAKK,WAAW1J,KAAMisI,EAAKviI,WAAW1J,MAG/C,KAETisI,EAAO5iI,EACPA,EAAOA,EAAKA,KAEd,OAAO6uC,EAITk8B,qBAEEnwE,EAEAqF,EAEAwhI,EAEAC,GAA6B,IAAA5nE,aAE7B+oE,EAAqC,KAErClB,EAAyB5yF,EAAWoqC,QAEpC,IAAI2pD,EAAoB,EACpBC,EAAoB,EACxB,IAAK,IAAI5iI,EAAI,EAAGC,EAAIxF,EAAesF,OAAQC,EAAIC,IAAKD,EAC7CvF,EAAeuF,GAAGlK,eAAe6sI,IACpCC,EAEJ,IAAIC,EAAgB/iI,EAAoBA,EAAkBC,OAAS,EACnE,GAAI8iI,EAAgBF,GAAqBE,EAAgBD,EAcvD,OAbIpB,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAeof,oCACfy2F,EACI,EAAA3/H,MAAMC,KACJrD,EAAmB,GAAG9K,MACtB8K,EAAmB+iI,EAAgB,GAAG7tI,OAExC0tI,EAAuB1tI,OAC1B6tI,EAAgBF,EAAoBA,EAAoBC,GAAmBz1G,WAC5E01G,EAAc11G,YAGX,KAET,IAAI93B,EAAgB,IAAIsP,MAAYi+H,GAChCE,GAAc,IAAAnpE,WAAuB4nE,GACzCA,EAAS/8E,QACT,IAAK,IAAIxkD,EAAI,EAAGA,EAAI4iI,IAAqB5iI,EAAG,CAC1C,IAAI/J,EAAO+J,EAAI6iI,EACXtuI,KAAKk4D,YACH3sD,EAAmBE,GACnBshI,EACAwB,EACAtB,GAEFjtI,KAAKk4D,YACHnsD,OAAO7F,EAAeuF,GAAGlK,aACzBwrI,GACA,IAAA3nE,WAAuB4nE,GACvBC,GAEN,IAAKvrI,EAAM,OAAO,KAElBsrI,EAASrgI,IAAIzG,EAAeuF,GAAG9K,KAAKsB,KAAMP,GAC1CZ,EAAc2K,GAAK/J,EAErB,OAAOZ,EAITi1E,eACEtrE,EACAkuC,EACA61F,EACAvB,EAAyB5yF,EAAWoqC,QAEpC,IAAI3jF,EAAgB2J,EAAK3J,cAGzB,GAAIA,EACF,OAAK63C,EAAUnsC,GAAG,EAAAF,YAAYsnD,SASvB5zD,KAAKyuI,iCACV91F,EACA73C,EACA0tI,EAAQx/E,gBACR,IAAAoW,WAAUopE,EAAQnpE,yBAClB56D,EACAwiI,IAdIA,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAemgB,sBACfnuC,EAAKjI,WAAW/B,MAAOk4C,EAAU9C,cAG9B,MAaX,GAAI8C,EAAUnsC,GAAG,EAAAF,YAAYsnD,SAAU,CACrC,IAAIyR,GAA0B,IAAAD,WAAuBopE,EAAQnpE,yBAGzDl6D,EAAqBY,OAAO4sC,EAAUxtC,oBACtCskF,EAAoBtkF,EAAmBK,OACvCkjI,EAAqB,IAAI/mF,IAC7B,IAAK,IAAIl8C,EAAI,EAAGA,EAAIgkF,IAAqBhkF,EAAG,CAC1C,IAAI9K,EAAOwK,EAAmBM,GAAG9K,KAAKsB,KACtCojE,EAAwB14D,IAAIhM,EAAM,EAAAo3B,KAAKoD,MACvCuzG,EAAmBp4H,IAAI3V,GAGzB,IAAImL,EAAiB6sC,EAAU9sC,iBAAiB5K,WAC5C05D,EAAgB7uD,EAAeN,OAC/BmjI,EAAgBlkI,EAAK5I,KACrBiN,EAAe6/H,EAAcnjI,OAGjC,IAAK,IAAIC,EAAI,EAAGA,EAAIkvD,IAAiBlvD,EAAG,CACtC,IAAImjI,EAAqBnjI,EAAIqD,EAAe6/H,EAAcljI,GAAKK,EAAeL,GAAG9J,YACjF,IAAKitI,EAOH,OANI3B,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAeqf,+BACfrtC,EAAKhK,MAAOk6D,EAAc/hC,WAAY9pB,EAAa8pB,YAGhD,KAET,IAAIk/B,EAAWhsD,EAAeL,GAAG/J,KACjC,GAAIo2D,EAAS5sD,oBAAoBC,GAAqB,CACpD,IAAIzJ,EAAO1B,KAAK27E,kBAAkBizD,EAAoBJ,EAAS,EAAAz2G,KAAKoD,KAAMkf,EAAWC,SACjF54C,GAAM1B,KAAK6uI,8BAA8B/2E,EAAUp2D,EAAM8sI,EAASnpE,EAAyBqpE,IAKnG,IAAII,EAAwB,IAAI1+H,MAAYq/E,GAC5C,IAAK,IAAIhkF,EAAI,EAAGA,EAAIgkF,IAAqBhkF,EAAG,CAC1C,IAAIsjI,EAAoB5jI,EAAmBM,GACvC9K,EAAOouI,EAAkBpuI,KAAKsB,KAClC,GAAIojE,EAAwBnqB,IAAIv6C,GAAO,CACrC,IAAIquI,EAAejjI,OAAOs5D,EAAwBlqB,IAAIx6C,IACtD,GAAIquI,GAAgB,EAAAj3G,KAAKoD,KAAM,CAC7B2zG,EAAsBrjI,GAAKujI,EAC3B,SAEF,IAAIztI,EAAcwtI,EAAkBxtI,YACpC,GAAIA,EAAa,CACf,IAAI0tI,EAAsBjvI,KAAKk4D,YAAY32D,EAAaitI,EAAQx/E,eAAgBqW,EAAyB4nE,GACzG,IAAKgC,EAAqB,OAAO,KACjCH,EAAsBrjI,GAAKwjI,EAC3B,UAWJ,OANIhC,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe6kD,uBACf7yE,EAAKjI,WAAW/B,MAAM83D,OAGnB,KAET,OAAOv4D,KAAKs2C,gBACVqC,EACAm2F,GACA,IAAA1pE,WAAuBopE,EAAQnpE,yBAC/B4nE,GAKJ,OAAOjtI,KAAKs2C,gBAAgBqC,EAAW,MAAM,IAAAysB,aAA0B6nE,GAIjE4B,8BAENpkI,EAEA/I,EAEA8sI,EAEAxB,EAEA0B,GAEA,GAAIjkI,EAAKjK,MAAQ,EAAAN,SAASkL,UAAW,CACnC,IAAIC,EAA+BZ,EAC/Bc,EAAoBF,EAAcvK,cACtC,GAA0B,OAAtByK,GAA8BA,EAAkBC,OAAS,EAAG,CAC9D,IAAIouC,EAAiBl4C,EAAKk4C,eAC1B,GAAIA,EAAgB,CAClB,IAAIqa,EAAiBj0D,KAAK09E,gBAAgBryE,EAAc1K,KAAM6tI,EAAQx/E,gBACtE,IAAKiF,GAAkBA,EAAezzD,MAAQ,EAAA21C,YAAY6d,gBAAiB,OAC3E,GAAIpa,EAAejB,WAA6Bsb,EAAgB,CAC9D,IAAInzD,EAAgB84C,EAAe94C,cACnC,GAAsB,OAAlBA,GAA0BA,EAAc0K,QAAUD,EAAkBC,OAAQ,CAC9E,IAAK,IAAIC,EAAI,EAAGC,EAAI5K,EAAc0K,OAAQC,EAAIC,IAAKD,EACjDzL,KAAK6uI,8BAA8BtjI,EAAkBE,GAAI3K,EAAc2K,GAAI+iI,EAASxB,EAAU0B,GAEhG,cAID,CACL,IAAI/tI,EAAO0K,EAAc1K,KAAKgL,WAAW1J,KACzC,GAAI+qI,EAAS9xF,IAAIv6C,GAAO,CACtB,IAAIq3B,EAAcjsB,OAAOihI,EAAS7xF,IAAIx6C,KAClCq3B,GAAe,EAAAD,KAAKoD,MAASuzG,EAAmBxzF,IAAIv6C,IAASq3B,EAAY8hB,eAAep4C,KAC1FsrI,EAASrgI,IAAIhM,EAAMe,UAIpB,GAAI+I,EAAKjK,MAAQ,EAAAN,SAAS0L,aAAc,CAC7C,IAAIC,EAAqCpB,EACrCqB,EAAiBD,EAAiB5K,WACtC,GAAuB,OAAnB6K,GAA2BA,EAAeN,OAAS,EAAG,CACxD,IAAIkvC,EAAqBh5C,EAAKg5C,mBAC9B,GAAIA,EAAoB,CACtB,IAAI/D,EAAiB+D,EAAmB/D,eACpCD,EAAWgE,EAAmBhE,SAClC,GAAIC,EAAenrC,QAAUM,EAAeN,SAAWkrC,IAAa7qC,EAAiB1K,iBAAkB,CACrG,IAAK,IAAIsK,EAAI,EAAGC,EAAIirC,EAAenrC,OAAQC,EAAIC,IAAKD,EAClDzL,KAAK6uI,8BAA8B/iI,EAAeL,GAAG/J,KAAMi1C,EAAelrC,GAAI+iI,EAASxB,EAAU0B,GAInG,OAFA1uI,KAAK6uI,8BAA8BhjI,EAAiB3K,WAAYw5C,EAAmBx5C,WAAYstI,EAASxB,EAAU0B,QAC9Gh4F,GAAU12C,KAAK6uI,8BAA8BhjI,EAAiB1K,iBAAmBu1C,EAAU83F,EAASxB,EAAU0B,QAS5Hr+D,iBAAiBl2B,GACf,IAAI35C,EAAO25C,EAAQ35C,KACnB,GAAIA,GAAQ,EAAA21C,YAAYhpC,SACjBnN,KAAKkvI,yBAAiC/0F,EAASE,EAAWC,SAAU,OAAO,KAElF,IAAI,IAAA60F,gBAAe3uI,GAAO,CACxB,IAAIkB,EAAsBy4C,EAASz4C,KAC/Bk4C,EAAiBl4C,EAAKm5C,kBAAkB76C,KAAKw1C,SACjD,GAAIoE,EAAgB,CAClB,IAAIwrF,EAAcxrF,EAAewrF,YAC7BA,IAAa1jI,EAAO0jI,GAE1B,OAAO1jI,EAET,OAAO,KAIT0tI,iBAAiB1tI,GACf,IAAIk4C,EAAiBl4C,EAAKm5C,kBAAkB76C,KAAKw1C,SACjD,OAAIoE,GACG,KAMTQ,iBAEE3vC,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,KAAOh6E,EAAKjK,MAAQ,EAAAN,SAASsP,eAC3B/E,EAAiCA,EAAMjI,WAEzC,OAAQiI,EAAKjK,MACX,KAAK,EAAAN,SAASqO,UACZ,OAAOvO,KAAKqvI,0BACW5kI,EACrB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASsO,OACZ,OAAOxO,KAAKsvI,uBACQ7kI,EAClB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASwK,KACZ,OAAO1K,KAAKuvI,qBACM9kI,EAChB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS8O,MACZ,OAAOhP,KAAKwvI,sBACO/kI,EACjB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASgP,cACZ,OAAOlP,KAAKyvI,8BACehlI,EACzB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASiP,SACZ,OAAOnP,KAAK0vI,yBACUjlI,EACpB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS2M,WACd,KAAK,EAAA3M,SAASqK,MACd,KAAK,EAAArK,SAASmK,KACd,KAAK,EAAAnK,SAASoK,KACZ,OAAOtK,KAAKk9E,2BACYzyE,EACtB+jI,EAASA,EAAQx/E,eAAgBi+E,GAGrC,KAAK,EAAA/sI,SAAS2K,KACZ,OAAO7K,KAAK2vI,qBACMllI,EAChB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS6K,MACZ,OAAO/K,KAAK4vI,sBACOnlI,EACjB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASkP,WACZ,OAAOpP,KAAK6vI,2BACYplI,EACtB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS4J,QACZ,OAAO9J,KAAK8vI,wBACSrlI,EACnB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASmP,IACZ,OAAOrP,KAAK+vI,oBACKtlI,EACf+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASyK,eACZ,OAAO3K,KAAKgwI,+BACgBvlI,EAC1B+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASwP,QACZ,OAAO1P,KAAKiwI,wBACSxlI,EACnB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS2P,aACZ,OAAO7P,KAAKkwI,6BACczlI,EACxB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS4P,YACZ,OAAO9P,KAAKmwI,4BACa1lI,EACvB+jI,EAAS/rD,EAASwqD,GAKxB,OADAlhI,QAAO,GACA,KAIT4vE,kBAEElxE,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,KAAOh6E,EAAKjK,MAAQ,EAAAN,SAASsP,eAC3B/E,EAAiCA,EAAMjI,WAEzC,OAAQiI,EAAKjK,MACX,KAAK,EAAAN,SAASqO,UACZ,OAAOvO,KAAKowI,2BACW3lI,EACrB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASsO,OACZ,OAAOxO,KAAKqwI,wBACQ5lI,EAClB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASwK,KACZ,OAAO1K,KAAKswI,sBACM7lI,EAChB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS8O,MACZ,OAAOhP,KAAKuwI,uBACO9lI,EACjB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASgP,cACZ,OAAOlP,KAAKwwI,+BACe/lI,EACzB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASiP,SACZ,OAAOnP,KAAKywI,0BACUhmI,EACpB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS2M,WACd,KAAK,EAAA3M,SAASqK,MACd,KAAK,EAAArK,SAASmK,KACd,KAAK,EAAAnK,SAASoK,KACZ,OAAOtK,KAAK0wI,4BACYjmI,EACtB+jI,EAAS/rD,EAAS+rD,EAAQx/E,eAAgBi+E,GAG9C,KAAK,EAAA/sI,SAAS2K,KACZ,OAAO7K,KAAK2wI,sBACMlmI,EAChB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS6K,MACZ,OAAO/K,KAAK4wI,uBACOnmI,EACjB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASkP,WACZ,OAAOpP,KAAK6wI,4BACYpmI,EACtB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS4J,QACZ,OAAO9J,KAAK8wI,yBACSrmI,EACnB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASmP,IACZ,OAAOrP,KAAK+wI,qBACKtmI,EACf+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASyK,eACZ,OAAO3K,KAAKgxI,gCACgBvmI,EAC1B+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAASwP,QACZ,OAAO1P,KAAKixI,yBACSxmI,EACnB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS2P,aACZ,OAAO7P,KAAKkxI,8BACczmI,EACxB+jI,EAAS/rD,EAASwqD,GAGtB,KAAK,EAAA/sI,SAAS4P,YACZ,OAAO9P,KAAKmxI,6BACa1mI,EACvB+jI,EAAS/rD,EAASwqD,GAKxB,OADAlhI,QAAO,GACA,KAITmxE,2BAEEzyE,EAEA+jI,EAEAzB,EAAsByB,EAAQx/E,eAE9Bi+E,EAAyB5yF,EAAWoqC,QAEpC,OAAQh6E,EAAKjK,MACX,KAAK,EAAAN,SAASoK,KACd,KAAK,EAAApK,SAASqK,MACd,KAAK,EAAArK,SAASmK,KAAM,CAClB,IAAI3I,EAAO1B,KAAK0wI,4BAA4BjmI,EAAM+jI,EAAS,EAAAz2G,KAAKoD,KAAM4xG,EAAYE,GAClF,OAAOvrI,EAAO1B,KAAKovI,iBAAiB1tI,GAAQ,MAGhD,IACIy4C,EADAx5C,EAAO8J,EAAKxI,KAEhB,GAAIk4C,EAAUq0F,EAAQp7E,OAAOzyD,GAG3B,OAFAX,KAAKuwE,sBAAwB,KAC7BvwE,KAAKwwE,yBAA2B,KACzBr2B,EAET,IAAI+mB,EAAYstE,EAAQjyD,MACxB,OAAIrb,IACE/mB,EAAU+mB,EAAU9N,OAAOzyD,MAM7Bw5C,EAAU4yF,EAAW35E,OAAOzyD,MAK5Bw5C,EAAUn6C,KAAKw1C,QAAQ4d,OAAOzyD,KAV9BX,KAAKuwE,sBAAwB,KAC7BvwE,KAAKwwE,yBAA2B,KACzBr2B,IAaP8yF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey5C,mBACfznE,EAAKhK,MAAOE,GAGT,MAID+vI,4BAENjmI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB4xG,EAAsByB,EAAQx/E,eAE9Bi+E,EAAyB5yF,EAAWoqC,QAEpC,OAAQh6E,EAAKjK,MACX,KAAK,EAAAN,SAASoK,KACd,KAAK,EAAApK,SAASqK,MAAO,OAAO,EAAAwtB,KAAKpe,KACjC,KAAK,EAAAzZ,SAASmK,KAAM,CAClB,IAAIuvC,EAAiB6oC,EAAQ5oC,WAC7B,GAAID,EACF,OAAOA,EAAel4C,KAAKi7E,aACtB,CACL,IAAIjiC,EAAqB+nC,EAAQjnC,eACjC,GAAId,EACF,OAAOA,EAAmBh5C,KAAKi7E,aAC1B,GAAI8F,EAAQva,oBACjB,OAAOua,EAGX,OAAOziF,KAAKw1C,QAAQnd,QAAQkD,WAGhC,IAAI4e,EAAUn6C,KAAKk9E,2BAA2BzyE,EAAM+jI,EAASzB,EAAYE,GACzE,IAAK9yF,EAAS,OAAO,KACrB,GAAIA,EAAQ35C,MAAQ,EAAA21C,YAAYC,mBAAoB,CAClD,IAAId,EAAWt1C,KAAKs2C,gBAAmC6D,EAAS,MAAM,IAAAirB,aAA0B6nE,GAChG,IAAK33F,EAAU,OAAO,KACtB6E,EAAU7E,EAEZ,IAAI5zC,EAAO1B,KAAKqwE,iBAAiBl2B,GASjC,OARKz4C,GACCurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey9C,2CACfzrE,EAAKhK,OAIJiB,EAIDwtI,yBAAyBnuF,EAAgBksF,EAAyB5yF,EAAWoqC,QACnF,GAAI1jC,EAAOv0C,GAAG,EAAAF,YAAY0rD,UAAW,OAAO,EAC5C,IAAIt2D,EACAo2D,EAAW/W,EAAO+W,SAMtB,SAJEp2D,EADEo2D,EACK93D,KAAKk4D,YAAYJ,EAAU/W,EAAO5J,OAAQ,KAAM81F,GAEhDjtI,KAAK27E,kBAAkB5vE,OAAOg1C,EAAOgX,iBAAkBhX,EAAOqO,KAAK+H,cAAc99B,KAAM,EAAAtB,KAAKoD,KAAM8xG,MAG3GlsF,EAAOsX,QAAQ32D,IACR,GAIDsuI,+BAENvlI,EAEA+jI,EAEA/rD,EAEAwqD,EAAyB5yF,EAAWoqC,QAEpC,IAAI2sD,EAAa3mI,EAAKjI,WAClBknD,EAAS1pD,KAAKo6C,iBAAiBg3F,EAAY5C,EAAS/rD,EAASwqD,GACjE,IAAKvjF,EAAQ,OAAO,KACpB,IAAI2nF,EAAe5mI,EAAKnG,SAASrC,KAGjC,OAAQynD,EAAOlpD,MACb,KAAK,EAAA21C,YAAYhpC,OAAQ,IAAKnN,KAAKkvI,yBAAiCxlF,EAAQujF,GAAa,OAAO,KAChG,KAAK,EAAA92F,YAAYue,UACjB,KAAK,EAAAve,YAAYq9B,MACjB,KAAK,EAAAr9B,YAAYe,MAAO,CACtB,IAAIo6F,EAA2C5nF,EAC3ChoD,EAAO4vI,EAAoB5vI,KAC/BqK,OAAOrK,GAAQ,EAAAq2B,KAAKsH,MACpB,IAAIua,EAAiBl4C,EAAKm5C,kBAAkB76C,KAAKw1C,SACjD,IAAKoE,EAOH,OANIqzF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe6oD,oCACf72E,EAAKnG,SAAS7D,MAAO4wI,EAAcC,EAAoB5vI,KAAKk3B,YAGzD,KAET8wB,EAAS9P,EACT,MAEF,KAAK,EAAAzD,YAAYge,mBAAoB,CACnC,IAAIC,EAAmBp0D,KAAK42D,gBAAmClN,EAAQujF,GACvE,IAAK74E,EAAkB,OAAO,KAC9B1K,EAAS0K,EAGX,KAAK,EAAAje,YAAY8e,SAAU,CACzB,IAEIvzD,EADiBqK,OADY29C,EACYwL,gBACnB7sD,UAAUnH,WAChC04C,EAAiBl4C,EAAKm5C,kBAAkB76C,KAAKw1C,SACjD,IAAKoE,EAOH,OANIqzF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe6oD,oCACf72E,EAAKnG,SAAS7D,MAAO4wI,EAAc3vI,EAAKk3B,YAGrC,KAET8wB,EAAS9P,EACT,MAEF,KAAK,EAAAzD,YAAYlkC,eAAgB,CAC/B,IACIklC,EADiCuS,EACTvS,OAC5BprC,OAAOorC,EAAO32C,MAAQ,EAAA21C,YAAYpnC,OAClC,IAAI+vC,EAAuB3H,EACvB9zC,EAAoB0I,OAAO/L,KAAKwwE,0BAChCoL,EAAa98B,EAAcysB,eAAe,EAAAC,aAAawI,aAC3D,IAAK4H,EAOH,OANIqxD,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey7C,qCACf7wE,EAAkB5C,MAAO02C,EAAOtB,cAG7B,KAET,IAAI30C,EAAa06E,EAAWvzE,UAAUnH,WAClC04C,EAAiB14C,EAAW25C,kBAAkB76C,KAAKw1C,SACvD,IAAKoE,EAOH,OANIqzF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe6oD,oCACf72E,EAAKnG,SAAS7D,MAAO4wI,EAAcnwI,EAAW03B,YAG3C,KAET8wB,EAAS9P,EACT,MAEF,KAAK,EAAAzD,YAAYC,mBAAoB,CAEnC,IAAIkyF,EAAa5+E,EAAO4+E,WACxB,GAAIA,EAAY,CACd,IAAKA,EAAW97H,GAAG,EAAAF,YAAY0rD,UAAW,CACxC,IAAIC,EAAej4D,KAAKk4D,YAAYowE,EAAWxwE,SAAUwwE,EAAWnxF,OAAQ,KAAM81F,GAC9Eh1E,GAAcqwE,EAAWjwE,QAAQJ,GAEvC,IAAIre,EAAiB0uF,EAAW5mI,KAAKk4C,eACjCA,IAAgB8P,EAAS9P,EAAejB,WAC5C,MACK,IAAK+Q,EAAOl9C,GAAG,EAAAF,YAAYsnD,SAAU,CAG1C,IADgBlK,EAAOxT,UAAUm7F,GACjB,CACd,IAAIx8E,EAAmB70D,KAAKs2C,gBAAmCoT,EAAQ,MAAM,IAAA0b,aAA0B/qB,EAAWC,SAClH,GAAIua,EAAkB,CACpB,IAAI08E,EAAU18E,EAAiBnzD,KAAKm5C,kBAAkB76C,KAAKw1C,SACvD+7F,IAAS7nF,EAAS6nF,KAI5B,OAKJ,OAAQ7nF,EAAOlpD,MACb,KAAK,EAAA21C,YAAY6d,gBACjB,KAAK,EAAA7d,YAAY4f,oBACjB,KAAK,EAAA5f,YAAYpnC,MACjB,KAAK,EAAAonC,YAAYslB,UACf,OAAG,CACD,IAAIxkB,EAASyS,EAAOxT,UAAUm7F,GAC9B,GAAIp6F,EAAQ,CACV,GAAIA,EAAOz2C,MAAQ,EAAA21C,YAAYge,mBAAoB,CACjD,IAAIC,EAAmBp0D,KAAK42D,gBAAmC3f,EAAQg2F,GACvE,IAAK74E,EAAkB,OAAO,KAC9Bnd,EAASmd,EACLA,EAAiB5nD,GAAG,EAAAF,YAAYgoD,QAClCt0D,KAAKuwE,sBAAwB,KAE7BvwE,KAAKuwE,sBAAwB6gE,OAG/BpxI,KAAKuwE,sBAAwB6gE,EAG/B,OADApxI,KAAKwwE,yBAA2B,KACzBv5B,EAGT,GACEyS,EAAOlpD,MAAQ,EAAA21C,YAAY6d,iBAC3BtK,EAAOlpD,MAAQ,EAAA21C,YAAY4f,oBAC3B,CACA,IACI8sE,EADiCn5E,EACFm5E,cACnC,IAAIA,EAGF,MAFAn5E,EAASm5E,MAKN,IACLn5E,EAAOlpD,MAAQ,EAAA21C,YAAYpnC,OAC3B26C,EAAOlpD,MAAQ,EAAA21C,YAAYslB,UAU3B,MATA,CACA,IACI+1E,EADuB9nF,EACM/T,KACjC,IAAI67F,EAGF,MAFA9nF,EAAS8nF,IAQf,MAEF,QAAS,CACP,IAAIv6F,EAASyS,EAAOxT,UAAUm7F,GAC9B,GAAIp6F,EAGF,OAFAj3C,KAAKuwE,sBAAwB6gE,EAC7BpxI,KAAKwwE,yBAA2B,KACzBv5B,EAET,OAUJ,OANIg2F,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe6oD,oCACf72E,EAAKnG,SAAS7D,MAAO4wI,EAAc3nF,EAAO7T,cAGvC,KAIDm7F,gCAENvmI,EAEA+jI,EAEA/rD,EAEAwqD,EAAyB5yF,EAAWoqC,QAEpC,IAAItqC,EAAUn6C,KAAKgwI,+BAA+BvlI,EAAM+jI,EAAS/rD,EAASwqD,GAC1E,IAAK9yF,EAAS,OAAO,KACrB,IAAIz4C,EAAO1B,KAAKqwE,iBAAiBl2B,GASjC,OARKz4C,GACCurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey9C,2CACfzrE,EAAKhK,OAIJiB,EAID+tI,8BAENhlI,EAEA+jI,EAEA/rD,EAEAwqD,EAAyB5yF,EAAWoqC,QAEpC,IAAI/I,EAAmBjxE,EAAKjI,WACxB4tE,EAAapwE,KAAK27E,kBAAkBD,EAAkB8yD,EAAS/rD,EAASwqD,GAC5E,IAAK78D,EAAY,OAAO,KACxB,IAAIx2B,EAAiBw2B,EAAWv1B,kBAAkB76C,KAAKw1C,SACvD,GAAIoE,EACF,EAAG,CACD,IAAItnC,EAAiBsnC,EAAetnC,eACpC,GAAIA,EAGF,OAFAtS,KAAKuwE,sBAAwBmL,EAC7B17E,KAAKwwE,yBAA2B/lE,EAAKpH,kBAC9BiP,EAETsnC,EAAiBA,EAAejE,WAC1BiE,GAQV,OANIqzF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey7C,qCACfwH,EAAiBj7E,MAAO2vE,EAAWx3C,YAGhC,KAID43G,+BAEN/lI,EAEA+jI,EAEA/rD,EAEAwqD,EAAyB5yF,EAAWoqC,QAEpC,IAAItqC,EAAUn6C,KAAKyvI,8BAA8BhlI,EAAM+jI,EAAS/rD,EAASwqD,GACzE,IAAK9yF,EAAS,OAAO,KACrB,IAAIz4C,EAAO1B,KAAKqwE,iBAAiBl2B,GASjC,OARKz4C,GACCurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey9C,2CACfzrE,EAAKhK,OAIJiB,EAIT08E,4BAEED,EAEAsE,GAEA,GAAIA,EAAQxqD,QAEV,OAAQwqD,EAAQjiF,MACd,KAAK,EACH,GAAIixI,UAAUtzD,GAAW,OAAO,EAAApmD,KAAK9e,GACrC,MAEF,KAAK,EACH,GAAIy4H,UAAUvzD,GAAW,OAAO,EAAApmD,KAAKze,GACrC,MAEF,KAAK,EACH,GAAIq4H,WAAWxzD,GAAW,OAAO,EAAApmD,KAAK7e,IACtC,MAEF,KAAK,EACH,GAAI04H,WAAWzzD,GAAW,OAAO,EAAApmD,KAAKxe,IACtC,MAEF,KAAK,EACH,GAAI2/B,WAAWilC,GAAW,OAAO,EAAApmD,KAAK5e,IACtC,MAEF,KAAK,EACH,GAAIigC,WAAW+kC,GAAW,OAAO,EAAApmD,KAAKve,IACtC,MAEF,KAAK,GACH,GAAIq4H,YAAY1zD,GAAW,OAAO,EAAApmD,KAAKpe,KACvC,MAEF,KAAK,EACH,IAAK3Z,KAAKw1C,QAAQnd,QAAQC,SAAU,CAClC,GAAI4gB,WAAWilC,GAAW,OAAO,EAAApmD,KAAKyzB,QACtC,MAEF,OAAO,EAAAzzB,KAAKwzB,QAEd,KAAK,EACH,IAAKvrD,KAAKw1C,QAAQnd,QAAQC,SAAU,CAClC,GAAI8gB,WAAW+kC,GAAW,OAAO,EAAApmD,KAAKmgB,QACtC,MAEF,OAAO,EAAAngB,KAAKggB,QAEd,KAAK,EAAc,OAAO,EAAAhgB,KAAK3e,IAC/B,KAAK,EAAc,OAAO,EAAA2e,KAAKte,IAC/B,KAAK,GAAc,OAAO,EAAAse,KAAKne,IAC/B,KAAK,GAAc,OAAO,EAAAme,KAAKle,IAInC,OAAIq/B,WAAWilC,GAAkB,EAAApmD,KAAK5e,IAClCigC,WAAW+kC,GAAkB,EAAApmD,KAAKve,IAC/B,EAAAue,KAAK3e,IAINi2H,0BAEN5kI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,OAAQh6E,EAAKlI,eACX,KAAK,EAAA+L,cAAcm8D,GACnB,KAAK,EAAAn8D,cAAck8D,OAAQ,CACzB,IAAI9oE,EAAO1B,KAAKk4D,YACdnsD,OAAOtB,EAAKhI,QACZ+rI,EAAQx/E,eACRw/E,EAAQnpE,wBACR4nE,GAEF,IAAKvrI,EAAM,OAAO,KAClB,IAAIy4C,EAAUn6C,KAAKovI,iBAAiB1tI,GACpC,OAAIy4C,IACA8yF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAeq5G,kCACfrnI,EAAKhK,MAAOiB,EAAKk3B,YAGrB54B,KAAKuwE,sBAAwB,KAC7BvwE,KAAKwwE,yBAA2B,KACzB,MAET,KAAK,EAAAliE,cAAco8D,QACjB,OAAO1qE,KAAKo6C,iBAAiB3vC,EAAKjI,WAAYgsI,EAAS/rD,EAASwqD,GAElE,KAAK,EAAA3+H,cAAc+lD,MAajB,OALAr0D,KAAKw4B,MACH,EAAAC,eAAemnB,kBACfn1C,EAAKhK,MACL,mBAEK,KAIX,OADAsL,QAAO,GACA,KAIDqkI,2BAEN3lI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,OAAQh6E,EAAKlI,eACX,KAAK,EAAA+L,cAAcm8D,GACnB,KAAK,EAAAn8D,cAAck8D,OACjB,OAAOxqE,KAAKk4D,YACVnsD,OAAOtB,EAAKhI,QACZ+rI,EAAQx/E,eACRw/E,EAAQnpE,wBACR4nE,GAGJ,KAAK,EAAA3+H,cAAco8D,QAAS,CAC1B,IAAIhpE,EAAO1B,KAAK27E,kBAAkBlxE,EAAKjI,WAAYgsI,EAAS/rD,EAASwqD,GACrE,OAAOvrI,EAAOA,EAAKk8C,gBAAkB,KAEvC,KAAK,EAAAtvC,cAAc+lD,MAAO,CACxB,IAAIla,EAAUn6C,KAAKo6C,iBAAiB3vC,EAAM+jI,EAAS/rD,EAASwqD,GAC5D,IAAK9yF,EAAS,OAAO,KACrB,IAAIz4C,EAAO1B,KAAKqwE,iBAAiBl2B,GASjC,OARKz4C,GACCurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey9C,2CACfzrE,EAAKhK,OAIJiB,EAET,QAASqK,QAAO,GAElB,OAAO,KAIDokI,4BAEN1lI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAI/iF,EAAO1B,KAAKmxI,6BAA6B1mI,EAAM+jI,EAAS/rD,EAASwqD,GACrE,IAAKvrI,EAAM,OAAO,KAClB,IAAIy4C,EAAUn6C,KAAKovI,iBAAiB1tI,GASpC,OARKy4C,GACC8yF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe40C,2CACf5iE,EAAKhK,OAAO,IAAAisE,uBAAsBjiE,EAAK9H,UAAWjB,EAAKk3B,YAItDuhB,EAIDg3F,6BAEN1mI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAIl/E,EAAUkF,EAAKlF,QACf5C,EAAW8H,EAAK9H,SACpB,OAAQA,GACN,KAAK,EAAAyoE,MAAMmC,MAET,GAAIhoE,EAAQqE,cAAc,EAAAxJ,YAAY8J,SACpC,OAAOlK,KAAKo+E,4BAA4BhiE,QAAQwqD,SAAqCrhE,EAAS/B,OAAQi/E,GAI1G,KAAK,EAAArX,MAAM+B,KACX,KAAK,EAAA/B,MAAMiY,UACX,KAAK,EAAAjY,MAAMqY,YAAa,CACtB,IAAI/hF,EAAO1B,KAAK27E,kBAAkBp2E,EAASipI,EAAS/rD,EAASwqD,GAC7D,IAAKvrI,EAAM,OAAO,KAClB,IAAIk4C,EAAiBl4C,EAAKm5C,kBAAkB76C,KAAKw1C,SACjD,GAAIoE,EAAgB,CAClB,IAAI0xB,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAamwD,qBAAqBh5H,IAC/E,GAAI2oE,EAAU,OAAOA,EAASjjE,UAAUnH,WAE1C,OAAKQ,EAAKg+B,eASHh+B,GARDurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe40C,2CACf5iE,EAAKhK,OAAO,IAAAisE,uBAAsB/pE,GAAWjB,EAAKk3B,YAG/C,MAIX,KAAK,EAAAwyC,MAAM4Y,YAAa,CACtB,IAAItiF,EAAO1B,KAAK27E,kBAAkBp2E,EAASipI,EAAS/rD,EAASwqD,GAC7D,IAAKvrI,EAAM,OAAO,KAClB,IAAIk4C,EAAiBl4C,EAAKm5C,kBAAkB76C,KAAKw1C,SACjD,GAAIoE,EAAgB,CAClB,IAAI0xB,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAayY,KAC1D,GAAI3Y,EAAU,OAAOA,EAASjjE,UAAUnH,WAE1C,OAAO,EAAA62B,KAAKpe,KAEd,KAAK,EAAAyxD,MAAM8Y,MAAO,CAChB,IAAIxiF,EAAO1B,KAAK27E,kBAAkBp2E,EAASipI,EAAS/rD,EAASwqD,GAC7D,IAAKvrI,EAAM,OAAO,KAClB,IAAIk4C,EAAiBl4C,EAAKm5C,kBAAkB76C,KAAKw1C,SACjD,GAAIoE,EAAgB,CAClB,IAAI0xB,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAa2Y,aAC1D,GAAI7Y,EAAU,OAAOA,EAASjjE,UAAUnH,WAE1C,OAAKQ,EAAKg+B,eASHh+B,EAAK+sE,SARNw+D,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe40C,2CACf5iE,EAAKhK,MAAO,IAAKiB,EAAKk3B,YAGnB,MAIX,KAAK,EAAAwyC,MAAMmZ,YAOT,OANI0oD,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAemnB,kBACfn1C,EAAKhK,MAAO,mBAGT,KAET,QAASsL,QAAO,GAElB,OAAO,KAIDmkI,6BAENzlI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAI/iF,EAAO1B,KAAKkxI,8BAA8BzmI,EAAM+jI,EAAS/rD,EAASwqD,GACtE,IAAKvrI,EAAM,OAAO,KAClB,IAAIy4C,EAAUn6C,KAAKovI,iBAAiB1tI,GASpC,OARKy4C,GACC8yF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe40C,2CACf5iE,EAAKhK,OAAO,IAAAisE,uBAAsBjiE,EAAK9H,UAAWjB,EAAKk3B,YAItDuhB,EAID+2F,8BAENzmI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAI9hF,EAAW8H,EAAK9H,SACpB,OAAQA,GACN,KAAK,EAAAyoE,MAAMiY,UACX,KAAK,EAAAjY,MAAMqY,YAAa,CACtB,IAAI/hF,EAAO1B,KAAK27E,kBAAkBlxE,EAAKlF,QAASipI,EAAS/rD,EAASwqD,GAClE,IAAKvrI,EAAM,OAAO,KAClB,IAAIk4C,EAAiBl4C,EAAKm5C,kBAAkB76C,KAAKw1C,SACjD,GAAIoE,EAAgB,CAClB,IAAI0xB,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAaowD,sBAAsBj5H,IAChF,GAAI2oE,EAAU,OAAOA,EAASjjE,UAAUnH,WAE1C,OAAKQ,EAAKg+B,eASHh+B,GARDurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe40C,2CACf5iE,EAAKhK,OAAO,IAAAisE,uBAAsB/pE,GAAWjB,EAAKk3B,YAG/C,OAMb,OADA7sB,QAAO,GACA,KAIDujI,uBAEN7kI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAI/iF,EAAO1B,KAAKqwI,wBAAwB5lI,EAAM+jI,EAAS/rD,EAASwqD,GAChE,IAAKvrI,EAAM,OAAO,KAClB,IAAIy4C,EAAUn6C,KAAKovI,iBAAiB1tI,GACpC,OAAIy4C,IACA8yF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAeq5G,kCACfrnI,EAAKhK,MAAOiB,EAAKk3B,YAGd,MAIDy3G,wBAEN5lI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAI7hF,EAAO6H,EAAK7H,KACZC,EAAQ4H,EAAK5H,MACbF,EAAW8H,EAAK9H,SAEpB,OAAQA,GAIN,KAAK,EAAAyoE,MAAM4B,OACX,KAAK,EAAA5B,MAAM8B,YACX,KAAK,EAAA9B,MAAMkC,aACX,KAAK,EAAAlC,MAAMqC,gBACX,KAAK,EAAArC,MAAMwC,yBACX,KAAK,EAAAxC,MAAM4C,aACX,KAAK,EAAA5C,MAAM+C,eACX,KAAK,EAAA/C,MAAMmD,yBACX,KAAK,EAAAnD,MAAMwD,+BACX,KAAK,EAAAxD,MAAM4D,2CACX,KAAK,EAAA5D,MAAMgE,iBACX,KAAK,EAAAhE,MAAMoE,WACX,KAAK,EAAApE,MAAMwE,aACT,OAAO5vE,KAAK27E,kBAAkB/4E,EAAM4rI,EAAS/rD,EAASwqD,GAKxD,KAAK,EAAA7hE,MAAMC,SACX,KAAK,EAAAD,MAAMU,YACX,KAAK,EAAAV,MAAMa,gBACX,KAAK,EAAAb,MAAMgB,mBAAoB,CAC7B,IAAIrB,EAAW/qE,KAAK27E,kBAAkB/4E,EAAM4rI,EAAS/rD,EAASwqD,GAC9D,IAAKliE,EAAU,OAAO,KACtB,IAAInxB,EAAiBmxB,EAASlwB,kBAAkB76C,KAAKw1C,SACrD,GAAIoE,EAAgB,CAClB,IAAI0xB,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAakwD,gBAAgB/4H,IAC1E,GAAI2oE,EAAU,OAAOA,EAASjjE,UAAUnH,WAE1C,OAAK6pE,EAASrrC,eASP,EAAA3H,KAAKpe,MARNszH,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe40C,2CACf5iE,EAAKhK,OAAO,IAAAisE,uBAAsB/pE,GAAWooE,EAASnyC,YAGnD,MAOX,KAAK,EAAAwyC,MAAMoB,cACX,KAAK,EAAApB,MAAMyB,mBAAoB,CAC7B,IAAI9B,EAAW/qE,KAAK27E,kBAAkB/4E,EAAM4rI,EAAS/rD,EAASwqD,GAC9D,IAAKliE,EAAU,OAAO,KACtB,IAAInxB,EAAiBmxB,EAASlwB,kBAAkB76C,KAAKw1C,SACrD,GAAIoE,EAAgB,CAClB,IAAI0xB,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAakwD,gBAAgB/4H,IAC1E,GAAI2oE,EAAU,OAAOA,EAASjjE,UAAUnH,WAE1C,OAAO,EAAA62B,KAAKpe,KAKd,KAAK,EAAAyxD,MAAMmB,qBACX,KAAK,EAAAnB,MAAMwB,0BACT,OAAO,EAAA70C,KAAKpe,KAKd,KAAK,EAAAyxD,MAAM+B,KACX,KAAK,EAAA/B,MAAMmC,MACX,KAAK,EAAAnC,MAAMsC,SACX,KAAK,EAAAtC,MAAM6C,MACX,KAAK,EAAA7C,MAAMgD,QACX,KAAK,EAAAhD,MAAMyC,kBAAmB,CAC5B,IAAI9C,EAAW/qE,KAAK27E,kBAAkB/4E,EAAM4rI,EAAS/rD,EAASwqD,GAC9D,IAAKliE,EAAU,OAAO,KACtB,IAAInxB,EAAiBmxB,EAASlwB,kBAAkB76C,KAAKw1C,SACrD,GAAIoE,EAAgB,CAClB,IAAI0xB,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAakwD,gBAAgB/4H,IAC1E,GAAI2oE,EAAU,OAAOA,EAASjjE,UAAUnH,WAE1C,IAAI+pE,EAAYjrE,KAAK27E,kBAAkB94E,EAAO2rI,EAASzjE,EAAUkiE,GACjE,IAAKhiE,EAAW,OAAO,KACvB,IAAIC,EAAa,EAAAnzC,KAAK4zC,kBAAkBZ,EAAUE,GAAW,GAS7D,OARKC,GACC+hE,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAemzC,8CACfnhE,EAAKhK,MAAOsqE,EAASnyC,WAAYqyC,EAAUryC,YAI1CsyC,EAKT,KAAK,EAAAE,MAAMoD,kBACX,KAAK,EAAApD,MAAMyD,wBACX,KAAK,EAAAzD,MAAM6D,oCAAqC,CAC9C,IAAIlE,EAAW/qE,KAAK27E,kBAAkB/4E,EAAM4rI,EAAS/rD,EAASwqD,GAC9D,IAAKliE,EAAU,OAAO,KACtB,IAAInxB,EAAiBmxB,EAASlwB,kBAAkB76C,KAAKw1C,SACrD,GAAIoE,EAAgB,CAClB,IAAI0xB,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAakwD,gBAAgB/4H,IAC1E,GAAI2oE,EAAU,OAAOA,EAASjjE,UAAUnH,WAE1C,OAAK6pE,EAASnsC,eASPmsC,GARDkiE,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe40C,2CACf5iE,EAAKhK,OAAO,IAAAisE,uBAAsB/pE,GAAWooE,EAASnyC,YAGnD,MAOX,KAAK,EAAAwyC,MAAMiE,UACX,KAAK,EAAAjE,MAAMqE,IACX,KAAK,EAAArE,MAAMyE,MAAO,CAChB,IAAI9E,EAAW/qE,KAAK27E,kBAAkB/4E,EAAM4rI,EAAS/rD,EAASwqD,GAC9D,IAAKliE,EAAU,OAAO,KACtB,IAAInxB,EAAiBmxB,EAASlwB,kBAAkB76C,KAAKw1C,SACrD,GAAIoE,EAAgB,CAClB,IAAI0xB,EAAW1xB,EAAe2xB,eAAe,EAAAC,aAAakwD,gBAAgB/4H,IAC1E,GAAI2oE,EAAU,OAAOA,EAASjjE,UAAUnH,WAE1C,IAAI+pE,EAAYjrE,KAAK27E,kBAAkB94E,EAAO2rI,EAAS/rD,EAASwqD,GAChE,IAAKhiE,EAAW,OAAO,KACvB,IAAIC,EAAa,EAAAnzC,KAAK4zC,kBAAkBZ,EAAUE,GAAW,GAS7D,OARKC,GAAeA,EAAWtsC,gBACzBquG,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAemzC,8CACfnhE,EAAKhK,OAAO,IAAAisE,uBAAsB/pE,GAAWooE,EAASnyC,WAAYqyC,EAAUryC,YAI3EsyC,EAKT,KAAK,EAAAE,MAAM4E,oBACX,KAAK,EAAA5E,MAAM+E,QACT,OAAOnwE,KAAK27E,kBAAkB/4E,EAAM4rI,EAAS/rD,EAASwqD,GAI1D,OADAlhI,QAAO,GACA,KAID4jI,qBAENllI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,GAAI+pD,EAAQt0E,SAAU,CACpB,IAAIyB,EAAY6yE,EAAQ5yE,YAAY,EAAArY,YAAYsB,OAChD,GAAI8W,EAGF,OAFA37D,KAAKuwE,sBAAwB,KAC7BvwE,KAAKwwE,yBAA2B,KACzB7U,EAGX,IAAIxkB,EAASq3F,EAAQx/E,eAAe7X,OACpC,OAAIA,GACFn3C,KAAKuwE,sBAAwB,KAC7BvwE,KAAKwwE,yBAA2B,KACzBr5B,IAEL81F,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAeinB,+CACfj1C,EAAKhK,OAGF,MAIDkwI,sBAENlmI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAItqC,EAAUn6C,KAAK2vI,qBAAqBllI,EAAM+jI,EAAS/rD,EAASwqD,GAChE,IAAK9yF,EAAS,OAAO,KACrB,IAAIz4C,EAAO1B,KAAKqwE,iBAAiBl2B,GASjC,OARKz4C,GACCurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey9C,2CACfzrE,EAAKhK,OAIJiB,EAIDkuI,sBAENnlI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,GAAI+pD,EAAQt0E,SAAU,CACpB,IAAI63E,EAAavD,EAAQ5yE,YAAY,EAAArY,YAAYuB,QACjD,GAAIitF,EAGF,OAFA/xI,KAAKuwE,sBAAwB,KAC7BvwE,KAAKwwE,yBAA2B,KACzBuhE,EAGX,IAAI56F,EAAyBq3F,EAAQx/E,eAAe7X,OACpD,GAAe,OAAXA,GAAmBA,EAAO32C,MAAQ,EAAA21C,YAAYpnC,MAAO,CACvD,IAAI4mC,EAAewB,EAAQxB,KAC3B,GAAIA,EAGF,OAFA31C,KAAKuwE,sBAAwB,KAC7BvwE,KAAKwwE,yBAA2B,KACzB76B,EASX,OANIs3F,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAei9C,iDACfjrE,EAAKhK,OAGF,KAIDmwI,uBAENnmI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAItqC,EAAUn6C,KAAK4vI,sBAAsBnlI,EAAM+jI,EAAS/rD,EAASwqD,GACjE,IAAK9yF,EAAS,OAAO,KACrB,IAAIz4C,EAAO1B,KAAKqwE,iBAAiBl2B,GASjC,OARKz4C,GACCurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey9C,2CACfzrE,EAAKhK,OAIJiB,EAIDouI,wBAENrlI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAIpC,OAFAzkF,KAAKuwE,sBAAwB9lE,EAC7BzK,KAAKwwE,yBAA2B,KACxB/lE,EAAKZ,aACX,KAAK,EAAAzJ,YAAY8J,QAAS,CACxB,IAAIukE,EAAUzuE,KAAKo+E,4BACU3zE,EAAMjH,MACjCi/E,GAEF,OAAO12E,OAAO0iE,EAAQ5zB,kBAAkB76C,KAAKw1C,UAE/C,KAAK,EAAAp1C,YAAY6J,MAAO,CACtB,IAAI+nI,EAAUvvD,GAAW,EAAA1qD,KAAKne,IAAM,EAAAme,KAAKne,IAAM,EAAAme,KAAKle,IACpD,OAAO9N,OAAOimI,EAAQn3F,kBAAkB76C,KAAKw1C,UAE/C,KAAK,EAAAp1C,YAAYgK,OACjB,KAAK,EAAAhK,YAAYuP,SACf,OAAO3P,KAAKw1C,QAAQuE,eAEtB,KAAK,EAAA35C,YAAYiO,MAAO,CACtB,IAAIurC,EAAiB6oC,EAAQ5oC,WAC7B,GAAuB,OAAnBD,GAA2BA,EAAejB,WAAa34C,KAAKw1C,QAAQyE,eACtE,OAAOj6C,KAAKovI,iBAAiB3sD,GAG/B,IAAIv/E,EAAuCuH,EAAMpI,mBAC7CmJ,EAAStI,EAAYsI,OACrBoxC,EAAc,EAAA7kB,KAAKoD,KACnB82G,EAAkB,EACtB,IAAK,IAAIxmI,EAAI,EAAGC,EAAIF,EAAQC,EAAIC,IAAKD,EAAG,CACtC,IAAIjJ,EAAaU,EAAYuI,GAC7B,GAAIjJ,EACF,GAAIA,EAAWhC,MAAQ,EAAAN,SAASmK,MAAQmB,EAAS,IAC7CymI,MACG,CACL,IAAIj6G,EAAch4B,KAAK27E,kBAAkBn5E,EAAYgsI,EAAS5xF,GAC9D,IAAK5kB,EAAa,OAAO,KACzB,GAAI4kB,GAAe,EAAA7kB,KAAKoD,KAAMyhB,EAAc5kB,OACvC,GAAIA,GAAe4kB,EAAa,CACnC,IAAIsuB,EAAa,EAAAnzC,KAAK4zC,kBAAkB/uB,EAAa5kB,GAAa,GAC9DkzC,IAAYtuB,EAAcsuB,KAMtC,GAAItuB,GAA2B,EAAA7kB,KAAKoD,KAAM,CACxC,GAAI82G,GAAmBzmI,EASrB,OANIyhI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey5G,2HACfznI,EAAKhK,MAAO,KAGT,KARPm8C,EAAc58C,KAAKw1C,QAAQnd,QAAQkD,UAiBvC,OALE02G,EAAkB,GAClBr1F,EAAYrB,sBAEZqB,EAAcA,EAAY+/B,cAErB5wE,OAAO/L,KAAK02D,aAAa12D,KAAKw1C,QAAQyE,eAAgB,CAAE2C,KAEjE,KAAK,EAAAx8C,YAAYkP,OACf,OAAImzE,EAAQ0vD,QAAgB1vD,EAAQ7oC,gBAChCqzF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey9C,2CACfzrE,EAAKhK,OAGF,MAIX,OADAsL,QAAO,GACA,KAID+kI,yBAENrmI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAItqC,EAAUn6C,KAAK8vI,wBAAwBrlI,EAAM+jI,EAAS/rD,EAASwqD,GACnE,IAAK9yF,EAAS,OAAO,KACrB,IAAIz4C,EAAO1B,KAAKqwE,iBAAiBl2B,GASjC,OARKz4C,GACCurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey9C,2CACfzrE,EAAKhK,OAIJiB,EAID6tI,qBAEN9kI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKsH,KAErB4tG,EAAyB5yF,EAAWoqC,QAEpC,IAAI/iF,EAAO1B,KAAKswI,sBAAsB7lI,EAAM+jI,EAAS/rD,EAASwqD,GAC9D,IAAKvrI,EAAM,OAAO,KAClB,IAAIy4C,EAAUn6C,KAAKovI,iBAAiB1tI,GASpC,OARKy4C,GACC8yF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAeq5G,kCACfrnI,EAAKhK,MAAOiB,EAAKk3B,YAIhBuhB,EAIDm2F,sBAEN7lI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKsH,KAErB4tG,EAAyB5yF,EAAWoqC,QAEpC,IAAI/I,EAAmBjxE,EAAKjI,WACxBknD,EAAS1pD,KAAKo6C,iBAChBshC,EACA8yD,EACA/rD,EACAwqD,GAEF,IAAKvjF,EAAQ,OAAO,KACpB,OAAQA,EAAOlpD,MACb,KAAK,EAAA21C,YAAYC,mBAAoB,CACnC,IAAIgJ,EAAuCsK,EAE3C,GACEtK,EAAkBvJ,cAAgB,EAAA5gC,aAAanD,WAC/CrH,EAAK5I,KAAK2J,OAAS,EAEnB,OAAOxL,KAAK27E,kBAAkBlxE,EAAK5I,KAAK,GAAI2sI,EAAS/rD,EAASwqD,GAEhE,IAAI33F,EAAWt1C,KAAK+1E,eAAetrE,EAAM20C,EAAmBovF,EAASvB,GACrE,OAAK33F,EACEA,EAASjtC,UAAUnH,WADJ,KAGxB,KAAK,EAAAi1C,YAAYhpC,OACjB,KAAK,EAAAgpC,YAAYq9B,MACjB,KAAK,EAAAr9B,YAAYe,MAAO,CACtB,IAAIk7F,EAAgC1oF,EAAQhoD,KACxC2wI,EAAaryI,KAAKovI,iBAAiBgD,GACvC,IAAKC,GAAcA,EAAW7xI,MAAQ,EAAA21C,YAAYpnC,MAChD,MAEF26C,EAAS2oF,EAGX,KAAK,EAAAl8F,YAAYpnC,MAAO,CACtB,IAAIjO,EAAwB4oD,EAAQlH,mBAAmBxiD,KAAKw1C,QAAQ4J,mBACpE,GAAsB,OAAlBt+C,GAA0BA,EAAc0K,OAAS,EAAG,CACtD,IAAI6zC,EAAQv+C,EAAc,GAE1B,OADyBiL,OAAOszC,EAAM3E,oBACZx5C,WAE5B,OASJ,OANI+rI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAew9C,uGACfyF,EAAiBj7E,MAAOipD,EAAO7T,cAG5B,KAID25F,sBAEN/kI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAIvhF,EAAcuH,EAAKvH,YACvB,OAAOlD,KAAKo6C,iBAAiBl3C,EAAY6I,OAAO7I,EAAYsI,QAAU,GAAIgjI,EAAS/rD,EAASwqD,GAItFsD,uBAEN9lI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,IAAIvhF,EAAcuH,EAAKvH,YACvB,OAAOlD,KAAK27E,kBAAkBz4E,EAAY6I,OAAO7I,EAAYsI,QAAU,GAAIgjI,EAAS/rD,EAASwqD,GAIvF4C,2BAENplI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,OAAO14E,OAAO,EAAAgsB,KAAKpe,KAAKkhC,kBAAkB76C,KAAKw1C,UAIzCq7F,4BAENpmI,EAEA+jI,EAEA/rD,EAAgB,EAAA1qD,KAAKoD,KAErB8xG,EAAyB5yF,EAAWoqC,QAEpC,OAAO,EAAA1sD,KAAKpe,KAINs2H,wBAENxlI,EAEA+jI,EAEA/rD,EAEAwqD,EAAyB5yF,EAAWoqC,QAEpC,IAAI/iF,EAAO1B,KAAKixI,yBAAyBxmI,EAAM+jI,EAAS/rD,EAASwqD,GACjE,IAAKvrI,EAAM,OAAO,KAClB,IAAIy4C,EAAUn6C,KAAKovI,iBAAiB1tI,GASpC,OARKy4C,GACC8yF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAeq5G,kCACfrnI,EAAKhK,MAAOiB,EAAKk3B,YAIhBuhB,EAID82F,yBAENxmI,EAEA+jI,EAEA/rD,EAEAwqD,EAAyB5yF,EAAWoqC,QAEpC,IAAI6tD,EAAWtyI,KAAK27E,kBAAkBlxE,EAAK7F,OAAQ4pI,EAAS/rD,EAASwqD,GACrE,IAAKqF,EAAU,OAAO,KACtB,IAAIC,EAAWvyI,KAAK27E,kBAAkBlxE,EAAK5F,OAAQ2pI,EAAS8D,EAAUrF,GACtE,IAAKsF,EAAU,OAAO,KACtB,IAAIrnE,EAAa,EAAAnzC,KAAK4zC,kBAAkB2mE,EAAUC,GAAU,GAS5D,OARKrnE,GACC+hE,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAemzC,8CACfnhE,EAAKhK,MAAO,KAAM6xI,EAAS15G,WAAY25G,EAAS35G,YAI/CsyC,EAID6kE,oBAENtlI,EAEA+jI,EAEA/rD,EAEAwqD,EAAyB5yF,EAAWoqC,QAEpC,IAAItqC,EAAUn6C,KAAK09E,gBAAgBjzE,EAAK3G,SAAU0qI,EAAQx/E,eAAgBi+E,GAC1E,OAAK9yF,EACDA,EAAQ35C,MAAQ,EAAA21C,YAAY6d,gBACvBh0D,KAAK2hF,8BACMxnC,EAChB1vC,EAAK3J,cACL0tI,EAAQx/E,gBACR,IAAAoW,WAAuBopE,EAAQnpE,yBAC/B56D,EACAwiI,IAGAA,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAesmB,qCACft0C,EAAKhK,OAGF,MAjBc,KAqBfswI,qBAENtmI,EAEA+jI,EAEA/rD,EAEAwqD,EAAyB5yF,EAAWoqC,QAEpC,IAAItqC,EAAUn6C,KAAK+vI,oBAAoBtlI,EAAM+jI,EAAS/rD,EAASwqD,GAC/D,IAAK9yF,EAAS,OAAO,KACrB,IAAIz4C,EAAO1B,KAAKqwE,iBAAiBl2B,GASjC,OARKz4C,GACCurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAey9C,2CACfzrE,EAAKhK,OAIJiB,EAIDguI,yBAENjlI,EAEA+jI,EAEA/rD,EAEAwqD,EAAyB5yF,EAAWoqC,QAEpC,IAAI/iF,EAAO1B,KAAKywI,0BAA0BhmI,EAAM+jI,EAAS/rD,EAASwqD,GAClE,IAAKvrI,EAAM,OAAO,KAClB,IAAIy4C,EAAUn6C,KAAKovI,iBAAiB1tI,GASpC,OARKy4C,GACC8yF,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAeq5G,kCACfrnI,EAAKhK,MAAOiB,EAAKk3B,YAIhBuhB,EAIDs2F,0BAENhmI,EAEA+jI,EAEA/rD,EAEAwqD,EAAyB5yF,EAAWoqC,QAEpC,OAAOzkF,KAAKmtI,oBAAoB1iI,EAAKzH,YAAYqF,UAAWmmI,EAAQx/E,eAAgBw/E,EAAQnpE,wBAAyB4nE,GAMvH32F,gBAEEqC,EAEA73C,EAEAksI,GAA6B,IAAA5nE,aAE7B6nE,EAAyB5yF,EAAWoqC,QAEpC,IAAIsN,EAAep5C,EAAUxB,OAAO32C,MAAQ,EAAA21C,YAAYge,mBACpDxb,EAAUxB,OAAOA,OACjBwB,EAAUxB,OACV2H,EAA8B,KAC9BmrF,EAAcnpI,GAAgB,IAAA0xI,eAAc1xI,GAAiB,GAGjE,GAAI63C,EAAUnsC,GAAG,EAAAF,YAAY8jD,UAAW,CACtCrkD,OAAOgmF,EAAavxF,MAAQ,EAAA21C,YAAYpnC,OAASgjF,EAAavxF,MAAQ,EAAA21C,YAAYslB,WAClF3c,EAAuBizC,EAGvB,IAAI0gD,EAAmB95F,EAAUqxF,oBAAoBC,GACrD,GAAIwI,EAAkB,OAAOA,EAG7B,IAAIC,EAAqB5zF,EAAch+C,cACvC,GAAI4xI,EAAoB,CACtB,IAAIC,EAAsB5mI,OAAO+yC,EAAcnG,UAAUxtC,oBACrDynI,EAAwBD,EAAoBnnI,OAChDO,OAAO6mI,GAAyBD,EAAoBnnI,QACpD,IAAK,IAAIC,EAAI,EAAGA,EAAImnI,IAAyBnnI,EAAG,CAC9C,IAAIonI,EAAyBF,EAAoBlnI,GAAG9K,KAAKsB,KAEzD+qI,EAASrgI,IAAIkmI,EAAwBH,EAAmBjnI,UAGvD,CACLM,OAAOgmF,EAAavxF,MAAQ,EAAA21C,YAAYpnC,OACxC,IAAI0jI,EAAmB95F,EAAUqxF,oBAAoBC,GACrD,GAAIwI,EAAkB,OAAOA,EAI/B,IAEIK,EAFA52D,EAAgBvjC,EAAU9sC,iBAC1BV,EAAqBwtC,EAAUxtC,mBAEnC,GAAsB,OAAlBrK,IAA2BgyI,EAA2BhyI,EAAc0K,QAAU,EAAG,CACnFO,OAA8B,OAAvBZ,GAA+B2nI,GAA4B3nI,EAAmBK,QACrF,IAAK,IAAIC,EAAI,EAAGA,EAAIqnI,IAA4BrnI,EAC9CuhI,EAASrgI,IACexB,EAAoBM,GAAG9K,KAAKsB,KAClDnB,EAAc2K,SAIlBM,QAAQZ,GAAmD,GAA7BA,EAAmBK,QAInD,IAAIkrC,EAAwB,KACxBv1C,EAAmB+6E,EAAc/6E,iBACrC,GAAIA,EAAkB,CAOpB,KANAu1C,EAAW12C,KAAKk4D,YACd/2D,EACAw3C,EAAUxB,OACV61F,EACAC,IAEa,OAAO,KACtBD,EAASrgI,IAAI,EAAA42C,YAAYsB,MAAOnO,QACvBoI,IACTpI,EAAWoI,EAAcp9C,KACzBsrI,EAASrgI,IAAI,EAAA42C,YAAYsB,MAAOnO,IAIlC,IAuCIx1C,EAvCA6xI,EAAsB72D,EAAcj7E,WACpC+xI,EAAyBD,EAAoBvnI,OAC7CmrC,EAAiB,IAAIvmC,MAAY4iI,GACjC1zF,EAAqB,EACzB,IAAK,IAAI7zC,EAAI,EAAGA,EAAIunI,IAA0BvnI,EAAG,CAC/C,IAAIwnI,EAAuBF,EAAoBtnI,GAC3CwnI,EAAqBxxI,eAAiB,EAAA0K,cAAcwoG,UACtDr1D,EAAqB7zC,EAAI,GAE3B,IAAIqsD,EAAWm7E,EAAqBvxI,KACpC,IAAI,IAAA26E,eAAcvkB,GAOhB,OANIm1E,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfN,EAASr3D,OAGN,KAET,IAAI0pI,EAAgBnqI,KAAKk4D,YACvBJ,EACAnf,EAAUxB,OACV61F,EACAC,GAEF,IAAK9C,EAAe,OAAO,KAC3B,GAAIA,GAAiB,EAAApyG,KAAKsH,KAOxB,OANI4tG,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfN,EAASr3D,OAGN,KAETk2C,EAAelrC,GAAK0+H,EAKtB,GAAIxxF,EAAUnsC,GAAG,EAAAF,YAAY0vD,KAC3B96D,EAAa,EAAA62B,KAAKsH,UACb,GAAIsZ,EAAUnsC,GAAG,EAAAF,YAAY2C,aAClC/N,EAAa49C,EAAep9C,SACvB,CACL,IAAIo2D,EAAWokB,EAAch7E,WAC7B,IAAI,IAAAm7E,eAAcvkB,GAOhB,OANIm1E,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfN,EAASr3D,OAGN,KAET,IAAIiB,EAAO1B,KAAKk4D,YACdJ,EACAnf,EAAUxB,OACV61F,EACAC,GAEF,IAAKvrI,EAAM,OAAO,KAClBR,EAAaQ,EAGf,IAAI2G,EAAY,IAAI,EAAAomD,UAAUzuD,KAAKw1C,QAASmB,EAAgBz1C,EAAYw1C,GACxEruC,EAAUi3C,mBAAqBA,EAE/B,IAAI4qF,EAAyBvxF,EAAUh4C,KACnCspI,EAAYz+H,SAAQ0+H,GAA0B,IAAMD,EAAc,KACtE,IAAI30F,EAAW,IAAI,EAAApf,SACjBg0G,EACAvxF,EACA73C,EACAuH,EACA2kI,GAKF,GAHAr0F,EAAUqpC,oBAAoBioD,EAAa30F,GAGvCwJ,EAAe,CACjB,IAAIo0F,EAAuB59F,EAAStyC,YAAYrC,KAAKsB,KACjD4/E,EAAY/iC,EAAcnJ,KAC9B,KAAOksC,GAAW,CAChB,IAAIsxD,EAActxD,EAAUz7E,QAC5B,GAAI+sI,GAAeA,EAAYj4F,IAAIg4F,GAAuB,CACxDlzI,KAAKwwD,oBAAqB,EAC1B,MAEFqxB,EAAYA,EAAUlsC,MAG1B,OAAOL,EAITm5F,iCAEE91F,EAEAptC,EAEAwhI,EAEAC,EAEAr0G,EAEAs0G,EAAyB5yF,EAAWoqC,QAEpC,IAAIsN,EAAep5C,EAAUxB,OAAO32C,MAAQ,EAAA21C,YAAYge,mBACpDxb,EAAUxB,OAAOA,OACjBwB,EAAUxB,OACV23F,EAAuC,KAG3C,GAAIn2F,EAAUnsC,GAAG,EAAAF,YAAYsnD,SAAU,CAGrC,GAAIjb,EAAUnsC,GAAG,EAAAF,YAAY8jD,UAAW,CACtCrkD,OAAOgmF,EAAavxF,MAAQ,EAAA21C,YAAYpnC,OACxC,IAAI+vC,EAAuBizC,EACvB2gD,EAAqB5zF,EAAch+C,cACvC,GAAI4xI,EAAoB,CACtB,IAAIvnI,EAAqBY,OAAO+yC,EAAcnG,UAAUxtC,oBACpDynI,EAAwBF,EAAmBlnI,OAC/CO,OAAO6mI,GAAyBznI,EAAmBK,QACnD,IAAK,IAAIC,EAAI,EAAGA,EAAImnI,IAAyBnnI,EAC3CuhI,EAASrgI,IACPxB,EAAmBM,GAAG9K,KAAKsB,KAC3BywI,EAAmBjnI,KAc3B,KARAqjI,EAAwB9uI,KAAKq2E,qBAC3BtqE,OAAO4sC,EAAUxtC,oBACjBI,EACAwhI,EACAC,EACAr0G,EACAs0G,IAE0B,OAAO,UAInC,GAA0B,OAAtB1hI,GAA8BA,EAAkBC,OAAS,EAO3D,OANIyhI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAemgB,sBACfjgB,EAAWl4B,MAAOk4C,EAAU9C,cAGzB,KAKX,OAAO71C,KAAKs2C,gBACVqC,EACAm2F,EACA9B,EACAC,GAKJv8E,iBAAiBpb,GACf,IAAI2xF,EAAqB3xF,EAASqD,UAAUyrF,UAC5C,IAAK6C,EAAoB,OAAO,KAEhC,IAAImM,EAAsBrnI,OAAOupC,EAAS6kC,uBACtCiqD,EAAY,IAAIz8E,IAKpB,IAAK,IAAI7Q,EAAUkZ,WAAWi3E,GAAqBx7H,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CACxF,IAAI4nI,EAA2Bv8F,EAAQrrC,GACvCM,QAAQsnI,EAAyB1K,SACjC,IAEIz0E,EAFAo/E,EAAwBD,EAAyBl8F,OACjDo8F,EAAaD,EAAsB9yI,MAAQ,EAAA21C,YAAYge,mBAE3D,GAAIo/E,EAAY,CACd,IAAIC,EAAqCF,EAAuBn8F,OAChEprC,OAAOynI,EAAehzI,MAAQ,EAAA21C,YAAY6d,iBAC1CE,EAAkCs/E,EAAgB1wF,eAElD/2C,OAAOunI,EAAsB9yI,MAAQ,EAAA21C,YAAY6d,iBACjDE,EAAkCo/E,EAAuBxwF,UAE3D,GAAKoR,EACL,IAAK,IAAIpd,EAAUC,WAAWmd,GAAiBld,EAAI,EAAGtlC,EAAIolC,EAAQtrC,OAAQwrC,EAAItlC,IAAKslC,EAAG,CACpF,IAGIyiC,EAHA36B,EAAgBhI,EAAQE,GAE5B,GAAK8H,EAAchF,eAAes5F,GAAlC,CAEA,GAAIG,EAAY,CACd,IAAIE,EAAgB1nI,OAAO+yC,EAAc14C,QAAS+0C,IAAIm4F,EAAsB3yI,OAC5EoL,OAAO0nI,EAAcjzI,MAAQ,EAAA21C,YAAYge,oBACzC,IAAIu/E,EAAwB1zI,KAAK42D,gBAAmC68E,GACpE,IAAKC,EAAuB,SACxBp+F,EAAS9oC,GAAG,EAAAF,YAAYyvD,KAC1B0d,EAAmBi6D,EAAsBx+E,gBAEzCnpD,OAAOupC,EAAS9oC,GAAG,EAAAF,YAAY0vD,MAC/Byd,EAAmBi6D,EAAsBv+E,oBAEtC,CACL,IAAIw+E,EAAiB5nI,OAAO+yC,EAAc14C,QAAS+0C,IAAIk4F,EAAyB1yI,OAChFoL,OAAO4nI,EAAenzI,MAAQ,EAAA21C,YAAYC,oBAC1CqjC,EAAmBz5E,KAAKs2C,gBAAmCq9F,EAAgBr+F,EAASx0C,eAElF24E,GAAkB2qD,EAAU9tH,IAAImjE,KAGxC,OAAOzpB,WAAWo0E,GAOpB1tE,aAEE/d,EAEA73C,EAEAksI,GAA6B,IAAA5nE,aAE7B6nE,EAAyB5yF,EAAWoqC,QAEpC,IAAIwlD,EAAcnpI,GAAgB,IAAA0xI,eAAc1xI,GAAiB,GAI7Dw0C,EAAWqD,EAAUqxF,oBAAoBC,GAC7C,GAAI30F,EAAU,OAAOA,EAGrB,IAAIs+F,EAAwBj7F,EAAUh4C,KAClCspI,EAAYz+H,SAAQooI,GAAyB,IAAM3J,EAAc,KAEnE30F,EADEqD,EAAUn4C,MAAQ,EAAA21C,YAAY4f,oBACrB,IAAI,EAAA89E,UAAUD,EAA2Cj7F,EAAW73C,GAEpE,IAAI,EAAAqqI,MAAMyI,EAAuBj7F,EAAW73C,GAEzD63C,EAAUqpC,oBAAoBioD,EAAa30F,GAC3C,IAAIw+F,EAAiB9zI,KAAK8sI,oBAK1B,GAJAgH,EAAex9H,IAAIg/B,GAIfx0C,EAAe,CACjB,IAAIqK,EAAqBY,OAAO4sC,EAAUxtC,oBACtCskF,EAAoBtkF,EAAmBK,OACvCkD,EAAmB5N,EAAc0K,OACrCO,OAAO2C,GAAoB+gF,GAC3B,IAAK,IAAIhkF,EAAI,EAAGA,EAAIiD,IAAoBjD,EACtCuhI,EAASrgI,IAAIxB,EAAmBM,GAAG9K,KAAKsB,KAAMnB,EAAc2K,QAEzD,CACL,IAAIN,EAAqBwtC,EAAUxtC,mBACnCY,SAAgC,OAAvBZ,GAA+BA,EAAmBK,OAAS,IAEtE8pC,EAAS+vB,wBAA0B2nE,EAEnC,IAAI+G,GAAa,EAGblR,EAAgBlqF,EAAUkqF,cAC9B,GAAIA,EAAe,CACjB,IAAIlhF,EAAiCkhF,EACrC,EAAG,CACD,GAAIlhF,GAAWhJ,EAMb,OALA34C,KAAKw4B,MACH,EAAAC,eAAeu7G,mEACfr7F,EAAUob,eAAetzD,MACzBk4C,EAAU9C,cAEL,KAET8L,EAAUA,EAAQkhF,oBACXlhF,GACT,IAAIsmC,EAAcl8E,OAAO4sC,EAAUsvC,aAC/BtyC,EAAO31C,KAAK2hF,8BACdkhD,EACA56C,EAAYnnF,cACZ63C,EAAUxB,QACV,IAAAiuB,WAAU4nE,GACV/kD,EACAglD,GAEF,IAAKt3F,EAAM,OAAO,KAClBL,EAASk2F,QAAQ71F,GAMbm+F,EAAe54F,IAAIvF,KAAOo+F,GAAa,GAI7C,IAAIzQ,EAAsB3qF,EAAU2qF,oBACpC,GAAIA,EACF,IAAK,IAAI73H,EAAI,EAAGC,EAAI43H,EAAoB93H,OAAQC,EAAIC,IAAKD,EAAG,CAC1D,IAAI43H,EAAqBC,EAAoB73H,GACzCk2C,EAAiC0hF,EACrC,EAAG,CACD,GAAI1hF,GAAWhJ,EAMb,OALA34C,KAAKw4B,MACH,EAAAC,eAAeu7G,mEACfr7F,EAAUob,eAAetzD,MACzBk4C,EAAU9C,cAEL,KAET8L,EAAUA,EAAQkhF,oBACXlhF,GACT,IAAIwhF,EAAiBp3H,OAAO4sC,EAAUuqF,gBAAiBz3H,IACnDogI,EAAQ7rI,KAAK2hF,8BACf0hD,EACAF,EAAeriI,cACf63C,EAAUxB,QACV,IAAAiuB,WAAU4nE,GACV7J,EACA8J,GAEF,IAAKpB,EAAO,OAAO,KACnB9/H,OAAO8/H,EAAMrrI,MAAQ,EAAA21C,YAAYslB,WACjCnmB,EAASs2F,aAAwBC,GAG7BiI,EAAe54F,IAAI2wF,KAAQkI,GAAa,GAGhD,OAAIA,GAGJ/zI,KAAKi0I,mBAAmB3+F,EAAU23F,GAHX33F,EAQjB2+F,mBAEN3+F,EAEA23F,GAEA,IAAI7mI,EAAUkvC,EAASlvC,QAClBA,IAASkvC,EAASlvC,QAAUA,EAAU,IAAIozC,KAE/C,IAAIs6F,EAAiB9zI,KAAK8sI,oBACtBoH,EAAgB,IAAI16F,IAGpB4xF,EAAa91F,EAAS81F,WAC1B,GAAIA,EACF,IAAK,IAAIt0F,EAAUkZ,WAAWo7E,GAAa3/H,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CAChF,IAAIogI,EAAQ/0F,EAAQrrC,GACpBM,QAAQ+nI,EAAe54F,IAAI2wF,IAC3B,IAAIsI,EAAetI,EAAMzlI,QACzB,GAAI+tI,EACF,IAAK,IAAI7yF,EAAQC,SAAS4yF,GAAe1oI,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CAC5E,IAAI4qD,EAAavkD,UAAUwvC,EAAM71C,IAC7BwrC,EAASlrC,OAAOooI,EAAah5F,IAAIkb,IACrC,GAAIjwD,EAAQ80C,IAAImb,GAAa,CAC3B,IAAI0P,EAAWh6D,OAAO3F,EAAQ+0C,IAAIkb,IAClC,IAAKpf,EAAOgyF,qBAAqBljE,GAAW,CAC1C/lE,KAAKgmE,aACH,EAAAvtC,eAAe27G,4EACfn9F,EAAOouC,4BAA6Btf,EAASsf,6BAE/C,UAGJj/E,EAAQuG,IAAI0pD,EAAYpf,GACxBi9F,EAAcvnI,IAAI0pD,EAAYpf,IAOtC,IAAII,EAAoB,EACpB1B,EAAOL,EAASK,KACpB,GAAIA,EAAM,CACR5pC,QAAQ+nI,EAAe54F,IAAIvF,IAC3B,IAAIw9F,EAAcx9F,EAAKvvC,QACvB,GAAI+sI,EAEF,IAAK,IAAI7xF,EAAQC,SAAS4xF,GAAc1nI,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CAC3E,IAAI4qD,EAAavkD,UAAUwvC,EAAM71C,IAC7BwrC,EAASlrC,OAAOonI,EAAYh4F,IAAIkb,IACpC,GAAIjwD,EAAQ80C,IAAImb,GAAa,CAC3B,IAAI0P,EAAWh6D,OAAO3F,EAAQ+0C,IAAIkb,IAClC,IAAKpf,EAAOgyF,qBAAqBljE,GAAW,CAC1C/lE,KAAKgmE,aACH,EAAAvtC,eAAe27G,4EACfn9F,EAAOouC,4BAA6Btf,EAASsf,6BAE/C,UAGJj/E,EAAQuG,IAAI0pD,EAAYpf,GACpBA,EAAOzqC,GAAG,EAAAF,YAAYkvD,UACxB04E,EAAcvnI,IAAI0pD,EAAYpf,GAE9Bi9F,EAAc/7E,OAAO9B,GAI3Bhf,EAAe1B,EAAK0F,iBAItB,IAAI1C,EAAYrD,EAASqD,UACrB07F,EAA2B17F,EAAUgkB,gBACrC23E,EAAa,IAAIlkI,MACrB,GAAIikI,EAEF,IAAK,IAAIv9F,EAAUC,WAAWs9F,GAA2B5oI,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CAC9F,IAAIwrC,EAASnlC,UAAUglC,EAAQrrC,IAC3B4qD,EAAapf,EAAOt2C,KACxB,OAAQs2C,EAAOz2C,MAEb,KAAK,EAAA21C,YAAYs0F,gBAAiB,CAChC,IAAI5kD,EAAiC5uC,EACjCs9F,EAAgB1uD,EAAe/tB,SAC/Bwd,EAAyB,KACzBk/D,EAA8B,KAClC,GAAI7+F,EAAM,CACR,IAAIw9F,EAAcx9F,EAAKvvC,QACvB,GAAoB,OAAhB+sI,GAAwBA,EAAYj4F,IAAI2qC,EAAellF,MAAO,CAChE,IAAI8zI,EAAY1oI,OAAOonI,EAAYh4F,IAAI0qC,EAAellF,OAClD8zI,EAAUj0I,MAAQ,EAAA21C,YAAYe,MAChCs9F,EAAuBC,EAEvBz0I,KAAKgmE,aACH,EAAAvtC,eAAesiC,uBACf8qB,EAAe9xB,eAAetzD,MAAOg0I,EAAU1gF,eAAetzD,MAC9DolF,EAAellF,OAKvB,GAAK4zI,GAmBH,GANAj/D,EAAYt1E,KAAKk4D,YACfq8E,EACA57F,EAAUxB,OACV7B,EAAS+vB,wBACT4nE,GAEE33D,GAAa,EAAAv9C,KAAKsH,KAAM,CACtB4tG,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfm8E,EAAc9zI,OAGlB,YAzBoB,OAAlB+zI,GAA2BA,EAAchoI,GAAG,EAAAF,YAAYgqD,WAC1Dgf,EAAYk/D,EAAc9yI,MAEvB4zE,GACC23D,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe2/B,cACfytB,EAAe9xB,eAAetzD,MAAM83D,OAqB5C,IAAK+c,EAAW,MAChB,GAAsB,OAAlBk/D,EAAwB,CAe1B,IAAI3yD,EAAmBlsC,EAGnBkwC,EAAer5E,GAAG,EAAAF,YAAYgqD,SAC5Bk+E,EAAchoI,GAAG,EAAAF,YAAYgqD,SAC/Bt2D,KAAKgmE,aACH,EAAAvtC,eAAei8G,yDACf7uD,EAAe9xB,eAAetzD,MAAO+zI,EAAczgF,eAAetzD,MAClEolF,EAAellF,MAGjBX,KAAKgmE,aACH,EAAAvtC,eAAek8G,kDACf9uD,EAAe9xB,eAAetzD,MAAO+zI,EAAczgF,eAAetzD,MAClEolF,EAAellF,KAAM20C,EAASO,aAAcgsC,EAAUhsC,cAGjDgwC,EAAer5E,GAAG,EAAAF,YAAYk1E,WACnCgzD,EAAchoI,GAAG,EAAAF,YAAYgqD,SAC/Bt2D,KAAKgmE,aACH,EAAAvtC,eAAek8G,kDACf9uD,EAAe9xB,eAAetzD,MAAO+zI,EAAczgF,eAAetzD,MAClEolF,EAAellF,KAAMkhF,EAAUhsC,aAAcP,EAASO,cAE9C2+F,EAAchoI,GAAG,EAAAF,YAAYk1E,YAEvCxhF,KAAKgmE,aACH,EAAAvtC,eAAem8G,uDACf/uD,EAAe9xB,eAAetzD,MAAO+zI,EAAczgF,eAAetzD,MAClEolF,EAAellF,KAAM20C,EAASO,aAAcgsC,EAAUhsC,cAKtD2+F,EAAchoI,GAAG,EAAAF,YAAYgqD,UAC/Bt2D,KAAKgmE,aACH,EAAAvtC,eAAek8G,kDACf9uD,EAAe9xB,eAAetzD,MAAO+zI,EAAczgF,eAAetzD,MAClEolF,EAAellF,KAAMkhF,EAAUhsC,aAAcP,EAASO,cAMvDy/B,EAAU1+B,uBAAuB49F,EAAc9yI,OAClD1B,KAAKgmE,aACH,EAAAvtC,eAAeo8G,2EACfhvD,EAAe9xB,eAAetzD,MAAO+zI,EAAczgF,eAAetzD,MAClEolF,EAAellF,KAAM20C,EAASO,aAAcgsC,EAAUhsC,cAI5D,IAAIuf,EAAgB,IAAI,EAAA0/E,MAAMjvD,EAAgBvwC,EAAUggC,GAExD,GADAvpE,QAAO,IAAA24B,YAAW4wC,EAAUt2C,WACN,OAAlBw1G,EACFp/E,EAAc/d,aAAem9F,EAAcn9F,iBACtC,CACL,IAAI1S,EAAO2wC,EAAUt2C,SAAW,EAC5BqY,EAAe1S,IAAM0S,EAAuC,GAAvBA,EAAe1S,IACxDywB,EAAc/d,aAAeA,EAC7BA,GAAgBi+B,EAAUt2C,SAE5BsW,EAASh/B,IAAI+/C,EAAYjB,GACzB,MAEF,KAAK,EAAAjf,YAAYC,mBAAoB,CACnC,IAAIu9F,EAAqC18F,EAAQ6yF,QAAQx0F,GACzDA,EAASh/B,IAAIq9H,EAAehzI,KAAMgzI,GAClC,MAEF,KAAK,EAAAx9F,YAAYge,mBAAoB,CACnC,IAAIw/E,EAAqC18F,EAAQ6yF,QAAQx0F,GACzDA,EAASh/B,IAAIq9H,EAAehzI,KAAMgzI,GAClC,MAEF,QAAS5nI,QAAO,GAEbkrC,EAAOzqC,GAAG,EAAAF,YAAYkvD,WACzB04E,EAAc/7E,OAAO9B,GAM3B,IAAK,IAAI5qD,EAAI,EAAGC,EAAI4oI,EAAW9oI,OAAQC,EAAIC,IAAKD,EAAG,CACjD,IAAInH,EAAWgwI,EAAW7oI,GACtBspI,EAAiBzwI,EAAS4wD,eAC9B,GAAK6/E,EAKE,CACL,IAAIC,EAAiB1wI,EAAS6wD,eACP,OAAnB6/E,GAA4BD,EAAe7Q,iBAAiB8Q,IAC9Dh1I,KAAKgmE,aACH,EAAAvtC,eAAew8G,uDACfF,EAAehhF,eAAetzD,MAAOu0I,EAAejhF,eAAetzD,YATvET,KAAKw4B,MACH,EAAAC,eAAey8G,qDACf5wI,EAASyvD,eAAetzD,MAAO6D,EAAS3D,MAa9C,GAAI20C,EAAS90C,MAAQ,EAAA21C,YAAYslB,UAAW,CAG1C,IAAKnmB,EAAS9oC,GAAG,EAAAF,YAAYkvD,WAAa04E,EAAc55G,KAAO,EAC7D,IAAK,IAAIgnB,EAAQC,SAAS2yF,GAAgBzoI,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CAC7E,IAAI4qD,EAAa/U,EAAM71C,GACnBwrC,EAASlrC,OAAOmoI,EAAc/4F,IAAIkb,IACtCr2D,KAAKgmE,aACH,EAAAvtC,eAAe08G,2EACf7/F,EAASye,eAAetzD,MAAOw2C,EAAO8c,eAAetzD,MACrD60C,EAASO,aAAcwgB,EAAYpf,EAAOE,OAAOtB,cAMvDP,EAAS+F,iBAAmBhE,EAG5B,CACE,IAAI0pC,EAAgBzrC,EAASY,UAAU,EAAAqN,YAAYhjD,aACnD,GAAsB,OAAlBwgF,GAA0BA,EAAc5pC,SAAW7B,EAAU,CAC/DvpC,OAAOg1E,EAAcvgF,MAAQ,EAAA21C,YAAYC,oBACzC,IAAIosC,EAAexiF,KAAKs2C,gBACHyqC,EACnB,KACAh1E,OAAOupC,EAAS+vB,yBAChB4nE,GAEEzqD,IAAcltC,EAASssC,oBAAgCY,KAMjE,IAAIykD,EAAqBtuF,EAAUsuF,mBAEnC,IAAK,IAAI3lF,EAAQC,SAAS0lF,GAAqBx7H,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CAClF,IAOI4nE,EAPA+hE,EAAetjI,UAAUwvC,EAAM71C,IAC/B4pI,EAAoBtpI,OAAOk7H,EAAmB9rF,IAAIi6F,IAEtD,GADArpI,OAAOqpI,GAAgB,EAAA5pE,aAAaiwD,SAChC4Z,EAAkB7oI,GAAG,EAAAF,YAAYsnD,SAEnC,SAGF,GAAIyhF,EAAkB7oI,GAAG,EAAAF,YAAY8jD,UAAW,CAC9C,IAAIujF,EAAiB0B,EAAkBvL,QAAQx0F,GAC/C+9B,EAAmBrzE,KAAKs2C,gBACtBq9F,EACA,MACA,IAAAvuE,aACA6nE,QAGF55D,EAAmBrzE,KAAKs2C,gBACtB++F,EACA,MACA,IAAAjwE,aACA6nE,GAGJ,IAAK55D,EAAkB,SACvB,IAAI+wD,EAAY9uF,EAAS8uF,UAKzB,GAJKA,IAAW9uF,EAAS8uF,UAAYA,EAAY,IAAI5qF,KAIjD65B,EAAiB7mE,GAAG,EAAAF,YAAY8jD,UAClC,OAAQglF,GACN,KAAK,EAAA5pE,aAAasY,WAClB,KAAK,EAAAtY,aAAauY,WAClB,KAAK,EAAAvY,aAAa8X,YAClB,KAAK,EAAA9X,aAAakY,YAAa,CAC7B,IAAIxiF,EAAamyE,EAAiBhrE,UAAUnH,WACvCA,EAAW44C,eAAexE,EAAS5zC,OAClCurI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAe+/B,mCACf68E,EAAkBxpI,iBAAiB3K,WAAWT,MAAOS,EAAW03B,WAAY0c,EAAS5zC,KAAKk3B,aAOtG,GAAKwrG,EAAUlpF,IAAIk6F,GAUbnI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAeytG,oBACf7yD,EAAiBrwE,YAAYvC,YAXjC,GADA2jI,EAAUz3H,IAAIyoI,EAAc/hE,GACxB+hE,GAAgB,EAAA5pE,aAAawI,aAAeohE,GAAgB,EAAA5pE,aAAauI,YAAa,CACxF,IAAIp6C,EAAQ2b,EAAShjC,eAChBqnB,IAAO2b,EAAShjC,eAAiBqnB,EAAQ,IAAI,EAAA27G,eAAehgG,IAC7D8/F,GAAgB,EAAA5pE,aAAawI,aAC/Br6C,EAAM0+B,QAAQgb,EAAiBhrE,UAAUnH,aAcjD6K,OAAO+nI,EAAe54F,IAAI5F,IAC1Bw+F,EAAe37E,OAAO7iB,GAMtB,IAAK,IAAIwB,EAAUkZ,WAAW8jF,GAAiBroI,EAAI,EAAGC,EAAIorC,EAAQtrC,OAAQC,EAAIC,IAAKD,EAAG,CACpF,IAAI8pI,EAAUz+F,EAAQrrC,GAClB+pI,EAAoBD,EAAQ5/F,OAASL,EACrC81F,EAAamK,EAAQnK,WACzB,GAAIA,EAAY,CACd,IAAI2I,GAAa,EACjB,IAAK,IAAI0B,EAAWzlF,WAAWo7E,GAAap0F,EAAI,EAAGtlC,EAAI+jI,EAASjqI,OAAQwrC,EAAItlC,IAAKslC,EAAG,CAClF,IAAI60F,EAAQ4J,EAASz+F,GACjB60F,IAAUv2F,EAAUkgG,GAAoB,EACnC1B,EAAe54F,IAAI2wF,KAAQkI,GAAa,GAEnD,GAAIA,EAAY,SAEdyB,GAAmBx1I,KAAKi0I,mBAAmBsB,EAAStI,IAK5DtrD,8BAEEhpC,EAEAptC,EAEAwhI,EAEAC,EAEAr0G,EAEAs0G,EAAyB5yF,EAAWoqC,QAEpC,IAAIqqD,EAAuC,KAG3C,GAAIn2F,EAAUnsC,GAAG,EAAAF,YAAYsnD,UAS3B,KARAk7E,EAAwB9uI,KAAKq2E,qBAC3BtqE,OAAO4sC,EAAUxtC,oBACjBI,EACAwhI,EACAC,EACAr0G,EACAs0G,IAE0B,OAAO,UAInC,GAA0B,OAAtB1hI,GAA8BA,EAAkBC,OAAS,EAO3D,OANIyhI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAemgB,sBACfjgB,EAAWl4B,MAAOk4C,EAAU9C,cAGzB,KAKX,OAAO71C,KAAK02D,aACV/d,EACAm2F,EACA9B,EACAC,GAKJr2E,gBAEEje,EAEAs0F,EAAyB5yF,EAAWoqC,QAEpC,IAAInvC,EAAWqD,EAAUrD,SACzB,GAAIA,EAAU,OAAOA,EACrBqD,EAAUrD,SAAWA,EAAW,IAAI,EAAAogG,SAAS/8F,EAAWA,GACxD,IAAI8rF,EAAkB9rF,EAAU8rF,gBAChC,GAAIA,EAAiB,CACnB,IAAIvvE,EAAiBl1D,KAAKs2C,gBACxBmuF,EACA,MACA,IAAAr/D,aACA6nE,GAEE/3E,IACF5f,EAAS4f,eAAiBA,EAC1B5f,EAAS+iB,QAAQnD,EAAe7sD,UAAUnH,aAG9C,IAAI2jI,EAAkBlsF,EAAUksF,gBAChC,GAAIA,EAAiB,CACnB,IAAI1vE,EAAiBn1D,KAAKs2C,gBACxBuuF,EACA,MACA,IAAAz/D,aACA6nE,GAEE93E,IACF7f,EAAS6f,eAAiBA,EACrB7f,EAAS9oC,GAAG,EAAAF,YAAY0rD,YAC3BjsD,OAAyD,GAAlDopD,EAAe9sD,UAAUsuC,eAAenrC,QAC/C8pC,EAAS+iB,QAAQlD,EAAe9sD,UAAUsuC,eAAe,MAI/D,OAAOrB,EAGD04F,sBAENvjI,EAEAwiI,EAAyB5yF,EAAWoqC,QAEpC,IAAIl5E,EAAoBd,EAAK3J,cAC7B,IAAI4N,EAAmB,EACvB,OAAKnD,GAAsE,IAAhDmD,EAAmBnD,EAAkBC,QASzDD,EAAkB,IARnB0hI,GAAc5yF,EAAWoqC,QAC3BzkF,KAAKw4B,MACH,EAAAC,eAAeof,oCACfptC,EAAKhK,MAAO,IAAKiO,EAAiBkqB,YAG/B,OA7yGb,c,6OC1GA,eAMA,QAKA,SAaA,IAAYwyC,EAyIA4qC,EAMZ,SAAgB2/B,EAAiB1zI,GAC/B,IAAI4S,EAAM5S,EAAKuJ,OAEf,OADAO,OAAO8I,GACC5S,EAAK8K,WAAW,IACtB,KAAK,GACH,GAAW,GAAP8H,EAAU,CACZ,GAAY,SAAR5S,EAAiB,OAAOmpE,EAAMwqE,MAClC,GAAY,SAAR3zI,EAAiB,OAAOmpE,EAAMyqE,MAClC,MAEF,GAAY,MAAR5zI,EAAc,OAAOmpE,EAAMX,GAC/B,GAAY,YAARxoE,EAAoB,OAAOmpE,EAAM5P,SACrC,MAEF,KAAK,GACH,GAAY,SAARv5D,EAAiB,OAAOmpE,EAAMh5D,MAClC,MAEF,KAAK,GACH,GAAW,GAAPyC,EAAU,CACZ,GAAY,SAAR5S,EAAiB,OAAOmpE,EAAM/W,MAClC,GAAY,SAARpyD,EAAiB,OAAOmpE,EAAMr8D,MAClC,GAAY,SAAR9M,EAAiB,OAAOmpE,EAAM82C,MAClC,MAEF,GAAY,QAARjgH,EAAgB,OAAOmpE,EAAM02C,KACjC,GAAY,YAAR7/G,EAAoB,OAAOmpE,EAAM54D,SACrC,GAAY,eAARvQ,EAAuB,OAAOmpE,EAAMn8D,YACxC,MAEF,KAAK,IACH,GAAW,GAAP4F,EAAU,CACZ,GAAY,WAAR5S,EAAmB,OAAOmpE,EAAMupC,QACpC,GAAY,WAAR1yG,EAAmB,OAAOmpE,EAAMykB,QACpC,MAEF,GAAY,MAAR5tF,EAAc,OAAOmpE,EAAM34D,GAC/B,GAAY,UAARxQ,EAAkB,OAAOmpE,EAAMs3C,OACnC,GAAY,YAARzgH,EAAoB,OAAOmpE,EAAM0qE,SACrC,MAEF,KAAK,IACH,GAAW,GAAPjhI,EAAU,CACZ,GAAY,QAAR5S,EAAgB,OAAOmpE,EAAMo2C,KACjC,GAAY,QAARv/G,EAAgB,OAAOmpE,EAAMtV,KACjC,MAEF,GAAY,UAAR7zD,EAAkB,OAAOmpE,EAAMr4D,OACnC,GAAY,WAAR9Q,EAAmB,OAAOmpE,EAAM4vC,QACpC,MAEF,KAAK,IACH,GAAInmG,GAAO,EAAG,CACZ,GAAY,SAAR5S,EAAiB,OAAOmpE,EAAM7gE,MAClC,GAAY,OAARtI,EAAe,OAAOmpE,EAAM53D,IAChC,GAAY,QAARvR,EAAgB,OAAOmpE,EAAMi0C,KACjC,MAEF,GAAY,YAARp9G,EAAoB,OAAOmpE,EAAMj8D,SACrC,GAAY,WAARlN,EAAmB,OAAOmpE,EAAM+2C,QACpC,MAEF,KAAK,IACH,GAAY,OAARlgH,EAAe,OAAOmpE,EAAMrP,IAChC,MAEF,KAAK,IACH,GAAW,GAAPlnD,EAAU,CACZ,GAAY,MAAR5S,EAAc,OAAOmpE,EAAMv3D,GAC/B,GAAY,MAAR5R,EAAc,OAAOmpE,EAAM66C,GAC/B,GAAY,MAARhkH,EAAc,OAAOmpE,EAAM2qE,GAC/B,MAEF,OAAQ9zI,EAAK8K,WAAW,IACtB,KAAK,IACH,GAAY,cAAR9K,EAAsB,OAAOmpE,EAAMyxC,WACvC,MAEF,KAAK,IACH,GAAY,UAAR56G,EAAkB,OAAOmpE,EAAMr3D,OACnC,MAEF,KAAK,IACH,GAAY,cAAR9R,EAAsB,OAAOmpE,EAAMh8D,WACvC,MAEF,KAAK,IACH,GAAY,aAARnN,EAAqB,OAAOmpE,EAAM3P,UAI1C,MAEF,KAAK,IACH,GAAY,SAARx5D,EAAiB,OAAOmpE,EAAM4qE,MAClC,MAEF,KAAK,IACH,GAAY,OAAR/zI,EAAe,OAAOmpE,EAAMlF,IAChC,MAEF,KAAK,IACH,GAAY,UAARjkE,EAAkB,OAAOmpE,EAAM6qE,OACnC,MAEF,KAAK,IACH,GAAY,OAARh0I,EAAe,OAAOmpE,EAAM/7D,IAChC,GAAY,QAARpN,EAAgB,OAAOmpE,EAAM/gE,KACjC,GAAY,aAARpI,EAAqB,OAAOmpE,EAAMpV,UACtC,MAEF,KAAK,IACH,GAAY,MAAR/zD,EAAc,OAAOmpE,EAAM81C,GAC/B,MAEF,KAAK,IACH,GAAW,GAAPrsG,EAAU,CACZ,GAAY,WAAR5S,EAAmB,OAAOmpE,EAAM9U,QACpC,GAAY,WAARr0D,EAAmB,OAAOmpE,EAAM8qE,QACpC,MAEF,GAAY,UAARj0I,EAAkB,OAAOmpE,EAAM0kB,OACnC,GAAY,aAAR7tF,EAAqB,OAAOmpE,EAAMoW,UACtC,MAEF,KAAK,IACH,GAAY,UAARv/E,EAAkB,OAAOmpE,EAAMj3D,OACnC,GAAY,YAARlS,EAAoB,OAAOmpE,EAAM7W,SACrC,MAEF,KAAK,IACH,GAAW,GAAP1/C,EAAU,CACZ,GAAY,UAAR5S,EAAkB,OAAOmpE,EAAM/2D,OACnC,GAAY,UAARpS,EAAkB,OAAOmpE,EAAM9W,OACnC,MAEF,GAAY,OAARryD,EAAe,OAAOmpE,EAAMpP,IAChC,GAAY,SAAR/5D,EAAiB,OAAOmpE,EAAMrgE,MAClC,MAEF,KAAK,IACH,GAAW,GAAP8J,EAAU,CACZ,GAAY,QAAR5S,EAAgB,OAAOmpE,EAAM9gE,KACjC,GAAY,QAARrI,EAAgB,OAAOmpE,EAAMvgE,KACjC,GAAY,QAAR5I,EAAgB,OAAOmpE,EAAMirC,KACjC,MAEF,GAAY,OAARp0G,EAAe,OAAOmpE,EAAM72D,IAChC,GAAY,SAARtS,EAAiB,OAAOmpE,EAAM92D,MAClC,GAAY,UAARrS,EAAkB,OAAOmpE,EAAMiZ,OACnC,MAEF,KAAK,IACH,GAAY,OAARpiF,EAAe,OAAOmpE,EAAMgqC,IAChC,GAAY,QAARnzG,EAAgB,OAAOmpE,EAAMz2D,KACjC,MAEF,KAAK,IACH,GAAY,SAAR1S,EAAiB,OAAOmpE,EAAMx2D,MAClC,GAAY,QAAR3S,EAAgB,OAAOmpE,EAAM+qE,KACjC,MAEF,KAAK,IACH,GAAY,SAARl0I,EAAiB,OAAOmpE,EAAMq3C,MAItC,OAAOr3C,EAAMqwD,QAGf,SAAgB2a,EAAsB9+B,GACpC,OAAQA,GACN,KAAKlsC,EAAM5P,SACX,KAAK4P,EAAMX,GACX,KAAKW,EAAMn8D,YACX,KAAKm8D,EAAMykB,QACX,KAAKzkB,EAAMs3C,OACX,KAAKt3C,EAAMi0C,KACX,KAAKj0C,EAAM53D,IACX,KAAK43D,EAAMrP,IACX,KAAKqP,EAAMh8D,WACX,KAAKg8D,EAAM2qE,GACX,KAAK3qE,EAAM4qE,MACX,KAAK5qE,EAAM6qE,OACX,KAAK7qE,EAAMpV,UACX,KAAKoV,EAAM/gE,KACX,KAAK+gE,EAAM7W,SACX,KAAK6W,EAAMpP,IACX,KAAKoP,EAAMirC,KACX,KAAKjrC,EAAMz2D,KAAM,OAAO,EACxB,QAAS,OAAO,IA7UpB,SAAYy2D,GAKV,2BACA,eACA,qBACA,qBACA,qBACA,mBACA,qBACA,qBACA,qBACA,2BACA,kCACA,4BACA,0BACA,0BACA,wBACA,gBACA,oBACA,oBACA,wBACA,0BACA,sBACA,0BACA,kBACA,oBACA,4BACA,kBACA,gBACA,gCACA,wBACA,gBACA,gCACA,8BACA,gBACA,sBACA,kBACA,wBACA,8BACA,kBACA,oBACA,gBACA,0BACA,0BACA,8BACA,wBACA,4BACA,wBACA,kBACA,wBACA,sBACA,wBACA,oBACA,sBACA,oBACA,kBACA,oBACA,wBACA,kBACA,oBACA,sBACA,oBACA,sBAIA,8BACA,gCACA,8BACA,gCACA,kCACA,oCACA,kBACA,kCACA,8BACA,sBACA,4BACA,kCACA,0CACA,gDACA,sCACA,gDACA,oDACA,8DACA,gDACA,oBACA,sBACA,8CACA,4BACA,sBACA,0BACA,8BACA,kCACA,8CACA,0DACA,kFACA,8BACA,kBACA,sBACA,kCACA,sBACA,kDACA,0BACA,4BACA,sBACA,yBACA,mCACA,qCACA,2CACA,6DACA,qCACA,yCACA,6DACA,yEACA,iGACA,6CACA,iCACA,qCACA,iBAIA,iCACA,uCACA,yCACA,qCACA,2CAIA,2BACA,+BAtIF,CAAYA,EAAA,EAAAA,QAAA,EAAAA,MAAK,KAyIjB,SAAY4qC,GACV,yBACA,uBACA,uBAHF,CAAYA,EAAA,EAAAA,qBAAA,EAAAA,mBAAkB,KAM9B,qBA0KA,0BAwBA,uCAA4Cr1G,GAE1C,OADAoL,OAAOpL,EAAK6K,QACJ7K,EAAKoM,WAAW,IACtB,KAAK,IAAY,MAAe,UAARpM,EACxB,KAAK,IAAY,MAAe,OAARA,EACxB,KAAK,IAAY,MAAe,cAARA,EACxB,KAAK,IAAY,MAAe,QAARA,EACxB,KAAK,IAAY,MAAe,QAARA,EAE1B,OAAO,GAGT,iCAAsC22G,GACpC,OAAQA,GACN,KAAKlsC,EAAMs3C,OAAQ,MAAO,SAC1B,KAAKt3C,EAAM66C,GAAI,MAAO,KACtB,KAAK76C,EAAMh8D,WAAY,MAAO,aAC9B,KAAKg8D,EAAM/7D,IAAK,MAAO,MACvB,KAAK+7D,EAAMiZ,OAAQ,MAAO,SAC1B,KAAKjZ,EAAMz2D,KAAM,MAAO,OACxB,KAAKy2D,EAAMq3C,MAAO,MAAO,QACzB,KAAKr3C,EAAMmZ,YAAa,MAAO,MAC/B,KAAKnZ,EAAMp8D,MAAO,MAAO,IACzB,KAAKo8D,EAAMC,SAAU,MAAO,IAC5B,KAAKD,EAAMU,YAAa,MAAO,IAC/B,KAAKV,EAAMa,gBAAiB,MAAO,KACnC,KAAKb,EAAMgB,mBAAoB,MAAO,KACtC,KAAKhB,EAAMoB,cAAe,MAAO,KACjC,KAAKpB,EAAMyB,mBAAoB,MAAO,KACtC,KAAKzB,EAAMmB,qBAAsB,MAAO,MACxC,KAAKnB,EAAMwB,0BAA2B,MAAO,MAC7C,KAAKxB,EAAM+B,KAAM,MAAO,IACxB,KAAK/B,EAAMmC,MAAO,MAAO,IACzB,KAAKnC,EAAMyC,kBAAmB,MAAO,KACrC,KAAKzC,EAAMsC,SAAU,MAAO,IAC5B,KAAKtC,EAAM6C,MAAO,MAAO,IACzB,KAAK7C,EAAMgD,QAAS,MAAO,IAC3B,KAAKhD,EAAMiY,UAAW,MAAO,KAC7B,KAAKjY,EAAMqY,YAAa,MAAO,KAC/B,KAAKrY,EAAMoD,kBAAmB,MAAO,KACrC,KAAKpD,EAAMyD,wBAAyB,MAAO,KAC3C,KAAKzD,EAAM6D,oCAAqC,MAAO,MACvD,KAAK7D,EAAMiE,UAAW,MAAO,IAC7B,KAAKjE,EAAMqE,IAAK,MAAO,IACvB,KAAKrE,EAAMyE,MAAO,MAAO,IACzB,KAAKzE,EAAM4Y,YAAa,MAAO,IAC/B,KAAK5Y,EAAM8Y,MAAO,MAAO,IACzB,KAAK9Y,EAAM4E,oBAAqB,MAAO,KACvC,KAAK5E,EAAM+E,QAAS,MAAO,KAC3B,KAAK/E,EAAM4B,OAAQ,MAAO,IAC1B,KAAK5B,EAAM8B,YAAa,MAAO,KAC/B,KAAK9B,EAAMkC,aAAc,MAAO,KAChC,KAAKlC,EAAMqC,gBAAiB,MAAO,KACnC,KAAKrC,EAAMwC,yBAA0B,MAAO,MAC5C,KAAKxC,EAAM4C,aAAc,MAAO,KAChC,KAAK5C,EAAM+C,eAAgB,MAAO,KAClC,KAAK/C,EAAMmD,yBAA0B,MAAO,MAC5C,KAAKnD,EAAMwD,+BAAgC,MAAO,MAClD,KAAKxD,EAAM4D,2CAA4C,MAAO,OAC9D,KAAK5D,EAAMgE,iBAAkB,MAAO,KACpC,KAAKhE,EAAMoE,WAAY,MAAO,KAC9B,KAAKpE,EAAMwE,aAAc,MAAO,KAChC,QAEE,OADA7jE,QAAO,GACA,KAKb,MAAa4C,EAOXpO,YAAY2U,EAAY1D,GAFxB,KAAAqzE,aAAsB,EAGpB7kF,KAAKkV,MAAQA,EACblV,KAAKwR,IAAMA,EAGb9Q,YAAY65E,EAAUC,GACpB,GAAID,EAAEvpE,QAAUwpE,EAAExpE,OAAQ,MAAM,IAAIm3C,MAAM,mBAC1C,IAAI1nD,EAAQ,IAAIkO,EACd4rE,EAAErlE,MAAQslE,EAAEtlE,MAAQqlE,EAAErlE,MAAQslE,EAAEtlE,MAChCqlE,EAAE/oE,IAAMgpE,EAAEhpE,IAAM+oE,EAAE/oE,IAAMgpE,EAAEhpE,KAG5B,OADA/Q,EAAMuQ,OAASupE,EAAEvpE,OACVvQ,EAGTqoF,OAAOC,GACL,OAAO/oF,KAAKgR,QAAU+3E,EAAM/3E,QAAUhR,KAAKkV,OAAS6zE,EAAM7zE,OAASlV,KAAKwR,KAAOu3E,EAAMv3E,IAGnF6kI,cACF,IAAI51I,EAAQ,IAAIkO,EAAM3O,KAAKkV,MAAOlV,KAAKkV,OAEvC,OADAzU,EAAMuQ,OAAShR,KAAKgR,OACbvQ,EAGL83D,YACF,IAAI93D,EAAQ,IAAIkO,EAAM3O,KAAKwR,IAAKxR,KAAKwR,KAErC,OADA/Q,EAAMuQ,OAAShR,KAAKgR,OACbvQ,EAGTm4B,WACE,OAAO54B,KAAKgR,OAAO/O,KAAK8O,UAAU/Q,KAAKkV,MAAOlV,KAAKwR,MAvCvD,UA+CA,MAAasiG,UAAkB,EAAA7nD,kBAgB7B1rD,YAAYyQ,EAAgBk7C,EAA0C,MACpEjhD,MAAMihD,GAdR,KAAA16C,IAAW,EAEX,KAAAb,IAAW,EACX,KAAA2mG,OAAgB,EAChB,KAAAjD,SAAgB,EAEhB,KAAAmG,WAAoB,EACpB,KAAAvF,aAAoB,EACpB,KAAAS,oBAA2B,EAE3B,KAAArC,UAAmC,KAylBnC,KAAAuS,uBAA8B,EAC9B,KAAAF,gBAAuB,EACvB,KAAAC,cAAqB,EArlBdz5D,IAAaA,EAAc,IAChClsD,KAAKksD,YAAcA,EACnBlsD,KAAKgR,OAASA,EAEd,IAAI/O,EAAO+O,EAAO/O,KACduP,EAAMvP,EAAKuJ,OACXmF,EAAM,EAUV,GAPEA,EAAMa,GACkB,OAAxBvP,EAAK8K,WAAW4D,MAEdA,EAKFA,EAAM,EAAIa,GACc,IAAxBvP,EAAK8K,WAAW4D,IACY,IAA5B1O,EAAK8K,WAAW4D,EAAM,GAGtB,IADAA,GAAO,EAELA,EAAMa,GACkB,IAAxBvP,EAAK8K,WAAW4D,MAEdA,EAIN3Q,KAAK2Q,IAAMA,EACX3Q,KAAKwR,IAAMA,EAGblG,KAAKgrI,EAAyCtgC,EAAmBrB,SAE/D,IAAI2C,EADJt3G,KAAKw6G,WAAa,EAElB,GAAGlD,EAAQt3G,KAAKu2I,WAAWD,SACpBh/B,GAASlsC,EAAMqwD,SAEtB,OADAz7H,KAAKs3G,MAAQA,EACNA,EAGDi/B,WACND,EAAyCtgC,EAAmBrB,QAC5D6hC,EAAsBr9H,IAAIokC,WAK1B,IAHA,IAAIt7C,EAAOjC,KAAKgR,OAAO/O,KACnBuP,EAAMxR,KAAKwR,IACXb,EAAM3Q,KAAK2Q,IACRA,EAAMa,GAAK,CAChBxR,KAAKq0G,SAAW1jG,EAChB,IAAIuwF,EAAIj/F,EAAK8K,WAAW4D,GACxB,OAAQuwF,GACN,KAAK,GACH,OACIvwF,EAAMa,GACgB,IAAxBvP,EAAK8K,WAAW4D,IACf,MAGL,KAAK,GACL,KAAK,EACL,KAAK,GACL,KAAK,GACL,KAAK,KACDA,EACF,MAEF,KAAK,GAEH,QADEA,EAEA6lI,EAAiB,GAAK7lI,EAAMa,GACJ,IAAxBvP,EAAK8K,WAAW4D,MAEdA,EAEA6lI,EAAiB,GAAK7lI,EAAMa,GACJ,IAAxBvP,EAAK8K,WAAW4D,IAEhB3Q,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMwB,4BAEf5sE,KAAK2Q,IAAMA,EACJy6D,EAAMyB,sBAEf7sE,KAAK2Q,IAAMA,EACJy6D,EAAM4Y,aAEf,KAAK,GACL,KAAK,GAEH,OADAhkF,KAAK2Q,IAAMA,EACJy6D,EAAM2sC,cAEf,KAAK,GAEH,OADA/3G,KAAK2Q,IAAMA,EACJy6D,EAAMy4C,gBAEf,KAAK,GAEH,QADElzG,EAEA6lI,EAAiB,GAAK7lI,EAAMa,GACJ,IAAxBvP,EAAK8K,WAAW4D,IAEhB3Q,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM+C,iBAEfnuE,KAAK2Q,IAAMA,EACJy6D,EAAMgD,SAEf,KAAK,GAEH,KADEz9D,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CACnC,IAAIilI,EAAMx0I,EAAK8K,WAAW4D,GAC1B,GAAW,IAAP8lI,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM4E,oBAEf,GAAW,IAAPymE,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMgE,iBAIjB,OADApvE,KAAK2Q,IAAMA,EACJy6D,EAAMiE,UAEf,KAAK,GAEH,OADArvE,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMmsC,UAEf,KAAK,GAEH,OADAv3G,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMssC,WAEf,KAAK,GAEH,KADE/mG,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CACnC,IAAIilI,EAAMx0I,EAAK8K,WAAW4D,GAC1B,GAAW,IAAP8lI,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMqC,gBAEf,GAAW,IAAPgpE,EAEF,QADE9lI,EAEA6lI,EAAiB,GAAK7lI,EAAMa,GACJ,IAAxBvP,EAAK8K,WAAW4D,IAEhB3Q,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMwC,2BAEf5tE,KAAK2Q,IAAMA,EACJy6D,EAAMyC,mBAIjB,OADA7tE,KAAK2Q,IAAMA,EACJy6D,EAAMsC,SAEf,KAAK,GAEH,KADE/8D,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CACnC,IAAIilI,EAAMx0I,EAAK8K,WAAW4D,GAC1B,GAAW,IAAP8lI,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMiY,UAEf,GAAW,IAAPozD,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM8B,YAIjB,OADAltE,KAAK2Q,IAAMA,EACJy6D,EAAM+B,KAEf,KAAK,GAEH,OADAntE,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMp8D,MAEf,KAAK,GAEH,KADE2B,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CACnC,IAAIilI,EAAMx0I,EAAK8K,WAAW4D,GAC1B,GAAW,IAAP8lI,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMqY,YAEf,GAAW,IAAPgzD,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMkC,aAIjB,OADAttE,KAAK2Q,IAAMA,EACJy6D,EAAMmC,MAEf,KAAK,GAEH,KADE58D,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CACnC,IAAIilI,EAAMx0I,EAAK8K,WAAW4D,GAC1B,IAAI,IAAA+lI,WAAUD,GAEZ,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMi5C,aAEf,GACEmyB,EAAiB,GAAK7lI,EAAM,EAAIa,GACzB,IAAPilI,GAC4B,IAA5Bx0I,EAAK8K,WAAW4D,EAAM,GAGtB,OADA3Q,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMmZ,YAIjB,OADAvkF,KAAK2Q,IAAMA,EACJy6D,EAAM6rC,IAEf,KAAK,GAAgB,CACnB,IAAI0/B,EAAkBhmI,EAEtB,KADEA,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CACnC,IAAIilI,EAAMx0I,EAAK8K,WAAW4D,GAC1B,GAAW,IAAP8lI,EAAuB,CACzB,IAAIz0I,EAAc,EAAAiM,YAAY2oI,KAQ9B,IANEjmI,EAAM,EAAIa,GACkB,IAA5BvP,EAAK8K,WAAW4D,EAAM,OAEpBA,EACF3O,EAAc,EAAAiM,YAAY4oI,UAEnBlmI,EAAMa,GACb,GAA4B,IAAxBvP,EAAK8K,WAAW4D,GAA2B,GAC3CA,EACF,MAGA3Q,KAAKqzG,WACPrzG,KAAKqzG,UACHrxG,EACAC,EAAK8O,UAAU4lI,EAAiBhmI,GAChC3Q,KAAKS,MAAMk2I,EAAiBhmI,IAGhC,MAEF,GAAW,IAAP8lI,EAA0B,CAC5B,IAAIK,GAAS,EACb,OAASnmI,EAAMa,GAEb,GADA0vF,EAAIj/F,EAAK8K,WAAW4D,GAEb,IAALuwF,GACAvwF,EAAM,EAAIa,GACkB,IAA5BvP,EAAK8K,WAAW4D,EAAM,GACtB,CACAA,GAAO,EACPmmI,GAAS,EACT,MAGCA,EAKM92I,KAAKqzG,WACdrzG,KAAKqzG,UACH,EAAAplG,YAAYkE,MACZlQ,EAAK8O,UAAU4lI,EAAiBhmI,GAChC3Q,KAAKS,MAAMk2I,EAAiBhmI,IAR9B3Q,KAAKw4B,MACH,EAAAC,eAAek/E,YACf33G,KAAKS,MAAMkQ,GAAM,MASrB,MAEF,GAAW,IAAP8lI,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM4C,aAIjB,OADAhuE,KAAK2Q,IAAMA,EACJy6D,EAAM6C,MAEf,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GAEH,OADAjuE,KAAK2Q,IAAMA,EACJ3Q,KAAK+2I,cACR3rE,EAAM64C,eACN74C,EAAMi5C,aAEZ,KAAK,GAEH,OADArkH,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMwtC,MAEf,KAAK,GAEH,OADA54G,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMsuC,UAEf,KAAK,GAEH,KADE/oG,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CACnC,IAAIilI,EAAMx0I,EAAK8K,WAAW4D,GAC1B,GAAW,IAAP8lI,EAEF,QADE9lI,EAEA6lI,EAAiB,GACjB7lI,EAAMa,GACkB,IAAxBvP,EAAK8K,WAAW4D,IAEhB3Q,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMmD,2BAEfvuE,KAAK2Q,IAAMA,EACJy6D,EAAMoD,mBAEf,GAAW,IAAPioE,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMa,gBAIjB,OADAjsE,KAAK2Q,IAAMA,EACJy6D,EAAMC,SAEf,KAAK,GAEH,KADE16D,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CACnC,IAAIilI,EAAMx0I,EAAK8K,WAAW4D,GAC1B,GAAW,IAAP8lI,EAEF,QADE9lI,EAEA6lI,EAAiB,GACjB7lI,EAAMa,GACkB,IAAxBvP,EAAK8K,WAAW4D,IAEhB3Q,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMmB,uBAEfvsE,KAAK2Q,IAAMA,EACJy6D,EAAMoB,eAEf,GAAW,IAAPiqE,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM8tC,mBAIjB,OADAl5G,KAAK2Q,IAAMA,EACJy6D,EAAM4B,OAEf,KAAK,GAEH,KADEr8D,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CACnC,IAAIilI,EAAMx0I,EAAK8K,WAAW4D,GAC1B,GAAW,IAAP8lI,EAA6B,CAE/B,KADE9lI,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CAEnC,GADAilI,EAAMx0I,EAAK8K,WAAW4D,GACX,IAAP8lI,EAEF,QADE9lI,EAEA6lI,EAAiB,GAAK7lI,EAAMa,GACJ,IAAxBvP,EAAK8K,WAAW4D,IAEhB3Q,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM4D,6CAEfhvE,KAAK2Q,IAAMA,EACJy6D,EAAM6D,qCAEf,GAAW,IAAPwnE,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMwD,+BAIjB,OADA5uE,KAAK2Q,IAAMA,EACJy6D,EAAMyD,wBAEf,GAAW,IAAP4nE,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMgB,mBAIjB,OADApsE,KAAK2Q,IAAMA,EACJy6D,EAAMU,YAEf,KAAK,GAEH,OADA9rE,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMytC,SAEf,KAAK,GAEH,OADA74G,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM+sC,YAEf,KAAK,GAEH,OADAn4G,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMitC,aAEf,KAAK,GAEH,QADE1nG,EAEA6lI,EAAiB,GAAK7lI,EAAMa,GACJ,IAAxBvP,EAAK8K,WAAW4D,IAEhB3Q,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMwE,eAEf5vE,KAAK2Q,IAAMA,EACJy6D,EAAMyE,OAEf,KAAK,IAEH,OADA7vE,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM8uC,UAEf,KAAK,IAEH,KADEvpG,EACE6lI,EAAiB,GAAK7lI,EAAMa,EAAK,CACnC,IAAIilI,EAAMx0I,EAAK8K,WAAW4D,GAC1B,GAAW,KAAP8lI,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM+E,QAEf,GAAW,IAAPsmE,EAEF,OADAz2I,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMoE,WAIjB,OADAxvE,KAAK2Q,IAAMA,EACJy6D,EAAMqE,IAEf,KAAK,IAEH,OADAzvE,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM+uC,WAEf,KAAK,IAEH,OADAn6G,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAM8Y,MAEf,KAAK,GAEH,OADAlkF,KAAK2Q,IAAMA,EAAM,EACVy6D,EAAMgpC,GAEf,QAAS,CACP,IAAI,IAAA4iC,mBAAkB91C,GAAI,CACxB,IAAI+1C,EAAYtmI,EAChB,OACIA,EAAMa,IACR,IAAA0lI,kBAAiBh2C,EAAIj/F,EAAK8K,WAAW4D,MAEvC,GAAI2lI,GAAsBtgC,EAAmBmI,OAAQ,CACnD,IAAIg5B,EAAoBxB,EAAiB1zI,EAAK8O,UAAUkmI,EAAWtmI,IACnE,GACEwmI,GAAqB/rE,EAAMqwD,UAEzB6a,GAAsBtgC,EAAmBC,SACzCmgC,EAAsBe,IAIxB,OADAn3I,KAAK2Q,IAAMA,EACJwmI,EAIX,OADAn3I,KAAK2Q,IAAMsmI,EACJ7rE,EAAMv+D,WACR,IAAI,IAAAuqI,cAAal2C,GAAI,GACxBvwF,EACF,MAEF,IAAIuE,EAAQvE,IAUZ,OARE,IAAA4gG,iBAAgBrQ,IAAMvwF,EAAMa,IAC5B,IAAAggG,gBAAevvG,EAAK8K,WAAW4D,OAC7BA,EACJ3Q,KAAKw4B,MACH,EAAAC,eAAe4+G,kBACfr3I,KAAKS,MAAMyU,EAAOvE,IAEpB3Q,KAAK2Q,IAAMA,EACJy6D,EAAMqwD,UAKnB,OADAz7H,KAAK2Q,IAAMA,EACJy6D,EAAM4oC,UAGfgB,KACEsiC,GAAuB,EACvBhB,EAAyCtgC,EAAmBrB,QAC5D4iC,EAAyBp+H,IAAIokC,WAE7B,IAAIt7C,EAAOjC,KAAKgR,OAAO/O,KACvB,GAAIjC,KAAKw6G,UAAY,EAAG,CACtB,IAGIA,EAHAy8B,EAAYj3I,KAAK2Q,IACjB6mI,EAAcx3I,KAAKs3G,MACnBmgC,EAAiBz3I,KAAKq0G,SAE1B,GAAGmG,EAAYx6G,KAAKu2I,WAAWD,EAAoBiB,SAC5C/8B,GAAapvC,EAAMqwD,SAG1B,GAFAz7H,KAAKw6G,UAAYA,EACjBx6G,KAAKi1G,aAAej1G,KAAKq0G,SACrBijC,EAAgB,CAClBt3I,KAAK01G,oBAAqB,EAC1B,IAAK,IAAI/kG,EAAMsmI,EAAWzlI,EAAMxR,KAAKi1G,aAActkG,EAAMa,IAAOb,EAC9D,IAAI,IAAA44E,aAAYtnF,EAAK8K,WAAW4D,IAAO,CACrC3Q,KAAK01G,oBAAqB,EAC1B,OAIN11G,KAAK2Q,IAAMsmI,EACXj3I,KAAKs3G,MAAQkgC,EACbx3I,KAAKq0G,SAAWojC,EAElB,OAAOz3I,KAAKw6G,UAGdjE,eAAe+/B,EAAyCtgC,EAAmBC,QACzE,OAAOj2G,KAAK+zG,KAAK3oC,EAAMv+D,WAAYypI,GAGrCviC,KAAKuD,EAAcg/B,EAAyCtgC,EAAmBrB,SAC7E,IAOI6F,EAPAy8B,EAAYj3I,KAAK2Q,IACjB6mI,EAAcx3I,KAAKs3G,MACnBmgC,EAAiBz3I,KAAKq0G,SACtBkjC,EAAoBp+H,IAAIokC,UACxB+5D,GAASlsC,EAAMU,cACjByrE,EAAoB,GAGtB,GAAG/8B,EAAYx6G,KAAKu2I,WAAWD,EAAoBiB,SAC5C/8B,GAAapvC,EAAMqwD,SAC1B,OAAIjhB,GAAalD,GACft3G,KAAKs3G,MAAQA,EACbt3G,KAAKw6G,WAAa,GACX,IAEPx6G,KAAK2Q,IAAMsmI,EACXj3I,KAAKs3G,MAAQkgC,EACbx3I,KAAKq0G,SAAWojC,GACT,GAIXliC,OACE,IAAID,EAAQoiC,EASZ,OARIpiC,GACFoiC,EAAgB,KAChBpiC,EAAM3kG,IAAM3Q,KAAK2Q,IACjB2kG,EAAMgC,MAAQt3G,KAAKs3G,MACnBhC,EAAMjB,SAAWr0G,KAAKq0G,UAEtBiB,EAAQ,IAAIqiC,EAAM33I,KAAK2Q,IAAK3Q,KAAKs3G,MAAOt3G,KAAKq0G,UAExCiB,EAGTQ,QAAQR,GACNoiC,EAAgBpiC,EAGlBK,MAAML,GACJt1G,KAAK2Q,IAAM2kG,EAAM3kG,IACjB3Q,KAAKs3G,MAAQhC,EAAMgC,MACnBt3G,KAAKq0G,SAAWiB,EAAMjB,SACtBr0G,KAAKw6G,WAAa,EAGpB/5G,MAAMyU,GAAa,EAAI1D,GAAW,GAC5B0D,EAAQ,GACVA,EAAQlV,KAAKq0G,SACb7iG,EAAMxR,KAAK2Q,KACFa,EAAM,IACfA,EAAM0D,GAER,IAAIzU,EAAQ,IAAIkO,EAAMuG,EAAO1D,GAE7B,OADA/Q,EAAMuQ,OAAShR,KAAKgR,OACbvQ,EAGTu2G,iBAKE,IAJA,IAAI/0G,EAAOjC,KAAKgR,OAAO/O,KACnBuP,EAAMxR,KAAKwR,IACXb,EAAM3Q,KAAK2Q,IACXuE,EAAQvE,IAERA,EAAMa,IACR,IAAA0lI,kBAAiBj1I,EAAK8K,WAAW4D,MAGnC,OADA3Q,KAAK2Q,IAAMA,EACJ1O,EAAK8O,UAAUmE,EAAOvE,GAO/B42F,WAAWxY,EAAa,EAAG6oD,GAAyB,GAClD,IAAI31I,EAAOjC,KAAKgR,OAAO/O,KACnBuP,EAAMxR,KAAKwR,IACXb,EAAM3Q,KAAK2Q,IACVo+E,IAAOA,EAAQ9sF,EAAK8K,WAAW4D,MACpC,IAAIuE,EAAQvE,EACZ3Q,KAAK0lH,gBAAkBxwG,EAGvB,IAFA,IAAI4oF,EAAS,KAEA,CACX,GAAIntF,GAAOa,EAAK,CACdssF,GAAU77F,EAAK8O,UAAUmE,EAAOvE,GAChC3Q,KAAKw4B,MACH,EAAAC,eAAeo/G,4BACf73I,KAAKS,MAAMyU,EAAQ,EAAG1D,IAExBxR,KAAK2lH,cAAgBn0G,EACrB,MAEF,IAAI0vF,EAAIj/F,EAAK8K,WAAW4D,GACxB,GAAIuwF,GAAKnS,EAAO,CACd/uF,KAAK2lH,cAAgBh1G,EACrBmtF,GAAU77F,EAAK8O,UAAUmE,EAAOvE,KAChC,MAEF,GAAS,IAALuwF,EAAJ,CAQA,GAAa,IAATnS,GACF,GAAS,IAALmS,GAAwBvwF,EAAM,EAAIa,GAAmC,KAA5BvP,EAAK8K,WAAW4D,EAAM,GAKjE,OAJAmtF,GAAU77F,EAAK8O,UAAUmE,EAAOvE,GAChC3Q,KAAK2lH,cAAgBh1G,EACrB3Q,KAAK2Q,IAAMA,EAAM,EACjB3Q,KAAK4lH,uBAAwB,EACtB9nB,OAEJ,IAAI,IAAAvU,aAAY2X,GAAI,CACzBpD,GAAU77F,EAAK8O,UAAUmE,EAAOvE,GAChC3Q,KAAKw4B,MACH,EAAAC,eAAeo/G,4BACf73I,KAAKS,MAAMyU,EAAQ,EAAGvE,IAExB3Q,KAAK2lH,cAAgBh1G,EACrB,QAEAA,OAxBAmtF,GAAU77F,EAAK8O,UAAUmE,EAAOvE,GAChC3Q,KAAK2Q,IAAMA,EACXmtF,GAAU99F,KAAK83I,mBAAmBF,GAElC1iI,EADAvE,EAAM3Q,KAAK2Q,IAyBf,OAFA3Q,KAAK2Q,IAAMA,EACX3Q,KAAK4lH,uBAAwB,EACtB9nB,EAGTg6C,mBAAmBF,GAAyB,GAE1C,IAAI1iI,EAAQlV,KAAK2Q,IACba,EAAMxR,KAAKwR,IACf,KAAMxR,KAAK2Q,KAAOa,EAKhB,OAJAxR,KAAKw4B,MACH,EAAAC,eAAemsF,uBACf5kH,KAAKS,MAAM+Q,IAEN,GAGT,IAAIvP,EAAOjC,KAAKgR,OAAO/O,KACnBi/F,EAAIj/F,EAAK8K,WAAW/M,KAAK2Q,OAC7B,OAAQuwF,GACN,KAAK,GACH,OAAI02C,GAAoB53I,KAAK2Q,IAAMa,IAAO,IAAAklI,WAAUz0I,EAAK8K,WAAW/M,KAAK2Q,SACrE3Q,KAAK2Q,IACA1O,EAAK8O,UAAUmE,EAAOlV,KAAK2Q,MAE7B,KAET,KAAK,GAAY,MAAO,KACxB,KAAK,IAAY,MAAO,KACxB,KAAK,IAAY,MAAO,KACxB,KAAK,IAAY,MAAO,KACxB,KAAK,IAAY,MAAO,KACxB,KAAK,IAAY,MAAO,KACxB,KAAK,GAAsB,MAAO,IAClC,KAAK,GAAsB,MAAO,IAClC,KAAK,IACH,OACE3Q,KAAK2Q,IAAMa,GACkB,KAA7BvP,EAAK8K,WAAW/M,KAAK2Q,QAEnB3Q,KAAK2Q,IACA3Q,KAAK+3I,0BAA0BH,EAAmB1iI,GAAS,IAE7DlV,KAAKg4I,kBAAkBJ,EAAmB1iI,GAAS,GAE5D,KAAK,IACH,OAAOlV,KAAKi4I,sBAAsB,EAAGL,EAAmB1iI,GAAU,GAEpE,KAAK,GAEDlV,KAAK2Q,IAAMa,GACkB,IAA7BvP,EAAK8K,WAAW/M,KAAK2Q,QAEnB3Q,KAAK2Q,IAIX,KAAK,GACL,KAAK,KACL,KAAK,KAA6B,MAAO,GACzC,QAAS,OAAO62C,OAAO0wF,cAAch3C,IAIzCujB,oBAKE,IAJA,IAAIxiH,EAAOjC,KAAKgR,OAAO/O,KACnBiT,EAAQlV,KAAK2Q,IACba,EAAMxR,KAAKwR,IACX2mI,GAAU,IACD,CACX,GAAIn4I,KAAK2Q,KAAOa,EAAK,CACnBxR,KAAKw4B,MACH,EAAAC,eAAe2/G,wCACfp4I,KAAKS,MAAMyU,EAAO1D,IAEpB,MAEF,GAAiC,IAA7BvP,EAAK8K,WAAW/M,KAAK2Q,KAA4B,GACjD3Q,KAAK2Q,IACPwnI,GAAU,EACV,SAEF,IAAIj3C,EAAIj/F,EAAK8K,WAAW/M,KAAK2Q,KAC7B,IAAKwnI,GAAgB,IAALj3C,EAAqB,MACrC,IAAI,IAAA3X,aAAY2X,GAAI,CAClBlhG,KAAKw4B,MACH,EAAAC,eAAe2/G,wCACfp4I,KAAKS,MAAMyU,EAAOlV,KAAK2Q,MAEzB,QAEA3Q,KAAK2Q,IACPwnI,GAAU,EAEZ,OAAOl2I,EAAK8O,UAAUmE,EAAOlV,KAAK2Q,KAGpCg0G,kBAKE,IAJA,IAAI1iH,EAAOjC,KAAKgR,OAAO/O,KACnBiT,EAAQlV,KAAK2Q,IACba,EAAMxR,KAAKwR,IACXvL,EAAQ,EACLjG,KAAK2Q,IAAMa,GAAK,CACrB,IAAI0vF,EAASj/F,EAAK8K,WAAW/M,KAAK2Q,KAClC,KAAK,IAAAumI,kBAAiBh2C,GAAI,MAI1B,SAHElhG,KAAK2Q,IAGCuwF,GACN,KAAK,IACHj7F,GAAiB,EAARA,GAAa,EAAI,EAC1B,MAEF,KAAK,IACHA,GAAiB,EAARA,GAAa,EAAI,EAC1B,MAEF,KAAK,IACHA,GAAiB,EAARA,GAAa,EAAI,EAC1B,MAEF,QACEA,GAAS,GAWf,OANc,GAAVA,GACFjG,KAAKw4B,MACH,EAAAC,eAAe4/G,iCACfr4I,KAAKS,MAAMyU,EAAOlV,KAAK2Q,MAGpB1O,EAAK8O,UAAUmE,EAAOlV,KAAK2Q,KAGpComI,cACE,IAAI90I,EAAOjC,KAAKgR,OAAO/O,KACnB0O,EAAM3Q,KAAK2Q,IACXa,EAAMxR,KAAKwR,IACf,GAAIb,EAAM,EAAIa,GAA+B,IAAxBvP,EAAK8K,WAAW4D,GACnC,OAAmC,GAA3B1O,EAAK8K,WAAW4D,EAAM,IAC5B,KAAK,IACL,KAAK,GACL,KAAK,IAAY,OAAO,EAG5B,KAAOA,EAAMa,GAAK,CAChB,IAAI0vF,EAAIj/F,EAAK8K,WAAW4D,GACxB,GAAS,IAALuwF,GAAiC,MAAP,GAAJA,GAAuB,OAAO,EACxD,GAAS,IAALA,IAAoBA,EAAI,IAAeA,EAAI,IAAc,MAE7DvwF,IAEF,OAAO,EAGTuzG,cACE,IAAIjiH,EAAOjC,KAAKgR,OAAO/O,KACnB0O,EAAM3Q,KAAK2Q,IACf,GAAIA,EAAM,EAAI3Q,KAAKwR,KAA+B,IAAxBvP,EAAK8K,WAAW4D,GAAqB,CAC7D,OAAmC,GAA3B1O,EAAK8K,WAAW4D,EAAM,IAC5B,KAAK,IAEH,OADA3Q,KAAK2Q,IAAMA,EAAM,EACV3Q,KAAKs4I,iBAEd,KAAK,GAEH,OADAt4I,KAAK2Q,IAAMA,EAAM,EACV3Q,KAAKu4I,oBAEd,KAAK,IAEH,OADAv4I,KAAK2Q,IAAMA,EAAM,EACV3Q,KAAKw4I,mBAGhB,IAAI,IAAAC,SAAQx2I,EAAK8K,WAAW4D,EAAM,IAAK,CACrC,IAAIuE,EAAQvE,EACZ3Q,KAAK2Q,IAAMA,EAAM,EACjB,IAAInN,EAAQxD,KAAKw4I,mBAKjB,OAJAx4I,KAAKw4B,MACH,EAAAC,eAAeigH,8CACf14I,KAAKS,MAAMyU,EAAOlV,KAAK2Q,MAElBnN,GAGX,OAAOxD,KAAK24I,qBAGdL,iBACE,IAAIr2I,EAAOjC,KAAKgR,OAAO/O,KACvB,IAAI0O,EAAM3Q,KAAK2Q,IAMf,IALA,IAAIa,EAAMxR,KAAKwR,IACX0D,EAAQvE,EACRioI,EAAS1jI,EACT1R,EAAQo3C,QAAQ,GAChBi+F,EAAQj+F,QAAQ,GACbjqC,EAAMa,GAAK,CAChB,IAAI0vF,EAAIj/F,EAAK8K,WAAW4D,GACxB,GAAIuwF,GAAK,IAAeA,GAAK,GAE3B19F,EAAQwY,QACN88H,QAAQt1I,EAAOq1I,GACfj+F,QAAQsmD,EAAI,UAET,GAAIA,GAAK,IAAcA,GAAK,GAEjC19F,EAAQwY,QACN88H,QAAQt1I,EAAOq1I,GACfj+F,QAAQ,GAAKsmD,EAAI,UAEd,GAAIA,GAAK,IAAcA,GAAK,IAEjC19F,EAAQwY,QACN88H,QAAQt1I,EAAOq1I,GACfj+F,QAAQ,GAAKsmD,EAAI,SAEd,IAAS,IAALA,EAWT,MAVI03C,GAAUjoI,GACZ3Q,KAAKw4B,MACHogH,GAAU1jI,EACN,EAAAujB,eAAesgH,wCACf,EAAAtgH,eAAeugH,0DACnBh5I,KAAKS,MAAMkQ,IAGfioI,EAASjoI,EAAM,IAIfA,EAcJ,OAZIA,GAAOuE,EACTlV,KAAKw4B,MACH,EAAAC,eAAewgH,2BACfj5I,KAAKS,MAAMyU,IAEJ0jI,GAAUjoI,GACnB3Q,KAAKw4B,MACH,EAAAC,eAAesgH,wCACf/4I,KAAKS,MAAMm4I,EAAS,IAGxB54I,KAAK2Q,IAAMA,EACJnN,EAGTm1I,qBAQE,IAPA,IAAI12I,EAAOjC,KAAKgR,OAAO/O,KACnB0O,EAAM3Q,KAAK2Q,IACXa,EAAMxR,KAAKwR,IACX0D,EAAQvE,EACRioI,EAAS1jI,EACT1R,EAAQo3C,QAAQ,GAChBs+F,EAASt+F,QAAQ,IACdjqC,EAAMa,GAAK,CAChB,IAAI0vF,EAAIj/F,EAAK8K,WAAW4D,GACxB,GAAIuwF,GAAK,IAAeA,GAAK,GAE3B19F,EAAQwY,QACNQ,QAAQhZ,EAAO01I,GACft+F,QAAQsmD,EAAI,SAET,IAAS,IAALA,EAgBT,MAfI03C,GAAUjoI,EACZ3Q,KAAKw4B,MACHogH,GAAU1jI,EACN,EAAAujB,eAAesgH,wCACf,EAAAtgH,eAAeugH,0DACnBh5I,KAAKS,MAAMkQ,IAEJA,EAAM,GAAKuE,GAAqC,IAA5BjT,EAAK8K,WAAW4D,EAAM,IACnD3Q,KAAKw4B,MACH,EAAAC,eAAesgH,wCACf/4I,KAAKS,MAAMkQ,IAGfioI,EAASjoI,EAAM,IAIfA,EAcJ,OAZIA,GAAOuE,EACTlV,KAAKw4B,MACH,EAAAC,eAAe0gH,eACfn5I,KAAKS,MAAMyU,IAEJ0jI,GAAUjoI,GACnB3Q,KAAKw4B,MACH,EAAAC,eAAesgH,wCACf/4I,KAAKS,MAAMm4I,EAAS,IAGxB54I,KAAK2Q,IAAMA,EACJnN,EAGTg1I,mBAQE,IAPA,IAAIv2I,EAAOjC,KAAKgR,OAAO/O,KACnB0O,EAAM3Q,KAAK2Q,IACXa,EAAMxR,KAAKwR,IACX0D,EAAQvE,EACRioI,EAAS1jI,EACT1R,EAAQo3C,QAAQ,GAChBw+F,EAAQx+F,QAAQ,GACbjqC,EAAMa,GAAK,CAChB,IAAI0vF,EAAIj/F,EAAK8K,WAAW4D,GACxB,GAAIuwF,GAAK,IAAeA,GAAK,GAE3B19F,EAAQwY,QACN88H,QAAQt1I,EAAO41I,GACfx+F,QAAQsmD,EAAI,SAET,IAAS,IAALA,EAWT,MAVI03C,GAAUjoI,GACZ3Q,KAAKw4B,MACHogH,GAAU1jI,EACN,EAAAujB,eAAesgH,wCACf,EAAAtgH,eAAeugH,0DACnBh5I,KAAKS,MAAMkQ,IAGfioI,EAASjoI,EAAM,IAIfA,EAcJ,OAZIA,GAAOuE,EACTlV,KAAKw4B,MACH,EAAAC,eAAe4gH,qBACfr5I,KAAKS,MAAMyU,IAEJ0jI,GAAUjoI,GACnB3Q,KAAKw4B,MACH,EAAAC,eAAesgH,wCACf/4I,KAAKS,MAAMm4I,EAAS,IAGxB54I,KAAK2Q,IAAMA,EACJnN,EAGT+0I,oBAQE,IAPA,IAAIt2I,EAAOjC,KAAKgR,OAAO/O,KACnB0O,EAAM3Q,KAAK2Q,IACXa,EAAMxR,KAAKwR,IACX0D,EAAQvE,EACRioI,EAAS1jI,EACT1R,EAAQo3C,QAAQ,GAChB0+F,EAAQ1+F,QAAQ,GACbjqC,EAAMa,GAAK,CAChB,IAAI0vF,EAAIj/F,EAAK8K,WAAW4D,GACxB,GAAS,IAALuwF,EAEF19F,EAAQs1I,QAAQt1I,EAAO81I,QAClB,GAAS,IAALp4C,EAET19F,EAAQwY,QACN88H,QAAQt1I,EAAO81I,GACfA,OAEG,IAAS,IAALp4C,EAWT,MAVI03C,GAAUjoI,GACZ3Q,KAAKw4B,MACHogH,GAAU1jI,EACN,EAAAujB,eAAesgH,wCACf,EAAAtgH,eAAeugH,0DACnBh5I,KAAKS,MAAMkQ,IAGfioI,EAASjoI,EAAM,IAIfA,EAcJ,OAZIA,GAAOuE,EACTlV,KAAKw4B,MACH,EAAAC,eAAe8gH,sBACfv5I,KAAKS,MAAMyU,IAEJ0jI,GAAUjoI,GACnB3Q,KAAKw4B,MACH,EAAAC,eAAesgH,wCACf/4I,KAAKS,MAAMm4I,EAAS,IAGxB54I,KAAK2Q,IAAMA,EACJnN,EAGT8gH,YAWE,OAAOtkH,KAAKw5I,mBAGdA,mBACE,IAAIv3I,EAAOjC,KAAKgR,OAAO/O,KACnBuP,EAAMxR,KAAKwR,IACX0D,EAAQlV,KAAK2Q,IACb8oI,EAAWz5I,KAAK05I,yBAAwB,GAK5C,GAJI15I,KAAK2Q,IAAMa,GAAoC,IAA7BvP,EAAK8K,WAAW/M,KAAK2Q,SACvC3Q,KAAK2Q,IACP8oI,GAAYz5I,KAAK05I,2BAEf15I,KAAK2Q,IAAMa,EAAK,CAClB,IAAI0vF,EAAIj/F,EAAK8K,WAAW/M,KAAK2Q,KACb,MAAP,GAAJuwF,QAEClhG,KAAK2Q,IAAMa,GACsB,KAAlC0vF,EAAIj/F,EAAK8K,WAAW/M,KAAK2Q,OAAgC,IAALuwF,IACrD,IAAAw1C,WAAUz0I,EAAK8K,WAAW/M,KAAK2Q,IAAM,QAEnC3Q,KAAK2Q,IAET8oI,GAAYz5I,KAAK05I,2BAGrB,IAAI57C,EAAS77F,EAAK8O,UAAUmE,EAAOlV,KAAK2Q,KAExC,OADI8oI,IAAU37C,EAASA,EAAO67C,WAAW,IAAK,KACvCC,WAAW97C,GAIZ47C,wBAAwBG,GAA4B,GAQ1D,IAPA,IAAI53I,EAAOjC,KAAKgR,OAAO/O,KACnB0O,EAAM3Q,KAAK2Q,IACXuE,EAAQvE,EACRa,EAAMxR,KAAKwR,IACXonI,EAAS1jI,EACTukI,EAAW,EAER9oI,EAAMa,GAAK,CAChB,IAAI0vF,EAAIj/F,EAAK8K,WAAW4D,GAExB,GAAS,IAALuwF,EACE03C,GAAUjoI,EACZ3Q,KAAKw4B,MACHogH,GAAU1jI,EACN,EAAAujB,eAAesgH,wCACf,EAAAtgH,eAAeugH,0DACnBh5I,KAAKS,MAAMkQ,IAEHkpI,GAAuBlpI,EAAM,GAAKuE,GAAqC,IAA5BjT,EAAK8K,WAAW4D,EAAM,IAC3E3Q,KAAKw4B,MACH,EAAAC,eAAesgH,wCACf/4I,KAAKS,MAAMkQ,IAGfioI,EAASjoI,EAAM,IACb8oI,OACG,KAAK,IAAA/C,WAAUx1C,GACpB,QAEAvwF,EAWJ,OARIA,GAAOuE,GAAS0jI,GAAUjoI,GAC5B3Q,KAAKw4B,MACH,EAAAC,eAAesgH,wCACf/4I,KAAKS,MAAMm4I,EAAS,IAIxB54I,KAAK2Q,IAAMA,EACJ8oI,EAGTK,eACE,MAAM,IAAI3xF,MAAM,mBAGlB8vF,sBAAsB9e,EAAc,EAAG4gB,GAA6B,GAKlE,IAJA,IAAIv2I,EAAQ,EACRvB,EAAOjC,KAAKgR,OAAO/O,KACnB0O,EAAM3Q,KAAK2Q,IACXa,EAAMxR,KAAKwR,IACRb,EAAMa,GAAK,CAChB,IAAI0vF,EAAIj/F,EAAK8K,WAAW4D,KACxB,GAAIuwF,GAAK,IAAeA,GAAK,GAC3B19F,GAASA,GAAS,GAAK09F,EAAI,QACtB,GAAIA,GAAK,IAAcA,GAAK,GACjC19F,GAASA,GAAS,GAAK09F,GAAI,OACtB,MAAIA,GAAK,IAAcA,GAAK,KAE5B,OAAK64C,GACV/5I,KAAK2Q,MAAQA,EACN1O,EAAK8O,UAAUgpI,EAAuBppI,KAE7C3Q,KAAK2Q,IAAMA,EACX3Q,KAAKw4B,MACH,EAAAC,eAAewgH,2BACfj5I,KAAKS,MAAMkQ,EAAM,EAAGA,IAEf,IAVPnN,GAASA,GAAS,GAAK09F,GAAI,GAY7B,GAAgB,KAAVi4B,EAAa,MAErB,OAAIA,GACFn5H,KAAK2Q,IAAMA,GACNopI,EACI93I,EAAK8O,UAAUgpI,EAAuBppI,IAE/C3Q,KAAKw4B,MACH,EAAAC,eAAemsF,uBACf5kH,KAAKS,MAAMkQ,IAEN,MAET3Q,KAAK2Q,IAAMA,EACJ62C,OAAO0wF,cAAc10I,IAG9B2gH,6CAEE,IAAIxzG,EAAM3Q,KAAK2Q,IACXA,EAAM3Q,KAAKwR,MAAO,IAAAwlI,mBAAkBh3I,KAAKgR,OAAO/O,KAAK8K,WAAW4D,KAClE3Q,KAAKw4B,MACH,EAAAC,eAAeuhH,qEACfh6I,KAAKS,MAAMkQ,IAKjBqnI,kBAAkB+B,GAA6B,GAC7C,OAAO/5I,KAAKi4I,sBAAsB,EAAG8B,GAG/BhC,0BAA0BgC,GAA6B,GAC7D,IAAI7kI,EAAQlV,KAAK2Q,IACbnN,EAAQxD,KAAKs4I,iBACb2B,EAAU9gG,QAAQ31C,GAClB02I,GAAU,EAEdnuI,QAAQstC,SAAS71C,IACby2I,EAAU,WACkB,GAA1BF,GACF/5I,KAAKw4B,MACH,EAAAC,eAAe0hH,4EACfn6I,KAAKS,MAAMyU,EAAOlV,KAAK2Q,MAG3BupI,GAAU,GAGZ,IAAI1oI,EAAMxR,KAAKwR,IACXvP,EAAOjC,KAAKgR,OAAO/O,KAqBvB,OApBIjC,KAAK2Q,KAAOa,IACgB,GAA1BuoI,GACF/5I,KAAKw4B,MACH,EAAAC,eAAemsF,uBACf5kH,KAAKS,MAAMyU,EAAO1D,IAGtB0oI,GAAU,GAC4B,KAA7Bj4I,EAAK8K,WAAW/M,KAAK2Q,OAC5B3Q,KAAK2Q,MAEuB,GAA1BopI,GACF/5I,KAAKw4B,MACH,EAAAC,eAAe2hH,qCACfp6I,KAAKS,MAAMyU,EAAOlV,KAAK2Q,MAG3BupI,GAAU,GAGRA,GACMH,EACJ93I,EAAK8O,UAAUgpI,EAAuB/5I,KAAK2Q,KAC3C,GAEC62C,OAAO0wF,cAAc+B,IAruChC,cA0uCA,MAAatC,EACXp3I,YAESoQ,EAEA2mG,EAEAjD,GAJA,KAAA1jG,IAAAA,EAEA,KAAA2mG,MAAAA,EAEA,KAAAjD,SAAAA,GAPX,UAYA,IAAIqjC,EAA8B,M,2JC3tDlC,eAMA,UAMA,SAAkB2C,GAKhB,eAEA,iBAEA,iBAEA,iBAEA,qBAKA,eAEA,iBAEA,iBAEA,iBAEA,qBAEA,oBAKA,kBAEA,kBAKA,oBAKA,0BAEA,8BAEA,wBAEA,sBAEA,wBAEA,0BAKA,oBA5DF,CAAkB,EAAAA,WAAA,EAAAA,SAAQ,KAgE1B,SAAkBC,GAChB,mBAEA,uBAEA,2BAEA,yBAEA,qBAEA,0BAEA,sBAEA,oBAEA,uBAEA,+BAEA,6BAEA,0BAEA,8BAEA,wBAEA,8BA7BF,CAAkB,EAAAA,YAAA,EAAAA,UAAS,KAiC3B,MAAaviH,EAoBXx3B,YAAYC,EAAgByF,EAAkBq0B,GALtC,KAAAigH,iBAAgC,KAEhC,KAAAC,cAA6B,KAInCx6I,KAAKQ,KAAOA,EACZR,KAAKiG,MAAQA,EACbjG,KAAKs6B,KAAOA,EACZt6B,KAAKg/B,SAAgB9nB,KAAeojB,EAAO,GAC3Ct6B,KAAK45C,eAAiB,KACtB55C,KAAK06C,mBAAqB,KACZ,IAARz0C,EAGJjG,KAAKw6I,cAAgBx6I,KAFrBA,KAAKu6I,iBAAmBv6I,KAOxByuE,cACF,GAAIzuE,MAAQ+3B,EAAKoD,KAAM,OAAOn7B,KAC9B,OAAQA,KAAKQ,MACX,KAAK,EAAa,OAAOu3B,EAAK9e,GAC9B,KAAK,EAAc,OAAO8e,EAAK7e,IAY/B,QAAS,OAAO6e,EAAK5e,IATrB,KAAK,GACL,KAAK,EAAc,OAAO4e,EAAK3e,IAC/B,KAAK,EAAgB,OAAoB,IAAbpZ,KAAKs6B,KAAavC,EAAKwzB,QAAUxzB,EAAKyzB,QAClE,KAAK,EAAa,OAAOzzB,EAAKze,GAC9B,KAAK,EAAc,OAAOye,EAAKxe,IAC/B,KAAK,EAAc,OAAOwe,EAAKve,IAC/B,KAAK,EAAc,OAAOue,EAAKte,IAC/B,KAAK,EAAgB,OAAoB,IAAbzZ,KAAKs6B,KAAavC,EAAKggB,QAAUhgB,EAAKmgB,SAOlEyyB,iBACF,OAAiB,IAAb3qE,KAAKQ,KAA8Bu3B,EAAKoD,KACrCn7B,KAIL23C,gBACF,OAAO,GAAKjhC,IAAS1W,KAAKg/B,UAIxB/G,cACF,OAAOj4B,KAAKwM,GAAG,KAIboyB,qBACF,OAAO5+B,KAAKwM,GAAG,KAIbi6D,0BACF,OAAOzmE,KAAKwM,GAAG,KAIbg8D,yBACF,OAAOxoE,KAAKwM,GAAG,KAIb2yB,2BACF,OAAOn/B,KAAKwM,GAAG,KAIbmoF,6BACF,OAAO30F,KAAKwM,GAAG,KAIb69D,4BACF,OAAOrqE,KAAKwM,GAAG,KAIb64H,6BACF,OAAOrlI,KAAKwM,GAAG,GAIbktC,mBACF,OAAO15C,KAAKwM,GAAG,KAIbkzB,qBACF,OAAO1/B,KAAK4+B,gBAAkB5+B,KAAK05C,aAIjCC,qBACF,OAAO35C,MAAQ+3B,EAAKpe,KAIlB8gI,oBACF,OAAOz6I,KAAKwM,GAAG,MAIbqJ,kBACF,OAAO7V,KAAKwM,GAAG,KAIb0tC,0BACF,OAAOl6C,KAAKwM,GAAG,KAIb+uC,0BACF,OAAOv7C,KAAKwM,GAAG,KAIb07D,0BACF,OAAOloE,KAAKwM,GAAG,MAIb2lI,cACF,QAAOnyI,KAAKu7C,qBACgB,OAAxBv7C,KAAK45C,eAKXC,WACE,OAAO75C,KAAKu7C,oBACRv7C,KAAK45C,eACL,KAINiB,kBAAkBrF,GAChB,IAAIoE,EAAiB55C,KAAK65C,WAC1B,GAAID,EAEF,OAAOA,EACF,CACL,IAAIc,EAAqB16C,KAAKw7C,eAC9B,GAAId,EAAoB,CAEtB,IAAIh5C,EAAOg5C,EAAmBh5C,KAC1B6vI,EAAUxlI,OAAOypC,EAAQa,SAASqgB,aAAalhB,EAAQ4J,kBAAmB,CAAE19C,KAEhF,OADA6vI,EAAQnM,YAAc1jI,EACf6vI,EACF,CACL,IAAItV,EAAiBzmF,EAAQymF,eAC7B,GAAIA,EAAe/gF,IAAIl7C,MAErB,OAAO+L,OAAOkwH,EAAe9gF,IAAIn7C,QAIvC,OAAO,KAILiW,iBACF,QAAOjW,KAAKu7C,qBACoB,OAA5Bv7C,KAAK06C,mBAKXc,eACE,OAAOx7C,KAAKu7C,oBACRv7C,KAAK06C,mBACL,KAIFtkC,gBACF,GAAIpW,KAAKu7C,oBAAqB,CAC5B,IAAI3B,EAAiB55C,KAAK45C,eAC1B,OAAIA,GAAwBA,EAAe+B,aAAa,EAAAC,eAAeruC,WACpC,OAA5BvN,KAAK06C,mBAEd,OAAO,EAILmb,kBACF,IAAIjc,EAAiB55C,KAAK45C,eAC1B,OAA0B,OAAnBA,GAA2BA,EAAe+B,aAAa,EAAAC,eAAeruC,WAI3EqwC,sBACF,OAAI59C,KAAKkoE,oBACAloE,KAEF+L,OAAO/L,KAAKu6I,kBAIjBG,mBACF,OAAO16I,KAAKw6I,cAId3zE,yBAAyBuJ,GACvB,OAAOA,EAAW91C,KAAOt6B,KAAKs6B,KAIhCwsC,wBAAwBsJ,GACtB,IAAI91C,EAAOt6B,KAAKwM,GAAG,GAAsBxM,KAAKs6B,KAAOt6B,KAAKs6B,KAAO,EACjE,OAAO,IAAQ81C,EAAW91C,KAAOA,EAInC9tB,GAAGvG,GAA0B,OAAQjG,KAAKiG,MAAQA,IAAUA,EAE5DyG,MAAMzG,GAA0B,OAA+B,IAAvBjG,KAAKiG,MAAQA,GAGrD02E,aACE5wE,OAAO/L,KAAKu7C,qBACZ,IAAIm/F,EAAe16I,KAAKw6I,cAQxB,OAPKE,IACH3uI,QAAQ/L,KAAKk6C,qBACbl6C,KAAKw6I,cAAgBE,EAAe,IAAI3iH,EAAK/3B,KAAKQ,KAAmB,IAAbR,KAAKiG,MAA4BjG,KAAKs6B,MAC9FogH,EAAa9gG,eAAiB55C,KAAK45C,eACnC8gG,EAAahgG,mBAAqB16C,KAAK06C,mBACvCggG,EAAaH,iBAAmBv6I,MAE3B06I,EAIT5xD,OAAOC,GACL,OAAI/oF,KAAKQ,MAAQuoF,EAAMvoF,QACnBR,KAAK6V,aAEL7V,KAAK45C,gBAAkBmvC,EAAMnvC,gBAC7B55C,KAAK06C,oBAAsBquC,EAAMruC,oBACjC16C,KAAKk6C,qBAAuB6uC,EAAM7uC,qBAOxCJ,eAAe4P,EAAcixF,GAA6B,GACxD,IAAIC,EACAC,EACApkB,EACAqkB,EACJ,GAAI96I,KAAK6V,aACP,GAAI6zC,EAAO7zC,eACJ7V,KAAKk6C,qBAAuBwP,EAAOxP,qBACtC,GAAI0gG,EAAe56I,KAAK65C,YACtB,GAAIghG,EAAcnxF,EAAO7P,WACvB,OAAO+gG,EAAa9gG,eAAe+gG,QAEhC,GAAIpkB,EAAkBz2H,KAAKw7C,gBAChC,GAAIs/F,EAAiBpxF,EAAOlO,eAC1B,OAAOi7E,EAAgB38E,eAAeghG,QAEnC,GAAI96I,KAAKkoE,sBAAwBloE,KAAKQ,MAAQkpD,EAAOlpD,MAAwB,IAAfkpD,EAAOlpD,MAAwC,IAAbR,KAAKQ,MAC1G,OAAO,OAIR,IAAKkpD,EAAO7zC,YACjB,GAAI7V,KAAK4+B,eACP,GAAI8qB,EAAO9qB,gBACT,IACG+7G,GACD36I,KAAK25C,gBACL35C,KAAKm/B,sBAAwBuqB,EAAOvqB,qBAEpC,OAAOn/B,KAAKs6B,MAAQovB,EAAOpvB,SAExB,IAAmB,IAAfovB,EAAOlpD,KAChB,OAAOR,KAAKs6B,MAAQ,GACf,GAAmB,IAAfovB,EAAOlpD,KAChB,OAAOR,KAAKs6B,MAAQ,QAEjB,GAAIt6B,KAAK05C,cACd,GAAIgQ,EAAOhQ,aACT,OAAO15C,KAAKs6B,MAAQovB,EAAOpvB,UAExB,GAAIt6B,KAAKy6I,eACV/wF,EAAO+wF,cACT,OAAOz6I,KAAKs6B,MAAQovB,EAAOpvB,KAIjC,OAAO,EAITsc,uBAAuB8S,EAAcixF,GAA6B,GAChE,OAAI36I,KAAK6V,YAAoB7V,KAAK85C,eAAe4P,IACxCA,EAAO7zC,cAEZ7V,KAAK4+B,eACA8qB,EAAO9qB,gBAAkB8qB,EAAOpvB,MAAQt6B,KAAKs6B,QACjDqgH,GACD36I,KAAKm/B,sBAAwBuqB,EAAOvqB,sBAGjCn/B,KAAKQ,MAAQkpD,EAAOlpD,MAI7Bk9C,eAAegM,GAEb,GAAI1pD,KAAKwM,GAAG,IAAsBk9C,EAAOl9C,GAAG,GAAoB,CAC9D,IAAI8tB,EAAOt6B,KAAKs6B,KAChB,OAAOA,GAAQovB,EAAOpvB,OAASA,GAAQ,IAAMt6B,KAAKwM,GAAG,IAAqBk9C,EAAOl9C,GAAG,IAEtF,OAAOxM,KAAKQ,MAAQkpD,EAAOlpD,KAI7BE,yBAAyBkC,EAAYC,EAAak4I,GAChD,OAAIl4I,EAAMi3C,eAAel3C,EAAMm4I,GAA+Bn4I,EACrDA,EAAKk3C,eAAej3C,EAAOk4I,GAA+Bl4I,EAC5D,KAIT+1B,SAASoiH,GAAiB,GACxB,MAAMC,EAAkBD,EACpB,QACA,UACJ,GAAIh7I,KAAK6V,YAAa,CACpB,IAAI+jC,EAAiB55C,KAAK65C,WAC1B,GAAID,EACF,OAAO55C,KAAKk6C,oBACRN,EAAe/D,aAAeolG,EAC9BrhG,EAAe/D,aACd,CACL,IAAI6E,EAAqB16C,KAAKw7C,eAC9B,GAAId,EACF,OAAO16C,KAAKk6C,oBACR,IAAMQ,EAAmB9hB,SAASoiH,GAAY,IAAMC,EACpDvgG,EAAmB9hB,SAASoiH,IAItC,OAAQh7I,KAAKQ,MACX,KAAK,EAAa,MAAO,KACzB,KAAK,EAAc,MAAO,MAC1B,KAAK,EAAc,MAAO,MAC1B,KAAK,EAAc,MAAO,MAC1B,KAAK,EAAgB,MAAO,QAC5B,KAAK,EAAa,MAAO,KACzB,KAAK,EAAc,MAAO,MAC1B,KAAK,EAAc,MAAO,MAC1B,KAAK,EAAc,MAAO,MAC1B,KAAK,EAAgB,MAAO,QAC5B,KAAK,GAAe,MAAO,OAC3B,KAAK,GAAc,MAAO,MAC1B,KAAK,GAAc,MAAO,MAC1B,KAAK,GAAe,MAAO,OAC3B,KAAK,GAAkB,MAAO,UAC9B,KAAK,GAAoB,MAAO,YAChC,KAAK,GAAiB,MAAO,SAC7B,KAAK,GAAgB,MAAO,QAC5B,KAAK,GAAiB,MAAO,SAC7B,KAAK,GAAkB,MAAO,UAC9B,QAASuL,QAAO,GAChB,KAAK,GAAe,MAAO,QAO/BywB,QACE,OAAQx8B,KAAKQ,MACX,QAASuL,QAAO,GAChB,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,GAAe,OAAO,EAAA0uB,QAAQC,IACnC,KAAK,EACL,KAAK,EAAgB,GAAiB,IAAb16B,KAAKs6B,KAAY,OAAO,EAAAG,QAAQC,IACzD,KAAK,EACL,KAAK,EAAc,OAAO,EAAAD,QAAQmB,IAClC,KAAK,GAAc,OAAO,EAAAnB,QAAQwhB,IAClC,KAAK,GAAc,OAAO,EAAAxhB,QAAQ2hB,IAClC,KAAK,GAAe,OAAO,EAAA3hB,QAAQwsB,KAEnC,KAAK,GAAkB,OAAO,EAAAxsB,QAAQysB,QACtC,KAAK,GAAoB,OAAO,EAAAzsB,QAAQ0sB,UACxC,KAAK,GAAiB,OAAO,EAAA1sB,QAAQ2sB,OACrC,KAAK,GAAgB,OAAO,EAAA3sB,QAAQ4sB,MACpC,KAAK,GAAiB,OAAO,EAAA5sB,QAAQ6sB,OACrC,KAAK,GAAkB,OAAO,EAAA7sB,QAAQ8sB,QACtC,KAAK,GAAe,OAAO,EAAA9sB,QAAQqb,OAoLzC,SAAgBid,EAAYq5C,GAC1B,IAAI8uC,EAAW9uC,EAAM5gG,OACjBuuB,EAAM,IAAI3pB,MAAe8qI,GAC7B,IAAK,IAAIzvI,EAAI,EAAGA,EAAIyvI,IAAYzvI,EAAGsuB,EAAItuB,GAAK2gG,EAAM3gG,GAAG+wB,QACrD,OAAOzC,EAjmBT,SAgbkB,EAAA9gB,GAAY,IAAI8e,EAAK,EACnC,IAGmB,GAIL,EAAA7e,IAAY,IAAI6e,EAAK,EACnC,IAGkB,IAIJ,EAAA5e,IAAY,IAAI4e,EAAK,EACnC,IAEkB,IAIJ,EAAA3e,IAAY,IAAI2e,EAAK,EACnC,IAGkB,IAIJ,EAAAyzB,QAAgB,IAAIzzB,EAAK,EACvC,IAGkB,IAIJ,EAAAwzB,QAAgB,IAAIxzB,EAAK,EACvC,IAIkB,IAIJ,EAAAze,GAAW,IAAIye,EAAK,EAClC,IAGmB,GAIL,EAAAxe,IAAY,IAAIwe,EAAK,EACnC,IAGkB,IAIJ,EAAAve,IAAY,IAAIue,EAAK,EACnC,IAEkB,IAIJ,EAAAte,IAAY,IAAIse,EAAK,EACnC,IAGkB,IAIJ,EAAAmgB,QAAgB,IAAIngB,EAAK,EACvC,IAGkB,IAIJ,EAAAggB,QAAgB,IAAIhgB,EAAK,EACvC,IAIkB,IAIJ,EAAApe,KAAa,IAAIoe,EAAK,GACpC,IAGmB,GAIL,EAAAne,IAAY,IAAIme,EAAK,GACnC,IAEkB,IAIJ,EAAAle,IAAY,IAAIke,EAAK,GACnC,IAGkB,IAIJ,EAAAje,KAAa,IAAIie,EAAK,GACpC,KACiB,KAIH,EAAAyrB,QAAgB,IAAIzrB,EAAK,GACvC,KAEqB,GAIP,EAAA0rB,UAAkB,IAAI1rB,EAAK,GACzC,KAEqB,GAIP,EAAA2rB,OAAe,IAAI3rB,EAAK,GACtC,KAEqB,GAIP,EAAA4rB,MAAc,IAAI5rB,EAAK,GACrC,KAEqB,GAIP,EAAAylB,OAAe,IAAIzlB,EAAK,GACtC,KACqB,GAIP,EAAA6rB,QAAgB,IAAI7rB,EAAK,GACvC,KAEqB,GAIP,EAAAsH,KAAa,IAAItH,EAAK,GAAD,EAAgC,GAGrD,EAAAoD,KAAa,IAAIpD,EAAKA,EAAK5e,IAAI3Y,KAAMu3B,EAAK5e,IAAIlT,MAAO8xB,EAAK5e,IAAImhB,MAIhF,gBAQA,yBAA8B8xE,GAC5B,IAAI8uC,EAAW9uC,EAAM5gG,OACrB,IAAK0vI,EAAU,MAAO,GACtB,IAAI3zD,EAAK,IAAIn3E,MAAc8qI,GAC3B,IAAK,IAAIzvI,EAAI,EAAGA,EAAIyvI,IAAYzvI,EAAG87E,EAAG97E,GAAK2gG,EAAM3gG,GAAGmtB,UAAS,GAC7D,OAAO2uD,EAAG34E,KAAK,MAIjB,MAAa6/C,EAmBXluD,YACEi1C,EACAmB,EAAgC,KAChCz1C,EAA0B,KAC1Bw1C,EAAwB,MArB1B,KAAAgF,GAAU,EAuBR17C,KAAK22C,eAAiBA,GAAkC,GACxD32C,KAAKs/C,mBAAqB,EAC1Bt/C,KAAKkB,WAAaA,GAA0B62B,EAAKsH,KACjDr/B,KAAK02C,SAAWA,EAChB12C,KAAKw1C,QAAUA,EACfx1C,KAAK62E,SAAU,EACf,IAAIt7C,EAAYia,EAAQnd,QAAQkD,UAC5B75B,EAAO,IAAIq2B,EAAKwD,EAAU/6B,MAAwB,IAAlB+6B,EAAUt1B,MAA2B,IAAqBs1B,EAAUjB,MACxGt6B,KAAK0B,KAAOA,EACZA,EAAKg5C,mBAAqB16C,KAE1B,IAAIm7I,EAAiB3lG,EAAQ0mF,iBACzB1wH,EAAS2vI,EAAe3vI,OAC5B,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAQC,IAAK,CAC/B,IAAI2vI,EAAUD,EAAe1vI,GAC7B,GAAIzL,KAAK8oF,OAAOsyD,GAEd,OADAp7I,KAAK07C,GAAK0/F,EAAQ1/F,GACX17C,KAGXA,KAAK07C,GAAKlG,EAAQsmF,kBAClBtmF,EAAQ0mF,iBAAiBzqH,KAAKzR,MAG5B6yD,gBACF,IAAInc,EAAW12C,KAAK02C,SAChBC,EAAiB32C,KAAK22C,eACtB0kG,EAAoB1kG,EAAenrC,OACvC,IAAK6vI,EACH,OAAK3kG,EACEA,EAASla,QADM,EAAA/B,QAAQqb,KAGhC,GAAIY,EAAU,CACZ,IAAI4kG,EAAW,IAAIlrI,MAAe,EAAIirI,GACtCC,EAAS,GAAK5kG,EAASla,QACvB,IAAK,IAAI/wB,EAAI,EAAGA,EAAI4vI,IAAqB5vI,EACvC6vI,EAAS7vI,EAAI,GAAKkrC,EAAelrC,GAAG+wB,QAEtC,OAAO,IAAAgb,YAAW8jG,GAEpB,OAAO,IAAA9jG,YAAWub,EAAYpc,IAG5Bmc,iBACF,OAAO9yD,KAAKkB,WAAWs7B,QAIzBssD,OAAOC,GAGL,IAAIwyD,EAAev7I,KAAK02C,SACpB8kG,EAAgBzyD,EAAMryC,SAC1B,GAAqB,OAAjB6kG,GACF,GAAsB,OAAlBC,IAA2BD,EAAazyD,OAAO0yD,GAAgB,OAAO,OACrE,GAAIA,EACT,OAAO,EAIT,GAAIx7I,KAAK62E,SAAWkS,EAAMlS,QAAS,OAAO,EAG1C,IAAI4kE,EAAqBz7I,KAAK22C,eAC1B+kG,EAAsB3yD,EAAMpyC,eAC5BgkB,EAAgB8gF,EAAmBjwI,OACvC,GAAImvD,GAAiB+gF,EAAoBlwI,OAAQ,OAAO,EACxD,IAAK,IAAIC,EAAI,EAAGA,EAAIkvD,IAAiBlvD,EACnC,IAAKgwI,EAAmBhwI,GAAGq9E,OAAO4yD,EAAoBjwI,IAAK,OAAO,EAIpE,OAAOzL,KAAKkB,WAAW4nF,OAAOC,EAAM7nF,YAItC44C,eAAe4P,EAAmBiyF,GAAwB,GAGxD,IAAIJ,EAAev7I,KAAK02C,SACpBklG,EAAiBlyF,EAAOhT,SAC5B,GAAqB,OAAjB6kG,GACF,GAAuB,OAAnBK,IAA4BL,EAAazhG,eAAe8hG,GAAiB,OAAO,OAC/E,GAAIA,EACT,OAAO,EAIT,GAAI57I,KAAK62E,SAAWntB,EAAOmtB,QAAS,OAAO,EAG3C,IAAI4kE,EAAqBz7I,KAAK22C,eAC1BklG,EAAuBnyF,EAAO/S,eAC9BgkB,EAAgB8gF,EAAmBjwI,OACvC,GAAImvD,GAAiBkhF,EAAqBrwI,OAAQ,OAAO,EACzD,IAAK,IAAIC,EAAI,EAAGA,EAAIkvD,IAAiBlvD,EAAG,CACtC,IAAIqwI,EAAoBL,EAAmBhwI,GACvCswI,EAAsBF,EAAqBpwI,GAC/C,IAAKqwI,EAAkBhiG,eAAeiiG,GAAsB,OAAO,EAIrE,IAAIC,EAAiBh8I,KAAKkB,WACtB+6I,EAAmBvyF,EAAOxoD,WAC9B,OAAO86I,GAAkBC,GAAoBD,EAAeliG,eAAemiG,GAIzEnnF,yBACF,IAAIpe,EAAW12C,KAAK02C,SACpB,GAAIA,GACEA,EAAStgC,UAAW,OAAO,EAEjC,IAAIugC,EAAiB32C,KAAK22C,eAC1B,IAAK,IAAIlrC,EAAI,EAAGC,EAAIirC,EAAenrC,OAAQC,EAAIC,IAAKD,EAClD,GAAIkrC,EAAelrC,GAAG2K,UAAW,OAAO,EAE1C,OAAO,EAIT4+C,2BACE,IAAIknF,EAAU,IAAI9rI,MACdupB,EAAQ,EACR+c,EAAW12C,KAAK02C,SAChBA,IACEA,EAAStgC,WACX8lI,EAAQzqI,KAAKkoB,KAEbA,GAEJ,IAAIgd,EAAiB32C,KAAK22C,eAC1B,IAAK,IAAIlrC,EAAI,EAAGC,EAAIirC,EAAenrC,OAAQC,EAAIC,IAAKD,EAC9CkrC,EAAelrC,GAAG2K,WACpB8lI,EAAQzqI,KAAKkoB,KAEbA,EAEJ,OAAOuiH,EAITtjH,SAASoiH,GAAiB,GACxB,IAAIzzD,EAAK,IAAIn3E,MACbm3E,EAAG91E,KAAKupI,EAAW,MAAQ,KAC3B,IAAIrhH,EAAQ,EACR+c,EAAW12C,KAAK02C,SAChBA,IACF6wC,EAAG91E,KAAKupI,EAAW,QAAU,UAC7BjvI,QAAQ2qC,EAASgE,oBACjB6sC,EAAG91E,KAAKilC,EAAS9d,SAASoiH,IAC1BrhH,EAAQ,GAEV,IAAI14B,EAAajB,KAAK22C,eAClBgkB,EAAgB15D,EAAWuK,OAC/B,GAAImvD,EAAe,CACjB,IAAIwhF,EAAgBn8I,KAAKs/C,mBACrB88F,EAAYp8I,KAAK62E,QAAUlc,EAAgB,GAAK,EACpD,IAAK,IAAIlvD,EAAI,EAAGA,EAAIkvD,IAAiBlvD,IAAKkuB,EACpCA,GAAO4tD,EAAG91E,KAAKupI,EAAW,MAAQ,MAClCvvI,GAAK2wI,GAAW70D,EAAG91E,KAAK,OAC5B81E,EAAG91E,KAAKxQ,EAAWwK,GAAGmtB,SAASoiH,IAC3BvvI,GAAK0wI,GAAiB1wI,GAAK2wI,GAAW70D,EAAG91E,KAAK,KAKtD,OAFA81E,EAAG91E,KAAKupI,EAAW,QAAU,SAC7BzzD,EAAG91E,KAAKzR,KAAKkB,WAAW03B,SAASoiH,IAC1BzzD,EAAG34E,KAAK,IAIjBgF,QACE,IAAI+iC,EAAiB32C,KAAK22C,eACtB0kG,EAAoB1kG,EAAenrC,OACnC6wI,EAAsB,IAAIjsI,MAAYirI,GAC1C,IAAK,IAAI5vI,EAAI,EAAGA,EAAI4vI,IAAqB5vI,EACvC4wI,EAAoB5wI,GAAKkrC,EAAelrC,GAE1C,OAAO,IAAIgjD,EAAUzuD,KAAKw1C,QAAS6mG,EAAqBr8I,KAAKkB,WAAYlB,KAAK02C,WA3MlF,e,yBCpsBA,SAAgBioB,EAAQtB,EAAoB1gB,GAC1C,OAAOxjC,IAAIkkD,EAAO1gB,IACXxjC,IAAIkkD,EAAO1gB,EAAS,KAAO,EAC3BxjC,IAAIkkD,EAAO1gB,EAAS,KAAO,GAC3BxjC,IAAIkkD,EAAO1gB,EAAS,KAAO,GAIpC,SAAgBoD,EAASv8C,EAAY65D,EAAoB1gB,GACvD0gB,EAAO1gB,GAAcn5C,EACrB65D,EAAO1gB,EAAS,GAAKn5C,IAAU,EAC/B65D,EAAO1gB,EAAS,GAAKn5C,IAAU,GAC/B65D,EAAO1gB,EAAS,GAAKn5C,IAAU,GAUjC,SAAgB84I,EAAQj/E,EAAoB1gB,GAC1C,IAAI4/F,EAAK59E,EAAQtB,EAAQ1gB,GACrB6/F,EAAK79E,EAAQtB,EAAQ1gB,EAAS,GAClC,OAAO/B,QAAQ2hG,EAAIC,G,oNA/CrB,kBAAuBn/E,EAAoB1gB,GACzC,OAAO0gB,EAAO1gB,IAIhB,mBAAwBn5C,EAAY65D,EAAoB1gB,GACtD0gB,EAAO1gB,GAAUn5C,GAInB,mBAAwB65D,EAAoB1gB,GAC1C,OAAOxjC,IAAIkkD,EAAO1gB,IACXxjC,IAAIkkD,EAAO1gB,EAAS,KAAO,GAIpC,oBAAyBn5C,EAAY65D,EAAoB1gB,GACvD0gB,EAAO1gB,GAAcn5C,EACrB65D,EAAO1gB,EAAS,GAAKn5C,IAAU,GAIjC,YAQA,aAQA,yBAA8BA,EAAY65D,EAAoB1gB,EAAa8/F,GAAiB,GAC1F18F,EAASv8C,EAAO65D,EAAQ1gB,GACxBoD,EAAS08F,GAAYj5I,GAAS,EAAI,GAAK,EAAG65D,EAAQ1gB,EAAS,IAI7D,YAOA,oBAAyBn5C,EAAY65D,EAAoB1gB,GACvDoD,EAAS5G,QAAQ31C,GAAQ65D,EAAQ1gB,GACjCoD,EAAS1G,SAAS71C,GAAQ65D,EAAQ1gB,EAAS,IAI7C,yBAA8Bn5C,EAAY65D,EAAoB1gB,EAAa8/F,GAAiB,GAC1F1wI,OAAO0wI,EAAWrjG,WAAW51C,GAAS01C,WAAW11C,IACjDu8C,EAAS5G,QAAQ31C,GAAQ65D,EAAQ1gB,IAInC,mBAAwB0gB,EAAoB1gB,GAC1C,OAAO+/F,WAAW/9E,EAAQtB,EAAQ1gB,KAIpC,oBAAyBn5C,EAAY65D,EAAoB1gB,GACvDoD,EAAS48F,WAAWn5I,GAAQ65D,EAAQ1gB,IAItC,mBAAwB0gB,EAAoB1gB,GAC1C,OAAOigG,WAAWN,EAAQj/E,EAAQ1gB,KAIpC,oBAAyBn5C,EAAY65D,EAAoB1gB,GACvD,IAAIkgG,EAAWC,WAAWt5I,GAC1Bu8C,EAAS5G,QAAQ0jG,GAAWx/E,EAAQ1gB,GACpCoD,EAAS1G,SAASwjG,GAAWx/E,EAAQ1gB,EAAS,K,6FCjFhD,qBAA+Bu7B,EAA4B,KAAM6kE,EAA6B,MAC5F,IAAIC,EAAS,IAAIxjG,IACjB,GAAI0+B,EAEF,IAAK,IAAI52B,EAAQC,SAAS22B,GAAWzsE,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CACxE,IAAIC,EAAIoG,UAAUwvC,EAAM71C,IACpBwxI,EAAIlxI,OAAOmsE,EAAS/8B,IAAIzvC,IAC5BsxI,EAAOrwI,IAAIjB,EAAGuxI,GAGlB,GAAIF,EAEF,IAAK,IAAIz7F,EAAQC,SAASw7F,GAAYtxI,EAAI,EAAGC,EAAI41C,EAAM91C,OAAQC,EAAIC,IAAKD,EAAG,CACzE,IAAIC,EAAIoG,UAAUwvC,EAAM71C,IACpBwxI,EAAIlxI,OAAOgxI,EAAU5hG,IAAIzvC,IAC7BsxI,EAAOrwI,IAAIjB,EAAGuxI,GAGlB,OAAOD,I,2ZCnBT,YACA,YACA,WACA,YACA,WACA,YACA,a,6FCLA,sBAA2BE,GACzB,OAAY,GAALA,GAA2B,IAAhBA,EAAKA,EAAI,K,2HCE7B,eAIMC,EAAY,GAMlB,SAAgBnqI,EAAcpM,GAK5B,IAJA,IAiBI2xD,EAjBA5nD,EAAM,EACNkE,EAAMjO,EAAK4E,OAGRmF,EAAM,EAAIkE,GACS,IAAxBjO,EAAKmG,WAAW4D,IAChB/J,EAAKmG,WAAW4D,EAAM,IAAMwsI,GAE5BxsI,GAAO,EAUT,KAPIA,EAAM,GAAKkE,EAAMjO,EAAK4E,UACxB5E,EAAOA,EAAKmK,UAAUJ,EAAKkE,GAC3BA,GAAOlE,EACPA,EAAM,GAIDA,EAAM,EAAIkE,GAAK,CAIpB,GAHA0jD,GAAQ,EAIN3xD,EAAKmG,WAAW4D,IAAQwsI,GACI,IAA5Bv2I,EAAKmG,WAAW4D,EAAM,GACtB,CAGA,IADA4nD,EAAQ5nD,EAAM,GAAKkE,IAEjBlE,EAAM,EAAIkE,GACVjO,EAAKmG,WAAW4D,EAAM,IAAMwsI,EAC5B,CACAv2I,EAAO2xD,EACH3xD,EAAKmK,UAAU,EAAGJ,GAClB/J,EAAKmK,UAAU,EAAGJ,GAAO/J,EAAKmK,UAAUJ,EAAM,GAClDkE,GAAO,EACP,SAKF,IADA0jD,EAAQ5nD,EAAM,GAAKkE,IACsB,IAA5BjO,EAAKmG,WAAW4D,EAAM,IACjCA,EAAM,EAAIkE,GACkB,IAA5BjO,EAAKmG,WAAW4D,EAAM,IACtB/J,EAAKmG,WAAW4D,EAAM,IAAMwsI,EAC5B,CAEA,IAAIC,EAAOzsI,EACX,OAASysI,GAAQ,GACf,GAAIx2I,EAAKmG,WAAWqwI,IAASD,EAAW,CAClCxsI,EAAMysI,GAAQ,GACa,IAA7Bx2I,EAAKmG,WAAWqwI,EAAO,IACM,IAA7Bx2I,EAAKmG,WAAWqwI,EAAO,KAEvBx2I,EAAO2xD,EACH3xD,EAAKmK,UAAU,EAAGqsI,GAClBx2I,EAAKmK,UAAU,EAAGqsI,GAAQx2I,EAAKmK,UAAUJ,EAAM,GACnDkE,GAAOlE,EAAM,EAAIysI,EACjBzsI,EAAMysI,EAAO,GAEf,MAKJ,GAAIA,EAAO,GAAKzsI,EAAM,IACT,GAAPA,GACoB,IAAtB/J,EAAKmG,WAAW,IACM,IAAtBnG,EAAKmG,WAAW,IAChB,CAEA8H,GADAjO,EAAOA,EAAKmK,UAAUJ,EAAM,IACjBnF,OACX,WAKRmF,IAEF,OAAOkE,EAAM,EAAIjO,EAAO,IAc1B,SAAgBy2I,EAAQntI,GACtB,IAAIS,EAAMT,EAAe1E,OACzB,GAAImF,GAAO,EAAG,CACZ,GAAW,GAAPA,EAAU,MAAO,IACrB,GAAIT,EAAenD,WAAW,IAAMowI,EAClC,OAAOjtI,EAGX,OAASS,EAAM,GACb,GAAIT,EAAenD,WAAW4D,IAAQwsI,EACpC,OAAOjtI,EAAea,UAAU,EAAGJ,GAGvC,MAAO,IA3GT,kBAoFA,uBAA4BT,EAAwBotI,GAClD,OAAIptI,EAAe+C,WAAW,QACrB/C,EAEF8C,EACLqqI,EAAQC,GAAU,EAAAzsI,eAAiBX,IAKvC,a,4PC3Ga,EAAAqtI,WAAa,QAEb,EAAA90D,UAAY,QAEZ,EAAA+0D,YAAc,QAEd,EAAAh1D,aAAe,QAEf,EAAAi1D,WAAa,QAEb,EAAAn1D,cAAgB,QAEhB,EAAAC,WAAa,QAEb,EAAAm1D,YAAc,QAEd,EAAAj0D,YAAc,OAG3B,IAAIk0D,GAAgB,EAGpB,6BACE,OAAOA,GAIT,4BAAiCC,GAG/B,OADAD,EAAgBC,EADCA,GAMnB,oBAAyB37I,EAAc47I,GACrC,OAAOF,EAAgBE,EAAQ57I,EAAO,EAAAwnF,YAAcxnF,I,yBCoLtD,SAAgB67I,EAAQ58C,GACtB,IAAI68C,EAAS,GAAJ78C,EACT,OAAO68C,GAAM,IAAcA,GAAM,IAInC,SAAgBrH,EAAUx1C,GACxB,OAAOA,GAAK,IAAeA,GAAK,GAelC,SAAgBnsF,EAAiBmsF,GAC/B,OAAO48C,EAAQ58C,IAAMw1C,EAAUx1C,G,oVA9OjC,SAAkB88C,GAEhB,mBACA,4BACA,wCACA,wCACA,kDACA,6BAEA,sBACA,6CACA,0BACA,0BACA,4BACA,4BACA,4CACA,0CACA,wCACA,oCACA,8CACA,gCACA,gCACA,0CACA,kDACA,+CACA,gDACA,wBAEA,cAEA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBAEA,cACA,cACA,cACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eAEA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cAEA,8BACA,4BACA,gBACA,8BACA,4BACA,mBACA,sBACA,iCACA,oCACA,gCACA,sBACA,sBACA,wBACA,kBACA,kCACA,wBACA,kCACA,kCACA,oBACA,4BACA,sBACA,+BACA,kCACA,8BACA,0BACA,oBACA,4BACA,8BACA,kCACA,sBACA,uBAEA,6BACA,4BACA,yCACA,iBACA,kCAnIF,CAAkB,EAAAA,WAAA,EAAAA,SAAQ,KAuI1B,uBAA4B98C,GAC1B,OAAQA,GACN,KAAK,GACL,KAAK,GACL,KAAK,KACL,KAAK,KACH,OAAO,EAET,QACE,OAAO,IAMb,wBAA6BA,GAC3B,OAAQA,GACN,KAAK,GACL,KAAK,EACL,KAAK,GACL,KAAK,GACL,KAAK,IACL,KAAK,IACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,MACL,KAAK,MACH,OAAO,EAET,QACE,OAAOA,GAAK,MAAmBA,GAAK,OAM7B,EAAAiR,eAAiB,MAGjB,EAAAC,cAAgB,MAG7B,uBAA4BlR,GAG1B,OAAY,MAAJA,IAAe,EAAAiR,gBAIzB,2BAAgCjR,GAE9B,OAAOA,EAAI,EAAAkR,eAIb,0BAA+BlR,GAE7B,OAAOA,GAAK,EAAAkR,eAId,2BAAgClR,GAG9B,OAAY,MAAJA,IAAe,EAAAiR,gBAIzB,0BAA+BjR,GAG7B,OAAY,MAAJA,IAAe,EAAAkR,eAIzB,6BAAkCoqC,EAASD,GACzC,OAAO,QAAiB,KAALC,IAAe,IAAY,KAALD,GAG3C,YAMA,cAKA,mBAAwBr7C,GACtB,OAAOA,GAAK,IAAeA,GAAK,IAIlC,iBAAsBA,GACpB,IAAI68C,EAAS,GAAJ78C,EACT,OAAOw1C,EAAUx1C,IAAO68C,GAAM,IAAcA,GAAM,KAIpD,qBAKA,6BAAkC78C,GAChC,OAAO48C,EAAQ58C,IACH,IAALA,GACK,IAALA,GACAA,GAAK,KAAOA,GAAK,OACd+8C,EAAmB/8C,EAAUg9C,IAIzC,4BAAiCh9C,GAC/B,OAAOnsF,EAAiBmsF,IACZ,IAALA,GACK,IAALA,GACAA,GAAK,KAAOA,GAAK,OACd+8C,EAAmB/8C,EAAUi9C,IAIzC,MAAMD,EAAgC,CACpC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IACpB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAEtCC,EAA+B,CACnC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IACpB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KACxB,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MA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","sources":["webpack://assemblyscript/webpack/universalModuleDefinition","webpack://assemblyscript/./src/ast.ts","webpack://assemblyscript/./src/builtins.ts","webpack://assemblyscript/./src/common.ts","webpack://assemblyscript/./src/compiler.ts","webpack://assemblyscript/./src/definitions.ts","webpack://assemblyscript/./src/diagnosticMessages.generated.ts","webpack://assemblyscript/./src/diagnostics.ts","webpack://assemblyscript/./src/extra/ast.ts","webpack://assemblyscript/./src/flow.ts","webpack://assemblyscript/./src/glue/js/index.ts","webpack://assemblyscript/./src/index.ts","webpack://assemblyscript/./src/module.ts","webpack://assemblyscript/./src/parser.ts","webpack://assemblyscript/./src/passes/findusedlocals.ts","webpack://assemblyscript/./src/passes/pass.ts","webpack://assemblyscript/./src/passes/rtrace.ts","webpack://assemblyscript/./src/passes/shadowstack.ts","webpack://assemblyscript/./src/program.ts","webpack://assemblyscript/./src/resolver.ts","webpack://assemblyscript/./src/tokenizer.ts","webpack://assemblyscript/./src/types.ts","webpack://assemblyscript/./src/util/binary.ts","webpack://assemblyscript/./src/util/collections.ts","webpack://assemblyscript/./src/util/index.ts","webpack://assemblyscript/./src/util/math.ts","webpack://assemblyscript/./src/util/path.ts","webpack://assemblyscript/./src/util/terminal.ts","webpack://assemblyscript/./src/util/text.ts","webpack://assemblyscript/./src/util/vector.ts","webpack://assemblyscript/./std/assembly/shared/feature.ts","webpack://assemblyscript/./std/assembly/shared/runtime.ts","webpack://assemblyscript/./std/assembly/shared/target.ts","webpack://assemblyscript/./std/assembly/shared/typeinfo.ts","webpack://assemblyscript/external umd \"binaryen\"","webpack://assemblyscript/./node_modules/long/umd/index.js","webpack://assemblyscript/./src/glue/binaryen.js","webpack://assemblyscript/./src/glue/js/collections.js","webpack://assemblyscript/./src/glue/js/float.js","webpack://assemblyscript/./src/glue/js/i64.js","webpack://assemblyscript/./std/portable/index.js","webpack://assemblyscript/webpack/bootstrap","webpack://assemblyscript/webpack/runtime/global","webpack://assemblyscript/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"binaryen\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"binaryen\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"assemblyscript\"] = factory(require(\"binaryen\"));\n\telse\n\t\troot[\"assemblyscript\"] = factory(root[\"binaryen\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__725__) {\nreturn ","/**\n * @fileoverview Abstract syntax tree representing a source file once parsed.\n *\n * Each node in the AST is represented by an instance of a subclass of `Node`,\n * with its `Node#kind` represented by one of the `NodeKind` constants, which\n * dependent code typically switches over. The intended way to create a node\n * is to use the respective `Node.createX` method instead of its constructor.\n *\n * Note that the AST does not contain any type information except type names.\n *\n * @license Apache-2.0\n */\n\n// TODO: Make the AST more easily serializable by refactoring `Node#range` so\n// it doesn't reference the non-serializable `Source` object.\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  LIBRARY_PREFIX,\n  LIBRARY_SUBST\n} from \"./common\";\n\nimport {\n  Token,\n  Range\n} from \"./tokenizer\";\n\nimport {\n  normalizePath,\n  resolvePath,\n  CharCode,\n  isAlphaOrDecimal\n} from \"./util\";\n\nimport {\n  ExpressionRef\n} from \"./module\";\n\nimport {\n  Type\n} from \"./types\";\n\n/** Indicates the kind of a node. */\nexport enum NodeKind {\n\n  SOURCE,\n\n  // types\n  NAMEDTYPE,\n  FUNCTIONTYPE,\n  TYPENAME,\n  TYPEPARAMETER,\n  PARAMETER,\n\n  // expressions\n  IDENTIFIER,\n  ASSERTION,\n  BINARY,\n  CALL,\n  CLASS,\n  COMMA,\n  ELEMENTACCESS,\n  FALSE,\n  FUNCTION,\n  INSTANCEOF,\n  LITERAL,\n  NEW,\n  NULL,\n  OMITTED,\n  PARENTHESIZED,\n  PROPERTYACCESS,\n  TERNARY,\n  SUPER,\n  THIS,\n  TRUE,\n  CONSTRUCTOR,\n  UNARYPOSTFIX,\n  UNARYPREFIX,\n  COMPILED,\n\n  // statements\n  BLOCK,\n  BREAK,\n  CONTINUE,\n  DO,\n  EMPTY,\n  EXPORT,\n  EXPORTDEFAULT,\n  EXPORTIMPORT,\n  EXPRESSION,\n  FOR,\n  FOROF,\n  IF,\n  IMPORT,\n  RETURN,\n  SWITCH,\n  THROW,\n  TRY,\n  VARIABLE,\n  VOID,\n  WHILE,\n\n  // declaration statements\n  CLASSDECLARATION,\n  ENUMDECLARATION,\n  ENUMVALUEDECLARATION,\n  FIELDDECLARATION,\n  FUNCTIONDECLARATION,\n  IMPORTDECLARATION,\n  INTERFACEDECLARATION,\n  METHODDECLARATION,\n  NAMESPACEDECLARATION,\n  TYPEDECLARATION,\n  VARIABLEDECLARATION,\n\n  // special\n  DECORATOR,\n  EXPORTMEMBER,\n  SWITCHCASE,\n  INDEXSIGNATURE,\n  COMMENT\n}\n\n/** Base class of all nodes. */\nexport abstract class Node {\n  constructor(\n    /** Kind of this node. */\n    public kind: NodeKind,\n    /** Source range. */\n    public range: Range\n  ) {}\n\n  // types\n\n  static createSimpleTypeName(\n    name: string,\n    range: Range\n  ): TypeName {\n    return new TypeName(Node.createIdentifierExpression(name, range), null, range);\n  }\n\n  static createNamedType(\n    name: TypeName,\n    typeArguments: TypeNode[] | null,\n    isNullable: bool,\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(name, typeArguments, isNullable, range);\n  }\n\n  static createFunctionType(\n    parameters: ParameterNode[],\n    returnType: TypeNode,\n    explicitThisType: NamedTypeNode | null,\n    isNullable: bool,\n    range: Range\n  ): FunctionTypeNode {\n    return new FunctionTypeNode(parameters, returnType, explicitThisType, isNullable, range);\n  }\n\n  static createOmittedType(\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(Node.createSimpleTypeName(\"\", range), null, false, range);\n  }\n\n  static createTypeParameter(\n    name: IdentifierExpression,\n    extendsType: NamedTypeNode | null,\n    defaultType: NamedTypeNode | null,\n    range: Range\n  ): TypeParameterNode {\n    return new TypeParameterNode(name, extendsType, defaultType, range);\n  }\n\n  static createParameter(\n    parameterKind: ParameterKind,\n    name: IdentifierExpression,\n    type: TypeNode,\n    initializer: Expression | null,\n    range: Range\n  ): ParameterNode {\n    return new ParameterNode(parameterKind, name, type, initializer, range);\n  }\n\n  // special\n\n  static createDecorator(\n    name: Expression,\n    args: Expression[] | null,\n    range: Range\n  ): DecoratorNode {\n    return new DecoratorNode(DecoratorKind.fromNode(name), name, args, range);\n  }\n\n  static createComment(\n    commentKind: CommentKind,\n    text: string,\n    range: Range\n  ): CommentNode {\n    return new CommentNode(commentKind, text, range);\n  }\n\n  // expressions\n\n  static createIdentifierExpression(\n    text: string,\n    range: Range,\n    isQuoted: bool = false\n  ): IdentifierExpression {\n    return new IdentifierExpression(text, isQuoted, range);\n  }\n\n  static createEmptyIdentifierExpression(\n    range: Range\n  ): IdentifierExpression {\n    return new IdentifierExpression(\"\", false, range);\n  }\n\n  static createArrayLiteralExpression(\n    elementExpressions: Expression[],\n    range: Range\n  ): ArrayLiteralExpression {\n    return new ArrayLiteralExpression(elementExpressions, range);\n  }\n\n  static createAssertionExpression(\n    assertionKind: AssertionKind,\n    expression: Expression,\n    toType: TypeNode | null,\n    range: Range\n  ): AssertionExpression {\n    return new AssertionExpression(assertionKind, expression, toType, range);\n  }\n\n  static createBinaryExpression(\n    operator: Token,\n    left: Expression,\n    right: Expression,\n    range: Range\n  ): BinaryExpression {\n    return new BinaryExpression(operator, left, right, range);\n  }\n\n  static createCallExpression(\n    expression: Expression,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): CallExpression {\n    return new CallExpression(expression, typeArguments, args, range);\n  }\n\n  static createClassExpression(\n    declaration: ClassDeclaration\n  ): ClassExpression {\n    return new ClassExpression(declaration);\n  }\n\n  static createCommaExpression(\n    expressions: Expression[],\n    range: Range\n  ): CommaExpression {\n    return new CommaExpression(expressions, range);\n  }\n\n  static createConstructorExpression(\n    range: Range\n  ): ConstructorExpression {\n    return new ConstructorExpression(range);\n  }\n\n  static createElementAccessExpression(\n    expression: Expression,\n    elementExpression: Expression,\n    range: Range\n  ): ElementAccessExpression {\n    return new ElementAccessExpression(expression, elementExpression, range);\n  }\n\n  static createFalseExpression(\n    range: Range\n  ): FalseExpression {\n    return new FalseExpression(range);\n  }\n\n  static createFloatLiteralExpression(\n    value: f64,\n    range: Range\n  ): FloatLiteralExpression {\n    return new FloatLiteralExpression(value, range);\n  }\n\n  static createFunctionExpression(\n    declaration: FunctionDeclaration\n  ): FunctionExpression {\n    return new FunctionExpression(declaration);\n  }\n\n  static createInstanceOfExpression(\n    expression: Expression,\n    isType: TypeNode,\n    range: Range\n  ): InstanceOfExpression {\n    return new InstanceOfExpression(expression, isType, range);\n  }\n\n  static createIntegerLiteralExpression(\n    value: i64,\n    range: Range\n  ): IntegerLiteralExpression {\n    return new IntegerLiteralExpression(value, range);\n  }\n\n  static createNewExpression(\n    typeName: TypeName,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): NewExpression {\n    return new NewExpression(typeName, typeArguments, args, range);\n  }\n\n  static createNullExpression(\n    range: Range\n  ): NullExpression {\n    return new NullExpression(range);\n  }\n\n  static createObjectLiteralExpression(\n    names: IdentifierExpression[],\n    values: Expression[],\n    range: Range\n  ): ObjectLiteralExpression {\n    return new ObjectLiteralExpression(names, values, range);\n  }\n\n  static createOmittedExpression(\n    range: Range\n  ): OmittedExpression {\n    return new OmittedExpression(range);\n  }\n\n  static createParenthesizedExpression(\n    expression: Expression,\n    range: Range\n  ): ParenthesizedExpression {\n    return new ParenthesizedExpression(expression, range);\n  }\n\n  static createPropertyAccessExpression(\n    expression: Expression,\n    property: IdentifierExpression,\n    range: Range\n  ): PropertyAccessExpression {\n    return new PropertyAccessExpression(expression, property, range);\n  }\n\n  static createRegexpLiteralExpression(\n    pattern: string,\n    patternFlags: string,\n    range: Range\n  ): RegexpLiteralExpression {\n    return new RegexpLiteralExpression(pattern, patternFlags, range);\n  }\n\n  static createTernaryExpression(\n    condition: Expression,\n    ifThen: Expression,\n    ifElse: Expression,\n    range: Range\n  ): TernaryExpression {\n    return new TernaryExpression(condition, ifThen, ifElse, range);\n  }\n\n  static createStringLiteralExpression(\n    value: string,\n    range: Range\n  ): StringLiteralExpression {\n    return new StringLiteralExpression(value, range);\n  }\n\n  static createSuperExpression(\n    range: Range\n  ): SuperExpression {\n    return new SuperExpression(range);\n  }\n\n  static createTemplateLiteralExpression(\n    tag: Expression | null,\n    parts: string[],\n    rawParts: string[],\n    expressions: Expression[],\n    range: Range\n  ): TemplateLiteralExpression {\n    return new TemplateLiteralExpression(tag, parts, rawParts, expressions, range);\n  }\n\n  static createThisExpression(\n    range: Range\n  ): ThisExpression {\n    return new ThisExpression(range);\n  }\n\n  static createTrueExpression(\n    range: Range\n  ): TrueExpression {\n    return new TrueExpression(range);\n  }\n\n  static createUnaryPostfixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPostfixExpression {\n    return new UnaryPostfixExpression(operator, operand, range);\n  }\n\n  static createUnaryPrefixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPrefixExpression {\n    return new UnaryPrefixExpression(operator, operand, range);\n  }\n\n  static createCompiledExpression(\n    expr: ExpressionRef,\n    type: Type,\n    range: Range\n  ): Expression {\n    return new CompiledExpression(expr, type, range);\n  }\n\n  // statements\n\n  static createBlockStatement(\n    statements: Statement[],\n    range: Range\n  ): BlockStatement {\n    return new BlockStatement(statements, range);\n  }\n\n  static createBreakStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): BreakStatement {\n    return new BreakStatement(label, range);\n  }\n\n  static createClassDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): ClassDeclaration {\n    return new ClassDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createContinueStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): ContinueStatement {\n    return new ContinueStatement(label, range);\n  }\n\n  static createDoStatement(\n    statement: Statement,\n    condition: Expression,\n    range: Range\n  ): DoStatement {\n    return new DoStatement(statement, condition, range);\n  }\n\n  static createEmptyStatement(\n    range: Range\n  ): EmptyStatement {\n    return new EmptyStatement(range);\n  }\n\n  static createEnumDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    values: EnumValueDeclaration[],\n    range: Range\n  ): EnumDeclaration {\n    return new EnumDeclaration(name, decorators, flags, values, range);\n  }\n\n  static createEnumValueDeclaration(\n    name: IdentifierExpression,\n    flags: CommonFlags,\n    initializer: Expression | null,\n    range: Range\n  ): EnumValueDeclaration {\n    return new EnumValueDeclaration(name, flags, initializer, range);\n  }\n\n  static createExportStatement(\n    members: ExportMember[] | null,\n    path: StringLiteralExpression | null,\n    isDeclare: bool,\n    range: Range\n  ): ExportStatement {\n    return new ExportStatement(members, path, isDeclare, range);\n  }\n\n  static createExportDefaultStatement(\n    declaration: DeclarationStatement,\n    range: Range\n  ): ExportDefaultStatement {\n    return new ExportDefaultStatement(declaration, range);\n  }\n\n  static createExportImportStatement(\n    name: IdentifierExpression,\n    externalName: IdentifierExpression,\n    range: Range\n  ): ExportImportStatement {\n    return new ExportImportStatement(name, externalName, range);\n  }\n\n  static createExportMember(\n    localName: IdentifierExpression,\n    exportedName: IdentifierExpression | null,\n    range: Range\n  ): ExportMember {\n    if (!exportedName) exportedName = localName;\n    return new ExportMember(localName, exportedName, range);\n  }\n\n  static createExpressionStatement(\n    expression: Expression\n  ): ExpressionStatement {\n    return new ExpressionStatement(expression);\n  }\n\n  static createIfStatement(\n    condition: Expression,\n    ifTrue: Statement,\n    ifFalse: Statement | null,\n    range: Range\n  ): IfStatement {\n    return new IfStatement(condition, ifTrue, ifFalse, range);\n  }\n\n  static createImportStatement(\n    declarations: ImportDeclaration[] | null,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(declarations, null, path, range);\n  }\n\n  static createWildcardImportStatement(\n    namespaceName: IdentifierExpression,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(null, namespaceName, path, range);\n  }\n\n  static createImportDeclaration(\n    foreignName: IdentifierExpression,\n    name: IdentifierExpression | null,\n    range: Range\n  ): ImportDeclaration {\n    if (!name) name = foreignName;\n    return new ImportDeclaration(name, foreignName, range);\n  }\n\n  static createInterfaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): InterfaceDeclaration {\n    return new InterfaceDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createFieldDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): FieldDeclaration {\n    return new FieldDeclaration(name, decorators, flags, type, initializer, -1, range);\n  }\n\n  static createForStatement(\n    initializer: Statement | null,\n    condition: Expression | null,\n    incrementor: Expression | null,\n    statement: Statement,\n    range: Range\n  ): ForStatement {\n    return new ForStatement(initializer, condition, incrementor, statement, range);\n  }\n\n  static createForOfStatement(\n    variable: Statement,\n    iterable: Expression,\n    statement: Statement,\n    range: Range\n  ): ForOfStatement {\n    return new ForOfStatement(variable, iterable, statement, range);\n  }\n\n  static createFunctionDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    arrowKind: ArrowKind,\n    range: Range\n  ): FunctionDeclaration {\n    return new FunctionDeclaration(name, decorators, flags, typeParameters, signature, body, arrowKind, range);\n  }\n\n  static createIndexSignature(\n    keyType: NamedTypeNode,\n    valueType: TypeNode,\n    flags: CommonFlags,\n    range: Range\n  ): IndexSignatureNode {\n    return new IndexSignatureNode(keyType, valueType, flags, range);\n  }\n\n  static createMethodDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    range: Range\n  ): MethodDeclaration {\n    return new MethodDeclaration(name, decorators, flags, typeParameters, signature, body, range);\n  }\n\n  static createNamespaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    members: Statement[],\n    range: Range\n  ): NamespaceDeclaration {\n    return new NamespaceDeclaration(name, decorators, flags, members, range);\n  }\n\n  static createReturnStatement(\n    value: Expression | null,\n    range: Range\n  ): ReturnStatement {\n    return new ReturnStatement(value, range);\n  }\n\n  static createSwitchStatement(\n    condition: Expression,\n    cases: SwitchCase[],\n    range: Range\n  ): SwitchStatement {\n    return new SwitchStatement(condition, cases, range);\n  }\n\n  static createSwitchCase(\n    label: Expression | null,\n    statements: Statement[],\n    range: Range\n  ): SwitchCase {\n    return new SwitchCase(label, statements, range);\n  }\n\n  static createThrowStatement(\n    value: Expression,\n    range: Range\n  ): ThrowStatement {\n    return new ThrowStatement(value, range);\n  }\n\n  static createTryStatement(\n    statements: Statement[],\n    catchVariable: IdentifierExpression | null,\n    catchStatements: Statement[] | null,\n    finallyStatements: Statement[] | null,\n    range: Range\n  ): TryStatement {\n    return new TryStatement(statements, catchVariable, catchStatements, finallyStatements, range);\n  }\n\n  static createTypeDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    type: TypeNode,\n    range: Range\n  ): TypeDeclaration {\n    return new TypeDeclaration(name, decorators, flags, typeParameters, type, range);\n  }\n\n  static createVariableStatement(\n    decorators: DecoratorNode[] | null,\n    declarations: VariableDeclaration[],\n    range: Range\n  ): VariableStatement {\n    return new VariableStatement(decorators, declarations, range);\n  }\n\n  static createVariableDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): VariableDeclaration {\n    return new VariableDeclaration(name, decorators, flags, type, initializer, range);\n  }\n\n  static createVoidStatement(\n    expression: Expression,\n    range: Range\n  ): VoidStatement {\n    return new VoidStatement(expression, range);\n  }\n\n  static createWhileStatement(\n    condition: Expression,\n    statement: Statement,\n    range: Range\n  ): WhileStatement {\n    return new WhileStatement(condition, statement, range);\n  }\n\n  /** Tests if this node is a literal of the specified kind. */\n  isLiteralKind(literalKind: LiteralKind): bool {\n    return this.kind == NodeKind.LITERAL\n        && (<LiteralExpression>changetype<Node>(this)).literalKind == literalKind; // TS\n  }\n\n  /** Tests if this node is a literal of a numeric kind (float or integer). */\n  get isNumericLiteral(): bool {\n    if (this.kind == NodeKind.LITERAL) {\n      switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n        case LiteralKind.FLOAT:\n        case LiteralKind.INTEGER: return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests whether this node is guaranteed to compile to a constant value. */\n  get compilesToConst(): bool {\n    switch (this.kind) {\n      case NodeKind.LITERAL: {\n        switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n          case LiteralKind.FLOAT:\n          case LiteralKind.INTEGER:\n          case LiteralKind.STRING: return true;\n        }\n        break;\n      }\n      case NodeKind.NULL:\n      case NodeKind.TRUE:\n      case NodeKind.FALSE: return true;\n    }\n    return false;\n  }\n\n  private isAccessOn(kind: NodeKind): bool {\n    let node = changetype<Node>(this);\n    if (node.kind == NodeKind.CALL) {\n      node = (<CallExpression>node).expression;\n    }\n    if (node.kind == NodeKind.PROPERTYACCESS) {\n      let target = (<PropertyAccessExpression>node).expression;\n      if (target.kind == kind) return true;\n    }\n    return false;\n  }\n\n  /** Checks if this node accesses a method or property on `this`. */\n  get isAccessOnThis(): bool {\n    return this.isAccessOn(NodeKind.THIS);\n  }\n\n  /** Checks if this node accesses a method or property on `super`. */\n  get isAccessOnSuper(): bool {\n    return this.isAccessOn(NodeKind.SUPER);\n  }\n}\n\n// types\n\nexport abstract class TypeNode extends Node {\n  constructor(\n    /** Kind of the type node. */\n    kind: NodeKind,\n    /** Whether nullable or not. */\n    public isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Tests if this type has a generic component matching one of the given type parameters. */\n  hasGenericComponent(typeParameterNodes: TypeParameterNode[]): bool {\n    if (this.kind == NodeKind.NAMEDTYPE) {\n      let namedTypeNode = <NamedTypeNode>changetype<TypeNode>(this); // TS\n      if (!namedTypeNode.name.next) {\n        let typeArgumentNodes = namedTypeNode.typeArguments;\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {\n            if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes)) return true;\n          }\n        } else {\n          let name = namedTypeNode.name.identifier.text;\n          for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {\n            if (typeParameterNodes[i].name.text == name) return true;\n          }\n        }\n      }\n    } else if (this.kind == NodeKind.FUNCTIONTYPE) {\n      let functionTypeNode = <FunctionTypeNode>changetype<TypeNode>(this); // TS\n      let parameterNodes = functionTypeNode.parameters;\n      for (let i = 0, k = parameterNodes.length; i < k; ++i) {\n        if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes)) return true;\n      }\n      if (functionTypeNode.returnType.hasGenericComponent(typeParameterNodes)) return true;\n      let explicitThisType = functionTypeNode.explicitThisType;\n      if (explicitThisType !== null && explicitThisType.hasGenericComponent(typeParameterNodes)) return true;\n    } else {\n      assert(false);\n    }\n    return false;\n  }\n}\n\n/** Represents a type name. */\nexport class TypeName extends Node {\n  constructor(\n    /** Identifier of this part. */\n    public identifier: IdentifierExpression,\n    /** Next part of the type name or `null` if this is the last part. */\n    public next: TypeName | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPENAME, range);\n  }\n}\n\n/** Represents a named type. */\nexport class NamedTypeNode extends TypeNode {\n  constructor(\n    /** Type name. */\n    public name: TypeName,\n    /** Type argument references. */\n    public typeArguments: TypeNode[] | null,\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NAMEDTYPE, isNullable, range);\n  }\n\n  /** Checks if this type node has type arguments. */\n  get hasTypeArguments(): bool {\n    var typeArguments = this.typeArguments;\n    return typeArguments !== null && typeArguments.length > 0;\n  }\n}\n\n/** Represents a function type. */\nexport class FunctionTypeNode extends TypeNode {\n  constructor(\n    /** Function parameters. */\n    public parameters: ParameterNode[],\n    /** Return type. */\n    public returnType: TypeNode,\n    /** Explicitly provided this type, if any. */\n    public explicitThisType: NamedTypeNode | null, // can't be a function\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FUNCTIONTYPE, isNullable, range);\n  }\n}\n\n/** Represents a type parameter. */\nexport class TypeParameterNode extends Node {\n  constructor(\n    /** Identifier reference. */\n    public name: IdentifierExpression,\n    /** Extended type reference, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Default type if omitted, if any. */\n    public defaultType: NamedTypeNode | null, // can't be a function\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPEPARAMETER, range);\n  }\n}\n\n/** Represents the kind of a parameter. */\nexport enum ParameterKind {\n  /** No specific flags. */\n  DEFAULT,\n  /** Is an optional parameter. */\n  OPTIONAL,\n  /** Is a rest parameter. */\n  REST\n}\n\n/** Represents a function parameter. */\nexport class ParameterNode extends Node {\n  constructor(\n    /** Parameter kind. */\n    public parameterKind: ParameterKind,\n    /** Parameter name. */\n    public name: IdentifierExpression,\n    /** Parameter type. */\n    public type: TypeNode,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PARAMETER, range);\n  }\n\n  /** Implicit field declaration, if applicable. */\n  implicitFieldDeclaration: FieldDeclaration | null = null;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.NONE;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n// special\n\n/** Built-in decorator kinds. */\nexport enum DecoratorKind {\n  CUSTOM,\n  GLOBAL,\n  OPERATOR,\n  OPERATOR_BINARY,\n  OPERATOR_PREFIX,\n  OPERATOR_POSTFIX,\n  UNMANAGED,\n  FINAL,\n  INLINE,\n  EXTERNAL,\n  BUILTIN,\n  LAZY,\n  UNSAFE\n}\n\nexport namespace DecoratorKind {\n\n  /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */\n  export function fromNode(nameNode: Expression): DecoratorKind {\n    if (nameNode.kind == NodeKind.IDENTIFIER) {\n      let nameStr = (<IdentifierExpression>nameNode).text;\n      assert(nameStr.length);\n      switch (nameStr.charCodeAt(0)) {\n        case CharCode.b: {\n          if (nameStr == \"builtin\") return DecoratorKind.BUILTIN;\n          break;\n        }\n        case CharCode.e: {\n          if (nameStr == \"external\") return DecoratorKind.EXTERNAL;\n          break;\n        }\n        case CharCode.f: {\n          if (nameStr == \"final\") return DecoratorKind.FINAL;\n          break;\n        }\n        case CharCode.g: {\n          if (nameStr == \"global\") return DecoratorKind.GLOBAL;\n          break;\n        }\n        case CharCode.i: {\n          if (nameStr == \"inline\") return DecoratorKind.INLINE;\n          break;\n        }\n        case CharCode.l: {\n          if (nameStr == \"lazy\") return DecoratorKind.LAZY;\n          break;\n        }\n        case CharCode.o: {\n          if (nameStr == \"operator\") return DecoratorKind.OPERATOR;\n          break;\n        }\n        case CharCode.u: {\n          if (nameStr == \"unmanaged\") return DecoratorKind.UNMANAGED;\n          if (nameStr == \"unsafe\") return DecoratorKind.UNSAFE;\n          break;\n        }\n      }\n    } else if (nameNode.kind == NodeKind.PROPERTYACCESS) {\n      let propertyAccessNode = <PropertyAccessExpression>nameNode;\n      let expression = propertyAccessNode.expression;\n      if (expression.kind == NodeKind.IDENTIFIER) {\n        let nameStr = (<IdentifierExpression>expression).text;\n        assert(nameStr.length);\n        let propStr = propertyAccessNode.property.text;\n        assert(propStr.length);\n        if (nameStr == \"operator\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.b: {\n              if (propStr == \"binary\") return DecoratorKind.OPERATOR_BINARY;\n              break;\n            }\n            case CharCode.p: {\n              if (propStr == \"prefix\") return DecoratorKind.OPERATOR_PREFIX;\n              if (propStr == \"postfix\") return DecoratorKind.OPERATOR_POSTFIX;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return DecoratorKind.CUSTOM;\n  }\n}\n\n/** Represents a decorator. */\nexport class DecoratorNode extends Node {\n  constructor(\n    /** Built-in decorator kind, or custom. */\n    public decoratorKind: DecoratorKind,\n    /** Name expression. */\n    public name: Expression,\n    /** Argument expressions. */\n    public args: Expression[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.DECORATOR, range);\n  }\n}\n\n/** Comment kinds. */\nexport enum CommentKind {\n  /** Line comment. */\n  LINE,\n  /** Triple-slash line comment. */\n  TRIPLE,\n  /** Block comment. */\n  BLOCK\n}\n\n/** Represents a comment. */\nexport class CommentNode extends Node {\n  constructor(\n    /** Comment kind. */\n    public commentKind: CommentKind,\n    /** Comment text. */\n    public text: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.COMMENT, range);\n  }\n}\n\n// expressions\n\n/** Base class of all expression nodes. */\nexport abstract class Expression extends Node { }\n\n/** Represents an identifier expression. */\nexport class IdentifierExpression extends Expression {\n  constructor(\n    /** Textual name. */\n    public text: string,\n    /** Whether quoted or not. */\n    public isQuoted: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IDENTIFIER, range);\n  }\n}\n\n/** Indicates the kind of a literal. */\nexport enum LiteralKind {\n  FLOAT,\n  INTEGER,\n  STRING,\n  TEMPLATE,\n  REGEXP,\n  ARRAY,\n  OBJECT\n}\n\n/** Base class of all literal expressions. */\nexport abstract class LiteralExpression extends Expression {\n  constructor(\n    /** Specific literal kind. */\n    public literalKind: LiteralKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.LITERAL, range);\n  }\n}\n\n/** Represents an `[]` literal expression. */\nexport class ArrayLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Nested element expressions. */\n    public elementExpressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.ARRAY, range);\n  }\n}\n\n/** Indicates the kind of an assertion. */\nexport enum AssertionKind {\n  /** A prefix assertion, i.e. `<T>expr`. */\n  PREFIX,\n  /** An as assertion, i.e. `expr as T`. */\n  AS,\n  /** A non-null assertion, i.e. `!expr`. */\n  NONNULL,\n  /** A const assertion, i.e. `expr as const`. */\n  CONST\n}\n\n/** Represents an assertion expression. */\nexport class AssertionExpression extends Expression {\n  constructor(\n    /** Specific kind of this assertion. */\n    public assertionKind: AssertionKind,\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Target type, if applicable. */\n    public toType: TypeNode | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ASSERTION, range);\n  }\n}\n\n/** Represents a binary expression. */\nexport class BinaryExpression extends Expression {\n  constructor(\n    /** Operator token. */\n    public operator: Token,\n    /** Left-hand side expression */\n    public left: Expression,\n    /** Right-hand side expression. */\n    public right: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BINARY, range);\n  }\n}\n\n/** Represents a call expression. */\nexport class CallExpression extends Expression {\n  constructor(\n    /** Called expression. Usually an identifier or property access expression. */\n    public expression: Expression,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CALL, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    var typeArguments = this.typeArguments;\n    var numTypeArguments: i32;\n    if (typeArguments) {\n      if (numTypeArguments = typeArguments.length) {\n        return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n      }\n    }\n    return this.expression.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    var args = this.args;\n    var numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.expression.range;\n  }\n}\n\n/** Represents a class expression using the 'class' keyword. */\nexport class ClassExpression extends Expression {\n  constructor(\n    /** Inline class declaration. */\n    public declaration: ClassDeclaration\n  ) {\n    super(NodeKind.CLASS, declaration.range);\n  }\n}\n\n/** Represents a comma expression composed of multiple expressions. */\nexport class CommaExpression extends Expression {\n  constructor(\n    /** Sequential expressions. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.COMMA, range);\n  }\n}\n\n/** Represents a `constructor` expression. */\nexport class ConstructorExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"constructor\", false, range);\n    this.kind = NodeKind.CONSTRUCTOR;\n  }\n}\n\n/** Represents an element access expression, e.g., array access. */\nexport class ElementAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Element of the expression being accessed. */\n    public elementExpression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ELEMENTACCESS, range);\n  }\n}\n\n/** Represents a float literal expression. */\nexport class FloatLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Float value. */\n    public value: f64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.FLOAT, range);\n  }\n}\n\n/** Represents a function expression using the 'function' keyword. */\nexport class FunctionExpression extends Expression {\n  constructor(\n    /** Inline function declaration. */\n    public declaration: FunctionDeclaration\n  ) {\n    super(NodeKind.FUNCTION, declaration.range);\n  }\n}\n\n/** Represents an `instanceof` expression. */\nexport class InstanceOfExpression extends Expression {\n  constructor(\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Type to test for. */\n    public isType: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.INSTANCEOF, range);\n  }\n}\n\n/** Represents an integer literal expression. */\nexport class IntegerLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Integer value. */\n    public value: i64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.INTEGER, range);\n  }\n}\n\n/** Represents a `new` expression. Like a call but with its own kind. */\nexport class NewExpression extends Expression {\n  constructor(\n    /** Type being constructed. */\n    public typeName: TypeName,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NEW, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    var typeArguments = this.typeArguments;\n    var numTypeArguments: i32;\n    if (typeArguments !== null && (numTypeArguments = typeArguments.length) > 0) {\n      return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    var args = this.args;\n    var numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n}\n\n/** Represents a `null` expression. */\nexport class NullExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"null\", false, range);\n    this.kind = NodeKind.NULL;\n  }\n}\n\n/** Represents an object literal expression. */\nexport class ObjectLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Field names. */\n    public names: IdentifierExpression[],\n    /** Field values. */\n    public values: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.OBJECT, range);\n  }\n}\n\n/** Represents an omitted expression, e.g. within an array literal. */\nexport class OmittedExpression extends Expression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.OMITTED, range);\n  }\n}\n\n/** Represents a parenthesized expression. */\nexport class ParenthesizedExpression extends Expression {\n  constructor(\n    /** Expression in parenthesis. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PARENTHESIZED, range);\n  }\n}\n\n/** Represents a property access expression. */\nexport class PropertyAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Property of the expression being accessed. */\n    public property: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PROPERTYACCESS, range);\n  }\n}\n\n/** Represents a regular expression literal expression. */\nexport class RegexpLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Regular expression pattern. */\n    public pattern: string,\n    /** Regular expression flags. */\n    public patternFlags: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.REGEXP, range);\n  }\n}\n\n/** Represents a ternary expression, i.e., short if notation. */\nexport class TernaryExpression extends Expression {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Expression executed when condition is `true`. */\n    public ifThen: Expression,\n    /** Expression executed when condition is `false`. */\n    public ifElse: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TERNARY, range);\n  }\n}\n\n/** Represents a string literal expression. */\nexport class StringLiteralExpression extends LiteralExpression {\n  constructor(\n    /** String value without quotes. */\n    public value: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.STRING, range);\n  }\n}\n\n/** Represents a `super` expression. */\nexport class SuperExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"super\", false, range);\n    this.kind = NodeKind.SUPER;\n  }\n}\n\n/** Represents a template literal expression. */\nexport class TemplateLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Tag expression, if any. */\n    public tag: Expression | null,\n    /** String parts. */\n    public parts: string[],\n    /** Raw string parts. */\n    public rawParts: string[],\n    /** Expression parts. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.TEMPLATE, range);\n  }\n}\n\n/** Represents a `this` expression. */\nexport class ThisExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"this\", false, range);\n    this.kind = NodeKind.THIS;\n  }\n}\n\n/** Represents a `true` expression. */\nexport class TrueExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"true\", false, range);\n    this.kind = NodeKind.TRUE;\n  }\n}\n\n/** Represents a `false` expression. */\nexport class FalseExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"false\", false, range);\n    this.kind = NodeKind.FALSE;\n  }\n}\n\n/** Base class of all unary expressions. */\nexport abstract class UnaryExpression extends Expression {\n  constructor(\n    /** Unary expression kind. */\n    kind: NodeKind,\n    /** Operator token. */\n    public operator: Token,\n    /** Operand expression. */\n    public operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n}\n\n/** Represents a unary postfix expression, e.g. a postfix increment. */\nexport class UnaryPostfixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UNARYPOSTFIX, operator, operand, range);\n  }\n}\n\n/** Represents a unary prefix expression, e.g. a negation. */\nexport class UnaryPrefixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UNARYPREFIX, operator, operand, range);\n  }\n}\n\n/** Represents a special pre-compiled expression. If the expression has side-effects, special care has to be taken. */\nexport class CompiledExpression extends Expression {\n  constructor(\n    /** Compiled expression. */\n    public expr: ExpressionRef,\n    /** Type of the compiled expression. */\n    public type: Type,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.COMPILED, range);\n  }\n}\n\n// statements\n\n/** Base class of all statement nodes. */\nexport abstract class Statement extends Node { }\n\n/** Indicates the specific kind of a source. */\nexport enum SourceKind {\n  /** User-provided file. */\n  USER = 0,\n  /** User-provided entry file. */\n  USER_ENTRY = 1,\n  /** Library-provided file. */\n  LIBRARY = 2,\n  /** Library-provided entry file. */\n  LIBRARY_ENTRY = 3\n}\n\n/** A top-level source node. */\nexport class Source extends Node {\n  constructor(\n    /** Source kind. */\n    public sourceKind: SourceKind,\n    /** Normalized path with file extension. */\n    public normalizedPath: string,\n    /** Full source text. */\n    public text: string\n  ) {\n    super(NodeKind.SOURCE, new Range(0, text.length));\n    var internalPath = mangleInternalPath(normalizedPath);\n    this.internalPath = internalPath;\n    var pos = internalPath.lastIndexOf(PATH_DELIMITER);\n    this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;\n    this.range.source = this;\n  }\n\n  /** Path used internally. */\n  internalPath: string;\n  /** Simple path (last part without extension). */\n  simplePath: string;\n  /** Contained statements. */\n  statements: Statement[] = new Array();\n  /** Source map index. */\n  debugInfoIndex: i32 = -1;\n  /** Re-exported sources. */\n  exportPaths: string[] | null = null;\n\n  /** Checks if this source represents native code. */\n  get isNative(): bool {\n    return this.internalPath == LIBRARY_SUBST;\n  }\n\n  /** Checks if this source is part of the (standard) library. */\n  get isLibrary(): bool {\n    var kind = this.sourceKind;\n    return kind == SourceKind.LIBRARY || kind == SourceKind.LIBRARY_ENTRY;\n  }\n\n  /** Cached line starts. */\n  private lineCache: i32[] | null = null;\n\n  /** Remembered column number. */\n  private lineColumn: i32 = 1;\n\n  /** Determines the line number at the specified position. Starts at `1`. */\n  lineAt(pos: i32): i32 {\n    assert(pos >= 0 && pos < 0x7fffffff);\n    var lineCache = this.lineCache;\n    if (!lineCache) {\n      this.lineCache = lineCache = [0];\n      let text = this.text;\n      let off = 0;\n      let end = text.length;\n      while (off < end) {\n        if (text.charCodeAt(off++) == CharCode.LINEFEED) lineCache.push(off);\n      }\n      lineCache.push(0x7fffffff);\n    }\n    var l = 0;\n    var r = lineCache.length - 1;\n    while (l < r) {\n      let m = l + ((r - l) >> 1);\n      let s = unchecked(lineCache[m]);\n      if (pos < s) r = m;\n      else if (pos < unchecked(lineCache[m + 1])) {\n        this.lineColumn = pos - s + 1;\n        return m + 1;\n      }\n      else l = m + 1;\n    }\n    return assert(0);\n  }\n\n  /** Gets the column number at the last position queried with `lineAt`. Starts at `1`. */\n  columnAt(): i32 {\n    return this.lineColumn;\n  }\n}\n\n/** Base class of all declaration statements. */\nexport abstract class DeclarationStatement extends Statement {\n  constructor(\n    /** Declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    public name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    public decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n/** Represents an index signature. */\nexport class IndexSignatureNode extends Node {\n  constructor(\n    /** Key type. */\n    public keyType: NamedTypeNode,\n    /** Value type. */\n    public valueType: TypeNode,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.INDEXSIGNATURE, range);\n  }\n}\n\n/** Base class of all variable-like declaration statements. */\nexport abstract class VariableLikeDeclarationStatement extends DeclarationStatement {\n  constructor(\n    /** Variable-like declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    public type: TypeNode | null,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, name, decorators, flags, range);\n  }\n}\n\n/** Represents a block statement. */\nexport class BlockStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BLOCK, range);\n  }\n}\n\n/** Represents a `break` statement. */\nexport class BreakStatement extends Statement {\n  constructor(\n    /** Target label, if any. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BREAK, range);\n  }\n}\n\n/** Represents a `class` declaration. */\nexport class ClassDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    public implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    public members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CLASSDECLARATION, name, decorators, flags, range);\n  }\n\n  /** Index signature, if present. */\n  indexSignature: IndexSignatureNode | null = null;\n\n  get isGeneric(): bool {\n    var typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n}\n\n/** Represents a `continue` statement. */\nexport class ContinueStatement extends Statement {\n  constructor(\n    /** Target label, if applicable. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CONTINUE, range);\n  }\n}\n\n/** Represents a `do` statement. */\nexport class DoStatement extends Statement {\n  constructor(\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Condition when to repeat. */\n    public condition: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.DO, range);\n  }\n}\n\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\nexport class EmptyStatement extends Statement {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EMPTY, range);\n  }\n}\n\n/** Represents an `enum` declaration. */\nexport class EnumDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Enum value declarations. */\n    public values: EnumValueDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ENUMDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a value of an `enum` declaration. */\nexport class EnumValueDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ENUMVALUEDECLARATION, name, null, flags, null, initializer, range);\n  }\n}\n\n/** Represents an `export import` statement of an interface. */\nexport class ExportImportStatement extends Statement {\n  constructor(\n    /** Identifier being imported. */\n    public name: IdentifierExpression,\n    /** Identifier being exported. */\n    public externalName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTIMPORT, range);\n  }\n}\n\n/** Represents a member of an `export` statement. */\nexport class ExportMember extends Node {\n  constructor(\n    /** Local identifier. */\n    public localName: IdentifierExpression,\n    /** Exported identifier. */\n    public exportedName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTMEMBER, range);\n  }\n}\n\n/** Represents an `export` statement. */\nexport class ExportStatement extends Statement {\n  constructor(\n    /** Array of members if a set of named exports, or `null` if a file export. */\n    public members: ExportMember[] | null,\n    /** Path being exported from, if applicable. */\n    public path: StringLiteralExpression | null,\n    /** Whether this is a declared export. */\n    public isDeclare: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORT, range);\n    if (path) {\n      let normalizedPath = normalizePath(path.value);\n      if (path.value.startsWith(\".\")) { // relative\n        normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n      } else { // absolute\n        if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n      }\n      this.internalPath = normalizedPath;\n    } else {\n      this.internalPath = null;\n    }\n  }\n\n  /** Internal path being referenced, if `path` is set. */\n  internalPath: string | null;\n}\n\n/** Represents an `export default` statement. */\nexport class ExportDefaultStatement extends Statement {\n  constructor(\n    /** Declaration being exported as default. */\n    public declaration: DeclarationStatement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTDEFAULT, range);\n  }\n}\n\n/** Represents an expression that is used as a statement. */\nexport class ExpressionStatement extends Statement {\n  constructor(\n    /** Expression being used as a statement.*/\n    public expression: Expression\n  ) {\n    super(NodeKind.EXPRESSION, expression.range);\n  }\n}\n\n/** Represents a field declaration within a `class`. */\nexport class FieldDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Parameter index if declared as a constructor parameter, otherwise `-1`. */\n    public parameterIndex: i32,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FIELDDECLARATION, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a `for` statement. */\nexport class ForStatement extends Statement {\n  constructor(\n    /** Initializer statement, if present. Either a `VariableStatement` or `ExpressionStatement`. */\n    public initializer: Statement | null,\n    /** Condition expression, if present. */\n    public condition: Expression | null,\n    /** Incrementor expression, if present. */\n    public incrementor: Expression | null,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FOR, range);\n  }\n}\n\n/** Represents a `for..of` statement. */\nexport class ForOfStatement extends Statement {\n  constructor(\n    /** Variable statement. Either a `VariableStatement` or `ExpressionStatement` of `IdentifierExpression`. */\n    public variable: Statement,\n    /** Iterable expression being iterated. */\n    public iterable: Expression,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FOROF, range);\n  }\n}\n\n/** Indicates the kind of an array function. */\nexport const enum ArrowKind {\n  /** Not an arrow function. */\n  NONE,\n  /** Parenthesized parameter list. */\n  ARROW_PARENTHESIZED,\n  /** Single parameter without parenthesis. */\n  ARROW_SINGLE\n}\n\n/** Represents a `function` declaration. */\nexport class FunctionDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    public signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    public body: Statement | null,\n    /** Arrow function kind, if applicable. */\n    public arrowKind: ArrowKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FUNCTIONDECLARATION, name, decorators, flags, range);\n  }\n\n  /** Gets if this function is generic. */\n  get isGeneric(): bool {\n    var typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n\n  /** Clones this function declaration. */\n  clone(): FunctionDeclaration {\n    return new FunctionDeclaration(\n      this.name,\n      this.decorators,\n      this.flags,\n      this.typeParameters,\n      this.signature,\n      this.body,\n      this.arrowKind,\n      this.range\n    );\n  }\n}\n\n/** Represents an `if` statement. */\nexport class IfStatement extends Statement {\n  constructor(\n    /** Condition. */\n    public condition: Expression,\n    /** Statement executed when condition is `true`. */\n    public ifTrue: Statement,\n    /** Statement executed when condition is `false`. */\n    public ifFalse: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IF, range);\n  }\n}\n\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\nexport class ImportDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Identifier being imported. */\n    public foreignName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IMPORTDECLARATION, name, null, CommonFlags.NONE, range);\n  }\n}\n\n/** Represents an `import` statement. */\nexport class ImportStatement extends Statement {\n  constructor(\n    /** Array of member declarations or `null` if an asterisk import. */\n    public declarations: ImportDeclaration[] | null,\n    /** Name of the local namespace, if an asterisk import. */\n    public namespaceName: IdentifierExpression | null,\n    /** Path being imported from. */\n    public path: StringLiteralExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IMPORT, range);\n    var normalizedPath = normalizePath(path.value);\n    if (path.value.startsWith(\".\")) { // relative in project\n      normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n    } else { // absolute in library\n      if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n    }\n    this.internalPath = normalizedPath;\n  }\n\n  /** Internal path being referenced. */\n  internalPath: string;\n}\n\n/** Represents an `interfarce` declaration. */\nexport class InterfaceDeclaration extends ClassDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n    this.kind = NodeKind.INTERFACEDECLARATION;\n  }\n}\n\n/** Represents a method declaration within a `class`. */\nexport class MethodDeclaration extends FunctionDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    body: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, signature, body, ArrowKind.NONE, range);\n    this.kind = NodeKind.METHODDECLARATION;\n  }\n}\n\n/** Represents a `namespace` declaration. */\nexport class NamespaceDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Array of namespace members. */\n    public members: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NAMESPACEDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a `return` statement. */\nexport class ReturnStatement extends Statement {\n  constructor(\n    /** Value expression being returned, if present. */\n    public value: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.RETURN, range);\n  }\n}\n\n/** Represents a single `case` within a `switch` statement. */\nexport class SwitchCase extends Node {\n  constructor(\n    /** Label expression. `null` indicates the default case. */\n    public label: Expression | null,\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SWITCHCASE, range);\n  }\n}\n\n/** Represents a `switch` statement. */\nexport class SwitchStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Contained cases. */\n    public cases: SwitchCase[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SWITCH, range);\n  }\n}\n\n/** Represents a `throw` statement. */\nexport class ThrowStatement extends Statement {\n  constructor(\n    /** Value expression being thrown. */\n    public value: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.THROW, range);\n  }\n}\n\n/** Represents a `try` statement. */\nexport class TryStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Exception variable name, if a `catch` clause is present. */\n    public catchVariable: IdentifierExpression | null,\n    /** Statements being executed on catch, if a `catch` clause is present. */\n    public catchStatements: Statement[] | null,\n    /** Statements being executed afterwards, if a `finally` clause is present. */\n    public finallyStatements: Statement[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TRY, range);\n  }\n}\n\n/** Represents a `type` declaration. */\nexport class TypeDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Type being aliased. */\n    public type: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPEDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a variable declaration part of a {@link VariableStatement}. */\nexport class VariableDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VARIABLEDECLARATION, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\nexport class VariableStatement extends Statement {\n  constructor(\n    /** Array of decorators. */\n    public decorators: DecoratorNode[] | null,\n    /** Array of member declarations. */\n    public declarations: VariableDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VARIABLE, range);\n  }\n}\n\n/** Represents a void statement dropping an expression's value. */\nexport class VoidStatement extends Statement {\n  constructor(\n    /** Expression being dropped. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VOID, range);\n  }\n}\n\n/** Represents a `while` statement. */\nexport class WhileStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.WHILE, range);\n  }\n}\n\n/** Finds the first decorator matching the specified kind. */\nexport function findDecorator(kind: DecoratorKind, decorators: DecoratorNode[] | null): DecoratorNode | null {\n  if (decorators) {\n    for (let i = 0, k = decorators.length; i < k; ++i) {\n      let decorator = decorators[i];\n      if (decorator.decoratorKind == kind) return decorator;\n    }\n  }\n  return null;\n}\n\n/** Mangles an external to an internal path. */\nexport function mangleInternalPath(path: string): string {\n  var pos = path.lastIndexOf(\".\");\n  var len = path.length;\n  if (pos >= 0 && len - pos >= 2) { // at least one char plus dot\n    let cur = pos;\n    while (++cur < len) {\n      if (!isAlphaOrDecimal(path.charCodeAt(cur))) {\n        assert(false); // not a valid external path\n        return path;\n      }\n    }\n    return path.substring(0, pos);\n  }\n  assert(false); // not an external path\n  return path;\n}\n\n/** Tests if the specified type node represents an omitted type. */\nexport function isTypeOmitted(type: TypeNode): bool {\n  if (type.kind == NodeKind.NAMEDTYPE) {\n    let name = (<NamedTypeNode>type).name;\n    return !(name.next !== null || name.identifier.text.length > 0);\n  }\n  return false;\n}\n","/**\n * @fileoverview Built-in elements providing core WebAssembly functionality.\n *\n * Each builtin is linked to its definition in std/assembly/builtins.ts.\n * When its prototype is called, the compiler recognizes the `@builtin`\n * decorator, looks up the respective handler in the global builtins map\n * and executes it, with the handler directly emitting WebAssembly code\n * according to context.\n *\n * Builtins can be categorized into core builtins that typically are generic\n * and emit code directly and aliases calling core builtins with overridden\n * contexts. The latter is used by inline assembler aliases of WebAssembly\n * instructions, like `i64.load8_u` deferring to `<i64>load<u8>`.\n *\n * The `contextIsExact` modifier is used to force a specific instruction\n * family. A `i32.store8` deferring to `<i32>store<i8>` for example is\n * ambiguous in that the input can still be an i32 or an i64, leading to\n * either an `i32.store8` or an `i64.store8`, so `i32` is forced there.\n * This behavior is indicated by `from i32/i64` in the comments below.\n *\n * @license Apache-2.0\n */\n\n// TODO: Add builtins for `i32.add` etc. that do not have a core builtin.\n\nimport {\n  Compiler,\n  Constraints,\n  RuntimeFeatures\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticCategory\n} from \"./diagnostics\";\n\nimport {\n  Expression,\n  LiteralKind,\n  StringLiteralExpression,\n  CallExpression,\n  NodeKind,\n  LiteralExpression,\n  ArrayLiteralExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  BinaryOp,\n  UnaryOp,\n  AtomicRMWOp,\n  SIMDExtractOp,\n  SIMDReplaceOp,\n  SIMDShiftOp,\n  SIMDTernaryOp,\n  SIMDLoadOp,\n  SIMDLoadStoreLaneOp,\n  RefIsOp,\n  TypeRef,\n  ExpressionRef,\n  ExpressionId,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI64High,\n  getConstValueI64Low,\n  getConstValueI32,\n  getConstValueF32,\n  getConstValueF64,\n  getLocalGetIndex,\n  createType,\n  ExpressionRunnerFlags\n} from \"./module\";\n\nimport {\n  ElementKind,\n  FunctionPrototype,\n  Field,\n  Global,\n  DecoratorFlags,\n  ClassPrototype,\n  Class\n} from \"./program\";\n\nimport {\n  findUsedLocals,\n  FlowFlags,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  CommonFlags,\n  Feature,\n  featureToString,\n  TypeinfoFlags\n} from \"./common\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  isPowerOf2\n} from \"./util\";\n\n/** Internal names of various compiler built-ins. */\nexport namespace BuiltinNames {\n\n  // compiler-generated\n  export const start = \"~start\";\n  export const started = \"~started\";\n  export const argumentsLength = \"~argumentsLength\";\n  export const setArgumentsLength = \"~setArgumentsLength\";\n\n  // std/builtins.ts\n  export const abort = \"~lib/builtins/abort\";\n  export const trace = \"~lib/builtins/trace\";\n  export const seed = \"~lib/builtins/seed\";\n\n  export const isInteger = \"~lib/builtins/isInteger\";\n  export const isFloat = \"~lib/builtins/isFloat\";\n  export const isBoolean = \"~lib/builtins/isBoolean\";\n  export const isSigned = \"~lib/builtins/isSigned\";\n  export const isReference = \"~lib/builtins/isReference\";\n  export const isString = \"~lib/builtins/isString\";\n  export const isArray = \"~lib/builtins/isArray\";\n  export const isArrayLike = \"~lib/builtins/isArrayLike\";\n  export const isFunction = \"~lib/builtins/isFunction\";\n  export const isNullable = \"~lib/builtins/isNullable\";\n  export const isDefined = \"~lib/builtins/isDefined\";\n  export const isConstant = \"~lib/builtins/isConstant\";\n  export const isManaged = \"~lib/builtins/isManaged\";\n  export const isVoid = \"~lib/builtins/isVoid\";\n\n  export const add = \"~lib/builtins/add\";\n  export const sub = \"~lib/builtins/sub\";\n  export const mul = \"~lib/builtins/mul\";\n  export const div = \"~lib/builtins/div\";\n  export const clz = \"~lib/builtins/clz\";\n  export const ctz = \"~lib/builtins/ctz\";\n  export const popcnt = \"~lib/builtins/popcnt\";\n  export const rotl = \"~lib/builtins/rotl\";\n  export const rotr = \"~lib/builtins/rotr\";\n  export const abs = \"~lib/builtins/abs\";\n  export const max = \"~lib/builtins/max\";\n  export const min = \"~lib/builtins/min\";\n  export const ceil = \"~lib/builtins/ceil\";\n  export const floor = \"~lib/builtins/floor\";\n  export const copysign = \"~lib/builtins/copysign\";\n  export const nearest = \"~lib/builtins/nearest\";\n  export const reinterpret = \"~lib/builtins/reinterpret\";\n  export const sqrt = \"~lib/builtins/sqrt\";\n  export const trunc = \"~lib/builtins/trunc\";\n  export const load = \"~lib/builtins/load\";\n  export const store = \"~lib/builtins/store\";\n  export const atomic_load = \"~lib/builtins/atomic.load\";\n  export const atomic_store = \"~lib/builtins/atomic.store\";\n  export const atomic_add = \"~lib/builtins/atomic.add\";\n  export const atomic_sub = \"~lib/builtins/atomic.sub\";\n  export const atomic_and = \"~lib/builtins/atomic.and\";\n  export const atomic_or = \"~lib/builtins/atomic.or\";\n  export const atomic_xor = \"~lib/builtins/atomic.xor\";\n  export const atomic_xchg = \"~lib/builtins/atomic.xchg\";\n  export const atomic_cmpxchg = \"~lib/builtins/atomic.cmpxchg\";\n  export const atomic_wait = \"~lib/builtins/atomic.wait\";\n  export const atomic_notify = \"~lib/builtins/atomic.notify\";\n  export const atomic_fence = \"~lib/builtins/atomic.fence\";\n\n  export const sizeof = \"~lib/builtins/sizeof\";\n  export const alignof = \"~lib/builtins/alignof\";\n  export const offsetof = \"~lib/builtins/offsetof\";\n  export const nameof = \"~lib/builtins/nameof\";\n  export const lengthof = \"~lib/builtins/lengthof\";\n  export const select = \"~lib/builtins/select\";\n  export const unreachable = \"~lib/builtins/unreachable\";\n  export const changetype = \"~lib/builtins/changetype\";\n  export const assert = \"~lib/builtins/assert\";\n  export const call_indirect = \"~lib/builtins/call_indirect\";\n  export const unchecked = \"~lib/builtins/unchecked\";\n  export const instantiate = \"~lib/builtins/instantiate\";\n  export const idof = \"~lib/builtins/idof\";\n\n  export const i8 = \"~lib/builtins/i8\";\n  export const i16 = \"~lib/builtins/i16\";\n  export const i32 = \"~lib/builtins/i32\";\n  export const i64 = \"~lib/builtins/i64\";\n  export const isize = \"~lib/builtins/isize\";\n  export const u8 = \"~lib/builtins/u8\";\n  export const u16 = \"~lib/builtins/u16\";\n  export const u32 = \"~lib/builtins/u32\";\n  export const u64 = \"~lib/builtins/u64\";\n  export const usize = \"~lib/builtins/usize\";\n  export const bool = \"~lib/builtins/bool\";\n  export const f32 = \"~lib/builtins/f32\";\n  export const f64 = \"~lib/builtins/f64\";\n  export const v128 = \"~lib/builtins/v128\";\n\n  export const i32_clz = \"~lib/builtins/i32.clz\";\n  export const i64_clz = \"~lib/builtins/i64.clz\";\n  export const i32_ctz = \"~lib/builtins/i32.ctz\";\n  export const i64_ctz = \"~lib/builtins/i64.ctz\";\n  export const i32_popcnt = \"~lib/builtins/i32.popcnt\";\n  export const i64_popcnt = \"~lib/builtins/i64.popcnt\";\n  export const i32_rotl = \"~lib/builtins/i32.rotl\";\n  export const i64_rotl = \"~lib/builtins/i64.rotl\";\n  export const i32_rotr = \"~lib/builtins/i32.rotr\";\n  export const i64_rotr = \"~lib/builtins/i64.rotr\";\n\n  export const f32_abs = \"~lib/builtins/f32.abs\";\n  export const f64_abs = \"~lib/builtins/f64.abs\";\n  export const f32_max = \"~lib/builtins/f32.max\";\n  export const f64_max = \"~lib/builtins/f64.max\";\n  export const f32_min = \"~lib/builtins/f32.min\";\n  export const f64_min = \"~lib/builtins/f64.min\";\n  export const f32_ceil = \"~lib/builtins/f32.ceil\";\n  export const f64_ceil = \"~lib/builtins/f64.ceil\";\n  export const f32_floor = \"~lib/builtins/f32.floor\";\n  export const f64_floor = \"~lib/builtins/f64.floor\";\n  export const f32_copysign = \"~lib/builtins/f32.copysign\";\n  export const f64_copysign = \"~lib/builtins/f64.copysign\";\n  export const f32_nearest = \"~lib/builtins/f32.nearest\";\n  export const f64_nearest = \"~lib/builtins/f64.nearest\";\n  export const i32_reinterpret_f32 = \"~lib/builtins/i32.reinterpret_f32\";\n  export const i64_reinterpret_f64 = \"~lib/builtins/i64.reinterpret_f64\";\n  export const f32_reinterpret_i32 = \"~lib/builtins/f32.reinterpret_i32\";\n  export const f64_reinterpret_i64 = \"~lib/builtins/f64.reinterpret_i64\";\n  export const f32_sqrt = \"~lib/builtins/f32.sqrt\";\n  export const f64_sqrt = \"~lib/builtins/f64.sqrt\";\n  export const f32_trunc = \"~lib/builtins/f32.trunc\";\n  export const f64_trunc = \"~lib/builtins/f64.trunc\";\n\n  export const i32_add = \"~lib/builtins/i32.add\";\n  export const i64_add = \"~lib/builtins/i64.add\";\n  export const f32_add = \"~lib/builtins/f32.add\";\n  export const f64_add = \"~lib/builtins/f64.add\";\n  export const i32_sub = \"~lib/builtins/i32.sub\";\n  export const i64_sub = \"~lib/builtins/i64.sub\";\n  export const f32_sub = \"~lib/builtins/f32.sub\";\n  export const f64_sub = \"~lib/builtins/f64.sub\";\n  export const i32_mul = \"~lib/builtins/i32.mul\";\n  export const i64_mul = \"~lib/builtins/i64.mul\";\n  export const f32_mul = \"~lib/builtins/f32.mul\";\n  export const f64_mul = \"~lib/builtins/f64.mul\";\n  export const i32_div_s = \"~lib/builtins/i32.div_s\";\n  export const i32_div_u = \"~lib/builtins/i32.div_u\";\n  export const i64_div_s = \"~lib/builtins/i64.div_s\";\n  export const i64_div_u = \"~lib/builtins/i64.div_u\";\n  export const f32_div = \"~lib/builtins/f32.div\";\n  export const f64_div = \"~lib/builtins/f64.div\";\n\n  export const i32_load8_s = \"~lib/builtins/i32.load8_s\";\n  export const i32_load8_u = \"~lib/builtins/i32.load8_u\";\n  export const i32_load16_s = \"~lib/builtins/i32.load16_s\";\n  export const i32_load16_u = \"~lib/builtins/i32.load16_u\";\n  export const i32_load = \"~lib/builtins/i32.load\";\n  export const i64_load8_s = \"~lib/builtins/i64.load8_s\";\n  export const i64_load8_u = \"~lib/builtins/i64.load8_u\";\n  export const i64_load16_s = \"~lib/builtins/i64.load16_s\";\n  export const i64_load16_u = \"~lib/builtins/i64.load16_u\";\n  export const i64_load32_s = \"~lib/builtins/i64.load32_s\";\n  export const i64_load32_u = \"~lib/builtins/i64.load32_u\";\n  export const i64_load = \"~lib/builtins/i64.load\";\n  export const f32_load = \"~lib/builtins/f32.load\";\n  export const f64_load = \"~lib/builtins/f64.load\";\n  export const i32_store8 = \"~lib/builtins/i32.store8\";\n  export const i32_store16 = \"~lib/builtins/i32.store16\";\n  export const i32_store = \"~lib/builtins/i32.store\";\n  export const i64_store8 = \"~lib/builtins/i64.store8\";\n  export const i64_store16 = \"~lib/builtins/i64.store16\";\n  export const i64_store32 = \"~lib/builtins/i64.store32\";\n  export const i64_store = \"~lib/builtins/i64.store\";\n  export const f32_store = \"~lib/builtins/f32.store\";\n  export const f64_store = \"~lib/builtins/f64.store\";\n\n  export const i32_atomic_load8_u = \"~lib/builtins/i32.atomic.load8_u\";\n  export const i32_atomic_load16_u = \"~lib/builtins/i32.atomic.load16_u\";\n  export const i32_atomic_load = \"~lib/builtins/i32.atomic.load\";\n  export const i64_atomic_load8_u = \"~lib/builtins/i64.atomic.load8_u\";\n  export const i64_atomic_load16_u = \"~lib/builtins/i64.atomic.load16_u\";\n  export const i64_atomic_load32_u = \"~lib/builtins/i64.atomic.load32_u\";\n  export const i64_atomic_load = \"~lib/builtins/i64.atomic.load\";\n  export const i32_atomic_store8 = \"~lib/builtins/i32.atomic.store8\";\n  export const i32_atomic_store16 = \"~lib/builtins/i32.atomic.store16\";\n  export const i32_atomic_store = \"~lib/builtins/i32.atomic.store\";\n  export const i64_atomic_store8 = \"~lib/builtins/i64.atomic.store8\";\n  export const i64_atomic_store16 = \"~lib/builtins/i64.atomic.store16\";\n  export const i64_atomic_store32 = \"~lib/builtins/i64.atomic.store32\";\n  export const i64_atomic_store = \"~lib/builtins/i64.atomic.store\";\n  export const i32_atomic_rmw8_add_u = \"~lib/builtins/i32.atomic.rmw8.add_u\";\n  export const i32_atomic_rmw16_add_u = \"~lib/builtins/i32.atomic.rmw16.add_u\";\n  export const i32_atomic_rmw_add = \"~lib/builtins/i32.atomic.rmw.add\";\n  export const i64_atomic_rmw8_add_u = \"~lib/builtins/i64.atomic.rmw8.add_u\";\n  export const i64_atomic_rmw16_add_u = \"~lib/builtins/i64.atomic.rmw16.add_u\";\n  export const i64_atomic_rmw32_add_u = \"~lib/builtins/i64.atomic.rmw32.add_u\";\n  export const i64_atomic_rmw_add = \"~lib/builtins/i64.atomic.rmw.add\";\n  export const i32_atomic_rmw8_sub_u = \"~lib/builtins/i32.atomic.rmw8.sub_u\";\n  export const i32_atomic_rmw16_sub_u = \"~lib/builtins/i32.atomic.rmw16.sub_u\";\n  export const i32_atomic_rmw_sub = \"~lib/builtins/i32.atomic.rmw.sub\";\n  export const i64_atomic_rmw8_sub_u = \"~lib/builtins/i64.atomic.rmw8.sub_u\";\n  export const i64_atomic_rmw16_sub_u = \"~lib/builtins/i64.atomic.rmw16.sub_u\";\n  export const i64_atomic_rmw32_sub_u = \"~lib/builtins/i64.atomic.rmw32.sub_u\";\n  export const i64_atomic_rmw_sub = \"~lib/builtins/i64.atomic.rmw.sub\";\n  export const i32_atomic_rmw8_and_u = \"~lib/builtins/i32.atomic.rmw8.and_u\";\n  export const i32_atomic_rmw16_and_u = \"~lib/builtins/i32.atomic.rmw16.and_u\";\n  export const i32_atomic_rmw_and = \"~lib/builtins/i32.atomic.rmw.and\";\n  export const i64_atomic_rmw8_and_u = \"~lib/builtins/i64.atomic.rmw8.and_u\";\n  export const i64_atomic_rmw16_and_u = \"~lib/builtins/i64.atomic.rmw16.and_u\";\n  export const i64_atomic_rmw32_and_u = \"~lib/builtins/i64.atomic.rmw32.and_u\";\n  export const i64_atomic_rmw_and = \"~lib/builtins/i64.atomic.rmw.and\";\n  export const i32_atomic_rmw8_or_u = \"~lib/builtins/i32.atomic.rmw8.or_u\";\n  export const i32_atomic_rmw16_or_u = \"~lib/builtins/i32.atomic.rmw16.or_u\";\n  export const i32_atomic_rmw_or = \"~lib/builtins/i32.atomic.rmw.or\";\n  export const i64_atomic_rmw8_or_u = \"~lib/builtins/i64.atomic.rmw8.or_u\";\n  export const i64_atomic_rmw16_or_u = \"~lib/builtins/i64.atomic.rmw16.or_u\";\n  export const i64_atomic_rmw32_or_u = \"~lib/builtins/i64.atomic.rmw32.or_u\";\n  export const i64_atomic_rmw_or = \"~lib/builtins/i64.atomic.rmw.or\";\n  export const i32_atomic_rmw8_xor_u = \"~lib/builtins/i32.atomic.rmw8.xor_u\";\n  export const i32_atomic_rmw16_xor_u = \"~lib/builtins/i32.atomic.rmw16.xor_u\";\n  export const i32_atomic_rmw_xor = \"~lib/builtins/i32.atomic.rmw.xor\";\n  export const i64_atomic_rmw8_xor_u = \"~lib/builtins/i64.atomic.rmw8.xor_u\";\n  export const i64_atomic_rmw16_xor_u = \"~lib/builtins/i64.atomic.rmw16.xor_u\";\n  export const i64_atomic_rmw32_xor_u = \"~lib/builtins/i64.atomic.rmw32.xor_u\";\n  export const i64_atomic_rmw_xor = \"~lib/builtins/i64.atomic.rmw.xor\";\n  export const i32_atomic_rmw8_xchg_u = \"~lib/builtins/i32.atomic.rmw8.xchg_u\";\n  export const i32_atomic_rmw16_xchg_u = \"~lib/builtins/i32.atomic.rmw16.xchg_u\";\n  export const i32_atomic_rmw_xchg = \"~lib/builtins/i32.atomic.rmw.xchg\";\n  export const i64_atomic_rmw8_xchg_u = \"~lib/builtins/i64.atomic.rmw8.xchg_u\";\n  export const i64_atomic_rmw16_xchg_u = \"~lib/builtins/i64.atomic.rmw16.xchg_u\";\n  export const i64_atomic_rmw32_xchg_u = \"~lib/builtins/i64.atomic.rmw32.xchg_u\";\n  export const i64_atomic_rmw_xchg = \"~lib/builtins/i64.atomic.rmw.xchg\";\n  export const i32_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw8.cmpxchg_u\";\n  export const i32_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw16.cmpxchg_u\";\n  export const i32_atomic_rmw_cmpxchg = \"~lib/builtins/i32.atomic.rmw.cmpxchg\";\n  export const i64_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw8.cmpxchg_u\";\n  export const i64_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw16.cmpxchg_u\";\n  export const i64_atomic_rmw32_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw32.cmpxchg_u\";\n  export const i64_atomic_rmw_cmpxchg = \"~lib/builtins/i64.atomic.rmw.cmpxchg\";\n  export const i32_wait = \"~lib/builtins/i32.wait\";\n  export const i64_wait = \"~lib/builtins/i64.wait\";\n\n  export const v128_splat = \"~lib/builtins/v128.splat\";\n  export const v128_extract_lane = \"~lib/builtins/v128.extract_lane\";\n  export const v128_replace_lane = \"~lib/builtins/v128.replace_lane\";\n  export const v128_shuffle = \"~lib/builtins/v128.shuffle\";\n  export const v128_swizzle = \"~lib/builtins/v128.swizzle\";\n  export const v128_load_splat = \"~lib/builtins/v128.load_splat\";\n  export const v128_load_ext = \"~lib/builtins/v128.load_ext\";\n  export const v128_load_zero = \"~lib/builtins/v128.load_zero\";\n  export const v128_load_lane = \"~lib/builtins/v128.load_lane\";\n  export const v128_store_lane = \"~lib/builtins/v128.store_lane\";\n  export const v128_load = \"~lib/builtins/v128.load\";\n  export const v128_load8x8_s = \"~lib/builtins/v128.load8x8_s\";\n  export const v128_load8x8_u = \"~lib/builtins/v128.load8x8_u\";\n  export const v128_load16x4_s = \"~lib/builtins/v128.load16x4_s\";\n  export const v128_load16x4_u = \"~lib/builtins/v128.load16x4_u\";\n  export const v128_load32x2_s = \"~lib/builtins/v128.load32x2_s\";\n  export const v128_load32x2_u = \"~lib/builtins/v128.load32x2_u\";\n  export const v128_load8_splat = \"~lib/builtins/v128.load8_splat\";\n  export const v128_load16_splat = \"~lib/builtins/v128.load16_splat\";\n  export const v128_load32_splat = \"~lib/builtins/v128.load32_splat\";\n  export const v128_load64_splat = \"~lib/builtins/v128.load64_splat\";\n  export const v128_load32_zero = \"~lib/builtins/v128.load32_zero\";\n  export const v128_load64_zero = \"~lib/builtins/v128.load64_zero\";\n  export const v128_load8_lane = \"~lib/builtins/v128.load8_lane\";\n  export const v128_load16_lane = \"~lib/builtins/v128.load16_lane\";\n  export const v128_load32_lane = \"~lib/builtins/v128.load32_lane\";\n  export const v128_load64_lane = \"~lib/builtins/v128.load64_lane\";\n  export const v128_store8_lane = \"~lib/builtins/v128.store8_lane\";\n  export const v128_store16_lane = \"~lib/builtins/v128.store16_lane\";\n  export const v128_store32_lane = \"~lib/builtins/v128.store32_lane\";\n  export const v128_store64_lane = \"~lib/builtins/v128.store64_lane\";\n  export const v128_store = \"~lib/builtins/v128.store\";\n  export const v128_add = \"~lib/builtins/v128.add\";\n  export const v128_sub = \"~lib/builtins/v128.sub\";\n  export const v128_mul = \"~lib/builtins/v128.mul\";\n  export const v128_div = \"~lib/builtins/v128.div\";\n  export const v128_neg = \"~lib/builtins/v128.neg\";\n  export const v128_add_sat = \"~lib/builtins/v128.add_sat\";\n  export const v128_sub_sat = \"~lib/builtins/v128.sub_sat\";\n  export const v128_shl = \"~lib/builtins/v128.shl\";\n  export const v128_shr = \"~lib/builtins/v128.shr\";\n  export const v128_and = \"~lib/builtins/v128.and\";\n  export const v128_or = \"~lib/builtins/v128.or\";\n  export const v128_xor = \"~lib/builtins/v128.xor\";\n  export const v128_andnot = \"~lib/builtins/v128.andnot\";\n  export const v128_not = \"~lib/builtins/v128.not\";\n  export const v128_bitselect = \"~lib/builtins/v128.bitselect\";\n  export const v128_any_true = \"~lib/builtins/v128.any_true\";\n  export const v128_all_true = \"~lib/builtins/v128.all_true\";\n  export const v128_bitmask = \"~lib/builtins/v128.bitmask\";\n  export const v128_popcnt = \"~lib/builtins/v128.popcnt\";\n  export const v128_min = \"~lib/builtins/v128.min\";\n  export const v128_max = \"~lib/builtins/v128.max\";\n  export const v128_pmin = \"~lib/builtins/v128.pmin\";\n  export const v128_pmax = \"~lib/builtins/v128.pmax\";\n  export const v128_dot = \"~lib/builtins/v128.dot\";\n  export const v128_avgr = \"~lib/builtins/v128.avgr\";\n  export const v128_abs = \"~lib/builtins/v128.abs\";\n  export const v128_sqrt = \"~lib/builtins/v128.sqrt\";\n  export const v128_ceil = \"~lib/builtins/v128.ceil\";\n  export const v128_floor = \"~lib/builtins/v128.floor\";\n  export const v128_trunc = \"~lib/builtins/v128.trunc\";\n  export const v128_nearest = \"~lib/builtins/v128.nearest\";\n  export const v128_eq = \"~lib/builtins/v128.eq\";\n  export const v128_ne = \"~lib/builtins/v128.ne\";\n  export const v128_lt = \"~lib/builtins/v128.lt\";\n  export const v128_le = \"~lib/builtins/v128.le\";\n  export const v128_gt = \"~lib/builtins/v128.gt\";\n  export const v128_ge = \"~lib/builtins/v128.ge\";\n  export const v128_convert = \"~lib/builtins/v128.convert\";\n  export const v128_convert_low = \"~lib/builtins/v128.convert_low\";\n  export const v128_trunc_sat = \"~lib/builtins/v128.trunc_sat\";\n  export const v128_trunc_sat_zero = \"~lib/builtins/v128.trunc_sat_zero\";\n  export const v128_narrow = \"~lib/builtins/v128.narrow\";\n  export const v128_extend_low = \"~lib/builtins/v128.extend_low\";\n  export const v128_extend_high = \"~lib/builtins/v128.extend_high\";\n  export const v128_extadd_pairwise = \"~lib/builtins/v128.extadd_pairwise\";\n  export const v128_demote_zero = \"~lib/builtins/v128.demote_zero\";\n  export const v128_promote_low = \"~lib/builtins/v128.promote_low\";\n  export const v128_q15mulr_sat = \"~lib/builtins/v128.q15mulr_sat\";\n  export const v128_extmul_low = \"~lib/builtins/v128.extmul_low\";\n  export const v128_extmul_high = \"~lib/builtins/v128.extmul_high\";\n\n  export const i8x16 = \"~lib/builtins/i8x16\";\n  export const i16x8 = \"~lib/builtins/i16x8\";\n  export const i32x4 = \"~lib/builtins/i32x4\";\n  export const i64x2 = \"~lib/builtins/i64x2\";\n  export const f32x4 = \"~lib/builtins/f32x4\";\n  export const f64x2 = \"~lib/builtins/f64x2\";\n\n  export const i8x16_splat = \"~lib/builtins/i8x16.splat\";\n  export const i8x16_extract_lane_s = \"~lib/builtins/i8x16.extract_lane_s\";\n  export const i8x16_extract_lane_u = \"~lib/builtins/i8x16.extract_lane_u\";\n  export const i8x16_replace_lane = \"~lib/builtins/i8x16.replace_lane\";\n  export const i8x16_add = \"~lib/builtins/i8x16.add\";\n  export const i8x16_sub = \"~lib/builtins/i8x16.sub\";\n  export const i8x16_mul = \"~lib/builtins/i8x16.mul\";\n  export const i8x16_min_s = \"~lib/builtins/i8x16.min_s\";\n  export const i8x16_min_u = \"~lib/builtins/i8x16.min_u\";\n  export const i8x16_max_s = \"~lib/builtins/i8x16.max_s\";\n  export const i8x16_max_u = \"~lib/builtins/i8x16.max_u\";\n  export const i8x16_avgr_u = \"~lib/builtins/i8x16.avgr_u\";\n  export const i8x16_abs = \"~lib/builtins/i8x16.abs\";\n  export const i8x16_neg = \"~lib/builtins/i8x16.neg\";\n  export const i8x16_add_sat_s = \"~lib/builtins/i8x16.add_sat_s\";\n  export const i8x16_add_sat_u = \"~lib/builtins/i8x16.add_sat_u\";\n  export const i8x16_sub_sat_s = \"~lib/builtins/i8x16.sub_sat_s\";\n  export const i8x16_sub_sat_u = \"~lib/builtins/i8x16.sub_sat_u\";\n  export const i8x16_shl = \"~lib/builtins/i8x16.shl\";\n  export const i8x16_shr_s = \"~lib/builtins/i8x16.shr_s\";\n  export const i8x16_shr_u = \"~lib/builtins/i8x16.shr_u\";\n  export const i8x16_all_true = \"~lib/builtins/i8x16.all_true\";\n  export const i8x16_bitmask = \"~lib/builtins/i8x16.bitmask\";\n  export const i8x16_popcnt = \"~lib/builtins/i8x16.popcnt\";\n  export const i8x16_eq = \"~lib/builtins/i8x16.eq\";\n  export const i8x16_ne = \"~lib/builtins/i8x16.ne\";\n  export const i8x16_lt_s = \"~lib/builtins/i8x16.lt_s\";\n  export const i8x16_lt_u = \"~lib/builtins/i8x16.lt_u\";\n  export const i8x16_le_s = \"~lib/builtins/i8x16.le_s\";\n  export const i8x16_le_u = \"~lib/builtins/i8x16.le_u\";\n  export const i8x16_gt_s = \"~lib/builtins/i8x16.gt_s\";\n  export const i8x16_gt_u = \"~lib/builtins/i8x16.gt_u\";\n  export const i8x16_ge_s = \"~lib/builtins/i8x16.ge_s\";\n  export const i8x16_ge_u = \"~lib/builtins/i8x16.ge_u\";\n  export const i8x16_narrow_i16x8_s = \"~lib/builtins/i8x16.narrow_i16x8_s\";\n  export const i8x16_narrow_i16x8_u = \"~lib/builtins/i8x16.narrow_i16x8_u\";\n  export const i8x16_shuffle = \"~lib/builtins/i8x16.shuffle\";\n  export const i8x16_swizzle = \"~lib/builtins/i8x16.swizzle\";\n\n  export const i16x8_splat = \"~lib/builtins/i16x8.splat\";\n  export const i16x8_extract_lane_s = \"~lib/builtins/i16x8.extract_lane_s\";\n  export const i16x8_extract_lane_u = \"~lib/builtins/i16x8.extract_lane_u\";\n  export const i16x8_replace_lane = \"~lib/builtins/i16x8.replace_lane\";\n  export const i16x8_add = \"~lib/builtins/i16x8.add\";\n  export const i16x8_sub = \"~lib/builtins/i16x8.sub\";\n  export const i16x8_mul = \"~lib/builtins/i16x8.mul\";\n  export const i16x8_min_s = \"~lib/builtins/i16x8.min_s\";\n  export const i16x8_min_u = \"~lib/builtins/i16x8.min_u\";\n  export const i16x8_max_s = \"~lib/builtins/i16x8.max_s\";\n  export const i16x8_max_u = \"~lib/builtins/i16x8.max_u\";\n  export const i16x8_avgr_u = \"~lib/builtins/i16x8.avgr_u\";\n  export const i16x8_abs = \"~lib/builtins/i16x8.abs\";\n  export const i16x8_neg = \"~lib/builtins/i16x8.neg\";\n  export const i16x8_add_sat_s = \"~lib/builtins/i16x8.add_sat_s\";\n  export const i16x8_add_sat_u = \"~lib/builtins/i16x8.add_sat_u\";\n  export const i16x8_sub_sat_s = \"~lib/builtins/i16x8.sub_sat_s\";\n  export const i16x8_sub_sat_u = \"~lib/builtins/i16x8.sub_sat_u\";\n  export const i16x8_shl = \"~lib/builtins/i16x8.shl\";\n  export const i16x8_shr_s = \"~lib/builtins/i16x8.shr_s\";\n  export const i16x8_shr_u = \"~lib/builtins/i16x8.shr_u\";\n  export const i16x8_all_true = \"~lib/builtins/i16x8.all_true\";\n  export const i16x8_bitmask = \"~lib/builtins/i16x8.bitmask\";\n  export const i16x8_eq = \"~lib/builtins/i16x8.eq\";\n  export const i16x8_ne = \"~lib/builtins/i16x8.ne\";\n  export const i16x8_lt_s = \"~lib/builtins/i16x8.lt_s\";\n  export const i16x8_lt_u = \"~lib/builtins/i16x8.lt_u\";\n  export const i16x8_le_s = \"~lib/builtins/i16x8.le_s\";\n  export const i16x8_le_u = \"~lib/builtins/i16x8.le_u\";\n  export const i16x8_gt_s = \"~lib/builtins/i16x8.gt_s\";\n  export const i16x8_gt_u = \"~lib/builtins/i16x8.gt_u\";\n  export const i16x8_ge_s = \"~lib/builtins/i16x8.ge_s\";\n  export const i16x8_ge_u = \"~lib/builtins/i16x8.ge_u\";\n  export const i16x8_narrow_i32x4_s = \"~lib/builtins/i16x8.narrow_i32x4_s\";\n  export const i16x8_narrow_i32x4_u = \"~lib/builtins/i16x8.narrow_i32x4_u\";\n  export const i16x8_extend_low_i8x16_s = \"~lib/builtins/i16x8.extend_low_i8x16_s\";\n  export const i16x8_extend_low_i8x16_u = \"~lib/builtins/i16x8.extend_low_i8x16_u\";\n  export const i16x8_extend_high_i8x16_s = \"~lib/builtins/i16x8.extend_high_i8x16_s\";\n  export const i16x8_extend_high_i8x16_u = \"~lib/builtins/i16x8.extend_high_i8x16_u\";\n  export const i16x8_extadd_pairwise_i8x16_s = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_s\";\n  export const i16x8_extadd_pairwise_i8x16_u = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_u\";\n  export const i16x8_q15mulr_sat_s = \"~lib/builtins/i16x8.q15mulr_sat_s\";\n  export const i16x8_extmul_low_i8x16_s = \"~lib/builtins/i16x8.extmul_low_i8x16_s\";\n  export const i16x8_extmul_low_i8x16_u = \"~lib/builtins/i16x8.extmul_low_i8x16_u\";\n  export const i16x8_extmul_high_i8x16_s = \"~lib/builtins/i16x8.extmul_high_i8x16_s\";\n  export const i16x8_extmul_high_i8x16_u = \"~lib/builtins/i16x8.extmul_high_i8x16_u\";\n\n  export const i32x4_splat = \"~lib/builtins/i32x4.splat\";\n  export const i32x4_extract_lane = \"~lib/builtins/i32x4.extract_lane\";\n  export const i32x4_replace_lane = \"~lib/builtins/i32x4.replace_lane\";\n  export const i32x4_add = \"~lib/builtins/i32x4.add\";\n  export const i32x4_sub = \"~lib/builtins/i32x4.sub\";\n  export const i32x4_mul = \"~lib/builtins/i32x4.mul\";\n  export const i32x4_min_s = \"~lib/builtins/i32x4.min_s\";\n  export const i32x4_min_u = \"~lib/builtins/i32x4.min_u\";\n  export const i32x4_max_s = \"~lib/builtins/i32x4.max_s\";\n  export const i32x4_max_u = \"~lib/builtins/i32x4.max_u\";\n  export const i32x4_dot_i16x8_s = \"~lib/builtins/i32x4.dot_i16x8_s\";\n  export const i32x4_abs = \"~lib/builtins/i32x4.abs\";\n  export const i32x4_neg = \"~lib/builtins/i32x4.neg\";\n  export const i32x4_shl = \"~lib/builtins/i32x4.shl\";\n  export const i32x4_shr_s = \"~lib/builtins/i32x4.shr_s\";\n  export const i32x4_shr_u = \"~lib/builtins/i32x4.shr_u\";\n  export const i32x4_all_true = \"~lib/builtins/i32x4.all_true\";\n  export const i32x4_bitmask = \"~lib/builtins/i32x4.bitmask\";\n  export const i32x4_eq = \"~lib/builtins/i32x4.eq\";\n  export const i32x4_ne = \"~lib/builtins/i32x4.ne\";\n  export const i32x4_lt_s = \"~lib/builtins/i32x4.lt_s\";\n  export const i32x4_lt_u = \"~lib/builtins/i32x4.lt_u\";\n  export const i32x4_le_s = \"~lib/builtins/i32x4.le_s\";\n  export const i32x4_le_u = \"~lib/builtins/i32x4.le_u\";\n  export const i32x4_gt_s = \"~lib/builtins/i32x4.gt_s\";\n  export const i32x4_gt_u = \"~lib/builtins/i32x4.gt_u\";\n  export const i32x4_ge_s = \"~lib/builtins/i32x4.ge_s\";\n  export const i32x4_ge_u = \"~lib/builtins/i32x4.ge_u\";\n  export const i32x4_trunc_sat_f32x4_s = \"~lib/builtins/i32x4.trunc_sat_f32x4_s\";\n  export const i32x4_trunc_sat_f32x4_u = \"~lib/builtins/i32x4.trunc_sat_f32x4_u\";\n  export const i32x4_trunc_sat_f64x2_s_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_s_zero\";\n  export const i32x4_trunc_sat_f64x2_u_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_u_zero\";\n  export const i32x4_extend_low_i16x8_s = \"~lib/builtins/i32x4.extend_low_i16x8_s\";\n  export const i32x4_extend_low_i16x8_u = \"~lib/builtins/i32x4.extend_low_i16x8_u\";\n  export const i32x4_extend_high_i16x8_s = \"~lib/builtins/i32x4.extend_high_i16x8_s\";\n  export const i32x4_extend_high_i16x8_u = \"~lib/builtins/i32x4.extend_high_i16x8_u\";\n  export const i32x4_extadd_pairwise_i16x8_s = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_s\";\n  export const i32x4_extadd_pairwise_i16x8_u = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_u\";\n  export const i32x4_extmul_low_i16x8_s = \"~lib/builtins/i32x4.extmul_low_i16x8_s\";\n  export const i32x4_extmul_low_i16x8_u = \"~lib/builtins/i32x4.extmul_low_i16x8_u\";\n  export const i32x4_extmul_high_i16x8_s = \"~lib/builtins/i32x4.extmul_high_i16x8_s\";\n  export const i32x4_extmul_high_i16x8_u = \"~lib/builtins/i32x4.extmul_high_i16x8_u\";\n\n  export const i64x2_splat = \"~lib/builtins/i64x2.splat\";\n  export const i64x2_extract_lane = \"~lib/builtins/i64x2.extract_lane\";\n  export const i64x2_replace_lane = \"~lib/builtins/i64x2.replace_lane\";\n  export const i64x2_add = \"~lib/builtins/i64x2.add\";\n  export const i64x2_sub = \"~lib/builtins/i64x2.sub\";\n  export const i64x2_mul = \"~lib/builtins/i64x2.mul\";\n  export const i64x2_abs = \"~lib/builtins/i64x2.abs\";\n  export const i64x2_neg = \"~lib/builtins/i64x2.neg\";\n  export const i64x2_shl = \"~lib/builtins/i64x2.shl\";\n  export const i64x2_shr_s = \"~lib/builtins/i64x2.shr_s\";\n  export const i64x2_shr_u = \"~lib/builtins/i64x2.shr_u\";\n  export const i64x2_all_true = \"~lib/builtins/i64x2.all_true\";\n  export const i64x2_bitmask = \"~lib/builtins/i64x2.bitmask\";\n  export const i64x2_eq = \"~lib/builtins/i64x2.eq\";\n  export const i64x2_ne = \"~lib/builtins/i64x2.ne\";\n  export const i64x2_lt_s = \"~lib/builtins/i64x2.lt_s\";\n  export const i64x2_lt_u = \"~lib/builtins/i64x2.lt_u\";\n  export const i64x2_le_s = \"~lib/builtins/i64x2.le_s\";\n  export const i64x2_le_u = \"~lib/builtins/i64x2.le_u\";\n  export const i64x2_gt_s = \"~lib/builtins/i64x2.gt_s\";\n  export const i64x2_gt_u = \"~lib/builtins/i64x2.gt_u\";\n  export const i64x2_ge_s = \"~lib/builtins/i64x2.ge_s\";\n  export const i64x2_ge_u = \"~lib/builtins/i64x2.ge_u\";\n  export const i64x2_extend_low_i32x4_s = \"~lib/builtins/i64x2.extend_low_i32x4_s\";\n  export const i64x2_extend_low_i32x4_u = \"~lib/builtins/i64x2.extend_low_i32x4_u\";\n  export const i64x2_extend_high_i32x4_s = \"~lib/builtins/i64x2.extend_high_i32x4_s\";\n  export const i64x2_extend_high_i32x4_u = \"~lib/builtins/i64x2.extend_high_i32x4_u\";\n  export const i64x2_extmul_low_i32x4_s = \"~lib/builtins/i64x2.extmul_low_i32x4_s\";\n  export const i64x2_extmul_low_i32x4_u = \"~lib/builtins/i64x2.extmul_low_i32x4_u\";\n  export const i64x2_extmul_high_i32x4_s = \"~lib/builtins/i64x2.extmul_high_i32x4_s\";\n  export const i64x2_extmul_high_i32x4_u = \"~lib/builtins/i64x2.extmul_high_i32x4_u\";\n\n  export const f32x4_splat = \"~lib/builtins/f32x4.splat\";\n  export const f32x4_extract_lane = \"~lib/builtins/f32x4.extract_lane\";\n  export const f32x4_replace_lane = \"~lib/builtins/f32x4.replace_lane\";\n  export const f32x4_add = \"~lib/builtins/f32x4.add\";\n  export const f32x4_sub = \"~lib/builtins/f32x4.sub\";\n  export const f32x4_mul = \"~lib/builtins/f32x4.mul\";\n  export const f32x4_div = \"~lib/builtins/f32x4.div\";\n  export const f32x4_neg = \"~lib/builtins/f32x4.neg\";\n  export const f32x4_min = \"~lib/builtins/f32x4.min\";\n  export const f32x4_max = \"~lib/builtins/f32x4.max\";\n  export const f32x4_pmin = \"~lib/builtins/f32x4.pmin\";\n  export const f32x4_pmax = \"~lib/builtins/f32x4.pmax\";\n  export const f32x4_abs = \"~lib/builtins/f32x4.abs\";\n  export const f32x4_sqrt = \"~lib/builtins/f32x4.sqrt\";\n  export const f32x4_ceil = \"~lib/builtins/f32x4.ceil\";\n  export const f32x4_floor = \"~lib/builtins/f32x4.floor\";\n  export const f32x4_trunc = \"~lib/builtins/f32x4.trunc\";\n  export const f32x4_nearest = \"~lib/builtins/f32x4.nearest\";\n  export const f32x4_eq = \"~lib/builtins/f32x4.eq\";\n  export const f32x4_ne = \"~lib/builtins/f32x4.ne\";\n  export const f32x4_lt = \"~lib/builtins/f32x4.lt\";\n  export const f32x4_le = \"~lib/builtins/f32x4.le\";\n  export const f32x4_gt = \"~lib/builtins/f32x4.gt\";\n  export const f32x4_ge = \"~lib/builtins/f32x4.ge\";\n  export const f32x4_convert_i32x4_s = \"~lib/builtins/f32x4.convert_i32x4_s\";\n  export const f32x4_convert_i32x4_u = \"~lib/builtins/f32x4.convert_i32x4_u\";\n  export const f32x4_demote_f64x2_zero = \"~lib/builtins/f32x4.demote_f64x2_zero\";\n\n  export const f64x2_splat = \"~lib/builtins/f64x2.splat\";\n  export const f64x2_extract_lane = \"~lib/builtins/f64x2.extract_lane\";\n  export const f64x2_replace_lane = \"~lib/builtins/f64x2.replace_lane\";\n  export const f64x2_add = \"~lib/builtins/f64x2.add\";\n  export const f64x2_sub = \"~lib/builtins/f64x2.sub\";\n  export const f64x2_mul = \"~lib/builtins/f64x2.mul\";\n  export const f64x2_div = \"~lib/builtins/f64x2.div\";\n  export const f64x2_neg = \"~lib/builtins/f64x2.neg\";\n  export const f64x2_min = \"~lib/builtins/f64x2.min\";\n  export const f64x2_max = \"~lib/builtins/f64x2.max\";\n  export const f64x2_pmin = \"~lib/builtins/f64x2.pmin\";\n  export const f64x2_pmax = \"~lib/builtins/f64x2.pmax\";\n  export const f64x2_abs = \"~lib/builtins/f64x2.abs\";\n  export const f64x2_sqrt = \"~lib/builtins/f64x2.sqrt\";\n  export const f64x2_ceil = \"~lib/builtins/f64x2.ceil\";\n  export const f64x2_floor = \"~lib/builtins/f64x2.floor\";\n  export const f64x2_trunc = \"~lib/builtins/f64x2.trunc\";\n  export const f64x2_nearest = \"~lib/builtins/f64x2.nearest\";\n  export const f64x2_eq = \"~lib/builtins/f64x2.eq\";\n  export const f64x2_ne = \"~lib/builtins/f64x2.ne\";\n  export const f64x2_lt = \"~lib/builtins/f64x2.lt\";\n  export const f64x2_le = \"~lib/builtins/f64x2.le\";\n  export const f64x2_gt = \"~lib/builtins/f64x2.gt\";\n  export const f64x2_ge = \"~lib/builtins/f64x2.ge\";\n  export const f64x2_convert_low_i32x4_s = \"~lib/builtins/f64x2.convert_low_i32x4_s\";\n  export const f64x2_convert_low_i32x4_u = \"~lib/builtins/f64x2.convert_low_i32x4_u\";\n  export const f64x2_promote_low_f32x4 = \"~lib/builtins/f64x2.promote_low_f32x4\";\n\n  export const i31_new = \"~lib/builtins/i31.new\";\n  export const i31_get = \"~lib/builtins/i31.get\";\n\n  // internals\n  export const data_end = \"~lib/memory/__data_end\";\n  export const stack_pointer = \"~lib/memory/__stack_pointer\";\n  export const heap_base = \"~lib/memory/__heap_base\";\n  export const rtti_base = \"~lib/rt/__rtti_base\";\n  export const visit_globals = \"~lib/rt/__visit_globals\";\n  export const visit_members = \"~lib/rt/__visit_members\";\n  export const tostack = \"~lib/rt/__tostack\";\n\n  // std/number.ts\n  export const isNaN = \"~lib/number/isNaN\";\n  export const isFinite = \"~lib/number/isFinite\";\n\n  // std/diagnostics.ts\n  export const ERROR = \"~lib/diagnostics/ERROR\";\n  export const WARNING = \"~lib/diagnostics/WARNING\";\n  export const INFO = \"~lib/diagnostics/INFO\";\n\n  // std/function.ts\n  export const Function = \"~lib/function/Function\";\n\n  // std/memory.ts\n  export const memory_size = \"~lib/memory/memory.size\";\n  export const memory_grow = \"~lib/memory/memory.grow\";\n  export const memory_copy = \"~lib/memory/memory.copy\";\n  export const memory_fill = \"~lib/memory/memory.fill\";\n  export const memory_data = \"~lib/memory/memory.data\";\n\n  // std/typedarray.ts\n  export const Int8Array = \"~lib/typedarray/Int8Array\";\n  export const Uint8Array = \"~lib/typedarray/Uint8Array\";\n  export const Uint8ClampedArray = \"~lib/typedarray/Uint8ClampedArray\";\n  export const Int16Array = \"~lib/typedarray/Int16Array\";\n  export const Uint16Array = \"~lib/typedarray/Uint16Array\";\n  export const Int32Array = \"~lib/typedarray/Int32Array\";\n  export const Uint32Array = \"~lib/typedarray/Uint32Array\";\n  export const Int64Array = \"~lib/typedarray/Int64Array\";\n  export const Uint64Array = \"~lib/typedarray/Uint64Array\";\n  export const Float32Array = \"~lib/typedarray/Float32Array\";\n  export const Float64Array = \"~lib/typedarray/Float64Array\";\n\n  // std/string.ts\n  export const String_raw = \"~lib/string/String.raw\";\n\n  // std/bindings/wasi.ts\n  export const wasiAbort = \"~lib/wasi/index/abort\";\n  export const wasiTrace = \"~lib/wasi/index/trace\";\n  export const wasiSeed = \"~lib/wasi/index/seed\";\n}\n\n/** Builtin compilation context. */\nexport class BuiltinContext {\n  constructor(\n    /** Compiler reference. */\n    public compiler: Compiler,\n    /** Prototype being called. */\n    public prototype: FunctionPrototype,\n    /** Provided type arguments. */\n    public typeArguments: Type[] | null,\n    /** Provided operands. */\n    public operands: Expression[],\n    /** Provided this operand, if any. */\n    public thisOperand: Expression | null,\n    /** Contextual type. */\n    public contextualType: Type,\n    /** Respective call expression. */\n    public reportNode: CallExpression,\n    /** Whether originating from inline assembly. */\n    public contextIsExact: bool\n  ) {}\n}\n\n/** Global builtins map. */\nexport const builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n/** Function builtins map. */\nexport const function_builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n// === Static type evaluation =================================================================\n\n// isInteger<T!>() / isInteger<T?>(value: T) -> bool\nfunction builtin_isInteger(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isIntegerValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isInteger, builtin_isInteger);\n\n// isFloat<T!>() / isFloat<T?>(value: T) -> bool\nfunction builtin_isFloat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isFloatValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isFloat, builtin_isFloat);\n\n// isBoolean<T!>() / isBoolean<T?>(value: T) -> bool\nfunction builtin_isBoolean(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isBooleanValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isBoolean, builtin_isBoolean);\n\n// isSigned<T!>() / isSigned<T?>(value: T) -> bool\nfunction builtin_isSigned(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isSignedIntegerValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isSigned, builtin_isSigned);\n\n// isReference<T!>() / isReference<T?>(value: T) -> bool\nfunction builtin_isReference(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isReference ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isReference, builtin_isReference);\n\n// isString<T!>() / isString<T?>(value: T) -> bool\nfunction builtin_isString(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.isAssignableTo(compiler.program.stringInstance)\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isString, builtin_isString);\n\n// isArray<T!>() / isArray<T?>(value: T) -> bool\nfunction builtin_isArray(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.extends(compiler.program.arrayPrototype)\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isArray, builtin_isArray);\n\n// isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool\nfunction builtin_isArrayLike(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.isArrayLike\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isArrayLike, builtin_isArrayLike);\n\n// isFunction<T!> / isFunction<T?>(value: T) -> bool\nfunction builtin_isFunction(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isFunction ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isFunction, builtin_isFunction);\n\n// isNullable<T!> / isNullable<T?>(value: T) -> bool\nfunction builtin_isNullable(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isNullableReference ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isNullable, builtin_isNullable);\n\n// isDefined(expression) -> bool\nfunction builtin_isDefined(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var element = compiler.resolver.lookupExpression(\n    ctx.operands[0],\n    compiler.currentFlow,\n    Type.auto,\n    ReportMode.SWALLOW\n  );\n  return module.i32(element !== null ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isDefined, builtin_isDefined);\n\n// isConstant(expression) -> bool\nfunction builtin_isConstant(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var expr = compiler.compileExpression(ctx.operands[0], Type.auto);\n  compiler.currentType = Type.bool;\n  return module.i32(getExpressionId(expr) == ExpressionId.Const ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isConstant, builtin_isConstant);\n\n// isManaged<T!>() -> bool\nfunction builtin_isManaged(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isManaged ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isManaged, builtin_isManaged);\n\n// isVoid<T!>() -> bool\nfunction builtin_isVoid(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.kind == TypeKind.VOID ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isVoid, builtin_isVoid);\n\n// lengthof<T!>() -> i32\nfunction builtin_lengthof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.i32;\n  if (!type) return module.unreachable();\n  var signatureReference = type.signatureReference;\n  if (!signatureReference) {\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_call_signatures,\n      ctx.reportNode.range, type.toString()\n    );\n    return module.unreachable();\n  }\n  return module.i32(signatureReference.parameterTypes.length);\n}\nbuiltins.set(BuiltinNames.lengthof, builtin_lengthof);\n\n// sizeof<T!>() -> usize*\nfunction builtin_sizeof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  var type = ctx.typeArguments![0];\n  var byteSize = type.byteSize;\n  if (!byteSize) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"sizeof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(byteSize), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.sizeof, builtin_sizeof);\n\n// alignof<T!>() -> usize*\nfunction builtin_alignof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  var type = ctx.typeArguments![0];\n  var byteSize = type.byteSize;\n  if (!isPowerOf2(byteSize)) { // implies == 0\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"alignof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(ctz<i32>(byteSize)), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.alignof, builtin_alignof);\n\n// offsetof<T!>(fieldName?: string) -> usize*\nfunction builtin_offsetof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 0, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var contextualType = ctx.contextualType;\n  var type = ctx.typeArguments![0];\n  var classReference = type.getClassOrWrapper(compiler.program);\n  if (!classReference) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"offsetof\", type.toString()\n    );\n    if (compiler.options.isWasm64) {\n      if (contextualType.isIntegerValue && contextualType.size <= 32) {\n        compiler.currentType = Type.u32;\n      }\n    } else {\n      if (contextualType.isIntegerValue && contextualType.size == 64) {\n        compiler.currentType = Type.u64;\n      }\n    }\n    return module.unreachable();\n  }\n  if (operands.length) {\n    let firstOperand = operands[0];\n    if (!firstOperand.isLiteralKind(LiteralKind.STRING)) {\n      compiler.error(\n        DiagnosticCode.String_literal_expected,\n        operands[0].range\n      );\n      return module.unreachable();\n    }\n    let fieldName = (<StringLiteralExpression>firstOperand).value;\n    let classMembers = classReference.members;\n    if (classMembers !== null && classMembers.has(fieldName)) {\n      let member = assert(classMembers.get(fieldName));\n      if (member.kind == ElementKind.FIELD) {\n        return contextualUsize(compiler, i64_new((<Field>member).memoryOffset), contextualType);\n      }\n    }\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_property_1,\n      firstOperand.range, classReference.internalName, fieldName\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(classReference.nextMemoryOffset), contextualType);\n}\nbuiltins.set(BuiltinNames.offsetof, builtin_offsetof);\n\n// nameof<T> -> string\nfunction builtin_nameof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var resultType = evaluateConstantType(ctx);\n  if (!resultType) {\n    compiler.currentType = compiler.program.stringInstance.type;\n    return module.unreachable();\n  }\n  var value: string;\n  if (resultType.isInternalReference) {\n    let classReference = resultType.getClass();\n    if (classReference) {\n      value = classReference.name;\n    } else {\n      assert(resultType.getSignature());\n      value = \"Function\";\n    }\n  } else {\n    value = resultType.toString();\n  }\n  return compiler.ensureStaticString(value);\n}\nbuiltins.set(BuiltinNames.nameof, builtin_nameof);\n\n// idof<T> -> u32\nfunction builtin_idof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.u32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n    return module.i32(signatureReference.id);\n  }\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (classReference !== null && !classReference.hasDecorator(DecoratorFlags.UNMANAGED)) {\n    return module.i32(classReference.id);\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"idof\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.idof, builtin_idof);\n\n// === Math ===================================================================================\n\n// clz<T?>(value: T) -> T\nfunction builtin_clz(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(ctx.operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.BOOL: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.ClzI32, arg0);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.ClzI64\n            : UnaryOp.ClzI32,\n          arg0\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.ClzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"clz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.clz, builtin_clz);\n\n// ctz<T?>(value: T) -> T\nfunction builtin_ctz(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.BOOL: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.CtzI32, arg0);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.CtzI64\n            : UnaryOp.CtzI32,\n          arg0\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.CtzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ctz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ctz, builtin_ctz);\n\n// popcnt<T?>(value: T) -> T\nfunction builtin_popcnt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (compiler.currentType.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8: // not wrapped\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.PopcntI32, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.PopcntI64, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.PopcntI64\n            : UnaryOp.PopcntI32,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.popcnt, builtin_popcnt);\n\n// rotl<T?>(value: T, shift: T) -> T\nfunction builtin_rotl(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value << (shift & mask)) | (value >>> ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotlI32, arg0, arg1);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.RotlI64\n            : BinaryOp.RotlI32,\n          arg0, arg1\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotlI64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotl, builtin_rotl);\n\n// rotr<T?>(value: T, shift: T) -> T\nfunction builtin_rotr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value >>> (shift & mask)) | (value << ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_tee(temp1.index, arg0, false), // i32\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1, false), // i32\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_get(temp1.index, TypeRef.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, TypeRef.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotrI32, arg0, arg1);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.RotrI64\n            : BinaryOp.RotrI32,\n          arg0, arg1\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotrI64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotr, builtin_rotr);\n\n// abs<T?>(value: T) -> T\nfunction builtin_abs(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: {\n        let flow = compiler.currentFlow;\n\n        // possibly overflows, e.g. abs<i8>(-128) == 128\n        let temp1 = flow.getTempLocal(Type.i32);\n        let temp2 = flow.getTempLocal(Type.i32);\n        // (x + (x >> 31)) ^ (x >> 31)\n        let ret = module.binary(BinaryOp.XorI32,\n          module.binary(BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0, false), // i32\n                module.i32(31)\n              ),\n              false // i32\n            ),\n            module.local_get(temp1.index, TypeRef.I32)\n          ),\n          module.local_get(temp2.index, TypeRef.I32)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.ISIZE: {\n        let options = compiler.options;\n        let flow = compiler.currentFlow;\n        let isWasm64 = options.isWasm64;\n\n        let temp1 = flow.getTempLocal(options.usizeType);\n        let temp2 = flow.getTempLocal(options.usizeType);\n        let ret = module.binary(isWasm64 ? BinaryOp.XorI64 : BinaryOp.XorI32,\n          module.binary(isWasm64 ? BinaryOp.AddI64 : BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(isWasm64 ? BinaryOp.ShrI64 : BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0, false), // i32/i64\n                isWasm64 ? module.i64(63) : module.i32(31)\n              ),\n              false // i32/i64\n            ),\n            module.local_get(temp1.index, options.sizeTypeRef)\n          ),\n          module.local_get(temp2.index, options.sizeTypeRef)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.I64: {\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(Type.i64);\n        let temp2 = flow.getTempLocal(Type.i64);\n        // (x + (x >> 63)) ^ (x >> 63)\n        let ret = module.binary(BinaryOp.XorI64,\n          module.binary(BinaryOp.AddI64,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI64,\n                module.local_tee(temp1.index, arg0, false), // i64\n                module.i64(63)\n              ),\n              false // i64\n            ),\n            module.local_get(temp1.index, TypeRef.I64)\n          ),\n          module.local_get(temp2.index, TypeRef.I64)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.USIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.abs, builtin_abs);\n\n// max<T?>(left: T, right: T) -> T\nfunction builtin_max(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: { op = BinaryOp.GtI32; break; }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: { op = BinaryOp.GtU32; break; }\n      case TypeKind.I64: { op = BinaryOp.GtI64; break; }\n      case TypeKind.U64: { op = BinaryOp.GtU64; break; }\n      case TypeKind.ISIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.GtI64\n          : BinaryOp.GtI32;\n        break;\n      }\n      case TypeKind.USIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.GtU64\n          : BinaryOp.GtU32;\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        ),\n        typeRef\n      );\n      flow.freeTempLocal(temp2);\n      flow.freeTempLocal(temp1);\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.max, builtin_max);\n\n// min<T?>(left: T, right: T) -> T\nfunction builtin_min(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: { op = BinaryOp.LtI32; break; }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: { op = BinaryOp.LtU32; break; }\n      case TypeKind.I64:  { op = BinaryOp.LtI64; break; }\n      case TypeKind.U64:  { op = BinaryOp.LtU64; break; }\n      case TypeKind.ISIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.LtI64\n          : BinaryOp.LtI32;\n        break;\n      }\n      case TypeKind.USIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.LtU64\n          : BinaryOp.LtU32;\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64, arg0, arg1);\n    }\n    if (op as i32 != -1) {\n      let flow = compiler.currentFlow;\n      let typeRef = type.toRef();\n      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0, false), // numeric\n        module.local_tee(temp2.index, arg1, false), // numeric\n        module.binary(op,\n          module.local_get(temp1.index, typeRef),\n          module.local_get(temp2.index, typeRef)\n        ),\n        typeRef\n      );\n      flow.freeTempLocal(temp2);\n      flow.freeTempLocal(temp1);\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.min, builtin_min);\n\n// ceil<T?>(value: T) -> T\nfunction builtin_ceil(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ceil, builtin_ceil);\n\n// floor<T?>(value: T) -> T\nfunction builtin_floor(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.floor, builtin_floor);\n\n// copysign<T?>(left: T, right: T) -> T\nfunction builtin_copysign(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      // TODO: does an integer version make sense?\n      case TypeKind.F32: return module.binary(BinaryOp.CopysignF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.CopysignF64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"copysign\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.copysign, builtin_copysign);\n\n// nearest<T?>(value: T) -> T\nfunction builtin_nearest(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.nearest, builtin_nearest);\n\n// reinterpret<T!>(value: *) -> T\nfunction builtin_reinterpret(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments![0];\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f32, Constraints.CONV_IMPLICIT);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF32ToI32, arg0);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f64, Constraints.CONV_IMPLICIT);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF64ToI64, arg0);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let arg0 = compiler.compileExpression(operands[0],\n          compiler.options.isWasm64\n            ? Type.f64\n            : Type.f32,\n          Constraints.CONV_IMPLICIT\n        );\n        compiler.currentType = type;\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.ReinterpretF64ToI64\n            : UnaryOp.ReinterpretF32ToI32,\n          arg0\n        );\n      }\n      case TypeKind.F32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\n        compiler.currentType = Type.f32;\n        return module.unary(UnaryOp.ReinterpretI32ToF32, arg0);\n      }\n      case TypeKind.F64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i64, Constraints.CONV_IMPLICIT);\n        compiler.currentType = Type.f64;\n        return module.unary(UnaryOp.ReinterpretI64ToF64, arg0);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"reinterpret\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.reinterpret, builtin_reinterpret);\n\n// sqrt<T?>(value: T) -> T\nfunction builtin_sqrt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      // TODO: integer versions (that return f64 or convert)?\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sqrt, builtin_sqrt);\n\n// trunc<T?>(value: T) -> T\nfunction builtin_trunc(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered truncated\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.trunc, builtin_trunc);\n\n// isNaN<T?>(value: T) -> bool\nfunction builtin_isNaN(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // never NaN\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE: {\n        return module.maybeDropCondition(arg0, module.i32(0));\n      }\n      // (t = arg0) != t\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF32,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.NeF32,\n          module.local_tee(temp.index, arg0, false), // f32\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF64,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.NeF64,\n          module.local_tee(temp.index, arg0, false), // f64\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isNaN\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isNaN, builtin_isNaN);\n\n// isFinite<T?>(value: T) -> bool\nfunction builtin_isFinite(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // always finite\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE: {\n        return module.maybeDropCondition(arg0, module.i32(1));\n      }\n      // (t = arg0) - t == 0\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF32,\n            module.binary(BinaryOp.SubF32,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\n            ),\n            module.f32(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.EqF32,\n          module.binary(BinaryOp.SubF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.local_get(temp.index, TypeRef.F32)\n          ),\n          module.f32(0)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF64,\n            module.binary(BinaryOp.SubF64,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\n            ),\n            module.f64(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.EqF64,\n          module.binary(BinaryOp.SubF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.local_get(temp.index, TypeRef.F64)\n          ),\n          module.f64(0)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isFinite\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isFinite, builtin_isFinite);\n\n// === Memory access ==========================================================================\n\n// load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*\nfunction builtin_load(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var outType = (\n    contextualType != Type.auto &&\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = outType;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = outType;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = outType;\n  return module.load(\n    type.byteSize,\n    type.isSignedIntegerValue,\n    arg0,\n    outType.toRef(),\n    immOffset,\n    immAlign\n  );\n}\nbuiltins.set(BuiltinNames.load, builtin_load);\n\n// store<T!>(ptr: usize, value: T*, immOffset?: usize, immAlign?: usize) -> void\nfunction builtin_store(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 4)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 3) {\n    immOffset = evaluateImmediateOffset(operands[2], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.void;\n      return module.unreachable();\n    }\n    if (numOperands == 4) {\n      immAlign = evaluateImmediateAlign(operands[3], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.void;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.void;\n  return module.store(type.byteSize, arg0, arg1, inType.toRef(), immOffset, immAlign);\n}\nbuiltins.set(BuiltinNames.store, builtin_store);\n\n// add<T?>(left: T, right: T) -> T\nfunction builtin_add(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeAdd(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"add\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.add, builtin_add);\n\n// sub<T?>(left: T, right: T) -> T\nfunction builtin_sub(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeSub(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"sub\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sub, builtin_sub);\n\n// mul<T?>(left: T, right: T) -> T\nfunction builtin_mul(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeMul(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"mul\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.mul, builtin_mul);\n\n// div<T?>(left: T, right: T) -> T\nfunction builtin_div(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeDiv(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"div\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.div, builtin_div);\n\n// === Atomics ================================================================================\n\n// atomic.load<T!>(offset: usize, immOffset?: usize) -> T*\nfunction builtin_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var outType = (\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.load\", type.toString()\n    );\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  compiler.currentType = outType;\n  return module.atomic_load(\n    type.byteSize,\n    arg0,\n    outType.toRef(),\n    immOffset\n  );\n}\nbuiltins.set(BuiltinNames.atomic_load, builtin_atomic_load);\n\n// atomic.store<T!>(offset: usize, value: T*, immOffset?: usize) -> void\nfunction builtin_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.store\", type.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(\n        operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue|| // float to int\n      inType.size < type.size  // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  compiler.currentType = Type.void;\n  return module.atomic_store(type.byteSize, arg0, arg1, inType.toRef(), immOffset);\n}\nbuiltins.set(BuiltinNames.atomic_store, builtin_atomic_store);\n\n// any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_binary(ctx: BuiltinContext, op: AtomicRMWOp, opName: string): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, opName, type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.CONV_IMPLICIT\n  );\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toRef());\n}\n\n// atomic.add<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_add(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Add, \"atomic.add\");\n}\nbuiltins.set(BuiltinNames.atomic_add, builtin_atomic_add);\n\n// atomic.sub<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_sub(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Sub, \"atomic.sub\");\n}\nbuiltins.set(BuiltinNames.atomic_sub, builtin_atomic_sub);\n\n// atomic.and<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.And, \"atomic.and\");\n}\nbuiltins.set(BuiltinNames.atomic_and, builtin_atomic_and);\n\n// atomic.or<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Or, \"atomic.or\");\n}\nbuiltins.set(BuiltinNames.atomic_or, builtin_atomic_or);\n\n// atomic.xor<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xor, \"atomic.xor\");\n}\nbuiltins.set(BuiltinNames.atomic_xor, builtin_atomic_xor);\n\n// atomic.xchg<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xchg(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xchg, \"atomic.xchg\");\n}\nbuiltins.set(BuiltinNames.atomic_xchg, builtin_atomic_xchg);\n\n// atomic.cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T\nfunction builtin_atomic_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 4)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.cmpxchg\", type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.CONV_IMPLICIT\n  );\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  var arg2 = compiler.compileExpression(operands[2],\n    inType,\n    Constraints.CONV_IMPLICIT\n  );\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    arg2 = compiler.convertExpression(arg2, inType, type, false, operands[2]);\n    inType = type;\n  }\n  var immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toRef());\n}\nbuiltins.set(BuiltinNames.atomic_cmpxchg, builtin_atomic_cmpxchg);\n\n// atomic.wait<T!>(ptr: usize, expected: T, timeout?: i64) -> i32\nfunction builtin_atomic_wait(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n  var arg2 = operands.length == 3\n    ? compiler.compileExpression(operands[2], Type.i64, Constraints.CONV_IMPLICIT)\n    : module.i64(-1, -1); // Infinite timeout\n  compiler.currentType = Type.i32;\n  switch (type.kind) {\n    case TypeKind.I32:\n    case TypeKind.I64:\n    case TypeKind.ISIZE:\n    case TypeKind.U32:\n    case TypeKind.U64:\n    case TypeKind.USIZE: return module.atomic_wait(arg0, arg1, arg2, type.toRef());\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"atomic.wait\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.atomic_wait, builtin_atomic_wait);\n\n// atomic.notify(ptr: usize, count?: i32) -> i32\nfunction builtin_atomic_notify(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = operands.length == 2\n    ? compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT)\n    : module.i32(-1); // Inifinity count of waiters\n  compiler.currentType = Type.i32;\n  return module.atomic_notify(arg0, arg1);\n}\nbuiltins.set(BuiltinNames.atomic_notify, builtin_atomic_notify);\n\n// atomic.fence() -> void\nfunction builtin_atomic_fence(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.atomic_fence();\n}\nbuiltins.set(BuiltinNames.atomic_fence, builtin_atomic_fence);\n\n// === Control flow ===========================================================================\n\n// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\nfunction builtin_select(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (!type.isAny(TypeFlags.VALUE | TypeFlags.REFERENCE)) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"select\", type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.makeIsTrueish(\n    compiler.compileExpression(operands[2], Type.bool),\n    compiler.currentType, // ^\n    operands[2]\n  );\n  compiler.currentType = type;\n  return module.select(arg0, arg1, arg2, type.toRef());\n}\nbuiltins.set(BuiltinNames.select, builtin_select);\n\n// unreachable() -> *\nfunction builtin_unreachable(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  checkArgsRequired(ctx, 0);\n  return ctx.compiler.module.unreachable();\n}\nbuiltins.set(BuiltinNames.unreachable, builtin_unreachable);\n\n// === Memory =================================================================================\n\n// memory.size() -> i32\nfunction builtin_memory_size(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.memory_size();\n}\nbuiltins.set(BuiltinNames.memory_size, builtin_memory_size);\n\n// memory.grow(pages: i32) -> i32\nfunction builtin_memory_grow(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  return module.memory_grow(compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.CONV_IMPLICIT));\n}\nbuiltins.set(BuiltinNames.memory_grow, builtin_memory_grow);\n\n// memory.copy(dest: usize, src: usize: n: usize) -> void\nfunction builtin_memory_copy(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  var usizeType = compiler.options.usizeType;\n  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], usizeType, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.void;\n  return module.memory_copy(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_copy, builtin_memory_copy);\n\n// memory.fill(dest: usize, value: u8, n: usize) -> void\nfunction builtin_memory_fill(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  var usizeType = compiler.options.usizeType;\n  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.void;\n  return module.memory_fill(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_fill, builtin_memory_fill);\n\n// memory.data(size[, align]) -> usize\n// memory.data<T>(values[, align]) -> usize\nfunction builtin_memory_data(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  var typeArguments = ctx.typeArguments;\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  var usizeType = compiler.options.usizeType;\n  var offset: i64;\n  if (typeArguments !== null && typeArguments.length > 0) { // data<T>(values[, align])\n    let elementType = typeArguments[0];\n    if (!elementType.isValue) {\n      compiler.error(\n        DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n        ctx.reportNode.typeArgumentsRange, \"memory.data\", elementType.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let valuesOperand = operands[0];\n    if (valuesOperand.kind != NodeKind.LITERAL || (<LiteralExpression>valuesOperand).literalKind != LiteralKind.ARRAY) {\n      compiler.error(\n        DiagnosticCode.Array_literal_expected,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let expressions = (<ArrayLiteralExpression>valuesOperand).elementExpressions;\n    let numElements = expressions.length;\n    let exprs = new Array<ExpressionRef>(numElements);\n    let isStatic = true;\n    for (let i = 0; i < numElements; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = compiler.compileExpression(elementExpression, elementType, Constraints.CONV_IMPLICIT);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        exprs[i] = expr;\n      } else {\n        exprs[i] = compiler.makeZero(elementType, elementExpression);\n      }\n    }\n    if (!isStatic) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        valuesOperand.range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = elementType.byteSize;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    let buf = new Uint8Array(numElements * elementType.byteSize);\n    assert(compiler.writeStaticBuffer(buf, 0, elementType, exprs) == buf.byteLength);\n    offset = compiler.addAlignedMemorySegment(buf, align).offset;\n  } else { // data(size[, align])\n    let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(arg0, ExpressionRunnerFlags.PreserveSideeffects);\n    if (!precomp) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let size = getConstValueI32(precomp);\n    if (size < 1) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[0].range, \"1\", i32.MAX_VALUE.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = 16;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    offset = compiler.addAlignedMemorySegment(new Uint8Array(size), align).offset;\n  }\n  // FIXME: what if recompiles happen? recompiles are bad.\n  compiler.currentType = usizeType;\n  if (usizeType == Type.usize32) {\n    assert(!i64_high(offset));\n    return module.i32(i64_low(offset));\n  } else {\n    return module.i64(i64_low(offset), i64_high(offset));\n  }\n}\nbuiltins.set(BuiltinNames.memory_data, builtin_memory_data);\n\n// === GC =====================================================================================\n\nfunction builtin_i31_new(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.i31ref;\n  return module.i31_new(arg0);\n}\nbuiltins.set(BuiltinNames.i31_new, builtin_i31_new);\n\nfunction builtin_i31_get(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.i31ref, Constraints.CONV_IMPLICIT);\n  if (ctx.contextualType.is(TypeFlags.UNSIGNED)) {\n    compiler.currentType = Type.u32;\n    return module.i31_get(arg0, false);\n  } else {\n    compiler.currentType = Type.i32;\n    return module.i31_get(arg0, true);\n  }\n}\nbuiltins.set(BuiltinNames.i31_get, builtin_i31_get);\n\n// === Helpers ================================================================================\n\n// changetype<T!>(value: *) -> T\nfunction builtin_changetype(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var toType = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.auto);\n  var fromType = compiler.currentType;\n  compiler.currentType = toType;\n  if (!fromType.isChangeableTo(toType)) {\n    compiler.error(\n      DiagnosticCode.Type_0_cannot_be_changed_to_type_1,\n      ctx.reportNode.range, fromType.toString(), toType.toString()\n    );\n    return module.unreachable();\n  }\n  return arg0;\n}\nbuiltins.set(BuiltinNames.changetype, builtin_changetype);\n\n// assert<T?>(isTrueish: T, message?: string) -> T{!= null}\nfunction builtin_assert(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var typeArguments = ctx.typeArguments;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    if (typeArguments) {\n      assert(typeArguments.length); // otherwise invalid, should not been set at all\n      compiler.currentType = typeArguments[0].nonNullableType;\n    }\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var contextualType = ctx.contextualType;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.bool, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  compiler.currentType = type.nonNullableType;\n\n  // omit if assertions are disabled\n  if (compiler.options.noAssert) {\n    return arg0;\n  }\n\n  // omit if the assertion can be proven statically\n  var evaled = module.runExpression(arg0, ExpressionRunnerFlags.Default);\n  if (evaled) {\n    switch (<u32>getExpressionType(evaled)) {\n      case <u32>TypeRef.I32: {\n        if (getConstValueI32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        if (getConstValueI64Low(evaled) | getConstValueI64High(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        if (getConstValueF32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        if (getConstValueF64(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n    }\n  }\n\n  // otherwise call abort if the assertion is false-ish\n  var abort = compiler.makeAbort(operands.length == 2 ? operands[1] : null, ctx.reportNode);\n  compiler.currentType = type.nonNullableType;\n  if (contextualType == Type.void) { // simplify if dropped anyway\n    compiler.currentType = Type.void;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.if(module.unary(UnaryOp.EqzI32, arg0), abort);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.if(module.unary(UnaryOp.EqzI64, arg0), abort);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.if(\n          module.unary(\n            compiler.options.isWasm64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            arg0\n          ),\n          abort\n        );\n      }\n      // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\n      case TypeKind.F32: return module.if(module.binary(BinaryOp.EqF32, arg0, module.f32(0)), abort);\n      case TypeKind.F64: return module.if(module.binary(BinaryOp.EqF64, arg0, module.f64(0)), abort);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF:\n      case TypeKind.EQREF:\n      case TypeKind.DATAREF:\n      case TypeKind.I31REF: return module.if(module.ref_is(RefIsOp.RefIsNull, arg0), abort);\n\n    }\n  } else {\n    compiler.currentType = type.nonNullableType;\n    let flow = compiler.currentFlow;\n    switch (compiler.currentType.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: {\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.WRAPPED); // arg0 is wrapped\n        let ret = module.if(\n          module.local_tee(temp.index, arg0, false), // numeric\n          module.local_get(temp.index, TypeRef.I32),\n          abort\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let temp = flow.getTempLocal(Type.i64);\n        let ret = module.if(\n          module.unary(UnaryOp.EqzI64,\n            module.local_tee(temp.index, arg0, false) // i64\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.I64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let temp = flow.getTempLocal(compiler.options.usizeType);\n        let ret = module.if(\n          module.unary(\n            compiler.options.isWasm64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            module.local_tee(temp.index, arg0, type.isManaged)\n          ),\n          abort,\n          module.local_get(temp.index, compiler.options.sizeTypeRef)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F32: {\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF32,\n            module.local_tee(temp.index, arg0, false), // f32\n            module.f32(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F32)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF64,\n            module.local_tee(temp.index, arg0, false), // f64\n            module.f64(0)\n          ),\n          abort,\n          module.local_get(temp.index, TypeRef.F64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF:\n      case TypeKind.EQREF:\n      case TypeKind.DATAREF:\n      case TypeKind.I31REF: {\n        let temp = flow.getTempLocal(type);\n        let ret = module.if(\n          module.ref_is(RefIsOp.RefIsNull,\n            module.local_tee(temp.index, arg0, false) // ref\n          ),\n          abort,\n          module.local_get(temp.index, type.toRef())\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"assert\", compiler.currentType.toString()\n  );\n  return abort;\n}\nbuiltins.set(BuiltinNames.assert, builtin_assert);\n\n// unchecked(expr: *) -> *\nfunction builtin_unchecked(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var flow = compiler.currentFlow;\n  var alreadyUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n  flow.set(FlowFlags.UNCHECKED_CONTEXT);\n  // eliminate unnecessary tees by preferring contextualType(=void)\n  var expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);\n  if (!alreadyUnchecked) flow.unset(FlowFlags.UNCHECKED_CONTEXT);\n  return expr;\n}\nbuiltins.set(BuiltinNames.unchecked, builtin_unchecked);\n\n// call_indirect<T?>(index: u32, ...args: *[]) -> T\nfunction builtin_call_indirect(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, i32.MAX_VALUE)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var returnType: Type;\n  if (typeArguments) {\n    assert(typeArguments.length);\n    returnType = typeArguments[0];\n  } else {\n    returnType = ctx.contextualType;\n  }\n  var indexArg = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length - 1;\n  var operandExprs = new Array<ExpressionRef>(numOperands);\n  var paramTypeRefs = new Array<TypeRef>(numOperands);\n  for (let i = 0; i < numOperands; ++i) {\n    operandExprs[i] = compiler.compileExpression(operands[1 + i], Type.auto);\n    paramTypeRefs[i] = compiler.currentType.toRef();\n  }\n  compiler.currentType = returnType;\n  return module.call_indirect(null /* TODO */, indexArg, operandExprs, createType(paramTypeRefs), returnType.toRef());\n}\nbuiltins.set(BuiltinNames.call_indirect, builtin_call_indirect);\n\n// instantiate<T!>(...args: *[]) -> T\nfunction builtin_instantiate(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var typeArgument = typeArguments[0];\n  var classInstance = typeArgument.getClass();\n  if (!classInstance) {\n    compiler.error(\n      DiagnosticCode.This_expression_is_not_constructable,\n      ctx.reportNode.expression.range\n    );\n    return module.unreachable();\n  }\n  compiler.currentType = classInstance.type;\n  var ctor = compiler.ensureConstructor(classInstance, ctx.reportNode);\n  compiler.checkFieldInitialization(classInstance, ctx.reportNode);\n  return compiler.compileInstantiate(ctor, operands, Constraints.NONE, ctx.reportNode);\n}\nbuiltins.set(BuiltinNames.instantiate, builtin_instantiate);\n\n// === User-defined diagnostics ===============================================================\n\nfunction builtin_diagnostic(ctx: BuiltinContext, category: DiagnosticCategory): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  checkTypeAbsent(ctx);\n  var operands = ctx.operands;\n  var reportNode = ctx.reportNode;\n  compiler.emitDiagnostic(\n    DiagnosticCode.User_defined_0,\n    category,\n    reportNode.range,\n    null,\n    operands.length\n      ? operands[0].range.toString()\n      : reportNode.range.toString()\n  );\n  return category == DiagnosticCategory.ERROR\n    ? module.unreachable()\n    : module.nop();\n}\n\n// ERROR(message?)\nfunction builtin_error(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.ERROR);\n}\nbuiltins.set(BuiltinNames.ERROR, builtin_error);\n\n// WARNING(message?)\nfunction builtin_warning(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.WARNING);\n}\nbuiltins.set(BuiltinNames.WARNING, builtin_warning);\n\n// INFO(message?)\nfunction builtin_info(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.INFO);\n}\nbuiltins.set(BuiltinNames.INFO, builtin_info);\n\n// === Function builtins ======================================================================\n\n// Function<T>#call(thisArg: thisof<T> | null, ...args: *[]) -> returnof<T>\nfunction builtin_function_call(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var parent = ctx.prototype.parent;\n  assert(parent.kind == ElementKind.CLASS);\n  var classInstance = <Class>parent;\n  assert(classInstance.prototype == compiler.program.functionPrototype);\n  var typeArguments = assert(classInstance.typeArguments);\n  assert(typeArguments.length == 1);\n  var ftype = typeArguments[0];\n  var signature = assert(ftype.getSignature());\n  var returnType = signature.returnType;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1 + signature.requiredParameters, 1 + signature.parameterTypes.length)\n  ) {\n    compiler.currentType = returnType;\n    return compiler.module.unreachable();\n  }\n  var functionArg = compiler.compileExpression(assert(ctx.thisOperand), ftype, Constraints.CONV_IMPLICIT);\n  var thisOperand = assert(ctx.operands.shift());\n  var thisType = signature.thisType;\n  var thisArg: usize = 0;\n  if (thisType) {\n    thisArg = compiler.compileExpression(thisOperand, thisType, Constraints.CONV_IMPLICIT);\n  } else if (thisOperand.kind != NodeKind.NULL) {\n    compiler.error(\n      DiagnosticCode._this_cannot_be_referenced_in_current_location,\n      thisOperand.range\n    );\n    return compiler.module.unreachable();\n  }\n  return compiler.compileCallIndirect(signature, functionArg, ctx.operands, ctx.reportNode, thisArg, ctx.contextualType == Type.void);\n}\nfunction_builtins.set(\"call\", builtin_function_call);\n\n// String.raw(parts: TemplateStringsArray, ...values: unknown[]): string\nfunction builtin_string_raw(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = ctx.compiler.program.stringInstance.type;\n  compiler.error(\n    DiagnosticCode.Not_implemented_0,\n    ctx.reportNode.range, \"String.raw\"\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.String_raw, builtin_string_raw);\n\n// === Portable type conversions ==============================================================\n\nfunction builtin_conversion(ctx: BuiltinContext, toType: Type): ExpressionRef {\n  var compiler = ctx.compiler;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = toType;\n    return compiler.module.unreachable();\n  }\n  return compiler.compileExpression(ctx.operands[0], toType, Constraints.CONV_EXPLICIT);\n}\n\n// i8(*) -> i8\nfunction builtin_i8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i8);\n}\nbuiltins.set(BuiltinNames.i8, builtin_i8);\n\n// i16(*) -> i16\nfunction builtin_i16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i16);\n}\nbuiltins.set(BuiltinNames.i16, builtin_i16);\n\n// i32(*) -> i32\nfunction builtin_i32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i32);\n}\nbuiltins.set(BuiltinNames.i32, builtin_i32);\n\n// i64(*) -> i64\nfunction builtin_i64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i64);\n}\nbuiltins.set(BuiltinNames.i64, builtin_i64);\n\n// isize(*) -> isize\nfunction builtin_isize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.isizeType);\n}\nbuiltins.set(BuiltinNames.isize, builtin_isize);\n\n// u8(*) -> u8\nfunction builtin_u8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u8);\n}\nbuiltins.set(BuiltinNames.u8, builtin_u8);\n\n// u16(*) -> u16\nfunction builtin_u16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u16);\n}\nbuiltins.set(BuiltinNames.u16, builtin_u16);\n\n// u32(*) -> u32\nfunction builtin_u32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u32);\n}\nbuiltins.set(BuiltinNames.u32, builtin_u32);\n\n// u64(*) -> u64\nfunction builtin_u64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u64);\n}\nbuiltins.set(BuiltinNames.u64, builtin_u64);\n\n// usize(*) -> usize\nfunction builtin_usize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.usizeType);\n}\nbuiltins.set(BuiltinNames.usize, builtin_usize);\n\n// bool(*) -> bool\nfunction builtin_bool(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.bool);\n}\nbuiltins.set(BuiltinNames.bool, builtin_bool);\n\n// f32(*) -> f32\nfunction builtin_f32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f32);\n}\nbuiltins.set(BuiltinNames.f32, builtin_f32);\n\n// f64(*) -> f64\nfunction builtin_f64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f64);\n}\nbuiltins.set(BuiltinNames.f64, builtin_f64);\n\n// TODO: alias for now, splat input integer perhaps?\nfunction builtin_v128(ctx: BuiltinContext): ExpressionRef {\n  return builtin_i8x16(ctx);\n}\nbuiltins.set(BuiltinNames.v128, builtin_v128);\n\n// === SIMD ===================================================================================\n\n// i8x16(...values: i8[16]) -> v128\nfunction builtin_i8x16(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 16)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 16; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i8, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI8(getConstValueI32(precomp), bytes, i);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i8x16, builtin_i8x16);\n\n// i16x8(...values: i16[8]) -> v128\nfunction builtin_i16x8(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 8)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 8; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i16, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI16(getConstValueI32(precomp), bytes, i << 1);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i16x8, builtin_i16x8);\n\n// i32x4(...values: i32[4]) -> v128\nfunction builtin_i32x4(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI32(getConstValueI32(precomp), bytes, i << 2);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i32x4, builtin_i32x4);\n\n// i64x2(...values: i64[2]) -> v128\nfunction builtin_i64x2(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      let off = i << 3;\n      writeI32(getConstValueI64Low(precomp), bytes, off);\n      writeI32(getConstValueI64High(precomp), bytes, off + 4);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i64x2, builtin_i64x2);\n\n// f32x4(...values: f32[4]) -> v128\nfunction builtin_f32x4(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF32(getConstValueF32(precomp), bytes, i << 2);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.f32x4, builtin_f32x4);\n\n// f64x2(...values: f64[2]) -> v128\nfunction builtin_f64x2(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF64(getConstValueF64(precomp), bytes, i << 3);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.f64x2, builtin_f64x2);\n\n// v128.splat<T!>(x: T) -> v128\nfunction builtin_v128_splat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], type, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.SplatI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.SplatI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.SplatI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.SplatI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.SplatI64x2\n            : UnaryOp.SplatI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.SplatF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SplatF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_splat, builtin_v128_splat);\n\n// v128.extract_lane<T!>(x: v128, idx: u8) -> T\nfunction builtin_v128_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  compiler.currentType = type;\n  var idx = 0;\n  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_extract(SIMDExtractOp.ExtractLaneI8x16, arg0, <u8>idx);\n      case TypeKind.U8: return module.simd_extract(SIMDExtractOp.ExtractLaneU8x16, arg0, <u8>idx);\n      case TypeKind.I16: return module.simd_extract(SIMDExtractOp.ExtractLaneI16x8, arg0, <u8>idx);\n      case TypeKind.U16: return module.simd_extract(SIMDExtractOp.ExtractLaneU16x8, arg0, <u8>idx);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_extract(SIMDExtractOp.ExtractLaneI32x4, arg0, <u8>idx);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_extract(SIMDExtractOp.ExtractLaneI64x2, arg0, <u8>idx);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_extract(\n          compiler.options.isWasm64\n            ? SIMDExtractOp.ExtractLaneI64x2\n            : SIMDExtractOp.ExtractLaneI32x4,\n          arg0, <u8>idx\n        );\n      }\n      case TypeKind.F32: return module.simd_extract(SIMDExtractOp.ExtractLaneF32x4, arg0, <u8>idx);\n      case TypeKind.F64: return module.simd_extract(SIMDExtractOp.ExtractLaneF64x2, arg0, <u8>idx);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extract_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extract_lane, builtin_v128_extract_lane);\n\n// v128.replace_lane<T!>(x: v128, idx: u8, value: T) -> v128\nfunction builtin_v128_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], type, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  var idx = 0;\n  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, arg0, <u8>idx, arg2);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, arg0, <u8>idx, arg2);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, arg0, <u8>idx, arg2);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, arg0, <u8>idx, arg2);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_replace(\n          compiler.options.isWasm64\n            ? SIMDReplaceOp.ReplaceLaneI64x2\n            : SIMDReplaceOp.ReplaceLaneI32x4,\n          arg0, <u8>idx, arg2\n        );\n      }\n      case TypeKind.F32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, arg0, <u8>idx, arg2);\n      case TypeKind.F64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, arg0, <u8>idx, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.replace_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_replace_lane, builtin_v128_replace_lane);\n\n// v128.shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128\nfunction builtin_v128_shuffle(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  if (type.isValue) {\n    let laneWidth = type.byteSize;\n    let laneCount = 16 / laneWidth;\n    assert(isInteger(laneCount) && isPowerOf2(laneCount));\n    if (\n      checkArgsRequired(ctx, 2 + laneCount)\n    ) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n    let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.F32:\n      case TypeKind.F64: {\n        let mask = new Uint8Array(16);\n        let maxIdx = (laneCount << 1) - 1;\n        for (let i = 0; i < laneCount; ++i) {\n          let operand = operands[2 + i];\n          let argN = compiler.compileExpression(operand, Type.u8, Constraints.CONV_IMPLICIT);\n          let precomp = module.runExpression(argN, ExpressionRunnerFlags.PreserveSideeffects);\n          let idx = 0;\n          if (precomp) {\n            idx = getConstValueI32(precomp);\n            if (idx < 0 || idx > maxIdx) {\n              compiler.error(\n                DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n                operand.range, \"Lane index\", \"0\", maxIdx.toString()\n              );\n              idx = 0;\n            }\n          } else {\n            compiler.error(\n              DiagnosticCode.Expression_must_be_a_compile_time_constant,\n              operand.range\n            );\n          }\n          switch (laneWidth) {\n            case 1: {\n              writeI8(idx, mask, i);\n              break;\n            }\n            case 2: {\n              let off8 = i << 1;\n              let idx8 = idx << 1;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              break;\n            }\n            case 4: {\n              let off8 = i << 2;\n              let idx8 = idx << 2;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              break;\n            }\n            case 8: {\n              let off8 = i << 3;\n              let idx8 = idx << 3;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              writeI8(idx8 + 4, mask, off8 + 4);\n              writeI8(idx8 + 5, mask, off8 + 5);\n              writeI8(idx8 + 6, mask, off8 + 6);\n              writeI8(idx8 + 7, mask, off8 + 7);\n              break;\n            }\n            default: assert(false);\n          }\n        }\n        compiler.currentType = Type.v128;\n        return module.simd_shuffle(arg0, arg1, mask);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shuffle\", type.toString()\n  );\n  compiler.currentType = Type.v128;\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shuffle, builtin_v128_shuffle);\n\n// v128.swizzle(a: v128, b: v128) -> v128\nfunction builtin_v128_swizzle(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.binary(BinaryOp.SwizzleI8x16, arg0, arg1);\n}\nbuiltins.set(BuiltinNames.v128_swizzle, builtin_v128_swizzle);\n\n// v128.load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_splat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: {\n        return module.simd_load(SIMDLoadOp.Load8Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        return module.simd_load(SIMDLoadOp.Load16Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: {\n        return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: {\n        return module.simd_load(SIMDLoadOp.Load64Splat, arg0, immOffset, immAlign);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_splat, builtin_v128_load_splat);\n\n// v128.load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_ext(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_load(SIMDLoadOp.Load8x8S, arg0, immOffset, immAlign);\n      case TypeKind.U8: return module.simd_load(SIMDLoadOp.Load8x8U, arg0, immOffset, immAlign);\n      case TypeKind.I16: return module.simd_load(SIMDLoadOp.Load16x4S, arg0, immOffset, immAlign);\n      case TypeKind.U16: return module.simd_load(SIMDLoadOp.Load16x4U, arg0, immOffset, immAlign);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.simd_load(SIMDLoadOp.Load32x2S, arg0, immOffset, immAlign);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.simd_load(SIMDLoadOp.Load32x2U, arg0, immOffset, immAlign);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_ext\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_ext, builtin_v128_load_ext);\n\n// v128.load_zero<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_zero(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_load(SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_load(SIMDLoadOp.Load64Zero, arg0, immOffset, immAlign);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.simd_load(compiler.options.isWasm64 ? SIMDLoadOp.Load64Zero : SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_zero, builtin_v128_load_zero);\n\n// v128.load_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.CONV_IMPLICIT);\n  var idx = 0;\n  var precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.simd_loadstorelane(compiler.options.isWasm64 ? SIMDLoadStoreLaneOp.Load64Lane : SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_lane, builtin_v128_load_lane);\n\n// v128.store_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_store_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 5)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.CONV_IMPLICIT);\n  var idx = 0;\n  var precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[2].range\n    );\n  }\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 4) {\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 5) {\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.simd_loadstorelane(compiler.options.isWasm64 ? SIMDLoadStoreLaneOp.Store64Lane : SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.store_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_store_lane, builtin_v128_store_lane);\n\n// v128.add<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.AddI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.AddI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.AddI64x2\n            : BinaryOp.AddI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add, builtin_v128_add);\n\n// v128.sub<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.SubI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.SubI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.SubI64x2\n            : BinaryOp.SubI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub, builtin_v128_sub);\n\n// v128.mul<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_mul(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.MulI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.MulI64x2 : BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.mul\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_mul, builtin_v128_mul);\n\n// v128.div<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_div(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.div\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_div, builtin_v128_div);\n\n// v128.add_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add_sat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.AddSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.AddSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.AddSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AddSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add_sat, builtin_v128_add_sat);\n\n// v128.sub_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub_sat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.SubSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.SubSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.SubSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.SubSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub_sat, builtin_v128_sub_sat);\n\n// v128.min<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_min(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MinI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MinU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MinI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MinU16x8, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MinI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MinU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_min, builtin_v128_min);\n\n// v128.max<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_max(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MaxI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MaxU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MaxI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MaxU16x8, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MaxI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MaxU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_max, builtin_v128_max);\n\n// v128.pmin<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmin(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PminF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PminF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmin\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmin, builtin_v128_pmin);\n\n// v128.pmax<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmax(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PmaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PmaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmax\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmax, builtin_v128_pmax);\n\n// v128.dot<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_dot(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.DotI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.dot\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_dot, builtin_v128_dot);\n\n// v128.avgr<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_avgr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.U8:  return module.binary(BinaryOp.AvgrU8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AvgrU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.avgr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_avgr, builtin_v128_avgr);\n\n// v128.eq<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_eq(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.EqI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.EqI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.EqI64x2 : BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.eq\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_eq, builtin_v128_eq);\n\n// v128.ne<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ne(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.NeI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.NeI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.NeI64x2 : BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ne\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ne, builtin_v128_ne);\n\n// v128.lt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_lt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64x2, arg0, arg1);\n      // no LtU64x2\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.LtI64x2 : BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.lt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_lt, builtin_v128_lt);\n\n// v128.le<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_le(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64x2, arg0, arg1);\n      // no LeU64x2\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.LeI64x2 : BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.le\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_le, builtin_v128_le);\n\n// v128.gt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_gt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64x2, arg0, arg1);\n      // no GtU64x2\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.GtI64x2 : BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.gt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_gt, builtin_v128_gt);\n\n// v128.ge<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ge(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64x2, arg0, arg1);\n      // no GeU64x2\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.GeI64x2 : BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ge\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ge, builtin_v128_ge);\n\n// v128.narrow<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_narrow(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.narrow\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_narrow, builtin_v128_narrow);\n\n// v128.neg<T!>(a: v128) -> v128\nfunction builtin_v128_neg(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.NegI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.NegI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.NegI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.NegI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.NegI64x2\n            : UnaryOp.NegI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.NegF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NegF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.neg\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_neg, builtin_v128_neg);\n\n// v128.abs<T!>(a: v128) -> v128\nfunction builtin_v128_abs(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.AbsI8x16, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.AbsI16x8, arg0);\n      case TypeKind.I32: return module.unary(UnaryOp.AbsI32x4, arg0);\n      case TypeKind.I64: return module.unary(UnaryOp.AbsI64x2, arg0);\n      case TypeKind.ISIZE: return module.unary(compiler.options.isWasm64 ? UnaryOp.AbsI64x2 : UnaryOp.AbsI32x4, arg0);\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_abs, builtin_v128_abs);\n\n// v128.sqrt<T!>(a: v128) -> v128\nfunction builtin_v128_sqrt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sqrt, builtin_v128_sqrt);\n\n// v128.ceil<T!>(a: v128) -> v128\nfunction builtin_v128_ceil(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ceil, builtin_v128_ceil);\n\n// v128.floor<T!>(a: v128) -> v128\nfunction builtin_v128_floor(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_floor, builtin_v128_floor);\n\n// v128.trunc<T!>(a: v128) -> v128\nfunction builtin_v128_trunc(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc, builtin_v128_trunc);\n\n// v128.nearest<T!>(a: v128) -> v128\nfunction builtin_v128_nearest(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_nearest, builtin_v128_nearest);\n\n// v128.convert<T!>(a: v128) -> v128\nfunction builtin_v128_convert(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertI32x4ToF32x4, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertU32x4ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_convert, builtin_v128_convert);\n\n// v128.convert_low<T!>(a: v128) -> v128\nfunction builtin_v128_convert_low(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertLowI32x4ToF64x2, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertLowU32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_convert_low, builtin_v128_convert_low);\n\n// v128.trunc_sat<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF32x4ToI32x4, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF32x4ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc_sat, builtin_v128_trunc_sat);\n\n// v128.trunc_sat_zero<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat_zero(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF64x2ToI32x4Zero, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF64x2ToU32x4Zero, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc_sat_zero, builtin_v128_trunc_sat_zero);\n\n// v128.extend_low<T!>(a: v128) -> v128\nfunction builtin_v128_extend_low(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendLowI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendLowU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendLowI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendLowU16x8ToU32x4, arg0);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendLowI32x4ToI64x2, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendLowU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extend_low, builtin_v128_extend_low);\n\n// v128.extend_high<T!>(a: v128) -> v128\nfunction builtin_v128_extend_high(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendHighI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendHighU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendHighI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendHighU16x8ToU32x4, arg0);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendHighI32x4ToI64x2, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendHighU32x4ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extend_high, builtin_v128_extend_high);\n\n// v128.shl<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shl(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShlI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShlI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShlI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShlI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShlI64x2\n            : SIMDShiftOp.ShlI32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shl, builtin_v128_shl);\n\n// v128.shr<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_shift(SIMDShiftOp.ShrI8x16, arg0, arg1);\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShrU8x16, arg0, arg1);\n      case TypeKind.I16: return module.simd_shift(SIMDShiftOp.ShrI16x8, arg0, arg1);\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShrU16x8, arg0, arg1);\n      case TypeKind.I32: return module.simd_shift(SIMDShiftOp.ShrI32x4, arg0, arg1);\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShrU32x4, arg0, arg1);\n      case TypeKind.I64: return module.simd_shift(SIMDShiftOp.ShrI64x2, arg0, arg1);\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShrU64x2, arg0, arg1);\n      case TypeKind.ISIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrI64x2\n            : SIMDShiftOp.ShrI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.USIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrU64x2\n            : SIMDShiftOp.ShrU32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shr, builtin_v128_shr);\n\nfunction builtin_v128_bitwise_binary(ctx: BuiltinContext, op: BinaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.binary(op, arg0, arg1);\n}\n\n// v128.and(a: v128, b: v128) -> v128\nfunction builtin_v128_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndV128);\n}\nbuiltins.set(BuiltinNames.v128_and, builtin_v128_and);\n\n// v128.or(a: v128, b: v128) -> v128\nfunction builtin_v128_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.OrV128);\n}\nbuiltins.set(BuiltinNames.v128_or, builtin_v128_or);\n\n// v128.xor(a: v128, b: v128) -> v128\nfunction builtin_v128_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.XorV128);\n}\nbuiltins.set(BuiltinNames.v128_xor, builtin_v128_xor);\n\n// v128.andnot(a: v128, b: v128) -> v128\nfunction builtin_v128_andnot(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndnotV128);\n}\nbuiltins.set(BuiltinNames.v128_andnot, builtin_v128_andnot);\n\nfunction builtin_v128_bitwise_unary(ctx: BuiltinContext, op: UnaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.unary(op, arg0);\n}\n\n// v128.not(a: v128) -> v128\nfunction builtin_v128_not(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_unary(ctx, UnaryOp.NotV128);\n}\nbuiltins.set(BuiltinNames.v128_not, builtin_v128_not);\n\nfunction builtin_v128_bitwise_ternary(ctx: BuiltinContext, op: SIMDTernaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.simd_ternary(op, arg0, arg1, arg2);\n}\n\n// v128.bitselect(v1: v128, v2: v128, c: v128) -> v128\nfunction builtin_v128_bitselect(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_ternary(ctx, SIMDTernaryOp.Bitselect);\n}\nbuiltins.set(BuiltinNames.v128_bitselect, builtin_v128_bitselect);\n\n// v128.any_true(a: v128) -> bool\nfunction builtin_v128_any_true(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.bool;\n  return module.unary(UnaryOp.AnyTrueV128, arg0);\n}\nbuiltins.set(BuiltinNames.v128_any_true, builtin_v128_any_true);\n\n// v128.all_true<T!>(a: v128) -> bool\nfunction builtin_v128_all_true(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.AllTrueI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.AllTrueI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.AllTrueI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.AllTrueI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(compiler.options.isWasm64 ? UnaryOp.AllTrueI64x2 : UnaryOp.AllTrueI32x4, arg0);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.all_true\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_all_true, builtin_v128_all_true);\n\n// v128.bitmask<T!>(a: v128) -> i32\nfunction builtin_v128_bitmask(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.i32;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.BitmaskI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.BitmaskI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.BitmaskI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.BitmaskI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: return module.unary(compiler.options.isWasm64 ? UnaryOp.BitmaskI64x2 : UnaryOp.BitmaskI32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.bitmask\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_bitmask, builtin_v128_bitmask);\n\n// v128.popcnt<T!>(a: v128) -> v128\nfunction builtin_v128_popcnt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.PopcntI8x16, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_popcnt, builtin_v128_popcnt);\n\n// v128.extadd_pairwise<T!>(a: v128) -> v128\nfunction builtin_v128_extadd_pairwise(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.ExtaddPairwiseI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.ExtaddPairwiseU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.ExtaddPairwiseI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.ExtaddPairwiseU16x8ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extadd_pairwise\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extadd_pairwise, builtin_v128_extadd_pairwise);\n\n// v128.demote_zero<T?>(a: v128) -> v128\nfunction builtin_v128_demote_zero(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments ? typeArguments[0] : Type.f64;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F64: return module.unary(UnaryOp.DemoteZeroF64x2ToF32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.demote_zero\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_demote_zero, builtin_v128_demote_zero);\n\n// v128.promote_low<T?>(a: v128) -> v128\nfunction builtin_v128_promote_low(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments ? typeArguments[0] : Type.f32;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.PromoteLowF32x4ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.promote_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_promote_low, builtin_v128_promote_low);\n\n// v128.q15mulr_sat<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_q15mulr_sat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.Q15mulrSatI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.q15mulr_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_q15mulr_sat, builtin_v128_q15mulr_sat);\n\n// v128.extmul_low<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_low(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulLowI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulLowU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulLowI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulLowU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulLowI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulLowU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extmul_low, builtin_v128_extmul_low);\n\n// v128.extmul_high<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_extmul_high(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulHighI16x8, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulHighU16x8, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulHighI32x4, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulHighU32x4, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulHighI64x2, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulHighU64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extmul_high, builtin_v128_extmul_high);\n\n// === Internal runtime =======================================================================\n\n// __visit_globals(cookie: u32) -> void\nfunction builtin_visit_globals(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1) // cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitGlobals;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_globals, [ arg0 ], TypeRef.None);\n}\nbuiltins.set(BuiltinNames.visit_globals, builtin_visit_globals);\n\n// __visit_members(ref: usize, cookie: u32) -> void\nfunction builtin_visit_members(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2) // ref, cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u32, Constraints.CONV_IMPLICIT);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitMembers;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_members, [ arg0, arg1 ], TypeRef.None);\n}\nbuiltins.set(BuiltinNames.visit_members, builtin_visit_members);\n\n// === Inline assembler =======================================================================\n\n// TODO: Operators can't be just deferred (don't have a corresponding generic built-in)\n//   add, sub, mul, div_s, div_u, rem_s, rem_u\n//   and, or, xor, shl, shr_u, shr_s\n//   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u\n\n// i32.clz -> clz<i32>\nfunction builtin_i32_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_clz, builtin_i32_clz);\n\n// i64.clz -> clz<i64>\nfunction builtin_i64_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_clz, builtin_i64_clz);\n\n// i32.ctz -> ctz<i32>\nfunction builtin_i32_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_ctz, builtin_i32_ctz);\n\n// i64.ctz -> ctz<i64>\nfunction builtin_i64_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_ctz, builtin_i64_ctz);\n\n// i32.popcnt -> popcnt<i32>\nfunction builtin_i32_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i32_popcnt, builtin_i32_popcnt);\n\n// i64.popcnt -> popcnt<i64>\nfunction builtin_i64_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i64_popcnt, builtin_i64_popcnt);\n\n// i32.rotl -> rotl<i32>\nfunction builtin_i32_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotl, builtin_i32_rotl);\n\n// i64.rotl -> rotl<i64>\nfunction builtin_i64_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotl, builtin_i64_rotl);\n\n// i32.rotr -> rotr<i32>\nfunction builtin_i32_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotr, builtin_i32_rotr);\n\n// i64.rotr -> rotr<i64>\nfunction builtin_i64_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotr, builtin_i64_rotr);\n\n// f32.abs -> abs<f32>\nfunction builtin_f32_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32_abs, builtin_f32_abs);\n\n// f64.abs -> abs<f64>\nfunction builtin_f64_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64_abs, builtin_f64_abs);\n\n// f32.max -> max<f32>\nfunction builtin_f32_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32_max, builtin_f32_max);\n\n// f64.max -> max<f64>\nfunction builtin_f64_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64_max, builtin_f64_max);\n\n// f32.min -> min<f32>\nfunction builtin_f32_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32_min, builtin_f32_min);\n\n// f64.min -> min<f64>\nfunction builtin_f64_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64_min, builtin_f64_min);\n\n// f32.ceil -> ceil<f32>\nfunction builtin_f32_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32_ceil, builtin_f32_ceil);\n\n// f64.ceil -> ceil<f64>\nfunction builtin_f64_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64_ceil, builtin_f64_ceil);\n\n// f32.floor -> floor<f32>\nfunction builtin_f32_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32_floor, builtin_f32_floor);\n\n// f64.floor -> floor<f64>\nfunction builtin_f64_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64_floor, builtin_f64_floor);\n\n// f32.copysign -> copysign<f32>\nfunction builtin_f32_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f32_copysign, builtin_f32_copysign);\n\n// f64.copysign -> copysign<f64>\nfunction builtin_f64_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f64_copysign, builtin_f64_copysign);\n\n// f32.nearest -> nearest<f32>\nfunction builtin_f32_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32_nearest, builtin_f32_nearest);\n\n// f64.nearest -> nearest<f64>\nfunction builtin_f64_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64_nearest, builtin_f64_nearest);\n\n// i32.reinterpret_f32 -> reinterpret<i32>\nfunction builtin_i32_reinterpret_f32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i32_reinterpret_f32, builtin_i32_reinterpret_f32);\n\n// i64.reinterpret_f64 -> reinterpret<i64>\nfunction builtin_i64_reinterpret_f64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i64_reinterpret_f64, builtin_i64_reinterpret_f64);\n\n// f32.reinterpret_i32 -> reinterpret<f32>\nfunction builtin_f32_reinterpret_i32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f32_reinterpret_i32, builtin_f32_reinterpret_i32);\n\n// f64.reinterpret_i64 -> reinterpret<f64>\nfunction builtin_f64_reinterpret_i64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f64_reinterpret_i64, builtin_f64_reinterpret_i64);\n\n// f32.sqrt -> sqrt<f32>\nfunction builtin_f32_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sqrt, builtin_f32_sqrt);\n\n// f64.sqrt -> sqrt<f64>\nfunction builtin_f64_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sqrt, builtin_f64_sqrt);\n\n// f32.trunc -> trunc<f32>\nfunction builtin_f32_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32_trunc, builtin_f32_trunc);\n\n// f64.trunc -> trunc<f64>\nfunction builtin_f64_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64_trunc, builtin_f64_trunc);\n\n// i32.add -> add<i32>\nfunction builtin_i32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_add, builtin_i32_add);\n\n// i64.add -> add<i64>\nfunction builtin_i64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_add, builtin_i64_add);\n\n// f32.add -> add<f32>\nfunction builtin_f32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32_add, builtin_f32_add);\n\n// f64.add -> add<f64>\nfunction builtin_f64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64_add, builtin_f64_add);\n\n// i32.sub -> sub<i32>\nfunction builtin_i32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_sub, builtin_i32_sub);\n\n// i64.sub -> sub<i64>\nfunction builtin_i64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_sub, builtin_i64_sub);\n\n// f32.sub -> sub<f32>\nfunction builtin_f32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sub, builtin_f32_sub);\n\n// f64.sub -> sub<f64>\nfunction builtin_f64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sub, builtin_f64_sub);\n\n// i32.mul -> mul<i32>\nfunction builtin_i32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32_mul, builtin_i32_mul);\n\n// i64.mul -> mul<i64>\nfunction builtin_i64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i64_mul, builtin_i64_mul);\n\n// f32.mul -> mul<f32>\nfunction builtin_f32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32_mul, builtin_f32_mul);\n\n// f64.mul -> mul<f64>\nfunction builtin_f64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64_mul, builtin_f64_mul);\n\n// i32.div_s -> div<i32>\nfunction builtin_i32_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_s, builtin_i32_div_s);\n\n// i32.div_u -> div<u32>\nfunction builtin_i32_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_u, builtin_i32_div_u);\n\n// i64.div_s -> div_s<i64>\nfunction builtin_i64_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_s, builtin_i64_div_s);\n\n// i64.div_u -> div_u<u64>\nfunction builtin_i64_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_u, builtin_i64_div_u);\n\n// f32.div -> div<f32>\nfunction builtin_f32_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32_div, builtin_f32_div);\n\n// f64.div -> div<f64>\nfunction builtin_f64_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64_div, builtin_f64_div);\n\n// i32.load8_s -> <i32>load<i8>\nfunction builtin_i32_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_s, builtin_i32_load8_s);\n\n// i32.load8_u -> <i32>load<u8>\nfunction builtin_i32_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_u, builtin_i32_load8_u);\n\n// i32.load16_s -> <i32>load<i16>\nfunction builtin_i32_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_s, builtin_i32_load16_s);\n\n// i32.load16_u -> <i32>load<u16>\nfunction builtin_i32_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_u, builtin_i32_load16_u);\n\n// i32.load -> <i32>load<i32>\nfunction builtin_i32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load, builtin_i32_load);\n\n// i64.load8_s -> <i64>load<i8>\nfunction builtin_i64_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_s, builtin_i64_load8_s);\n\n// i64.load8_u -> <i64>load<u8>\nfunction builtin_i64_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_u, builtin_i64_load8_u);\n\n// i64.load16_s -> <i64>load<i16>\nfunction builtin_i64_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_s, builtin_i64_load16_s);\n\n// i64.load16_u -> <i64>load<u16>\nfunction builtin_i64_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_u, builtin_i64_load16_u);\n\n// i64.load32_s -> <i64>load<i32>\nfunction builtin_i64_load32_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_s, builtin_i64_load32_s);\n\n// i64.load32_u -> <i64>load<u32>\nfunction builtin_i64_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_u, builtin_i64_load32_u);\n\n// i64.load -> <i64>load<i64>\nfunction builtin_i64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load, builtin_i64_load);\n\n// f32.load -> <f32>load<f32>\nfunction builtin_f32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f32_load, builtin_f32_load);\n\n// f64.load -> <f64>load<f64>\nfunction builtin_f64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f64_load, builtin_f64_load);\n\n// i32.store8 -> store<i8 from i32>\nfunction builtin_i32_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store8, builtin_i32_store8);\n\n// i32.store16 -> store<i16 from i32>\nfunction builtin_i32_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store16, builtin_i32_store16);\n\n// i32.store -> store<i32 from i32>\nfunction builtin_i32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store, builtin_i32_store);\n\n// i64.store8 -> store<i8 from i64>\nfunction builtin_i64_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store8, builtin_i64_store8);\n\n// i64.store16 -> store<i16 from i64>\nfunction builtin_i64_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store16, builtin_i64_store16);\n\n// i64.store32 -> store<i32 from i64>\nfunction builtin_i64_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store32, builtin_i64_store32);\n\n// i64.store -> store<i64 from i64>\nfunction builtin_i64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store, builtin_i64_store);\n\n// f32.store -> store<f32 from f64>\nfunction builtin_f32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f32_store, builtin_f32_store);\n\n// f64.store -> store<f64 from f64>\nfunction builtin_f64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f64_store, builtin_f64_store);\n\n// i32.atomic.load8_u -> <i32>atomic.load<u8>\nfunction builtin_i32_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load8_u, builtin_i32_atomic_load8_u);\n\n// i32.atomic.load16_u -> <i32>atomic.load<u16>\nfunction builtin_i32_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load16_u, builtin_i32_atomic_load16_u);\n\n// i32.atomic.load -> <i32>atomic.load<i32>\nfunction builtin_i32_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load, builtin_i32_atomic_load);\n\n// i64.atomic.load8_u -> <i64>atomic.load<u8>\nfunction builtin_i64_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load8_u, builtin_i64_atomic_load8_u);\n\n// i64.atomic.load16_u -> <i64>atomic.load<u16>\nfunction builtin_i64_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load16_u, builtin_i64_atomic_load16_u);\n\n// i64.atomic.load32_u -> <i64>atomic.load<u32>\nfunction builtin_i64_atomic_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load32_u, builtin_i64_atomic_load32_u);\n\n// i64.atomic.load -> <i64>atomic.load<i64>\nfunction builtin_i64_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load, builtin_i64_atomic_load);\n\n// i32.atomic.store8 -> atomic.store<i8 from i32>\nfunction builtin_i32_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store8, builtin_i32_atomic_store8);\n\n// i32.atomic.store16 -> atomic.store<i16 from i32>\nfunction builtin_i32_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store16, builtin_i32_atomic_store16);\n\n// i32.atomic.store -> atomic.store<i32 from i32>\nfunction builtin_i32_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store, builtin_i32_atomic_store);\n\n// i64.atomic.store8 -> atomic.store<i8 from i64>\nfunction builtin_i64_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store8, builtin_i64_atomic_store8);\n\n// i64.atomic.store16 -> atomic.store<i16 from i64>\nfunction builtin_i64_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store16, builtin_i64_atomic_store16);\n\n// i64.atomic.store32 -> atomic.store<i32 from i64>\nfunction builtin_i64_atomic_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store32, builtin_i64_atomic_store32);\n\n// i64.atomic.store -> atomic.store<i64 from i64>\nfunction builtin_i64_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store, builtin_i64_atomic_store);\n\n// i32.atomic.rmw8.add_u -> <i32>atomic.add<u8 from i32>\nfunction builtin_i32_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_add_u, builtin_i32_atomic_rmw8_add_u);\n\n// i32.atomic.rmw16.add_u -> <i32>atomic.add<u16 from i32>\nfunction builtin_i32_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_add_u, builtin_i32_atomic_rmw16_add_u);\n\n// i32.atomic.rmw.add -> <i32>atomic.add<i32 from i32>\nfunction builtin_i32_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_add, builtin_i32_atomic_rmw_add);\n\n// i64.atomic.rmw8.add_u -> <i64>atomic.add<u8 from i64>\nfunction builtin_i64_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_add_u, builtin_i64_atomic_rmw8_add_u);\n\n// i64.atomic.rmw16.add_u -> <i64>atomic.add<u16 from i64>\nfunction builtin_i64_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_add_u, builtin_i64_atomic_rmw16_add_u);\n\n// i64.atomic.rmw32.add_u -> <i64>atomic.add<u32 from i64>\nfunction builtin_i64_atomic_rmw32_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_add_u, builtin_i64_atomic_rmw32_add_u);\n\n// i64.atomic.rmw.add -> <i64>atomic.add<i64 from i64>\nfunction builtin_i64_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_add, builtin_i64_atomic_rmw_add);\n\n// i32.atomic.rmw8.sub_u -> <i32>atomic.sub<u8 from i32>\nfunction builtin_i32_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_sub_u, builtin_i32_atomic_rmw8_sub_u);\n\n// i32.atomic.rmw16.sub_u -> <i32>atomic.sub<u16 from i32>\nfunction builtin_i32_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_sub_u, builtin_i32_atomic_rmw16_sub_u);\n\n// i32.atomic.rmw.sub -> <i32>atomic.sub<i32 from i32>\nfunction builtin_i32_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_sub, builtin_i32_atomic_rmw_sub);\n\n// i64.atomic.rmw8.sub_u -> <i64>atomic.sub<u8 from i64>\nfunction builtin_i64_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_sub_u, builtin_i64_atomic_rmw8_sub_u);\n\n// i64.atomic.rmw16.sub_u -> <i64>atomic.sub<u16 from i64>\nfunction builtin_i64_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_sub_u, builtin_i64_atomic_rmw16_sub_u);\n\n// i64.atomic.rmw32.sub_u -> <i64>atomic.sub<u32 from i64>\nfunction builtin_i64_atomic_rmw32_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_sub_u, builtin_i64_atomic_rmw32_sub_u);\n\n// i64.atomic.rmw.sub -> <i64>atomic.sub<i64 from i64>\nfunction builtin_i64_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_sub, builtin_i64_atomic_rmw_sub);\n\n// i32.atomic.rmw8.and_u -> <i32>atomic.and<u8 from i32>\nfunction builtin_i32_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_and_u, builtin_i32_atomic_rmw8_and_u);\n\n// i32.atomic.rmw16.and_u -> <i32>atomic.and<u16 from i32>\nfunction builtin_i32_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_and_u, builtin_i32_atomic_rmw16_and_u);\n\n// i32.atomic.rmw.and -> <i32>atomic.and<i32 from i32>\nfunction builtin_i32_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_and, builtin_i32_atomic_rmw_and);\n\n// i64.atomic.rmw8.and_u -> <i64>atomic.and<u8 from i64>\nfunction builtin_i64_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_and_u, builtin_i64_atomic_rmw8_and_u);\n\n// i64.atomic.rmw16.and_u -> <i64>atomic.and<u16 from i64>\nfunction builtin_i64_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_and_u, builtin_i64_atomic_rmw16_and_u);\n\n// i64.atomic.rmw32.and_u -> <i64>atomic.and<u32 from i64>\nfunction builtin_i64_atomic_rmw32_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_and_u, builtin_i64_atomic_rmw32_and_u);\n\n// i64.atomic.rmw.and -> <i64>atomic.and<i64 from i64>\nfunction builtin_i64_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_and, builtin_i64_atomic_rmw_and);\n\n// i32.atomic.rmw8.or_u -> <i32>atomic.or<u8 from i32>\nfunction builtin_i32_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_or_u, builtin_i32_atomic_rmw8_or_u);\n\n// i32.atomic.rmw16.or_u -> <i32atomic.or<u16 from i32>\nfunction builtin_i32_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_or_u, builtin_i32_atomic_rmw16_or_u);\n\n// i32.atomic.rmw.or -> <i32>atomic.or<i32 from i32>\nfunction builtin_i32_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_or, builtin_i32_atomic_rmw_or);\n\n// i64.atomic.rmw8.or_u -> <i64>atomic.or<u8 from i64>\nfunction builtin_i64_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_or_u, builtin_i64_atomic_rmw8_or_u);\n\n// i64.atomic.rmw16.or_u -> <i64>atomic.or<u16 from i64>\nfunction builtin_i64_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_or_u, builtin_i64_atomic_rmw16_or_u);\n\n// i64.atomic.rmw32.or_u -> <i64>atomic.or<u32 from i64>\nfunction builtin_i64_atomic_rmw32_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_or_u, builtin_i64_atomic_rmw32_or_u);\n\n// i64.atomic.rmw.or -> <i64>atomic.or<i64 from i64>\nfunction builtin_i64_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_or, builtin_i64_atomic_rmw_or);\n\n// i32.atomic.rmw8.xor_u -> <i32>atomic.xor<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xor_u, builtin_i32_atomic_rmw8_xor_u);\n\n// i32.atomic.rmw16.xor_u -> <i32>atomic.xor<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xor_u, builtin_i32_atomic_rmw16_xor_u);\n\n// i32.atomic.rmw.xor -> <i32>atomic.xor<i32 from i32>\nfunction builtin_i32_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xor, builtin_i32_atomic_rmw_xor);\n\n// i64.atomic.rmw8.xor_u -> <i64>atomic.xor<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xor_u, builtin_i64_atomic_rmw8_xor_u);\n\n// i64.atomic.rmw16.xor_u -> <i64>atomic.xor<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xor_u, builtin_i64_atomic_rmw16_xor_u);\n\n// i64.atomic.rmw32.xor_u -> <i64>atomic.xor<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xor_u, builtin_i64_atomic_rmw32_xor_u);\n\n// i64.atomic.rmw.xor -> <i64>atomic.xor<i64 from i64>\nfunction builtin_i64_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xor, builtin_i64_atomic_rmw_xor);\n\n// i32.atomic.rmw8.xchg_u -> <i32>atomic.xchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xchg_u, builtin_i32_atomic_rmw8_xchg_u);\n\n// i32.atomic.rmw16.xchg_u -> <i32>atomic.xchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xchg_u, builtin_i32_atomic_rmw16_xchg_u);\n\n// i32.atomic.rmw.xchg -> <i32>atomic.xchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xchg, builtin_i32_atomic_rmw_xchg);\n\n// i64.atomic.rmw8.xchg_u -> <i64>atomic.xchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xchg_u, builtin_i64_atomic_rmw8_xchg_u);\n\n// i64.atomic.rmw16.xchg_u -> <i64>atomic.xchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xchg_u, builtin_i64_atomic_rmw16_xchg_u);\n\n// i64.atomic.rmw32.xchg_u -> <i64>atomic.xchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xchg_u, builtin_i64_atomic_rmw32_xchg_u);\n\n// i64.atomic.rmw.xchg -> <i64>atomic.xchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xchg, builtin_i64_atomic_rmw_xchg);\n\n// i32.atomic.rmw8.cmpxchg_u -> <i32>atomic.cmpxchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_cmpxchg_u, builtin_i32_atomic_rmw8_cmpxchg_u);\n\n// i32.atomic.rmw16.cmpxchg_u -> <i32>atomic.cmpxchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_cmpxchg_u, builtin_i32_atomic_rmw16_cmpxchg_u);\n\n// i32.atomic.rmw.cmpxchg -> <i32>atomic.cmpxchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_cmpxchg, builtin_i32_atomic_rmw_cmpxchg);\n\n// i64.atomic.rmw8.cmpxchg_u -> <i64>atomic.cmpxchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_cmpxchg_u, builtin_i64_atomic_rmw8_cmpxchg_u);\n\n// i64.atomic.rmw16.cmpxchg_u -> <i64>atomic.cmpxchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_cmpxchg_u, builtin_i64_atomic_rmw16_cmpxchg_u);\n\n// i64.atomic.rmw32.cmpxchg_u -> <i64>atomic.cmpxchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_cmpxchg_u, builtin_i64_atomic_rmw32_cmpxchg_u);\n\n// i64.atomic.rmw.cmpxchg -> <i64>atomic.cmpxchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_cmpxchg, builtin_i64_atomic_rmw_cmpxchg);\n\n// i32.wait -> atomic.wait<i32>\nfunction builtin_i32_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i32_wait, builtin_i32_wait);\n\n// i64.wait -> atomic.wait<i64>\nfunction builtin_i64_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i64_wait, builtin_i64_wait);\n\n// v128.load -> load<v128>\nfunction builtin_v128_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load, builtin_v128_load);\n\n// v128.load8x8_s -> v128.load_ext<i8>\nfunction builtin_v128_load8x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8x8_s, builtin_v128_load8x8_s);\n\n// v128.load8x8_u -> v128.load_ext<u8>\nfunction builtin_v128_load8x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8x8_u, builtin_v128_load8x8_u);\n\n// v128.load16x4_s -> v128.load_ext<i16>\nfunction builtin_v128_load16x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16x4_s, builtin_v128_load16x4_s);\n\n// v128.load16x4_u -> v128.load_ext<u16>\nfunction builtin_v128_load16x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16x4_u, builtin_v128_load16x4_u);\n\n// v128.load32x2_s -> v128.load_ext<i32>\nfunction builtin_v128_load32x2_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32x2_s, builtin_v128_load32x2_s);\n\n// v128.load32x2_u -> v128.load_ext<u32>\nfunction builtin_v128_load32x2_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32x2_u, builtin_v128_load32x2_u);\n\n// v128.load8_splat -> v128.load_splat<u8>\nfunction builtin_v128_load8_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8_splat, builtin_v128_load8_splat);\n\n// v128.load16_splat -> v128.load_splat<u16>\nfunction builtin_v128_load16_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16_splat, builtin_v128_load16_splat);\n\n// v128.load32_splat -> v128.load_splat<u32>\nfunction builtin_v128_load32_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_splat, builtin_v128_load32_splat);\n\n// v128.load64_splat -> v128.load_splat<u64>\nfunction builtin_v128_load64_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_splat, builtin_v128_load64_splat);\n\n// v128.load32_zero -> v128.load_zero<u32>\nfunction builtin_v128_load32_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_zero, builtin_v128_load32_zero);\n\n// v128.load64_zero -> v128.load_zero<u64>\nfunction builtin_v128_load64_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_zero(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_zero, builtin_v128_load64_zero);\n\n// v128.load8_lane -> v128.load_lane<u8>\nfunction builtin_v128_load8_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load8_lane, builtin_v128_load8_lane);\n\n// v128.load16_lane -> v128.load_lane<u16>\nfunction builtin_v128_load16_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load16_lane, builtin_v128_load16_lane);\n\n// v128.load32_lane -> v128.load_lane<u32>\nfunction builtin_v128_load32_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load32_lane, builtin_v128_load32_lane);\n\n// v128.load64_lane -> v128.load_lane<u64>\nfunction builtin_v128_load64_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load64_lane, builtin_v128_load64_lane);\n\n// v128.store8_lane -> v128.store_lane<u8>\nfunction builtin_v128_store8_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store8_lane, builtin_v128_store8_lane);\n\n// v128.store16_lane -> v128.store_lane<u16>\nfunction builtin_v128_store16_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store16_lane, builtin_v128_store16_lane);\n\n// v128.store32_lane -> v128.store_lane<u32>\nfunction builtin_v128_store32_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store32_lane, builtin_v128_store32_lane);\n\n// v128.store64_lane -> v128.store_lane<u64>\nfunction builtin_v128_store64_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_store_lane(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store64_lane, builtin_v128_store64_lane);\n\n// v128.store -> store<v128 from v128>\nfunction builtin_v128_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store, builtin_v128_store);\n\n// i8x16_splat -> v128.splat<i8>\nfunction builtin_i8x16_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_splat, builtin_i8x16_splat);\n\n// i8x16.extract_lane_s -> <i32>v128.extract_lane<i8>\nfunction builtin_i8x16_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_s, builtin_i8x16_extract_lane_s);\n\n// i8x16.extract_lane_u -> <i32>v128.extract_lane<u8>\nfunction builtin_i8x16_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_u, builtin_i8x16_extract_lane_u);\n\n// i8x16.replace_lane -> v128.replace_lane<i8>\nfunction builtin_i8x16_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_replace_lane, builtin_i8x16_replace_lane);\n\n// i8x16.add -> v128.add<i8>\nfunction builtin_i8x16_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add, builtin_i8x16_add);\n\n// i8x16.sub -> v128.sub<i8>\nfunction builtin_i8x16_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub, builtin_i8x16_sub);\n\n// i8x16.min_s -> v128.min<i8>\nfunction builtin_i8x16_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_s, builtin_i8x16_min_s);\n\n// i8x16.min_u -> v128.min<u8>\nfunction builtin_i8x16_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_u, builtin_i8x16_min_u);\n\n// i8x16.max_s -> v128.max<i8>\nfunction builtin_i8x16_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_s, builtin_i8x16_max_s);\n\n// i8x16.max_u -> v128.max<u8>\nfunction builtin_i8x16_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_u, builtin_i8x16_max_u);\n\n// i8x16.avgr_u -> v128.avgr<u8>\nfunction builtin_i8x16_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_avgr_u, builtin_i8x16_avgr_u);\n\n// i8x16.abs -> v128.abs<i8>\nfunction builtin_i8x16_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_abs, builtin_i8x16_abs);\n\n// i8x16.neg -> v128.neg<i8>\nfunction builtin_i8x16_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_neg, builtin_i8x16_neg);\n\n// i8x16.add_sat_s -> v128.add_sat<i8>\nfunction builtin_i8x16_add_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_sat_s, builtin_i8x16_add_sat_s);\n\n// i8x16.add_sat_u -> v128.add_sat<u8>\nfunction builtin_i8x16_add_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_sat_u, builtin_i8x16_add_sat_u);\n\n// i8x16.sub_sat_s -> v128.sub_sat<i8>\nfunction builtin_i8x16_sub_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_sat_s, builtin_i8x16_sub_sat_s);\n\n// i8x16.sub_sat_u -> v128.sub_sat<u8>\nfunction builtin_i8x16_sub_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_sat_u, builtin_i8x16_sub_sat_u);\n\n// i8x16.shl -> v128.shl<i8>\nfunction builtin_i8x16_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shl, builtin_i8x16_shl);\n\n// i8x16.shr_s -> v128.shr<i8>\nfunction builtin_i8x16_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_s, builtin_i8x16_shr_s);\n\n// i8x16.shr_u -> v128.shr<u8>\nfunction builtin_i8x16_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_u, builtin_i8x16_shr_u);\n\n// i8x16.all_true -> v128.all_true<i8>\nfunction builtin_i8x16_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_all_true, builtin_i8x16_all_true);\n\n// i8x16.bitmask -> v128.bitmask<i8>\nfunction builtin_i8x16_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_bitmask, builtin_i8x16_bitmask);\n\n// i8x16.popcnt -> v128.popcnt<i8>\nfunction builtin_i8x16_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_popcnt, builtin_i8x16_popcnt);\n\n// i8x16.eq -> v128.eq<i8>\nfunction builtin_i8x16_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_eq, builtin_i8x16_eq);\n\n// i8x16.ne -> v128.ne<i8>\nfunction builtin_i8x16_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ne, builtin_i8x16_ne);\n\n// i8x16.lt_s -> v128.lt<i8>\nfunction builtin_i8x16_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_s, builtin_i8x16_lt_s);\n\n// i8x16.lt_u -> v128.lt<u8>\nfunction builtin_i8x16_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_u, builtin_i8x16_lt_u);\n\n// i8x16.le_s -> v128.le<i8>\nfunction builtin_i8x16_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_s, builtin_i8x16_le_s);\n\n// i8x16.le_u -> v128.le<u8>\nfunction builtin_i8x16_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_u, builtin_i8x16_le_u);\n\n// i8x16.gt_s -> v128.gt<i8>\nfunction builtin_i8x16_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_s, builtin_i8x16_gt_s);\n\n// i8x16.gt_u -> v128.gt<u8>\nfunction builtin_i8x16_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_u, builtin_i8x16_gt_u);\n\n// i8x16.ge_s -> v128.ge<i8>\nfunction builtin_i8x16_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_s, builtin_i8x16_ge_s);\n\n// i8x16.ge_u -> v128.ge<u8>\nfunction builtin_i8x16_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_u, builtin_i8x16_ge_u);\n\n// i8x16.narrow_i16x8_s -> v128.narrow<i16>\nfunction builtin_i8x16_narrow_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_s, builtin_i8x16_narrow_i16x8_s);\n\n// i8x16.narrow_i16x8_u -> v128.narrow<u16>\nfunction builtin_i8x16_narrow_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_u, builtin_i8x16_narrow_i16x8_u);\n\n// i8x16.shuffle -> v128.shuffle<i8>\nfunction builtin_i8x16_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shuffle, builtin_i8x16_shuffle);\n\n// i8x16.swizzle -> v128.swizzle\nfunction builtin_i8x16_swizzle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_swizzle, builtin_i8x16_swizzle);\n\n// i16x8.splat -> v128.splat<i16>\nfunction builtin_i16x8_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_splat, builtin_i16x8_splat);\n\n// i16x8.extract_lane_s -> v128.extract_lane<i16>\nfunction builtin_i16x8_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_s, builtin_i16x8_extract_lane_s);\n\n// i16x8..extract_lane_u -> v128.extract_lane<u16>\nfunction builtin_i16x8_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_u, builtin_i16x8_extract_lane_u);\n\n// i16x8.replace_lane -> v128.replace_lane<i16>\nfunction builtin_i16x8_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_replace_lane, builtin_i16x8_replace_lane);\n\n// i16x8.add -> v128.add<i16>\nfunction builtin_i16x8_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add, builtin_i16x8_add);\n\n// i16x8.sub -> v128.sub<i16>\nfunction builtin_i16x8_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub, builtin_i16x8_sub);\n\n// i16x8.mul -> v128.mul<i16>\nfunction builtin_i16x8_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_mul, builtin_i16x8_mul);\n\n// i16x8.min_s -> v128.min<i16>\nfunction builtin_i16x8_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_s, builtin_i16x8_min_s);\n\n// i16x8.min_u -> v128.min<u16>\nfunction builtin_i16x8_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_u, builtin_i16x8_min_u);\n\n// i16x8.max_s -> v128.max<i16>\nfunction builtin_i16x8_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_s, builtin_i16x8_max_s);\n\n// i16x8.max_u -> v128.max<u16>\nfunction builtin_i16x8_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_u, builtin_i16x8_max_u);\n\n// i16x8.avgr_u -> v128.avgr<u16>\nfunction builtin_i16x8_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_avgr_u, builtin_i16x8_avgr_u);\n\n// i16x8.abs -> v128.abs<i16>\nfunction builtin_i16x8_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_abs, builtin_i16x8_abs);\n\n// i16x8.neg -> v128.neg<i16>\nfunction builtin_i16x8_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_neg, builtin_i16x8_neg);\n\n// i16x8.add_sat_s -> v128.add_sat<i16>\nfunction builtin_i16x8_add_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_sat_s, builtin_i16x8_add_sat_s);\n\n// i16x8.add_sat_u -> v128.add_sat<u16>\nfunction builtin_i16x8_add_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_sat_u, builtin_i16x8_add_sat_u);\n\n// i16x8.sub_sat_s -> v128.sub_sat<i16>\nfunction builtin_i16x8_sub_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_sat_s, builtin_i16x8_sub_sat_s);\n\n// i16x8.sub_sat_u -> v128.sub_sat<u16>\nfunction builtin_i16x8_sub_sat_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_sat_u, builtin_i16x8_sub_sat_u);\n\n// i16x8.shl -> v128.shl<i16>\nfunction builtin_i16x8_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shl, builtin_i16x8_shl);\n\n// i16x8.shr_s -> v128.shr<i16>\nfunction builtin_i16x8_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_s, builtin_i16x8_shr_s);\n\n// i16x8.shr_u -> v128.shr<u16>\nfunction builtin_i16x8_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_u, builtin_i16x8_shr_u);\n\n// i16x8.all_true -> v128.all_true<i16>\nfunction builtin_i16x8_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_all_true, builtin_i16x8_all_true);\n\n// i16x8.bitmask -> v128.bitmask<i16>\nfunction builtin_i16x8_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_bitmask, builtin_i16x8_bitmask);\n\n// i16x8.eq -> v128.eq<i16>\nfunction builtin_i16x8_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_eq, builtin_i16x8_eq);\n\n// i16x8.ne -> v128.ne<i16>\nfunction builtin_i16x8_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ne, builtin_i16x8_ne);\n\n// i16x8.lt_s -> v128.lt<i16>\nfunction builtin_i16x8_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_s, builtin_i16x8_lt_s);\n\n// i16x8.lt_u -> v128.lt<u16>\nfunction builtin_i16x8_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_u, builtin_i16x8_lt_u);\n\n// i16x8.le_s -> v128.le<i16>\nfunction builtin_i16x8_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_s, builtin_i16x8_le_s);\n\n// i16x8.le_u -> v128.le<u16>\nfunction builtin_i16x8_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_u, builtin_i16x8_le_u);\n\n// i16x8.gt_s -> v128.gt<i16>\nfunction builtin_i16x8_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_s, builtin_i16x8_gt_s);\n\n// i16x8.gt_u -> v128.gt<u16>\nfunction builtin_i16x8_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_u, builtin_i16x8_gt_u);\n\n// i16x8.ge_s -> v128.ge<i16>\nfunction builtin_i16x8_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_s, builtin_i16x8_ge_s);\n\n// i16x8.ge_u -> v128.ge<u16>\nfunction builtin_i16x8_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_u, builtin_i16x8_ge_u);\n\n// i16x8.narrow_i32x4_s -> v128.narrow<i32>\nfunction builtin_i16x8_narrow_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_s, builtin_i16x8_narrow_i32x4_s);\n\n// i16x8.narrow_i32x4_u -> v128.narrow<u32>\nfunction builtin_i16x8_narrow_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_u, builtin_i16x8_narrow_i32x4_u);\n\n// i16x8.extend_low_i8x16_s -> v128.extend_low<i8>\nfunction builtin_i16x8_extend_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_low_i8x16_s, builtin_i16x8_extend_low_i8x16_s);\n\n// i16x8.extend_low_i8x16_u -> v128.extend_low<u8>\nfunction builtin_i16x8_extend_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_low_i8x16_u, builtin_i16x8_extend_low_i8x16_u);\n\n// i16x8.extend_high_i8x16_s -> v128.extend_high<i8>\nfunction builtin_i16x8_extend_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_high_i8x16_s, builtin_i16x8_extend_high_i8x16_s);\n\n// i16x8.extend_high_i8x16_u -> v128.extend_high<u8>\nfunction builtin_i16x8_extend_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extend_high_i8x16_u, builtin_i16x8_extend_high_i8x16_u);\n\n// i16x8.extadd_pairwise_i8x16_s -> v128.extadd_pairwise<i8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_s, builtin_i16x8_extadd_pairwise_i8x16_s);\n\n// i16x8.extadd_pairwise_i8x16_u -> v128.extadd_pairwise<u8>\nfunction builtin_i16x8_extadd_pairwise_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_u, builtin_i16x8_extadd_pairwise_i8x16_u);\n\n// i16x8.q15mulr_sat_s -> v128.q15mulr_sat<i16>\nfunction builtin_i16x8_q15mulr_sat_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_q15mulr_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_q15mulr_sat_s, builtin_i16x8_q15mulr_sat_s);\n\n// i16x8.extmul_low_i8x16_s -> v128.extmul_low<i16>\nfunction builtin_i16x8_extmul_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_low_i8x16_s, builtin_i16x8_extmul_low_i8x16_s);\n\n// i16x8.extmul_low_i8x16_u -> v128.extmul_low<u16>\nfunction builtin_i16x8_extmul_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_low_i8x16_u, builtin_i16x8_extmul_low_i8x16_u);\n\n// i16x8.extmul_high_i8x16_s -> v128.extmul_high<i16>\nfunction builtin_i16x8_extmul_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_high_i8x16_s, builtin_i16x8_extmul_high_i8x16_s);\n\n// i16x8.extmul_high_i8x16_u -> v128.extmul_high<u16>\nfunction builtin_i16x8_extmul_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extmul_high_i8x16_u, builtin_i16x8_extmul_high_i8x16_u);\n\n// i32x4.splat -> v128.splat<i32>\nfunction builtin_i32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_splat, builtin_i32x4_splat);\n\n// i32x4.extract_lane -> <i32>v128.extract_lane<i32>\nfunction builtin_i32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extract_lane, builtin_i32x4_extract_lane);\n\n// i32x4.replace_lane -> v128.replace_lane<i32>\nfunction builtin_i32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_replace_lane, builtin_i32x4_replace_lane);\n\n// i32x4.add -> v128.add<i32>\nfunction builtin_i32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_add, builtin_i32x4_add);\n\n// i32x4.sub -> v128.sub<i32>\nfunction builtin_i32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_sub, builtin_i32x4_sub);\n\n// i32x4.mul -> v128.mul<i32>\nfunction builtin_i32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_mul, builtin_i32x4_mul);\n\n// i32x4.min_s -> v128.min<i32>\nfunction builtin_i32x4_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_s, builtin_i32x4_min_s);\n\n// i32x4.min_u -> v128.min<u32>\nfunction builtin_i32x4_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_u, builtin_i32x4_min_u);\n\n// i32x4.max_s -> v128.max<i32>\nfunction builtin_i32x4_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_s, builtin_i32x4_max_s);\n\n// i32x4.max_u -> v128.max<u32>\nfunction builtin_i32x4_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_u, builtin_i32x4_max_u);\n\n// i32x4.dot_i16x8_s -> v128.dot<i16>\nfunction builtin_i32x4_dot_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_dot(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_dot_i16x8_s, builtin_i32x4_dot_i16x8_s);\n\n// i32x4.abs -> v128.abs<i32>\nfunction builtin_i32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_abs, builtin_i32x4_abs);\n\n// i32x4.neg -> v128.neg<i32>\nfunction builtin_i32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_neg, builtin_i32x4_neg);\n\n// i32x4.shl -> v128.shl<i32>\nfunction builtin_i32x4_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shl, builtin_i32x4_shl);\n\n// i32x4.shr_s -> v128.shr<i32>\nfunction builtin_i32x4_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_s, builtin_i32x4_shr_s);\n\n// i32x4.shr_u -> v128.shr<u32>\nfunction builtin_i32x4_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_u, builtin_i32x4_shr_u);\n\n// i32x4.all_true -> v128.all_true<i32>\nfunction builtin_i32x4_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_all_true, builtin_i32x4_all_true);\n\n// i32x4.bitmask -> v128.bitmask<i32>\nfunction builtin_i32x4_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_bitmask, builtin_i32x4_bitmask);\n\n// i32x4.eq -> v128.eq<i32>\nfunction builtin_i32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_eq, builtin_i32x4_eq);\n\n// i32x4.ne -> v128.ne<i32>\nfunction builtin_i32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ne, builtin_i32x4_ne);\n\n// i32x4.lt_s -> v128.lt<i32>\nfunction builtin_i32x4_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_s, builtin_i32x4_lt_s);\n\n// i32x4.lt_u -> v128.lt<u32>\nfunction builtin_i32x4_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_u, builtin_i32x4_lt_u);\n\n// i32x4.le_s -> v128.le<i32>\nfunction builtin_i32x4_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_s, builtin_i32x4_le_s);\n\n// i32x4.le_u -> v128.le<u32>\nfunction builtin_i32x4_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_u, builtin_i32x4_le_u);\n\n// i32x4.gt_s -> v128.gt<i32>\nfunction builtin_i32x4_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_s, builtin_i32x4_gt_s);\n\n// i32x4.gt_u -> v128.gt<u32>\nfunction builtin_i32x4_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_u, builtin_i32x4_gt_u);\n\n// i32x4.ge_s -> v128.ge<i32>\nfunction builtin_i32x4_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_s, builtin_i32x4_ge_s);\n\n// i32x4.ge_u -> v128.ge<u32>\nfunction builtin_i32x4_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_u, builtin_i32x4_ge_u);\n\n// i32x4.trunc_sat_f32x4_s -> v128.trunc_sat<i32>\nfunction builtin_i32x4_trunc_sat_f32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_s, builtin_i32x4_trunc_sat_f32x4_s);\n\n// i32x4.trunc_sat_f32x4_u -> v128.trunc_sat<u32>\nfunction builtin_i32x4_trunc_sat_f32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_u, builtin_i32x4_trunc_sat_f32x4_u);\n\n// i32x4.trunc_sat_f64x2_s_zero -> v128.trunc_sat_zero<i32>\nfunction builtin_i32x4_trunc_sat_f64x2_s_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f64x2_s_zero, builtin_i32x4_trunc_sat_f64x2_s_zero);\n\n// i32x4.trunc_sat_f64x2_u_zero -> v128.trunc_sat_zero<u32>\nfunction builtin_i32x4_trunc_sat_f64x2_u_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat_zero(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f64x2_u_zero, builtin_i32x4_trunc_sat_f64x2_u_zero);\n\n// i32x4.extend_low_i16x8_s -> // v128.extend_low<i16>\nfunction builtin_i32x4_extend_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_low_i16x8_s, builtin_i32x4_extend_low_i16x8_s);\n\n// i32x4.extend_low_i16x8_u -> v128.extend_low<u16>\nfunction builtin_i32x4_extend_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_low_i16x8_u, builtin_i32x4_extend_low_i16x8_u);\n\n// i32x4.extend_high_i16x8_s -> v128.extend_high<i16>\nfunction builtin_i32x4_extend_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_high_i16x8_s, builtin_i32x4_extend_high_i16x8_s);\n\n// i32x4.extend_high_i16x8_u -> v128.extend_high<u16>\nfunction builtin_i32x4_extend_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extend_high_i16x8_u, builtin_i32x4_extend_high_i16x8_u);\n\n// i32x4.extadd_pairwise_i16x8_s -> v128.extadd_pairwise<i16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_s, builtin_i32x4_extadd_pairwise_i16x8_s);\n\n// i32x4.extadd_pairwise_i16x8_u -> v128.extadd_pairwise<u16>\nfunction builtin_i32x4_extadd_pairwise_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extadd_pairwise(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_u, builtin_i32x4_extadd_pairwise_i16x8_u);\n\n// i32x4.extmul_low_i16x8_s -> v128.extmul_low<i16>\nfunction builtin_i32x4_extmul_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_low_i16x8_s, builtin_i32x4_extmul_low_i16x8_s);\n\n// i32x4.extmul_low_i16x8_u -> v128.extmul_low<u16>\nfunction builtin_i32x4_extmul_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_low_i16x8_u, builtin_i32x4_extmul_low_i16x8_u);\n\n// i32x4.extmul_high_i16x8_s -> v128.extmul_high<i16>\nfunction builtin_i32x4_extmul_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_high_i16x8_s, builtin_i32x4_extmul_high_i16x8_s);\n\n// i32x4.extmul_high_i16x8_u -> v128.extmul_high<u16>\nfunction builtin_i32x4_extmul_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extmul_high_i16x8_u, builtin_i32x4_extmul_high_i16x8_u);\n\n// i64x2.splat -> v128.splat<i64>\nfunction builtin_i64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_splat, builtin_i64x2_splat);\n\n// i64x2.extract_lane -> <i64>v128.extract_lane<i64>\nfunction builtin_i64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extract_lane, builtin_i64x2_extract_lane);\n\n// i64x2.replace_lane -> v128.replace_lane<i64>\nfunction builtin_i64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_replace_lane, builtin_i64x2_replace_lane);\n\n// i64x2.add -> v128.add<i64>\nfunction builtin_i64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_add, builtin_i64x2_add);\n\n// i64x2.sub -> v128.sub<i64>\nfunction builtin_i64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_sub, builtin_i64x2_sub);\n\n// i64x2.mul -> v128.mul<i64>\nfunction builtin_i64x2_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_mul, builtin_i64x2_mul);\n\n// i64x2.abs -> v128.abs<i64>\nfunction builtin_i64x2_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_abs, builtin_i64x2_abs);\n\n// i64x2.neg -> v128.neg<i64>\nfunction builtin_i64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_neg, builtin_i64x2_neg);\n\n// i64x2.shl -> v128.shl<i64>\nfunction builtin_i64x2_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shl, builtin_i64x2_shl);\n\n// i64x2.shr_s -> v128.shr<i64>\nfunction builtin_i64x2_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_s, builtin_i64x2_shr_s);\n\n// i64x2.shr_u -> v128.shr<u64>\nfunction builtin_i64x2_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_u, builtin_i64x2_shr_u);\n\n// i64x2.all_true -> v128.all_true<i64>\nfunction builtin_i64x2_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_all_true, builtin_i64x2_all_true);\n\n// i64x2.bitmask -> v128.bitmask<i64>\nfunction builtin_i64x2_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_bitmask, builtin_i64x2_bitmask);\n\n// i64x2.eq -> v128.eq<i64>\nfunction builtin_i64x2_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_eq, builtin_i64x2_eq);\n\n// i64x2.ne -> v128.ne<i64>\nfunction builtin_i64x2_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_ne, builtin_i64x2_ne);\n\n// i64x2.lt_s -> v128.lt<i64>\nfunction builtin_i64x2_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_lt_s, builtin_i64x2_lt_s);\n\n// i64x2.le_s -> v128.le<i64>\nfunction builtin_i64x2_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_le_s, builtin_i64x2_le_s);\n\n// i64x2.gt_s -> v128.gt<i64>\nfunction builtin_i64x2_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_gt_s, builtin_i64x2_gt_s);\n\n// i64x2.ge_s -> v128.ge<i64>\nfunction builtin_i64x2_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_ge_s, builtin_i64x2_ge_s);\n\n// i64x2.extend_low_i32x4_s -> // v128.extend_low<i32>\nfunction builtin_i64x2_extend_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_low_i32x4_s, builtin_i64x2_extend_low_i32x4_s);\n\n// i64x2.extend_low_i32x4_u -> v128.extend_low<u32>\nfunction builtin_i64x2_extend_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_low_i32x4_u, builtin_i64x2_extend_low_i32x4_u);\n\n// i64x2.extend_high_i32x4_s -> v128.extend_high<i32>\nfunction builtin_i64x2_extend_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_high_i32x4_s, builtin_i64x2_extend_high_i32x4_s);\n\n// i64x2.extend_high_i32x4_u -> v128.extend_high<u32>\nfunction builtin_i64x2_extend_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extend_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extend_high_i32x4_u, builtin_i64x2_extend_high_i32x4_u);\n\n// i64x2.extmul_low_i32x4_s -> v128.extmul_low<i32>\nfunction builtin_i64x2_extmul_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_low_i32x4_s, builtin_i64x2_extmul_low_i32x4_s);\n\n// i64x2.extmul_low_i32x4_u -> v128.extmul_low<u32>\nfunction builtin_i64x2_extmul_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_low(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_low_i32x4_u, builtin_i64x2_extmul_low_i32x4_u);\n\n// i64x2.extmul_high_i32x4_s -> v128.extmul_high<i32>\nfunction builtin_i64x2_extmul_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_high_i32x4_s, builtin_i64x2_extmul_high_i32x4_s);\n\n// i64x2.extmul_high_i32x4_u -> v128.extmul_high<u32>\nfunction builtin_i64x2_extmul_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_extmul_high(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extmul_high_i32x4_u, builtin_i64x2_extmul_high_i32x4_u);\n\n// f32x4.splat -> v128.splat<f32>\nfunction builtin_f32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_splat, builtin_f32x4_splat);\n\n// f32x4.extract_lane -> <f32>v128.extract_lane<f32>\nfunction builtin_f32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_extract_lane, builtin_f32x4_extract_lane);\n\n// f32x4.replace_lane -> v128.replace_lane<f32>\nfunction builtin_f32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_replace_lane, builtin_f32x4_replace_lane);\n\n// f32x4.add -> v128.add<f32>\nfunction builtin_f32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_add, builtin_f32x4_add);\n\n// f32x4.sub -> v128.sub<f32>\nfunction builtin_f32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sub, builtin_f32x4_sub);\n\n// f32x4.mul -> v128.mul<f32>\nfunction builtin_f32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_mul, builtin_f32x4_mul);\n\n// f32x4.div -> v128.div<f32>\nfunction builtin_f32x4_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_div, builtin_f32x4_div);\n\n// f32x4.neg -> v128.neg<f32>\nfunction builtin_f32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_neg, builtin_f32x4_neg);\n\n// f32x4.min -> v128.min<f32>\nfunction builtin_f32x4_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_min, builtin_f32x4_min);\n\n// f32x4.max -> v128.max<f32>\nfunction builtin_f32x4_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_max, builtin_f32x4_max);\n\n// f32x4.pmin -> v128.pmin<f32>\nfunction builtin_f32x4_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmin, builtin_f32x4_pmin);\n\n// f32x4.pmax -> v128.pmax<f32>\nfunction builtin_f32x4_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmax, builtin_f32x4_pmax);\n\n// f32x4.abs -> v128.abs<f32>\nfunction builtin_f32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_abs, builtin_f32x4_abs);\n\n// f32x4.sqrt -> v128.sqrt<f32>\nfunction builtin_f32x4_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sqrt, builtin_f32x4_sqrt);\n\n// f32x4.ceil -> v128.ceil<f32>\nfunction builtin_f32x4_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ceil, builtin_f32x4_ceil);\n\n// f32x4.floor -> v128.floor<f32>\nfunction builtin_f32x4_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_floor, builtin_f32x4_floor);\n\n// f32x4.trunc -> v128.trunc<f32>\nfunction builtin_f32x4_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_trunc, builtin_f32x4_trunc);\n\n// f32x4.nearest -> v128.nearest<f32>\nfunction builtin_f32x4_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_nearest, builtin_f32x4_nearest);\n\n// f32x4.eq -> v128.eq<f32>\nfunction builtin_f32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_eq, builtin_f32x4_eq);\n\n// f32x4.ne -> v128.ne<f32>\nfunction builtin_f32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ne, builtin_f32x4_ne);\n\n// f32x4.lt -> v128.lt<f32>\nfunction builtin_f32x4_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_lt, builtin_f32x4_lt);\n\n// f32x4.le -> v128.le<f32>\nfunction builtin_f32x4_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_le, builtin_f32x4_le);\n\n// f32x4.gt -> v128.gt<f32>\nfunction builtin_f32x4_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_gt, builtin_f32x4_gt);\n\n// f32x4.ge -> v128.ge<f32>\nfunction builtin_f32x4_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ge, builtin_f32x4_ge);\n\n// f32x4.convert_i32x4_s -> v128.convert<i32>\nfunction builtin_f32x4_convert_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_s, builtin_f32x4_convert_i32x4_s);\n\n// f32x4.convert_i32x4_u -> v128.convert<u32>\nfunction builtin_f32x4_convert_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_u, builtin_f32x4_convert_i32x4_u);\n\n// f32x4.demote_f64x2_zero -> v128.demote_zero<f64>\nfunction builtin_f32x4_demote_f64x2_zero(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_demote_zero(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_demote_f64x2_zero, builtin_f32x4_demote_f64x2_zero);\n\n// f64x2.splat -> v128.splat<f64>\nfunction builtin_f64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_splat, builtin_f64x2_splat);\n\n// f64x2.extract_lane -> <f64>v128.extract_lane<f64>\nfunction builtin_f64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_extract_lane, builtin_f64x2_extract_lane);\n\n// f64x2.replace_lane -> v128.replace_lane\nfunction builtin_f64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_replace_lane, builtin_f64x2_replace_lane);\n\n// f64x2.add -> v128.add<f64>\nfunction builtin_f64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_add, builtin_f64x2_add);\n\n// f64x2.sub -> v128.sub<f64>\nfunction builtin_f64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sub, builtin_f64x2_sub);\n\n// f64x2.mul -> v128.mul<f64>\nfunction builtin_f64x2_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_mul, builtin_f64x2_mul);\n\n// f64x2.div -> v128.div<f64>\nfunction builtin_f64x2_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_div, builtin_f64x2_div);\n\n// f64x2.neg -> v128.neg<f64>\nfunction builtin_f64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_neg, builtin_f64x2_neg);\n\n// f64x2.min -> v128.min<f64>\nfunction builtin_f64x2_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_min, builtin_f64x2_min);\n\n// f64x2.max -> v128.max<f64>\nfunction builtin_f64x2_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_max, builtin_f64x2_max);\n\n// f64x2.pmin -> v128.pmin<f64>\nfunction builtin_f64x2_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmin, builtin_f64x2_pmin);\n\n// f64x2.pmax -> v128.pmax<f64>\nfunction builtin_f64x2_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmax, builtin_f64x2_pmax);\n\n// f64x2.abs -> v128.abs<f64>\nfunction builtin_f64x2_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_abs, builtin_f64x2_abs);\n\n// f64x2.sqrt -> v128.sqrt<f64>\nfunction builtin_f64x2_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sqrt, builtin_f64x2_sqrt);\n\n// f64x2.ceil -> v128.ceil<f64>\nfunction builtin_f64x2_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ceil, builtin_f64x2_ceil);\n\n// f64x2.floor -> v128.floor<f64>\nfunction builtin_f64x2_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_floor, builtin_f64x2_floor);\n\n// f64x2.trunc -> v128.trunc<f64>\nfunction builtin_f64x2_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_trunc, builtin_f64x2_trunc);\n\n// f64x2.nearest -> v128.nearest<f64>\nfunction builtin_f64x2_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_nearest, builtin_f64x2_nearest);\n\n// f64x2.eq -> v128.eq<f64>\nfunction builtin_f64x2_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_eq, builtin_f64x2_eq);\n\n// f64x2.ne -> v128.ne<f64>\nfunction builtin_f64x2_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ne, builtin_f64x2_ne);\n\n// f64x2.lt -> v128.lt<f64>\nfunction builtin_f64x2_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_lt, builtin_f64x2_lt);\n\n// f64x2.le -> v128.le<f64>\nfunction builtin_f64x2_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_le, builtin_f64x2_le);\n\n// f64x2.gt -> v128.gt<f64>\nfunction builtin_f64x2_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_gt, builtin_f64x2_gt);\n\n// f64x2.ge -> v128.ge<f64>\nfunction builtin_f64x2_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ge, builtin_f64x2_ge);\n\n// f64x2.convert_low_i32x4_s -> v128.convert_low<i32>\nfunction builtin_f64x2_convert_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_low_i32x4_s, builtin_f64x2_convert_low_i32x4_s);\n\n// f64x2.convert_low_i32x4_u -> v128.convert_low<u32>\nfunction builtin_f64x2_convert_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_low_i32x4_u, builtin_f64x2_convert_low_i32x4_u);\n\n// f64x2.promote_low_f32x4 -> v128.promote_low<f32>\nfunction builtin_f64x4_promote_low_f32x4(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_promote_low(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_promote_low_f32x4, builtin_f64x4_promote_low_f32x4);\n\n// === Internal helpers =======================================================================\n\n/** Compiles the `visit_globals` function. */\nexport function compileVisitGlobals(compiler: Compiler): void {\n  var module = compiler.module;\n  var exprs = new Array<ExpressionRef>();\n  var sizeTypeRef = compiler.options.sizeTypeRef;\n  var visitInstance = assert(compiler.program.visitInstance);\n\n  // this function is @lazy: make sure it exists\n  compiler.compileFunction(visitInstance, true);\n\n  // TODO: for (let element of compiler.program.elementsByName.values()) {\n  for (let _values = Map_values(compiler.program.elementsByName), i = 0, k = _values.length; i < k; ++i) {\n    let element = unchecked(_values[i]);\n    if (element.kind != ElementKind.GLOBAL) continue;\n    let global = <Global>element;\n    let globalType = global.type;\n    let classReference = globalType.getClass();\n    if (\n      classReference !== null &&\n      !classReference.hasDecorator(DecoratorFlags.UNMANAGED) &&\n      global.is(CommonFlags.COMPILED)\n    ) {\n      if (global.is(CommonFlags.INLINED)) {\n        let value = global.constantIntegerValue;\n        if (i64_low(value) || i64_high(value)) {\n          exprs.push(\n            module.call(visitInstance.internalName, [\n              compiler.options.isWasm64\n                ? module.i64(i64_low(value), i64_high(value))\n                : module.i32(i64_low(value)),\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          );\n        }\n      } else {\n        exprs.push(\n          module.if(\n            module.local_tee(1,\n              module.global_get(global.internalName, sizeTypeRef),\n              false // internal\n            ),\n            module.call(visitInstance.internalName, [\n              module.local_get(1, sizeTypeRef), // tempRef != null\n              module.local_get(0, TypeRef.I32) // cookie\n            ], TypeRef.None)\n          )\n        );\n      }\n    }\n  }\n  module.addFunction(BuiltinNames.visit_globals,\n    TypeRef.I32,  // cookie\n    TypeRef.None, // => void\n    [ sizeTypeRef ],\n    exprs.length\n      ? module.block(null, exprs)\n      : module.nop()\n  );\n}\n\n/** Ensures that the visitor function of the specified class is compiled. */\nfunction ensureVisitMembersOf(compiler: Compiler, instance: Class): void {\n  assert(instance.type.isManaged);\n  if (instance.visitRef) return;\n\n  var program = compiler.program;\n  var module = compiler.module;\n  var usizeType = program.options.usizeType;\n  var sizeTypeRef = usizeType.toRef();\n  var sizeTypeSize = usizeType.byteSize;\n  var visitInstance = assert(program.visitInstance);\n  var body = new Array<ExpressionRef>();\n\n  // If the class has a base class, call its visitor first\n  var base = instance.base;\n  if (base) {\n    body.push(\n      module.call(base.internalName + \"~visit\", [\n        module.local_get(0, sizeTypeRef), // this\n        module.local_get(1, TypeRef.I32)  // cookie\n      ], TypeRef.None)\n    );\n  }\n\n  // Some standard library components provide a custom visitor implementation,\n  // for example to visit all members of a collection, e.g. arrays and maps.\n  var hasVisitImpl = false;\n  if (instance.isDeclaredInLibrary) {\n    let visitPrototype = instance.getMember(\"__visit\");\n    if (visitPrototype) {\n      assert(visitPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n      let visitInstance = program.resolver.resolveFunction(<FunctionPrototype>visitPrototype, null);\n      if (!visitInstance || !compiler.compileFunction(visitInstance)) {\n        body.push(\n          module.unreachable()\n        );\n      } else {\n        let visitSignature = visitInstance.signature;\n        let visitThisType = assert(visitSignature.thisType);\n        assert(\n          visitSignature.parameterTypes.length == 1 &&\n          visitSignature.parameterTypes[0] == Type.u32 &&\n          visitSignature.returnType == Type.void &&\n          instance.type.isStrictlyAssignableTo(visitThisType) // incl. implemented on super\n        );\n        body.push(\n          module.call(visitInstance.internalName, [\n            module.local_get(0, sizeTypeRef), // this\n            module.local_get(1, TypeRef.I32)  // cookie\n          ], TypeRef.None)\n        );\n      }\n      hasVisitImpl = true;\n    }\n  }\n\n  // Otherwise, if there is no custom visitor, generate a visitor function\n  // according to class layout, visiting all _own_ managed members.\n  var needsTempValue = false;\n  if (!hasVisitImpl) {\n    let members = instance.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), j = 0, l = _values.length; j < l; ++j) {\n        let member = unchecked(_values[j]);\n        if (member.kind == ElementKind.FIELD) {\n          if ((<Field>member).parent === instance) {\n            let fieldType = (<Field>member).type;\n            if (fieldType.isManaged) {\n              let fieldOffset = (<Field>member).memoryOffset;\n              assert(fieldOffset >= 0);\n              needsTempValue = true;\n              body.push(\n                // if ($2 = value) __visit($2, $1)\n                module.if(\n                  module.local_tee(2,\n                    module.load(sizeTypeSize, false,\n                      module.local_get(0, sizeTypeRef),\n                      sizeTypeRef, fieldOffset\n                    ),\n                    false // internal\n                  ),\n                  module.call(visitInstance.internalName, [\n                    module.local_get(2, sizeTypeRef), // value\n                    module.local_get(1, TypeRef.I32)  // cookie\n                  ], TypeRef.None)\n                )\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Create the visitor function\n  instance.visitRef = module.addFunction(instance.internalName + \"~visit\",\n    createType([sizeTypeRef, TypeRef.I32]),\n    TypeRef.None,\n    needsTempValue ? [ sizeTypeRef ] : null,\n    module.flatten(body, TypeRef.None)\n  );\n\n  // And make sure the base visitor function exists\n  if (base && base.type.isManaged) {\n    // errored earlier if not managed\n    ensureVisitMembersOf(compiler, base);\n  }\n}\n\n/** Compiles the `__visit_members` function. */\nexport function compileVisitMembers(compiler: Compiler): void {\n  var program = compiler.program;\n  var module = compiler.module;\n  var usizeType = program.options.usizeType;\n  var sizeTypeRef = usizeType.toRef();\n  var managedClasses = program.managedClasses;\n  var visitInstance = assert(program.visitInstance);\n  compiler.compileFunction(visitInstance, true); // is lazy, make sure it is compiled\n\n  // Prepare a mapping of class names to visitor calls. Each name corresponds to\n  // the respective sequential (0..N) class id.\n  var names = new Array<string>();\n  var cases = new Array<ExpressionRef>();\n  var nextId = 0;\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = _keys[i];\n    assert(instanceId == nextId++);\n    let instance = assert(managedClasses.get(instanceId));\n    names[i] = instance.internalName;\n    if (instance.isPointerfree) {\n      cases[i] = module.return();\n    } else {\n      cases[i] = module.block(null, [\n        module.call(instance.internalName + \"~visit\", [\n          module.local_get(0, sizeTypeRef), // this\n          module.local_get(1, TypeRef.I32)  // cookie\n        ], TypeRef.None),\n        module.return()\n      ], TypeRef.None);\n      ensureVisitMembersOf(compiler, instance);\n    }\n  }\n\n  // Make a br_table of the mapping, calling visitor functions by unique class id\n  var current = module.block(names[0], [\n    module.switch(names, \"invalid\",\n      // load<u32>(changetype<usize>(this) - 8)\n      module.load(4, false,\n        sizeTypeRef == TypeRef.I64\n          ? module.binary(BinaryOp.SubI64,\n              module.local_get(0, sizeTypeRef),\n              module.i64(8)\n            )\n          : module.binary(BinaryOp.SubI32,\n              module.local_get(0, sizeTypeRef),\n              module.i32(8) // rtId is at -8\n            ),\n        TypeRef.I32, 0\n      )\n    )\n  ], TypeRef.None);\n\n  // Wrap blocks in order\n  for (let i = 0, k = names.length - 1; i < k; ++i) {\n    current = module.block(names[i + 1], [\n      current,\n      cases[i]\n    ], TypeRef.None);\n  }\n\n  // Wrap the last id in an 'invalid' block to break out of on invalid ids\n  current = module.block(\"invalid\", [\n    current,\n    cases[names.length - 1]\n  ], TypeRef.None);\n\n  // Add the function, executing an unreachable if breaking to 'invalid'\n  module.addFunction(BuiltinNames.visit_members,\n    createType([ sizeTypeRef, TypeRef.I32 ]), // this, cookie\n    TypeRef.None, // => void\n    null,\n    module.flatten([\n      current,\n      module.unreachable()\n    ])\n  );\n}\n\nfunction typeToRuntimeFlags(type: Type): TypeinfoFlags {\n  var flags = TypeinfoFlags.VALUE_ALIGN_0 * (1 << type.alignLog2);\n  if (type.is(TypeFlags.SIGNED)) flags |= TypeinfoFlags.VALUE_SIGNED;\n  if (type.is(TypeFlags.FLOAT)) flags |= TypeinfoFlags.VALUE_FLOAT;\n  if (type.is(TypeFlags.NULLABLE)) flags |= TypeinfoFlags.VALUE_NULLABLE;\n  if (type.isManaged) flags |= TypeinfoFlags.VALUE_MANAGED;\n  return flags / TypeinfoFlags.VALUE_ALIGN_0;\n}\n\n/** Compiles runtime type information for use by stdlib. */\nexport function compileRTTI(compiler: Compiler): void {\n  var program = compiler.program;\n  var module = compiler.module;\n  var managedClasses = program.managedClasses;\n  var count = managedClasses.size;\n  var size = 4 + 8 * count;\n  var data = new Uint8Array(size);\n  writeI32(count, data, 0);\n  var off = 4;\n  var abvInstance = program.arrayBufferViewInstance;\n  var abvPrototype = abvInstance.prototype;\n  var arrayPrototype = program.arrayPrototype;\n  var setPrototype = program.setPrototype;\n  var mapPrototype = program.mapPrototype;\n  var staticArrayPrototype = program.staticArrayPrototype;\n  var lastId = 0;\n  // TODO: for (let [instanceId, instance] of managedClasses) {\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = unchecked(_keys[i]);\n    let instance = assert(managedClasses.get(instanceId));\n    assert(instanceId == lastId++);\n    let flags: TypeinfoFlags = 0;\n    if (instance.isPointerfree) flags |= TypeinfoFlags.POINTERFREE;\n    if (instance !== abvInstance && instance.extends(abvPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAYBUFFERVIEW;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extends(arrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extends(setPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));\n      assert(typeArguments.length == 1);\n      flags |= TypeinfoFlags.SET;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n    } else if (instance.extends(mapPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));\n      assert(typeArguments.length == 2);\n      flags |= TypeinfoFlags.MAP;\n      flags |= TypeinfoFlags.KEY_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[1]);\n    } else if (instance.extends(staticArrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.STATICARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    }\n    writeI32(flags, data, off); off += 4;\n    instance.rttiFlags = flags;\n    let base = instance.base;\n    writeI32(base ? base.id : 0, data, off); off += 4;\n  }\n  assert(off == size);\n  var usizeType = program.options.usizeType;\n  var segment = compiler.addAlignedMemorySegment(data);\n  if (usizeType.size == 8) {\n    let offset = segment.offset;\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, false, module.i64(i64_low(offset), i64_high(offset)));\n  } else {\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, false, module.i32(i64_low(segment.offset)));\n  }\n}\n\n/** Compiles a class-specific instanceof helper, checking a ref against all concrete instances. */\nexport function compileClassInstanceOf(compiler: Compiler, prototype: ClassPrototype): void {\n  var module = compiler.module;\n  var sizeTypeRef = compiler.options.sizeTypeRef;\n  var instanceofInstance = assert(prototype.program.instanceofInstance);\n  compiler.compileFunction(instanceofInstance);\n\n  var stmts = new Array<ExpressionRef>();\n\n  // if (!ref) return false\n  stmts.push(\n    module.if(\n      module.unary(\n        sizeTypeRef == TypeRef.I64\n          ? UnaryOp.EqzI64\n          : UnaryOp.EqzI32,\n        module.local_get(0, sizeTypeRef)\n      ),\n      module.return(\n        module.i32(0)\n      )\n    )\n  );\n\n  // if (__instanceof(ref, ID[i])) return true\n  var instances = prototype.instances;\n  if (instances !== null && instances.size > 0) {\n    // TODO: for (let instance of instances.values()) {\n    for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n      let instance = unchecked(_values[i]);\n      stmts.push(\n        module.if(\n          module.call(instanceofInstance.internalName, [\n            module.local_get(0, sizeTypeRef),\n            module.i32(instance.id)\n          ], TypeRef.I32),\n          module.return(\n            module.i32(1)\n          )\n        )\n      );\n    }\n  }\n\n  // return false\n  stmts.push(\n    module.return(\n      module.i32(0)\n    )\n  );\n\n  module.addFunction(prototype.internalName + \"~instanceof\", sizeTypeRef, TypeRef.I32, null, module.flatten(stmts));\n}\n\n// Helpers\n\n/** Evaluates the constant type of a type argument *or* expression. */\nfunction evaluateConstantType(ctx: BuiltinContext): Type | null {\n  var compiler = ctx.compiler;\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  if (operands.length == 0) { // requires type argument\n    if (!typeArguments || typeArguments.length != 1) {\n      compiler.error(\n        DiagnosticCode.Expected_0_type_arguments_but_got_1,\n        ctx.reportNode.typeArgumentsRange, \"1\", typeArguments ? typeArguments.length.toString() : \"0\"\n      );\n      return null;\n    }\n    return typeArguments[0];\n  }\n  if (operands.length == 1) { // optional type argument\n    if (typeArguments !== null && typeArguments.length > 0) {\n      if (typeArguments.length > 1) {\n        compiler.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n        );\n        return null;\n      }\n      compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT);\n    } else {\n      compiler.compileExpression(operands[0], Type.auto);\n    }\n    return compiler.currentType;\n  }\n  if (typeArguments !== null && typeArguments.length > 1) {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n    );\n  }\n  compiler.error(\n    DiagnosticCode.Expected_0_arguments_but_got_1,\n    ctx.reportNode.argumentsRange, \"1\", operands.length.toString()\n  );\n  return null;\n}\n\n/** Evaluates a compile-time constant immediate offset argument.*/\nfunction evaluateImmediateOffset(expression: Expression, compiler: Compiler): i32 {\n  var module = compiler.module;\n  var value: i32;\n  if (compiler.options.isWasm64) {\n    let expr = compiler.compileExpression(expression, Type.usize64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      assert(getConstValueI64High(precomp) == 0); // TODO\n      value = getConstValueI64Low(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  } else {\n    let expr = compiler.compileExpression(expression, Type.usize32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      value = getConstValueI32(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  }\n  return value;\n}\n\n/** Evaluates a compile-time constant immediate align argument. */\nfunction evaluateImmediateAlign(expression: Expression, naturalAlign: i32, compiler: Compiler): i32 {\n  var align = evaluateImmediateOffset(expression, compiler);\n  if (align < 0) return align;\n  if (align < 1 || naturalAlign > 16) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n      expression.range, \"Alignment\", \"1\", naturalAlign.toString()\n    );\n    return -1;\n  }\n  if (!isPowerOf2(align)) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_power_of_two,\n      expression.range, \"Alignment\"\n    );\n    return -1;\n  }\n  return align;\n}\n\n/** Checks that the specified feature is enabled. */\nfunction checkFeatureEnabled(ctx: BuiltinContext, feature: Feature): i32 {\n  var compiler = ctx.compiler;\n  if (!compiler.options.hasFeature(feature)) {\n    compiler.error(\n      DiagnosticCode.Feature_0_is_not_enabled,\n      ctx.reportNode.range, featureToString(feature)\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call with a single required type argument. Returns `1` on error. */\nfunction checkTypeRequired(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  var compiler = ctx.compiler;\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n  } else {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.range, \"1\", \"0\"\n    );\n  }\n  return 1;\n}\n\n/** Checks a call with a single optional type argument. Returns `1` on error. */\nfunction checkTypeOptional(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let compiler = ctx.compiler;\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that is not generic. Returns `1` on error. */\nfunction checkTypeAbsent(ctx: BuiltinContext): i32 {\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let prototype = ctx.prototype;\n    prototype.program.error(\n      DiagnosticCode.Type_0_is_not_generic,\n      ctx.reportNode.typeArgumentsRange, prototype.internalName\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */\nfunction checkArgsRequired(ctx: BuiltinContext, expected: i32): i32 {\n  var operands = ctx.operands;\n  if (operands.length != expected) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expected.toString(), operands.length.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a variable number of arguments. Returns `1` on error. */\nfunction checkArgsOptional(ctx: BuiltinContext, expectedMinimum: i32, expectedMaximum: i32): i32 {\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  if (numOperands < expectedMinimum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMinimum.toString(), numOperands.toString()\n    );\n    return 1;\n  } else if (numOperands > expectedMaximum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMaximum.toString(), numOperands.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Makes an usize constant matching contextual type if reasonable. */\nfunction contextualUsize(compiler: Compiler, value: i64, contextualType: Type): ExpressionRef {\n  var module = compiler.module;\n  // Check if contextual type fits\n  if (contextualType != Type.auto && contextualType.isIntegerValue) {\n    switch (contextualType.kind) {\n      case TypeKind.I32: {\n        if (i64_is_i32(value)) {\n          compiler.currentType = Type.i32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.U32: {\n        if (i64_is_u32(value)) {\n          compiler.currentType = Type.u32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        compiler.currentType = contextualType;\n        return module.i64(i64_low(value), i64_high(value));\n      }\n      // isize/usize falls through\n      // small int is probably not intended\n    }\n  }\n  // Default to usize\n  if (compiler.options.isWasm64) {\n    compiler.currentType = Type.usize64;\n    return module.i64(i64_low(value), i64_high(value));\n  } else {\n    compiler.currentType = Type.usize32;\n    assert(!i64_high(value));\n    return module.i32(i64_low(value));\n  }\n}\n","/**\n * @fileoverview Common constants used by various parts of the compiler.\n * @license Apache-2.0\n */\n\n/** Indicates traits of a {@link Node} or {@link Element}. */\nexport enum CommonFlags {\n  /** No flags set. */\n  NONE = 0,\n\n  // Basic modifiers\n\n  /** Has an `import` modifier. */\n  IMPORT = 1 << 0,\n  /** Has an `export` modifier. */\n  EXPORT = 1 << 1,\n  /** Has a `declare` modifier. */\n  DECLARE = 1 << 2,\n  /** Has a `const` modifier. */\n  CONST = 1 << 3,\n  /** Has a `let` modifier. */\n  LET = 1 << 4,\n  /** Has a `static` modifier. */\n  STATIC = 1 << 5,\n  /** Has a `readonly` modifier. */\n  READONLY = 1 << 6,\n  /** Has an `abstract` modifier. */\n  ABSTRACT = 1 << 7,\n  /** Has a `public` modifier. */\n  PUBLIC = 1 << 8,\n  /** Has a `private` modifier. */\n  PRIVATE = 1 << 9,\n  /** Has a `protected` modifier. */\n  PROTECTED = 1 << 10,\n  /** Has a `get` modifier. */\n  GET = 1 << 11,\n  /** Has a `set` modifier. */\n  SET = 1 << 12,\n  /** Has a definite assignment assertion `!` as in `x!: i32;`. */\n  DEFINITELY_ASSIGNED = 1 << 13,\n\n  // Extended modifiers usually derived from basic modifiers\n\n  /** Is ambient, that is either declared or nested in a declared element. */\n  AMBIENT = 1 << 14,\n  /** Is generic. */\n  GENERIC = 1 << 15,\n  /** Is part of a generic context. */\n  GENERIC_CONTEXT = 1 << 16,\n  /** Is an instance member. */\n  INSTANCE = 1 << 17,\n  /** Is a constructor. */\n  CONSTRUCTOR = 1 << 18,\n  /** Is a module export. */\n  MODULE_EXPORT = 1 << 19,\n  /** Is a module import. */\n  MODULE_IMPORT = 1 << 20,\n\n  // Compilation states\n\n  /** Is resolved. */\n  RESOLVED = 1 << 21,\n  /** Is compiled. */\n  COMPILED = 1 << 22,\n  /** Did error. */\n  ERRORED = 1 << 23,\n  /** Has a constant value and is therefore inlined. */\n  INLINED = 1 << 24,\n  /** Is scoped. */\n  SCOPED = 1 << 25,\n  /** Is a stub. */\n  STUB = 1 << 26,\n  /** Is a virtual method. */\n  VIRTUAL = 1 << 27,\n  /** Is (part of) a closure. */\n  CLOSURE = 1 << 28,\n\n  // Other\n\n  /** Is quoted. */\n  QUOTED = 1 << 29\n}\n\n/** Path delimiter inserted between file system levels. */\nexport const PATH_DELIMITER = \"/\";\n/** Substitution used to indicate the parent directory. */\nexport const PARENT_SUBST = \"..\";\n/** Function name prefix used for getters. */\nexport const GETTER_PREFIX = \"get:\";\n/** Function name prefix used for setters. */\nexport const SETTER_PREFIX = \"set:\";\n/** Delimiter used between class names and instance members. */\nexport const INSTANCE_DELIMITER = \"#\";\n/** Delimiter used between class and namespace names and static members. */\nexport const STATIC_DELIMITER = \".\";\n/** Delimiter used between a function and its inner elements. */\nexport const INNER_DELIMITER = \"~\";\n/** Substitution used to indicate a library directory. */\nexport const LIBRARY_SUBST = \"~lib\";\n/** Library directory prefix. */\nexport const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;\n/** Path index suffix. */\nexport const INDEX_SUFFIX = PATH_DELIMITER + \"index\";\n/** Stub function delimiter. */\nexport const STUB_DELIMITER = \"@\";\n\n/** Common names. */\nexport namespace CommonNames {\n  // special\n  export const EMPTY = \"\";\n  // types\n  export const i8 = \"i8\";\n  export const i16 = \"i16\";\n  export const i32 = \"i32\";\n  export const i64 = \"i64\";\n  export const isize = \"isize\";\n  export const u8 = \"u8\";\n  export const u16 = \"u16\";\n  export const u32 = \"u32\";\n  export const u64 = \"u64\";\n  export const usize = \"usize\";\n  export const bool = \"bool\";\n  export const f32 = \"f32\";\n  export const f64 = \"f64\";\n  export const v128 = \"v128\";\n  export const funcref = \"funcref\";\n  export const externref = \"externref\";\n  export const anyref = \"anyref\";\n  export const eqref = \"eqref\";\n  export const i31ref = \"i31ref\";\n  export const dataref = \"dataref\";\n  export const i8x16 = \"i8x16\";\n  export const u8x16 = \"u8x16\";\n  export const i16x8 = \"i16x8\";\n  export const u16x8 = \"u16x8\";\n  export const i32x4 = \"i32x4\";\n  export const u32x4 = \"u32x4\";\n  export const i64x2 = \"i64x2\";\n  export const u64x2 = \"u64x2\";\n  export const f32x4 = \"f32x4\";\n  export const f64x2 = \"f64x2\";\n  export const void_ = \"void\";\n  export const number = \"number\";\n  export const boolean = \"boolean\";\n  export const string = \"string\";\n  export const native = \"native\";\n  export const indexof = \"indexof\";\n  export const valueof = \"valueof\";\n  export const returnof = \"returnof\";\n  export const nonnull = \"nonnull\";\n  // aliases\n  export const null_ = \"null\";\n  export const true_ = \"true\";\n  export const false_ = \"false\";\n  // objects\n  export const this_ = \"this\";\n  export const super_ = \"super\";\n  export const constructor = \"constructor\";\n  // constants\n  export const ASC_TARGET = \"ASC_TARGET\";\n  export const ASC_RUNTIME = \"ASC_RUNTIME\";\n  export const ASC_NO_ASSERT = \"ASC_NO_ASSERT\";\n  export const ASC_MEMORY_BASE = \"ASC_MEMORY_BASE\";\n  export const ASC_TABLE_BASE = \"ASC_TABLE_BASE\";\n  export const ASC_OPTIMIZE_LEVEL = \"ASC_OPTIMIZE_LEVEL\";\n  export const ASC_SHRINK_LEVEL = \"ASC_SHRINK_LEVEL\";\n  export const ASC_LOW_MEMORY_LIMIT = \"ASC_LOW_MEMORY_LIMIT\";\n  export const ASC_EXPORT_RUNTIME = \"ASC_EXPORT_RUNTIME\";\n  export const ASC_WASI = \"ASC_WASI\";\n  export const ASC_FEATURE_SIGN_EXTENSION = \"ASC_FEATURE_SIGN_EXTENSION\";\n  export const ASC_FEATURE_MUTABLE_GLOBALS = \"ASC_FEATURE_MUTABLE_GLOBALS\";\n  export const ASC_FEATURE_NONTRAPPING_F2I = \"ASC_FEATURE_NONTRAPPING_F2I\";\n  export const ASC_FEATURE_BULK_MEMORY = \"ASC_FEATURE_BULK_MEMORY\";\n  export const ASC_FEATURE_SIMD = \"ASC_FEATURE_SIMD\";\n  export const ASC_FEATURE_THREADS = \"ASC_FEATURE_THREADS\";\n  export const ASC_FEATURE_EXCEPTION_HANDLING = \"ASC_FEATURE_EXCEPTION_HANDLING\";\n  export const ASC_FEATURE_TAIL_CALLS = \"ASC_FEATURE_TAIL_CALLS\";\n  export const ASC_FEATURE_REFERENCE_TYPES = \"ASC_FEATURE_REFERENCE_TYPES\";\n  export const ASC_FEATURE_MULTI_VALUE = \"ASC_FEATURE_MULTI_VALUE\";\n  export const ASC_FEATURE_GC = \"ASC_FEATURE_GC\";\n  export const ASC_FEATURE_MEMORY64 = \"ASC_FEATURE_MEMORY64\";\n  export const ASC_VERSION_MAJOR = \"ASC_VERSION_MAJOR\";\n  export const ASC_VERSION_MINOR = \"ASC_VERSION_MINOR\";\n  export const ASC_VERSION_PATCH = \"ASC_VERSION_PATCH\";\n  // classes\n  export const I8 = \"I8\";\n  export const I16 = \"I16\";\n  export const I32 = \"I32\";\n  export const I64 = \"I64\";\n  export const Isize = \"Isize\";\n  export const U8 = \"U8\";\n  export const U16 = \"U16\";\n  export const U32 = \"U32\";\n  export const U64 = \"U64\";\n  export const Usize = \"Usize\";\n  export const Bool = \"Bool\";\n  export const F32 = \"F32\";\n  export const F64 = \"F64\";\n  export const V128 = \"V128\";\n  export const Funcref = \"Funcref\";\n  export const Externref = \"Externref\";\n  export const Anyref = \"Anyref\";\n  export const Eqref = \"Eqref\";\n  export const I31ref = \"I31ref\";\n  export const Dataref = \"Dataref\";\n  export const String = \"String\";\n  export const Object = \"Object\";\n  export const Array = \"Array\";\n  export const StaticArray = \"StaticArray\";\n  export const Set = \"Set\";\n  export const Map = \"Map\";\n  export const Function = \"Function\";\n  export const ArrayBufferView = \"ArrayBufferView\";\n  export const ArrayBuffer = \"ArrayBuffer\";\n  export const Math = \"Math\";\n  export const Mathf = \"Mathf\";\n  export const NativeMath = \"NativeMath\";\n  export const NativeMathf = \"NativeMathf\";\n  export const Int8Array = \"Int8Array\";\n  export const Int16Array = \"Int16Array\";\n  export const Int32Array = \"Int32Array\";\n  export const Int64Array = \"Int64Array\";\n  export const Uint8Array = \"Uint8Array\";\n  export const Uint8ClampedArray = \"Uint8ClampedArray\";\n  export const Uint16Array = \"Uint16Array\";\n  export const Uint32Array = \"Uint32Array\";\n  export const Uint64Array = \"Uint64Array\";\n  export const Float32Array = \"Float32Array\";\n  export const Float64Array = \"Float64Array\";\n  export const TemplateStringsArray = \"TemplateStringsArray\";\n  export const Error = \"Error\";\n  // runtime\n  export const abort = \"abort\";\n  export const trace = \"trace\";\n  export const seed = \"seed\";\n  export const pow = \"pow\";\n  export const ipow32 = \"ipow32\";\n  export const ipow64 = \"ipow64\";\n  export const mod = \"mod\";\n  export const alloc = \"__alloc\";\n  export const realloc = \"__realloc\";\n  export const free = \"__free\";\n  export const new_ = \"__new\";\n  export const renew = \"__renew\";\n  export const link = \"__link\";\n  export const collect = \"__collect\";\n  export const typeinfo = \"__typeinfo\";\n  export const instanceof_ = \"__instanceof\";\n  export const visit = \"__visit\";\n  export const newBuffer = \"__newBuffer\";\n  export const newArray = \"__newArray\";\n  export const BLOCK = \"~lib/rt/common/BLOCK\";\n  export const OBJECT = \"~lib/rt/common/OBJECT\";\n}\n\n// shared\nexport { Feature, featureToString } from \"../std/assembly/shared/feature\";\nexport { Target } from \"../std/assembly/shared/target\";\nexport { Runtime } from \"../std/assembly/shared/runtime\";\nexport { Typeinfo, TypeinfoFlags } from \"../std/assembly/shared/typeinfo\";\n","/**\n * @fileoverview The AssemblyScript compiler.\n * @license Apache-2.0\n */\n\nimport {\n  BuiltinNames,\n  BuiltinContext,\n  builtins,\n  function_builtins,\n  compileVisitGlobals,\n  compileVisitMembers,\n  compileRTTI,\n  compileClassInstanceOf\n} from \"./builtins\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Module,\n  MemorySegment,\n  ExpressionRef,\n  UnaryOp,\n  BinaryOp,\n  RefIsOp,\n  TypeRef,\n  FunctionRef,\n  ExpressionId,\n  GlobalRef,\n  FeatureFlags,\n  Index,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI32,\n  getConstValueI64Low,\n  getConstValueI64High,\n  getConstValueF32,\n  getConstValueF64,\n  getBlockChildCount,\n  getBlockChildAt,\n  getBlockName,\n  needsExplicitUnreachable,\n  getLocalSetValue,\n  getGlobalGetName,\n  isGlobalMutable,\n  createType,\n  getSideEffects,\n  SideEffects,\n  SwitchBuilder,\n  ExpressionRunnerFlags,\n  isConstZero\n} from \"./module\";\n\nimport {\n  CommonFlags,\n  INSTANCE_DELIMITER,\n  STATIC_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INDEX_SUFFIX,\n  CommonNames,\n  Feature,\n  Target,\n  Runtime,\n  featureToString\n} from \"./common\";\n\nimport {\n  Program,\n  ClassPrototype,\n  Class,\n  Element,\n  ElementKind,\n  Enum,\n  Field,\n  FunctionPrototype,\n  Function,\n  Global,\n  Local,\n  EnumValue,\n  Property,\n  VariableLikeElement,\n  ConstantValueKind,\n  OperatorKind,\n  DecoratorFlags,\n  PropertyPrototype,\n  IndexSignature,\n  File,\n  mangleInternalName\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  Flow,\n  LocalFlags,\n  FieldFlags,\n  ConditionKind,\n  findUsedLocals\n} from \"./flow\";\n\nimport {\n  Resolver,\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  Token,\n  Range,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  DecoratorKind,\n  AssertionKind,\n  SourceKind,\n  FunctionTypeNode,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DoStatement,\n  EmptyStatement,\n  EnumDeclaration,\n  ExportDefaultStatement,\n  ExportStatement,\n  ExpressionStatement,\n  FieldDeclaration,\n  ForStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  NamespaceDeclaration,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  VoidStatement,\n  WhileStatement,\n\n  Expression,\n  AssertionExpression,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FloatLiteralExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  IntegerLiteralExpression,\n  LiteralExpression,\n  LiteralKind,\n  NewExpression,\n  ObjectLiteralExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  ArrayLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  UnaryPostfixExpression,\n  UnaryPrefixExpression,\n  CompiledExpression,\n\n  TypeNode,\n  NamedTypeNode,\n\n  findDecorator,\n  isTypeOmitted\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags,\n  Signature,\n  typesToRefs\n} from \"./types\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeI64,\n  writeF32,\n  writeF64,\n  uniqueMap,\n  isPowerOf2,\n  v128_zero,\n  readI32\n} from \"./util\";\n\nimport {\n  RtraceMemory\n} from \"./passes/rtrace\";\n\nimport {\n  ShadowStackPass\n} from \"./passes/shadowstack\";\n\n/** Compiler options. */\nexport class Options {\n\n  /** WebAssembly target. Defaults to {@link Target.WASM32}. */\n  target: Target = Target.WASM32;\n  /** Runtime type. Defaults to Incremental GC. */\n  runtime: Runtime = Runtime.Incremental;\n  /** If true, replaces assertions with nops. */\n  noAssert: bool = false;\n  /** It true, exports the memory to the embedder. */\n  exportMemory: bool = true;\n  /** If true, imports the memory provided by the embedder. */\n  importMemory: bool = false;\n  /** Initial memory size, in pages. */\n  initialMemory: u32 = 0;\n  /** Maximum memory size, in pages. */\n  maximumMemory: u32 = 0;\n  /** If true, memory is declared as shared. */\n  sharedMemory: bool = false;\n  /** If true, imported memory is zero filled. */\n  zeroFilledMemory: bool = false;\n  /** If true, imports the function table provided by the embedder. */\n  importTable: bool = false;\n  /** If true, exports the function table. */\n  exportTable: bool = false;\n  /** If true, generates information necessary for source maps. */\n  sourceMap: bool = false;\n  /** If true, generates an explicit start function. */\n  explicitStart: bool = false;\n  /** Static memory start offset. */\n  memoryBase: u32 = 0;\n  /** Static table start offset. */\n  tableBase: u32 = 0;\n  /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */\n  globalAliases: Map<string,string> | null = null;\n  /** Features to activate by default. These are the finished proposals. */\n  features: Feature = Feature.MUTABLE_GLOBALS | Feature.SIGN_EXTENSION;\n  /** If true, disallows unsafe features in user code. */\n  noUnsafe: bool = false;\n  /** If true, enables pedantic diagnostics. */\n  pedantic: bool = false;\n  /** Indicates a very low (<64k) memory limit. */\n  lowMemoryLimit: u32 = 0;\n  /** If true, exports the runtime helpers. */\n  exportRuntime: bool = false;\n  /** Stack size in bytes, if using a stack. */\n  stackSize: i32 = 0;\n  /** Semantic major bundle version from root package.json */\n  bundleMajorVersion: i32 = 0;\n  /** Semantic minor bundle version from root package.json */\n  bundleMinorVersion: i32 = 0;\n  /** Semantic patch bundle version from root package.json */\n  bundlePatchVersion: i32 = 0;\n\n  /** Hinted optimize level. Not applied by the compiler itself. */\n  optimizeLevelHint: i32 = 0;\n  /** Hinted shrink level. Not applied by the compiler itself. */\n  shrinkLevelHint: i32 = 0;\n\n  /** Tests if the target is WASM64 or, otherwise, WASM32. */\n  get isWasm64(): bool {\n    return this.target == Target.WASM64;\n  }\n\n  /** Gets the unsigned size type matching the target. */\n  get usizeType(): Type {\n    return this.target == Target.WASM64 ? Type.usize64 : Type.usize32;\n  }\n\n  /** Gets the signed size type matching the target. */\n  get isizeType(): Type {\n    return this.target == Target.WASM64 ? Type.isize64 : Type.isize32;\n  }\n\n  /** Gets the size type reference matching the target. */\n  get sizeTypeRef(): TypeRef {\n    return this.target == Target.WASM64 ? TypeRef.I64 : TypeRef.I32;\n  }\n\n  /** Gets if any optimizations will be performed. */\n  get willOptimize(): bool {\n    return this.optimizeLevelHint > 0 || this.shrinkLevelHint > 0;\n  }\n\n  /** Tests if a specific feature is activated. */\n  hasFeature(feature: Feature): bool {\n    return (this.features & feature) != 0;\n  }\n}\n\n/** Various constraints in expression compilation. */\nexport const enum Constraints {\n  NONE = 0,\n\n  /** Must implicitly convert to the target type. */\n  CONV_IMPLICIT = 1 << 0,\n  /** Must explicitly convert to the target type. */\n  CONV_EXPLICIT = 1 << 1,\n  /** Must wrap small integer values to match the target type. */\n  MUST_WRAP = 1 << 2,\n\n  /** Indicates that the value will be dropped immediately. */\n  WILL_DROP = 1 << 3,\n  /** Indicates that static data is preferred. */\n  PREFER_STATIC = 1 << 4,\n  /** Indicates that the value will become `this` of a property access or instance call. */\n  IS_THIS = 1 << 5\n}\n\n/** Runtime features to be activated by the compiler. */\nexport const enum RuntimeFeatures {\n  NONE = 0,\n  /** Requires data setup. */\n  DATA = 1 << 0,\n  /** Requires a stack. */\n  STACK = 1 << 1,\n  /** Requires heap setup. */\n  HEAP = 1 << 2,\n  /** Requires runtime type information setup. */\n  RTTI = 1 << 3,\n  /** Requires the built-in globals visitor. */\n  visitGlobals = 1 << 4,\n  /** Requires the built-in members visitor. */\n  visitMembers = 1 << 5,\n  /** Requires the setArgumentsLength export. */\n  setArgumentsLength = 1 << 6\n}\n\n/** Exported names of compiler-generated elements. */\nexport namespace ExportNames {\n  /** Name of the explicit start function, if applicable. */\n  export const start = \"_start\"; // match WASI\n  /** Name of the argumentsLength varargs helper global. */\n  export const argumentsLength = \"__argumentsLength\";\n  /** Name of the alternative argumentsLength setter function. */\n  export const setArgumentsLength = \"__setArgumentsLength\";\n  /** Name of the memory instance, if exported. */\n  export const memory = \"memory\";\n  /** Name of the table instance, if exported. */\n  export const table = \"table\";\n}\n\n/** Functions to export if `--exportRuntime` is set. */\nconst runtimeFunctions = [ \"__new\", \"__pin\", \"__unpin\", \"__collect\" ];\n/** Globals to export if `--exportRuntime` is set. */\nconst runtimeGlobals = [ \"__rtti_base\" ];\n\n/** Compiler interface. */\nexport class Compiler extends DiagnosticEmitter {\n\n  /** Program reference. */\n  program: Program;\n  /** Resolver reference. */\n  get resolver(): Resolver { return this.program.resolver; }\n  /** Provided options. */\n  get options(): Options { return this.program.options; }\n  /** Module instance being compiled. */\n  module: Module;\n\n  /** Current control flow. */\n  currentFlow: Flow;\n  /** Current parent element if not a function, i.e. an enum or namespace. */\n  currentParent: Element | null = null;\n  /** Current type in compilation. */\n  currentType: Type = Type.void;\n  /** Start function statements. */\n  currentBody: ExpressionRef[];\n  /** Counting memory offset. */\n  memoryOffset: i64;\n  /** Memory segments being compiled. */\n  memorySegments: MemorySegment[] = [];\n  /** Map of already compiled static string segments. */\n  stringSegments: Map<string,MemorySegment> = new Map();\n  /** Function table being compiled. First elem is blank. */\n  functionTable: Function[] = [];\n  /** Arguments length helper global. */\n  builtinArgumentsLength: GlobalRef = 0;\n  /** Requires runtime features. */\n  runtimeFeatures: RuntimeFeatures = RuntimeFeatures.NONE;\n  /** Current inline functions stack. */\n  inlineStack: Function[] = [];\n  /** Lazily compiled functions. */\n  lazyFunctions: Set<Function> = new Set();\n  /** Pending class-specific instanceof helpers. */\n  pendingClassInstanceOf: Set<ClassPrototype> = new Set();\n  /** Virtually called stubs that may have overloads. */\n  virtualStubs: Set<Function> = new Set();\n  /** Elements currently undergoing compilation. */\n  pendingElements: Set<Element> = new Set();\n  /** Elements, that are module exports, already processed */\n  doneModuleExports: Set<Element> = new Set();\n  /** Shadow stack reference. */\n  shadowStack!: ShadowStackPass;\n\n  /** Compiles a {@link Program} to a {@link Module} using the specified options. */\n  static compile(program: Program): Module {\n    return new Compiler(program).compile();\n  }\n\n  /** Constructs a new compiler for a {@link Program} using the specified options. */\n  constructor(program: Program) {\n    super(program.diagnostics);\n    this.program = program;\n    var options = program.options;\n    var module = Module.create(options.stackSize > 0, options.sizeTypeRef);\n    this.module = module;\n    if (options.memoryBase) {\n      this.memoryOffset = i64_new(options.memoryBase);\n      module.setLowMemoryUnused(false);\n    } else {\n      if (!options.lowMemoryLimit && options.optimizeLevelHint >= 2) {\n        this.memoryOffset = i64_new(1024);\n        module.setLowMemoryUnused(true);\n      } else {\n        this.memoryOffset = i64_new(8);\n        module.setLowMemoryUnused(false);\n      }\n    }\n    var featureFlags: FeatureFlags = 0;\n    if (options.hasFeature(Feature.SIGN_EXTENSION)) featureFlags |= FeatureFlags.SignExt;\n    if (options.hasFeature(Feature.MUTABLE_GLOBALS)) featureFlags |= FeatureFlags.MutableGloabls;\n    if (options.hasFeature(Feature.NONTRAPPING_F2I)) featureFlags |= FeatureFlags.TruncSat;\n    if (options.hasFeature(Feature.BULK_MEMORY)) featureFlags |= FeatureFlags.BulkMemory;\n    if (options.hasFeature(Feature.SIMD)) featureFlags |= FeatureFlags.SIMD;\n    if (options.hasFeature(Feature.THREADS)) featureFlags |= FeatureFlags.Atomics;\n    if (options.hasFeature(Feature.EXCEPTION_HANDLING)) featureFlags |= FeatureFlags.ExceptionHandling;\n    if (options.hasFeature(Feature.TAIL_CALLS)) featureFlags |= FeatureFlags.TailCall;\n    if (options.hasFeature(Feature.REFERENCE_TYPES)) featureFlags |= FeatureFlags.ReferenceTypes;\n    if (options.hasFeature(Feature.MULTI_VALUE)) featureFlags |= FeatureFlags.MultiValue;\n    if (options.hasFeature(Feature.GC)) featureFlags |= FeatureFlags.GC;\n    if (options.hasFeature(Feature.MEMORY64)) featureFlags |= FeatureFlags.Memory64;\n    module.setFeatures(featureFlags);\n\n    // set up the main start function\n    var startFunctionInstance = program.makeNativeFunction(BuiltinNames.start, new Signature(program, [], Type.void));\n    startFunctionInstance.internalName = BuiltinNames.start;\n    this.currentFlow = startFunctionInstance.flow;\n    this.currentBody = new Array<ExpressionRef>();\n    this.shadowStack = new ShadowStackPass(this);\n  }\n\n  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\n  compile(): Module {\n    var options = this.options;\n    var module = this.module;\n    var program = this.program;\n    var resolver = this.resolver;\n    var hasShadowStack = options.stackSize > 0; // implies runtime=incremental\n\n    // initialize lookup maps, built-ins, imports, exports, etc.\n    this.program.initialize();\n\n    // obtain the main start function\n    var startFunctionInstance = this.currentFlow.actualFunction;\n    assert(startFunctionInstance.internalName == BuiltinNames.start);\n    var startFunctionBody = this.currentBody;\n    assert(startFunctionBody.length == 0);\n\n    // add mutable data, heap and rtti offset dummies\n    if (options.isWasm64) {\n      module.addGlobal(BuiltinNames.data_end, TypeRef.I64, true, module.i64(0));\n      module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, true, module.i64(0));\n      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, true, module.i64(0));\n    } else {\n      module.addGlobal(BuiltinNames.data_end, TypeRef.I32, true, module.i32(0));\n      module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, true, module.i32(0));\n      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, true, module.i32(0));\n    }\n\n    // compile entry file(s) while traversing reachable elements\n    var files = program.filesByName;\n    // TODO: for (let file of files.values()) {\n    for (let _values = Map_values(files), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) {\n        this.compileFile(file);\n        this.compileExports(file);\n      }\n    }\n\n    // set up module exports\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.ensureModuleExports(file);\n    }\n\n    // compile and export runtime if requested\n    if (this.options.exportRuntime) {\n      for (let i = 0, k = runtimeFunctions.length; i < k; ++i) {\n        let name = runtimeFunctions[i];\n        let instance = program.requireFunction(name);\n        if (this.compileFunction(instance) && !module.hasExport(name)) {\n          module.addFunctionExport(instance.internalName, name);\n        }\n      }\n      for (let i = 0, k = runtimeGlobals.length; i < k; ++i) {\n        let name = runtimeGlobals[i];\n        let instance = program.requireGlobal(name);\n        if (this.compileGlobal(instance) && !module.hasExport(name)) {\n          module.addGlobalExport(instance.internalName, name);\n        }\n      }\n    }\n\n    // compile lazy functions\n    var lazyFunctions = this.lazyFunctions;\n    do {\n      let functionsToCompile = new Array<Function>();\n      // TODO: for (let instance of lazyLibraryFunctions) {\n      for (let _values = Set_values(lazyFunctions), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        functionsToCompile.push(instance);\n      }\n      lazyFunctions.clear();\n      for (let i = 0, k = functionsToCompile.length; i < k; ++i) {\n        this.compileFunction(unchecked(functionsToCompile[i]), true);\n      }\n    } while (lazyFunctions.size);\n\n    // compile pending class-specific instanceof helpers\n    // TODO: for (let prototype of this.pendingClassInstanceOf.values()) {\n    for (let _values = Set_values(this.pendingClassInstanceOf), i = 0, k = _values.length; i < k; ++i) {\n      let prototype = unchecked(_values[i]);\n      compileClassInstanceOf(this, prototype);\n    }\n\n    // set up virtual stubs\n    var functionTable = this.functionTable;\n    var virtualStubs = this.virtualStubs;\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      let instance = functionTable[i];\n      if (instance.is(CommonFlags.VIRTUAL)) {\n        assert(instance.is(CommonFlags.INSTANCE));\n        functionTable[i] = this.ensureVirtualStub(instance); // includes varargs stub\n      } else if (instance.signature.requiredParameters < instance.signature.parameterTypes.length) {\n        functionTable[i] = this.ensureVarargsStub(instance);\n      }\n    }\n    var virtualStubsSeen = new Set<Function>();\n    do {\n      // virtual stubs and overloads have cross-dependencies on each other, in that compiling\n      // either may discover the respective other. do this in a loop until no more are found.\n      resolver.discoveredOverload = false;\n      for (let _values = Set_values(virtualStubs), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        let overloadInstances = resolver.resolveOverloads(instance);\n        if (overloadInstances) {\n          for (let i = 0, k = overloadInstances.length; i < k; ++i) {\n            this.compileFunction(overloadInstances[i]);\n          }\n        }\n        virtualStubsSeen.add(instance);\n      }\n    } while (virtualStubs.size > virtualStubsSeen.size || resolver.discoveredOverload);\n    virtualStubsSeen.clear();\n    for (let _values = Set_values(virtualStubs), i = 0, k = _values.length; i < k; ++i) {\n      this.finalizeVirtualStub(_values[i]);\n    }\n\n    // finalize runtime features\n    module.removeGlobal(BuiltinNames.rtti_base);\n    if (this.runtimeFeatures & RuntimeFeatures.RTTI) compileRTTI(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitGlobals) compileVisitGlobals(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitMembers) compileVisitMembers(this);\n\n    var memoryOffset = i64_align(this.memoryOffset, options.usizeType.byteSize);\n\n    // finalize data\n    module.removeGlobal(BuiltinNames.data_end);\n    if ((this.runtimeFeatures & RuntimeFeatures.DATA) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize stack (grows down from __heap_base to __data_end)\n    module.removeGlobal(BuiltinNames.stack_pointer);\n    if ((this.runtimeFeatures & RuntimeFeatures.STACK) != 0 || hasShadowStack) {\n      memoryOffset = i64_align(\n        i64_add(memoryOffset, i64_new(options.stackSize)),\n        options.usizeType.byteSize\n      );\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I64, true,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I32, true,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // finalize heap\n    module.removeGlobal(BuiltinNames.heap_base);\n    if ((this.runtimeFeatures & RuntimeFeatures.HEAP) != 0 || hasShadowStack) {\n      if (options.isWasm64) {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    this.memoryOffset = memoryOffset;\n\n    // check that we didn't exceed lowMemoryLimit already\n    var lowMemoryLimit32 = this.options.lowMemoryLimit;\n    if (lowMemoryLimit32) {\n      let lowMemoryLimit = i64_new(lowMemoryLimit32 & ~15);\n      if (i64_gt(memoryOffset, lowMemoryLimit)) {\n        this.error(\n          DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,\n          null, i64_to_string(memoryOffset), i64_to_string(lowMemoryLimit)\n        );\n      }\n    }\n\n    // set up memory\n    var initialPages: u32 = 0;\n    if (this.options.memoryBase /* is specified */ || this.memorySegments.length) {\n      initialPages = u32(i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16))));\n    }\n    if (options.initialMemory) {\n      if (options.initialMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        initialPages = options.initialMemory;\n      }\n    }\n    var maximumPages = Module.UNLIMITED_MEMORY;\n    if (options.maximumMemory) {\n      if (options.maximumMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        maximumPages = options.maximumMemory;\n      }\n    }\n    var isSharedMemory = false;\n    if (options.sharedMemory) {\n      isSharedMemory = true;\n      if (!options.maximumMemory) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,\n          null\n        );\n        isSharedMemory = false;\n      }\n      if (!options.hasFeature(Feature.THREADS)) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,\n          null\n        );\n        isSharedMemory = false;\n      }\n    }\n    module.setMemory(\n      initialPages,\n      maximumPages,\n      this.memorySegments,\n      options.target,\n      options.exportMemory ? ExportNames.memory : null,\n      isSharedMemory\n    );\n\n    // import memory if requested (default memory is named '0' by Binaryen)\n    if (options.importMemory) module.addMemoryImport(\"0\", \"env\", \"memory\", isSharedMemory);\n\n    // import and/or export table if requested (default table is named '0' by Binaryen)\n    if (options.importTable) {\n      module.addTableImport(\"0\", \"env\", \"table\");\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n    if (options.exportTable) {\n      module.addTableExport(\"0\", ExportNames.table);\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n\n    // set up function table (first elem is blank)\n    var tableBase = this.options.tableBase;\n    if (!tableBase) tableBase = 1; // leave first elem blank\n    var functionTableNames = new Array<string>(functionTable.length);\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      functionTableNames[i] = functionTable[i].internalName;\n    }\n    module.addFunctionTable(\"0\", tableBase + functionTable.length, Module.UNLIMITED_TABLE, functionTableNames, module.i32(tableBase));\n\n    // expose the arguments length helper if there are varargs exports\n    if (this.runtimeFeatures & RuntimeFeatures.setArgumentsLength) {\n      module.addFunction(BuiltinNames.setArgumentsLength, TypeRef.I32, TypeRef.None, null,\n        module.global_set(this.ensureArgumentsLength(), module.local_get(0, TypeRef.I32))\n      );\n      module.addFunctionExport(BuiltinNames.setArgumentsLength, ExportNames.setArgumentsLength);\n    }\n\n    // NOTE: no more element compiles from here. may go to the start function!\n\n    // compile the start function if not empty or if explicitly requested\n    var startIsEmpty = !startFunctionBody.length;\n    var explicitStart = program.isWasi || options.explicitStart;\n    if (!startIsEmpty || explicitStart) {\n      let signature = startFunctionInstance.signature;\n      if (!startIsEmpty && explicitStart) {\n        module.addGlobal(BuiltinNames.started, TypeRef.I32, true, module.i32(0));\n        startFunctionBody.unshift(\n          module.global_set(BuiltinNames.started, module.i32(1))\n        );\n        startFunctionBody.unshift(\n          module.if(\n            module.global_get(BuiltinNames.started, TypeRef.I32),\n            module.return()\n          )\n        );\n      }\n      let funcRef = module.addFunction(\n        startFunctionInstance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(startFunctionInstance.additionalLocals),\n        module.flatten(startFunctionBody)\n      );\n      startFunctionInstance.finalize(module, funcRef);\n      if (!explicitStart) module.setStart(funcRef);\n      else module.addFunctionExport(startFunctionInstance.internalName, ExportNames.start);\n    }\n\n    // Run custom passes\n    if (hasShadowStack) {\n      this.shadowStack.walkModule();\n    }\n    if (program.lookup(\"ASC_RTRACE\") != null) {\n      new RtraceMemory(this).walkModule();\n    }\n\n    return module;\n  }\n\n  // === Exports ==================================================================================\n\n  /** Applies the respective module exports for the specified file. */\n  private ensureModuleExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let [elementName, element] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let elementName = unchecked(_keys[i]);\n        let element = assert(exports.get(elementName));\n        this.ensureModuleExport(elementName, element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar)  {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.ensureModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Applies the respective module export(s) for the specified element. */\n  private ensureModuleExport(name: string, element: Element, prefix: string = \"\"): void {\n    var module = this.module;\n    switch (element.kind) {\n\n      // traverse instances\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>element;\n        let functionInstances = functionPrototype.instances;\n        if (functionInstances !== null && functionInstances.size > 0) {\n          // TODO: for (let instance of instances.values()) {\n          for (let _values = Map_values(functionInstances), i = 0, k = _values.length; i < k; ++i) {\n            let instance = unchecked(_values[i]);\n            let instanceName = name;\n            if (instance.is(CommonFlags.GENERIC)) {\n              let fullName = instance.internalName;\n              instanceName += fullName.substring(fullName.lastIndexOf(\"<\"));\n            }\n            this.ensureModuleExport(instanceName, instance, prefix);\n          }\n        } else if (functionPrototype.is(CommonFlags.GENERIC)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,\n              functionPrototype.identifierNode.range\n            );\n          }\n        }\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        let classPrototype = <ClassPrototype>element;\n        let classInstances = classPrototype.instances;\n        if (classInstances !== null && classInstances.size > 0) {\n          // TODO: for (let instance of instances.values()) {\n          for (let _values = Map_values(classInstances), i = 0, k = _values.length; i < k; ++i) {\n            let instance = unchecked(_values[i]);\n            let instanceName = name;\n            if (instance.is(CommonFlags.GENERIC)) {\n              let fullName = instance.internalName;\n              instanceName += fullName.substring(fullName.lastIndexOf(\"<\"));\n            }\n            this.ensureModuleExport(instanceName, instance, prefix);\n          }\n        } else if (classPrototype.is(CommonFlags.GENERIC)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,\n              classPrototype.identifierNode.range\n            );\n          }\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (propertyInstance) this.ensureModuleExport(name, propertyInstance, prefix);\n        break;\n      }\n\n      // export concrete elements\n      case ElementKind.GLOBAL: {\n        let global = <Global>element;\n        let isConst = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);\n        if (!isConst && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n          this.error(\n            DiagnosticCode.Cannot_export_a_mutable_global,\n            global.identifierNode.range\n          );\n        } else if (global.is(CommonFlags.COMPILED)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n          }\n        }\n        break;\n      }\n      case ElementKind.ENUMVALUE: {\n        let enumValue = <EnumValue>element;\n        if (!enumValue.isImmutable && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n          this.error(\n            DiagnosticCode.Cannot_export_a_mutable_global,\n            enumValue.identifierNode.range\n          );\n        } else if (enumValue.is(CommonFlags.COMPILED)) {\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(element.internalName, exportName);\n          }\n        }\n        break;\n      }\n      case ElementKind.FUNCTION: {\n        let functionInstance = <Function>element;\n        if (!functionInstance.hasDecorator(DecoratorFlags.BUILTIN)) {\n          let signature = functionInstance.signature;\n          if (signature.requiredParameters < signature.parameterTypes.length) {\n            // utilize varargs stub to fill in omitted arguments\n            functionInstance = this.ensureVarargsStub(functionInstance);\n            this.runtimeFeatures |= RuntimeFeatures.setArgumentsLength;\n          }\n          if (functionInstance.is(CommonFlags.COMPILED)) {\n            let exportName = prefix + name;\n            if (!module.hasExport(exportName)) {\n              module.addFunctionExport(functionInstance.internalName, exportName);\n              if (signature.hasManagedOperands) {\n                this.shadowStack.noteExport(exportName, signature.getManagedOperandIndices());\n              }\n            }\n          }\n        }\n        break;\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.ensureModuleExport(GETTER_PREFIX + name, getterInstance, prefix);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.ensureModuleExport(SETTER_PREFIX + name, setterInstance, prefix);\n        break;\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>element;\n        if (element.is(CommonFlags.COMPILED)) {\n          let getterExportName = prefix + GETTER_PREFIX + name;\n          if (this.compileFieldGetter(fieldInstance) && !module.hasExport(getterExportName)) {\n            module.addFunctionExport(fieldInstance.internalGetterName, getterExportName);\n            let signature = fieldInstance.internalGetterSignature;\n            if (signature.hasManagedOperands) {\n              this.shadowStack.noteExport(getterExportName, signature.getManagedOperandIndices());\n            }\n          }\n          if (!element.is(CommonFlags.READONLY)) {\n            let setterExportName = prefix + SETTER_PREFIX + name;\n            if (this.compileFieldSetter(fieldInstance) && !module.hasExport(setterExportName)) {\n              module.addFunctionExport(fieldInstance.internalSetterName, setterExportName);\n              let signature = fieldInstance.internalSetterSignature;\n              if (signature.hasManagedOperands) {\n                this.shadowStack.noteExport(setterExportName, signature.getManagedOperandIndices());\n              }\n            }\n          }\n        }\n        break;\n      }\n      case ElementKind.CLASS: {\n        let classInstance = <Class>element;\n        // make the class name itself represent its runtime id\n        if (!classInstance.type.isUnmanaged) {\n          let module = this.module;\n          let internalName = classInstance.internalName;\n\n          if (!this.doneModuleExports.has(element)) {\n            module.addGlobal(internalName, TypeRef.I32, false, module.i32(classInstance.id));\n            this.doneModuleExports.add(element);\n          }\n\n          let exportName = prefix + name;\n          if (!module.hasExport(exportName)) {\n            module.addGlobalExport(internalName, exportName);\n          }\n        }\n        break;\n      }\n\n      // just traverse members below\n      case ElementKind.ENUM:\n      case ElementKind.INTERFACE_PROTOTYPE:\n      case ElementKind.NAMESPACE:\n      case ElementKind.TYPEDEFINITION:\n      case ElementKind.INDEXSIGNATURE: break;\n\n      default: assert(false); // unexpected module export\n    }\n\n    // traverse members\n    var members = element.members;\n    if (members) {\n      let subPrefix = prefix + name + (element.kind == ElementKind.CLASS\n        ? INSTANCE_DELIMITER\n        : STATIC_DELIMITER\n      );\n      if (element.kind == ElementKind.NAMESPACE) {\n        let implicitExport = element.is(CommonFlags.SCOPED);\n        // TODO: for (let [memberName, member] of members) {\n        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(members.get(memberName));\n          if (implicitExport || member.is(CommonFlags.EXPORT)) {\n            this.ensureModuleExport(memberName, member, subPrefix);\n          }\n        }\n      } else {\n        // TODO: for (let [memberName, member] of members) {\n        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(members.get(memberName));\n          if (!member.is(CommonFlags.PRIVATE)) {\n            this.ensureModuleExport(memberName, member, subPrefix);\n          }\n        }\n      }\n    }\n  }\n\n  // === Elements =================================================================================\n\n  /** Compiles any element. */\n  compileElement(element: Element, compileMembers: bool = true): void {\n    switch (element.kind) {\n      case ElementKind.GLOBAL: {\n        this.compileGlobal(<Global>element);\n        break;\n      }\n      case ElementKind.ENUM: {\n        this.compileEnum(<Enum>element);\n        break;\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        if (!element.is(CommonFlags.GENERIC)) {\n          let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n          if (functionInstance) this.compileFunction(functionInstance);\n        }\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        if (!element.is(CommonFlags.GENERIC)) {\n          let classInstance = this.resolver.resolveClass(<ClassPrototype>element, null);\n          if (classInstance) this.compileClass(classInstance);\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n        if (propertyInstance) this.compileProperty(propertyInstance);\n        break;\n      }\n      case ElementKind.INTERFACE_PROTOTYPE:\n      case ElementKind.NAMESPACE:\n      case ElementKind.TYPEDEFINITION:\n      case ElementKind.ENUMVALUE:\n      case ElementKind.INDEXSIGNATURE: break;\n      default: assert(false);\n    }\n    if (compileMembers) {\n      let members = element.members;\n      if (members) {\n        // TODO: for (let element of members.values()) {\n        for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n          let element = unchecked(_values[i]);\n          this.compileElement(element);\n        }\n      }\n    }\n  }\n\n  /** Compiles a file's exports. */\n  compileExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileElement(element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.compileFile(exportStar);\n        this.compileExports(exportStar);\n      }\n    }\n  }\n\n  // files\n\n  /** Compiles the file matching the specified path. */\n  compileFileByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {\n    var file: File;\n    var filesByName = this.program.filesByName;\n    var pathWithIndex: string;\n    if (filesByName.has(normalizedPathWithoutExtension)) {\n      file = assert(filesByName.get(normalizedPathWithoutExtension));\n    } else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + INDEX_SUFFIX)) {\n      file = assert(filesByName.get(pathWithIndex));\n    } else {\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        reportNode.range, normalizedPathWithoutExtension\n      );\n      return;\n    }\n    this.compileFile(file);\n  }\n\n  /** Compiles the specified file. */\n  compileFile(file: File): void {\n    if (file.is(CommonFlags.COMPILED)) return;\n    file.set(CommonFlags.COMPILED);\n\n    // compile top-level statements within the file's start function\n    var startFunction = file.startFunction;\n    var startSignature = startFunction.signature;\n    var previousBody = this.currentBody;\n    var startFunctionBody = new Array<ExpressionRef>();\n    this.currentBody = startFunctionBody;\n\n    // compile top-level statements\n    var previousFlow = this.currentFlow;\n    var flow = startFunction.flow;\n    this.currentFlow = flow;\n    for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {\n      this.compileTopLevelStatement(statements[i], startFunctionBody);\n    }\n    // no need to insert unreachable since last statement should have done that\n    this.currentFlow = previousFlow;\n    this.currentBody = previousBody;\n\n    // if top-level statements are present, make the per-file start function and call it in start\n    if (startFunctionBody.length) {\n      let module = this.module;\n      let locals = startFunction.localsByIndex;\n      let numLocals = locals.length;\n      let varTypes = new Array<TypeRef>(numLocals);\n      for (let i = 0; i < numLocals; ++i) varTypes[i] = locals[i].type.toRef();\n      module.addFunction(\n        startFunction.internalName,\n        startSignature.paramRefs,\n        startSignature.resultRefs,\n        varTypes,\n        module.flatten(startFunctionBody)\n      );\n      previousBody.push(\n        module.call(startFunction.internalName, null, TypeRef.None)\n      );\n    }\n  }\n\n  // === Globals ==================================================================================\n\n  /** Compiles a global variable. */\n  compileGlobal(global: Global): bool {\n    if (global.is(CommonFlags.COMPILED)) return !global.is(CommonFlags.ERRORED);\n    global.set(CommonFlags.COMPILED);\n\n    var pendingElements = this.pendingElements;\n    pendingElements.add(global);\n\n    var module = this.module;\n    var initExpr: ExpressionRef = 0;\n    var typeNode = global.typeNode;\n    var initializerNode = global.initializerNode;\n\n    if (!global.is(CommonFlags.RESOLVED)) {\n\n      // Resolve type if annotated\n      if (typeNode) {\n        let resolvedType = this.resolver.resolveType(typeNode, global.parent); // reports\n        if (!resolvedType) {\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        if (resolvedType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(resolvedType);\n        this.checkTypeSupported(global.type, typeNode);\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, Type.auto, // reports\n          Constraints.MUST_WRAP | Constraints.PREFER_STATIC\n        );\n        this.currentFlow = previousFlow;\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            initializerNode.range, this.currentType.toString(), \"<auto>\"\n          );\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(this.currentType);\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          global.identifierNode.range.atEnd\n        );\n        global.set(CommonFlags.ERRORED);\n        pendingElements.delete(global);\n        return false;\n      }\n    }\n\n    // Handle ambient builtins like '__heap_base' that need to be resolved but are added explicitly\n    if (global.is(CommonFlags.AMBIENT) && global.hasDecorator(DecoratorFlags.BUILTIN)) {\n      let internalName = global.internalName;\n      if (internalName == BuiltinNames.data_end) this.runtimeFeatures |= RuntimeFeatures.DATA;\n      else if (internalName == BuiltinNames.stack_pointer) this.runtimeFeatures |= RuntimeFeatures.STACK;\n      else if (internalName == BuiltinNames.heap_base) this.runtimeFeatures |= RuntimeFeatures.HEAP;\n      else if (internalName == BuiltinNames.rtti_base) this.runtimeFeatures |= RuntimeFeatures.RTTI;\n      pendingElements.delete(global);\n      return true;\n    }\n\n    var type = global.type;\n    var typeRef = type.toRef();\n    var isDeclaredConstant = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);\n    var isDeclaredInline = global.hasDecorator(DecoratorFlags.INLINE);\n\n    // Handle imports\n    if (global.is(CommonFlags.AMBIENT)) {\n\n      // Constant global or mutable globals enabled\n      if (isDeclaredConstant || this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n        global.set(CommonFlags.MODULE_IMPORT);\n        mangleImportName(global, global.declaration);\n        module.addGlobalImport(\n          global.internalName,\n          mangleImportName_moduleName,\n          mangleImportName_elementName,\n          typeRef,\n          !isDeclaredConstant\n        );\n        pendingElements.delete(global);\n        return true;\n      }\n\n      // Importing mutable globals is not supported in the MVP\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        global.declaration.range, \"mutable-globals\"\n      );\n      global.set(CommonFlags.ERRORED);\n      pendingElements.delete(global);\n      return false;\n    }\n\n    // The MVP does not yet support initializer expressions other than constants and gets of\n    // imported immutable globals, hence such initializations must be performed in the start.\n    var initializeInStart = false;\n\n    // Evaluate initializer if present\n    if (initializerNode) {\n      if (!initExpr) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, type,\n          Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP | Constraints.PREFER_STATIC\n        );\n        this.currentFlow = previousFlow;\n      }\n\n      // If not a constant, attempt to precompute\n      if (getExpressionId(initExpr) != ExpressionId.Const) {\n        if (isDeclaredConstant) {\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              initializeInStart = true;\n            }\n          }\n        } else {\n          initializeInStart = true;\n        }\n      }\n\n      // Handle special case of initializing from imported immutable global\n      if (initializeInStart && getExpressionId(initExpr) == ExpressionId.GlobalGet) {\n        let fromName = assert(getGlobalGetName(initExpr));\n        if (!isGlobalMutable(module.getGlobal(fromName))) {\n          let elementsByName = this.program.elementsByName;\n          if (elementsByName.has(fromName)) {\n            let global = assert(elementsByName.get(fromName));\n            if (global.is(CommonFlags.AMBIENT)) initializeInStart = false;\n          }\n        }\n      }\n\n      // Explicitly inline if annotated\n      if (isDeclaredInline) {\n        if (initializeInStart) {\n          this.warning(\n            DiagnosticCode.Mutable_value_cannot_be_inlined,\n            initializerNode.range\n          );\n        } else {\n          assert(getExpressionId(initExpr) == ExpressionId.Const);\n          let exprType = getExpressionType(initExpr);\n          switch (<u32>exprType) {\n            case <u32>TypeRef.I32: {\n              global.constantValueKind = ConstantValueKind.INTEGER;\n              global.constantIntegerValue = i64_new(getConstValueI32(initExpr), 0);\n              break;\n            }\n            case <u32>TypeRef.I64: {\n              global.constantValueKind = ConstantValueKind.INTEGER;\n              global.constantIntegerValue = i64_new(\n                getConstValueI64Low(initExpr),\n                getConstValueI64High(initExpr)\n              );\n              break;\n            }\n            case <u32>TypeRef.F32: {\n              global.constantValueKind = ConstantValueKind.FLOAT;\n              global.constantFloatValue = getConstValueF32(initExpr);\n              break;\n            }\n            case <u32>TypeRef.F64: {\n              global.constantValueKind = ConstantValueKind.FLOAT;\n              global.constantFloatValue = getConstValueF64(initExpr);\n              break;\n            }\n            default: {\n              assert(false);\n              global.set(CommonFlags.ERRORED);\n              pendingElements.delete(global);\n              return false;\n            }\n          }\n          global.set(CommonFlags.INLINED); // inline the value from now on\n        }\n      }\n\n    // Initialize to zero if there's no initializer\n    } else {\n      if (global.is(CommonFlags.INLINED)) {\n        initExpr = this.compileInlineConstant(global, global.type, Constraints.PREFER_STATIC);\n      } else {\n        initExpr = this.makeZero(type, global.declaration);\n      }\n    }\n\n    var internalName = global.internalName;\n\n    if (initializeInStart) { // initialize to mutable zero and set the actual value in start\n      if (isDeclaredInline) {\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          findDecorator(DecoratorKind.INLINE, global.decoratorNodes)!.range, \"inline\"\n        );\n      }\n      module.addGlobal(internalName, typeRef, true, this.makeZero(type, global.declaration));\n      this.currentBody.push(\n        module.global_set(internalName, initExpr)\n      );\n    } else if (!isDeclaredInline) { // compile normally\n      module.addGlobal(internalName, typeRef, !isDeclaredConstant, initExpr);\n    }\n    pendingElements.delete(global);\n    return true;\n  }\n\n  // === Enums ====================================================================================\n\n  /** Compiles an enum. */\n  compileEnum(element: Enum): bool {\n    if (element.is(CommonFlags.COMPILED)) return !element.is(CommonFlags.ERRORED);\n    element.set(CommonFlags.COMPILED);\n\n    var pendingElements = this.pendingElements;\n    pendingElements.add(element);\n\n    var module = this.module;\n    var previousParent = this.currentParent;\n    this.currentParent = element;\n    var previousValue: EnumValue | null = null;\n    var previousValueIsMut = false;\n    var isInline = element.is(CommonFlags.CONST) || element.hasDecorator(DecoratorFlags.INLINE);\n\n    var members = element.members;\n    if (members) {\n      // TODO: for (let member of element.members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.ENUMVALUE) continue; // happens if an enum is also a namespace\n        let initInStart = false;\n        let enumValue = <EnumValue>member;\n        let valueNode = enumValue.valueNode;\n        enumValue.set(CommonFlags.COMPILED);\n        let previousFlow = this.currentFlow;\n        if (element.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = element.file.startFunction.flow;\n        }\n        let initExpr: ExpressionRef;\n        if (valueNode) {\n          initExpr = this.compileExpression(valueNode, Type.i32,\n            Constraints.CONV_IMPLICIT\n          );\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.CONST)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  valueNode.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        } else if (previousValue == null) {\n          initExpr = module.i32(0);\n        } else {\n          if (previousValueIsMut) {\n            this.error(\n              DiagnosticCode.Enum_member_must_have_initializer,\n              enumValue.identifierNode.range.atEnd\n            );\n          }\n          if (isInline) {\n            let value = i64_add(previousValue.constantIntegerValue, i64_new(1));\n            assert(!i64_high(value));\n            initExpr = module.i32(i64_low(value));\n          } else {\n            initExpr = module.binary(BinaryOp.AddI32,\n              module.global_get(previousValue.internalName, TypeRef.I32),\n              module.i32(1)\n            );\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.CONST)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  member.declaration.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        }\n        this.currentFlow = previousFlow;\n        if (initInStart) {\n          module.addGlobal(enumValue.internalName, TypeRef.I32, true, module.i32(0));\n          this.currentBody.push(\n            this.makeGlobalAssignment(enumValue, initExpr, Type.i32, false)\n          );\n          previousValueIsMut = true;\n        } else {\n          if (isInline) {\n            enumValue.setConstantIntegerValue(i64_new(getConstValueI32(initExpr)), Type.i32);\n            if (enumValue.is(CommonFlags.MODULE_EXPORT)) {\n              module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n            }\n          } else {\n            module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\n          }\n          enumValue.isImmutable = true;\n          previousValueIsMut = false;\n        }\n        previousValue = enumValue;\n      }\n    }\n    this.currentParent = previousParent;\n    pendingElements.delete(element);\n    return true;\n  }\n\n  // === Functions ================================================================================\n\n  /** Compiles a priorly resolved function. */\n  compileFunction(\n    /** Function to compile. */\n    instance: Function,\n    /** Force compilation of stdlib alternative if a builtin. */\n    forceStdAlternative: bool = false\n  ): bool {\n    if (instance.is(CommonFlags.COMPILED)) return !instance.is(CommonFlags.ERRORED);\n\n    if (!forceStdAlternative) {\n      if (instance.hasDecorator(DecoratorFlags.BUILTIN)) return true;\n      if (instance.hasDecorator(DecoratorFlags.LAZY)) {\n        this.lazyFunctions.add(instance);\n        return true;\n      }\n    }\n\n    // ensure the function hasn't duplicate parameters\n    var parameters = instance.prototype.functionTypeNode.parameters;\n    var numParameters = parameters.length;\n    if (numParameters >= 2) {\n      let visited = new Set<string>();\n      visited.add(parameters[0].name.text);\n      for (let i = 1; i < numParameters; i++) {\n        let paramIdentifier = parameters[i].name;\n        let paramName = paramIdentifier.text;\n        if (!visited.has(paramName)) {\n          visited.add(paramName);\n        } else {\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            paramIdentifier.range, paramName\n          );\n        }\n      }\n    }\n\n    instance.set(CommonFlags.COMPILED);\n    var pendingElements = this.pendingElements;\n    pendingElements.add(instance);\n\n    var previousType = this.currentType;\n    var module = this.module;\n    var signature = instance.signature;\n    var bodyNode = instance.prototype.bodyNode;\n    var declarationNode = instance.declaration;\n    assert(declarationNode.kind == NodeKind.FUNCTIONDECLARATION || declarationNode.kind == NodeKind.METHODDECLARATION);\n    this.checkSignatureSupported(instance.signature, (<FunctionDeclaration>declarationNode).signature);\n\n    var funcRef: FunctionRef;\n\n    // concrete function\n    if (bodyNode) {\n\n      // must not be ambient\n      if (instance.is(CommonFlags.AMBIENT)) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          instance.identifierNode.range\n        );\n      }\n\n      // cannot have an annotated external name\n      if (instance.hasDecorator(DecoratorFlags.EXTERNAL)) {\n        let decoratorNodes = instance.decoratorNodes;\n        let decorator = assert(findDecorator(DecoratorKind.EXTERNAL, decoratorNodes));\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          decorator.range, \"external\"\n        );\n      }\n\n      // compile body in this function's context\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n      let stmts = new Array<ExpressionRef>();\n\n      if (!this.compileFunctionBody(instance, stmts)) {\n        stmts.push(module.unreachable());\n      }\n\n      this.currentFlow = previousFlow;\n\n      // create the function\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        typesToRefs(instance.additionalLocals),\n        module.flatten(stmts, instance.signature.returnType.toRef())\n      );\n\n    // imported function\n    } else if (instance.is(CommonFlags.AMBIENT)) {\n      instance.set(CommonFlags.MODULE_IMPORT);\n      mangleImportName(instance, declarationNode); // TODO: check for duplicates\n      module.addFunctionImport(\n        instance.internalName,\n        mangleImportName_moduleName,\n        mangleImportName_elementName,\n        signature.paramRefs,\n        signature.resultRefs\n      );\n      funcRef = module.getFunction(instance.internalName);\n\n    // abstract or interface function\n    } else if (instance.is(CommonFlags.ABSTRACT) || instance.parent.kind == ElementKind.INTERFACE) {\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        null,\n        module.unreachable()\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        instance.identifierNode.range\n      );\n      funcRef = 0; // TODO?\n      instance.set(CommonFlags.ERRORED);\n    }\n\n    instance.finalize(module, funcRef);\n    this.currentType = previousType;\n    pendingElements.delete(instance);\n    return true;\n  }\n\n  /** Compiles the body of a function within the specified flow. */\n  private compileFunctionBody(\n    /** Function to compile. */\n    instance: Function,\n    /** Target array of statements also being returned. Creates a new array if omitted. */\n    stmts: ExpressionRef[]\n  ): bool {\n    var module = this.module;\n    var bodyNode = assert(instance.prototype.bodyNode);\n    var returnType = instance.signature.returnType;\n    var flow = this.currentFlow;\n    var thisLocal = instance.signature.thisType\n      ? assert(flow.lookupLocal(CommonNames.this_))\n      : null;\n    var bodyStartIndex = stmts.length;\n\n    // compile statements\n    if (bodyNode.kind == NodeKind.BLOCK) {\n      stmts = this.compileStatements((<BlockStatement>bodyNode).statements, true, stmts);\n    } else {\n      // must be an expression statement if not a block\n      assert(bodyNode.kind == NodeKind.EXPRESSION);\n\n      // must be an arrow function\n      assert(instance.prototype.arrowKind);\n\n      // none of the following can be an arrow function\n      assert(!instance.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.GET | CommonFlags.SET));\n\n      let expr = this.compileExpression((<ExpressionStatement>bodyNode).expression, returnType, Constraints.CONV_IMPLICIT);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\n\n      if (!stmts) stmts = [ expr ];\n      else stmts.push(expr);\n\n      if (!flow.is(FlowFlags.TERMINATES)) {\n        if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\n        if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\n        flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);\n      }\n    }\n\n    // Make constructors return their instance pointer, and prepend a conditional\n    // allocation if any code path accesses `this`.\n    if (instance.is(CommonFlags.CONSTRUCTOR)) {\n      assert(instance.is(CommonFlags.INSTANCE));\n      thisLocal = assert(thisLocal);\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n\n      if (flow.isAny(FlowFlags.ACCESSES_THIS | FlowFlags.CONDITIONALLY_ACCESSES_THIS) || !flow.is(FlowFlags.TERMINATES)) {\n\n        // Allocate `this` if not a super call, and initialize fields\n        let allocStmts = new Array<ExpressionRef>();\n        allocStmts.push(\n          this.makeConditionalAllocation(classInstance, thisLocal.index)\n        );\n        this.makeFieldInitializationInConstructor(classInstance, allocStmts);\n\n        // Insert right before the body\n        for (let i = stmts.length - 1; i >= bodyStartIndex; --i) {\n          stmts[i + 1] = stmts[i];\n        }\n        stmts[bodyStartIndex] = module.flatten(allocStmts, TypeRef.None);\n\n        // Just prepended allocation is dropped when returning non-'this'\n        if (flow.is(FlowFlags.MAY_RETURN_NONTHIS)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,\n              instance.identifierNode.range\n            );\n          }\n        }\n      }\n\n      // Returning something else than 'this' would break 'super()' calls\n      if (flow.is(FlowFlags.MAY_RETURN_NONTHIS) && !classInstance.hasDecorator(DecoratorFlags.FINAL)) {\n        this.error(\n          DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,\n          classInstance.identifierNode.range\n        );\n      }\n\n      // Implicitly return `this` if the flow falls through\n      if (!flow.is(FlowFlags.TERMINATES)) {\n        stmts.push(\n          module.local_get(thisLocal.index, this.options.sizeTypeRef)\n        );\n        flow.set(FlowFlags.RETURNS | FlowFlags.RETURNS_NONNULL | FlowFlags.TERMINATES);\n      }\n\n      // check that super has been called if this is a derived class\n      if (classInstance.base !== null && !flow.is(FlowFlags.CALLS_SUPER)) {\n        this.error(\n          DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,\n          instance.prototype.declaration.range\n        );\n      }\n\n    // if this is a normal function, make sure that all branches terminate\n    } else if (returnType != Type.void && !flow.is(FlowFlags.TERMINATES)) {\n      this.error(\n        DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,\n        instance.prototype.functionTypeNode.returnType.range\n      );\n      return false; // not recoverable\n    }\n\n    return true;\n  }\n\n  // === Classes ==================================================================================\n\n  /** Compiles a priorly resolved class. */\n  compileClass(instance: Class): bool {\n    if (instance.is(CommonFlags.COMPILED)) return true;\n    instance.set(CommonFlags.COMPILED);\n    var prototype = instance.prototype;\n    var staticMembers = (<ClassPrototype>prototype).members;\n    if (staticMembers) {\n      // TODO: for (let element of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        switch (element.kind) {\n          case ElementKind.GLOBAL: {\n            this.compileGlobal(<Global>element);\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            if (element.is(CommonFlags.GENERIC)) break;\n            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n            if (!functionInstance) break;\n            element = functionInstance;\n            // fall-through\n          }\n          case ElementKind.FUNCTION: {\n            this.compileFunction(<Function>element);\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n            if (!propertyInstance) break;\n            element = propertyInstance;\n            // fall-through\n          }\n          case ElementKind.PROPERTY: {\n            this.compileProperty(<Property>element);\n            break;\n          }\n        }\n      }\n    }\n    this.ensureConstructor(instance, instance.identifierNode);\n    this.checkFieldInitialization(instance);\n\n    var instanceMembers = instance.members;\n    if (instanceMembers) {\n      // TODO: for (let element of instanceMembers.values()) {\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        switch (element.kind) {\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            if (element.is(CommonFlags.GENERIC)) break;\n            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n            if (!functionInstance) break;\n            element = functionInstance;\n            // fall-through\n          }\n          case ElementKind.FUNCTION: {\n            this.compileFunction(<Function>element);\n            break;\n          }\n          case ElementKind.FIELD: {\n            this.compileField(<Field>element);\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n            if (!propertyInstance) break;\n            element = propertyInstance;\n            // fall-through\n          }\n          case ElementKind.PROPERTY: {\n            this.compileProperty(<Property>element);\n            break;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Compiles an instance field to a getter and a setter. */\n  compileField(instance: Field): bool {\n    this.compileFieldGetter(instance);\n    this.compileFieldSetter(instance);\n    return instance.is(CommonFlags.COMPILED);\n  }\n\n  /** Compiles the getter of the specified instance field. */\n  compileFieldGetter(instance: Field): bool {\n    if (instance.getterRef) return true;\n    var module = this.module;\n    var valueType = instance.type;\n    var valueTypeRef = valueType.toRef();\n    var thisTypeRef = this.options.sizeTypeRef;\n    // return this.field\n    instance.getterRef = module.addFunction(instance.internalGetterName, thisTypeRef, valueTypeRef, null,\n      module.load(valueType.byteSize, valueType.isSignedIntegerValue,\n        module.local_get(0, thisTypeRef),\n        valueTypeRef, instance.memoryOffset\n      )\n    );\n    if (instance.setterRef) {\n      instance.set(CommonFlags.COMPILED);\n    } else {\n      let typeNode = instance.typeNode;\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\n    }\n    return true;\n  }\n\n  /** Compiles the setter of the specified instance field. */\n  compileFieldSetter(instance: Field): bool {\n    if (instance.setterRef) return true;\n    var type = instance.type;\n    var thisTypeRef = this.options.sizeTypeRef;\n    var valueTypeRef = type.toRef();\n    var module = this.module;\n    // void(this.field = value)\n    var bodyExpr = module.store(type.byteSize,\n      module.local_get(0, thisTypeRef),\n      module.local_get(1, valueTypeRef),\n      valueTypeRef, instance.memoryOffset\n    );\n    if (type.isManaged) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.CLASS);\n      if ((<Class>parent).type.isManaged) {\n        let linkInstance = this.program.linkInstance;\n        this.compileFunction(linkInstance);\n        bodyExpr = module.block(null, [\n          bodyExpr,\n          module.call(linkInstance.internalName, [\n            module.local_get(0, thisTypeRef),\n            module.local_get(1, valueTypeRef),\n            module.i32(0)\n          ], TypeRef.None)\n        ], TypeRef.None);\n      }\n    }\n    instance.setterRef = module.addFunction(instance.internalSetterName, createType([ thisTypeRef, valueTypeRef ]), TypeRef.None, null,\n      bodyExpr\n    );\n    if (instance.getterRef) {\n      instance.set(CommonFlags.COMPILED);\n    } else {\n      let typeNode = instance.typeNode;\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\n    }\n    return true;\n  }\n\n  /** Compiles a property to a getter and potentially a setter. */\n  compileProperty(instance: Property): bool {\n    this.compilePropertyGetter(instance);\n    this.compilePropertySetter(instance);\n    return instance.is(CommonFlags.COMPILED);\n  }\n\n  /* Compiles the getter of the specified property. */\n  compilePropertyGetter(instance: Property): bool {\n    var getterInstance = instance.getterInstance;\n    if (getterInstance) {\n      let ret = this.compileFunction(getterInstance);\n      let setterInstance = instance.setterInstance;\n      if (getterInstance.is(CommonFlags.COMPILED) && (!setterInstance || setterInstance.is(CommonFlags.COMPILED))) {\n        instance.set(CommonFlags.COMPILED);\n      }\n      return ret;\n    }\n    return false;\n  }\n\n  /** Compiles the setter of the specified property. */\n  compilePropertySetter(instance: Property): bool {\n    var setterInstance = instance.setterInstance;\n    if (setterInstance) {\n      let ret = this.compileFunction(setterInstance);\n      let getterInstance = instance.getterInstance;\n      if (getterInstance !== null && getterInstance.is(CommonFlags.COMPILED) && setterInstance.is(CommonFlags.COMPILED)) {\n        instance.set(CommonFlags.COMPILED);\n      }\n      return ret;\n    }\n    return false;\n  }\n\n  // === Memory ===================================================================================\n\n  /** Adds a static memory segment with the specified data. */\n  addAlignedMemorySegment(buffer: Uint8Array, alignment: i32 = 16): MemorySegment {\n    assert(isPowerOf2(alignment));\n    var memoryOffset = i64_align(this.memoryOffset, alignment);\n    var segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Adds a static memory segment representing a runtime object. */\n  addRuntimeMemorySegment(buffer: Uint8Array): MemorySegment {\n    var memoryOffset = this.program.computeBlockStart64(this.memoryOffset);\n    var segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\n    return segment;\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer expression. Deduplicates. */\n  ensureStaticString(stringValue: string): ExpressionRef {\n    var ptr = this.ensureStaticStringPtr(stringValue);\n    this.currentType = this.program.stringInstance.type;\n    return this.module.usize(ptr);\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer to it. Deduplicates. */\n  ensureStaticStringPtr(stringValue: string): i64 {\n    var program = this.program;\n    var totalOverhead = program.totalOverhead;\n    var stringInstance = assert(program.stringInstance);\n    var stringSegment: MemorySegment;\n    var segments = this.stringSegments;\n    if (segments.has(stringValue)) {\n      stringSegment = assert(segments.get(stringValue)); // reuse\n    } else {\n      let len = stringValue.length;\n      let buf = stringInstance.createBuffer(len << 1);\n      for (let i = 0; i < len; ++i) {\n        writeI16(stringValue.charCodeAt(i), buf, totalOverhead + (i << 1));\n      }\n      stringSegment = this.addRuntimeMemorySegment(buf);\n      segments.set(stringValue, stringSegment);\n    }\n    return i64_add(stringSegment.offset, i64_new(totalOverhead));\n  }\n\n  /** Writes a series of static values of the specified type to a buffer. */\n  writeStaticBuffer(buf: Uint8Array, pos: i32, elementType: Type, values: ExpressionRef[]): i32 {\n    var length = values.length;\n    var byteSize = elementType.byteSize;\n    var elementTypeRef = elementType.toRef();\n    switch (<u32>elementTypeRef) {\n      case <u32>TypeRef.I32: {\n        switch (byteSize) {\n          case 1: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI8(getConstValueI32(value), buf, pos);\n              pos += 1;\n            }\n            break;\n          }\n          case 2: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI16(getConstValueI32(value), buf, pos);\n              pos += 2;\n            }\n            break;\n          }\n          case 4: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == elementTypeRef);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI32(getConstValueI32(value), buf, pos);\n              pos += 4;\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeI64(i64_new(getConstValueI64Low(value), getConstValueI64High(value)), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF32(getConstValueF32(value), buf, pos);\n          pos += 4;\n        }\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == elementTypeRef);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF64(getConstValueF64(value), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      default: assert(false);\n    }\n    return pos;\n  }\n\n  /** Adds a buffer to static memory and returns the created segment. */\n  addStaticBuffer(elementType: Type, values: ExpressionRef[], id: u32 = this.program.arrayBufferInstance.id): MemorySegment {\n    var program = this.program;\n    var arrayBufferInstance = program.arrayBufferInstance;\n    var buf = arrayBufferInstance.createBuffer(values.length * elementType.byteSize);\n    this.program.OBJECTInstance.writeField(\"rtId\", id, buf, 0); // use specified rtId\n    this.writeStaticBuffer(buf, program.totalOverhead, elementType, values);\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  /** Adds an array header to static memory and returns the created segment. */\n  private addStaticArrayHeader(\n    elementType: Type,\n    bufferSegment: MemorySegment,\n    /** Optional array instance override. */\n    arrayInstance: Class | null = null\n  ): MemorySegment {\n    var program = this.program;\n    if (!arrayInstance) {\n      arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ elementType ]));\n    }\n    var bufferLength = readI32(bufferSegment.buffer, program.OBJECTInstance.offsetof(\"rtSize\"));\n    var arrayLength = i32(bufferLength / elementType.byteSize);\n    var bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n    var buf = arrayInstance.createBuffer();\n    assert(arrayInstance.writeField(\"buffer\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"dataStart\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"byteLength\", bufferLength, buf));\n    assert(arrayInstance.writeField(\"length_\", arrayLength, buf));\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  // === Table ====================================================================================\n\n  /** Ensures that a runtime counterpart of the specified function exists and returns its address. */\n  ensureRuntimeFunction(instance: Function): i64 {\n    assert(instance.is(CommonFlags.COMPILED) && !instance.is(CommonFlags.STUB));\n    var program = this.program;\n    var memorySegment = instance.memorySegment;\n    if (!memorySegment) {\n\n      // Add to the function table\n      let functionTable = this.functionTable;\n      let tableBase = this.options.tableBase;\n      if (!tableBase) tableBase = 1; // leave first elem blank\n      let index = tableBase + functionTable.length;\n      functionTable.push(instance);\n\n      // Create runtime function\n      let rtInstance = assert(this.resolver.resolveClass(program.functionPrototype, [ instance.type ]));\n      let buf = rtInstance.createBuffer();\n      assert(rtInstance.writeField(\"_index\", index, buf));\n      assert(rtInstance.writeField(\"_env\", 0, buf));\n      instance.memorySegment = memorySegment = this.addRuntimeMemorySegment(buf);\n    }\n    return i64_add(memorySegment.offset, i64_new(program.totalOverhead));\n  }\n\n  // === Statements ===============================================================================\n\n  /** Compiles a top level statement (incl. function declarations etc.) to the specified body. */\n  compileTopLevelStatement(statement: Statement, body: ExpressionRef[]): void {\n    switch (statement.kind) {\n      case NodeKind.CLASSDECLARATION: {\n        let memberStatements = (<ClassDeclaration>statement).members;\n        for (let i = 0, k = memberStatements.length; i < k; ++i) {\n          this.compileTopLevelStatement(memberStatements[i], body);\n        }\n        break;\n      }\n      case NodeKind.ENUMDECLARATION: {\n        let element = this.program.getElementByDeclaration(<EnumDeclaration>statement);\n        if (element) {\n          assert(element.kind == ElementKind.ENUM);\n          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileEnum(<Enum>element);\n        }\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        let declaration = <NamespaceDeclaration>statement;\n        let element = this.program.getElementByDeclaration(declaration);\n        if (element) {\n          // any potentiall merged element\n          let previousParent = this.currentParent;\n          this.currentParent = element;\n          let memberStatements = declaration.members;\n          for (let i = 0, k = memberStatements.length; i < k; ++i) {\n            this.compileTopLevelStatement(memberStatements[i], body);\n          }\n          this.currentParent = previousParent;\n        }\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        let declarations = (<VariableStatement>statement).declarations;\n        for (let i = 0, k = declarations.length; i < k; ++i) {\n          let element = this.program.getElementByDeclaration(declarations[i]);\n          if (element) {\n            assert(element.kind == ElementKind.GLOBAL);\n            if (\n              !element.is(CommonFlags.AMBIENT) && // delay imports\n              !element.hasDecorator(DecoratorFlags.LAZY)\n            ) this.compileGlobal(<Global>element);\n          }\n        }\n        break;\n      }\n      case NodeKind.FIELDDECLARATION: {\n        let element = this.program.getElementByDeclaration(<FieldDeclaration>statement);\n        if (element !== null && element.kind == ElementKind.GLOBAL) { // static\n          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileGlobal(<Global>element);\n        }\n        break;\n      }\n      case NodeKind.EXPORT: {\n        let exportStatement = <ExportStatement>statement;\n        let internalPath = exportStatement.internalPath;\n        if (internalPath !== null) {\n          this.compileFileByPath(internalPath, assert(exportStatement.path));\n        }\n        break;\n      }\n      case NodeKind.EXPORTDEFAULT: {\n        this.compileTopLevelStatement((<ExportDefaultStatement>statement).declaration, body);\n        break;\n      }\n      case NodeKind.IMPORT: {\n        let importStatement = <ImportStatement>statement;\n        this.compileFileByPath(importStatement.internalPath, importStatement.path);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION:\n      case NodeKind.METHODDECLARATION:\n      case NodeKind.INTERFACEDECLARATION:\n      case NodeKind.INDEXSIGNATURE:\n      case NodeKind.TYPEDECLARATION: break;\n      default: { // otherwise a top-level statement that is part of the start function's body\n        let stmt = this.compileStatement(statement);\n        if (getExpressionId(stmt) != ExpressionId.Nop) body.push(stmt);\n        break;\n      }\n    }\n  }\n\n  /** Compiles a statement. */\n  compileStatement(\n    /** Statement to compile. */\n    statement: Statement,\n    /** Whether this is the last statement of the body, if known. */\n    isLastInBody: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    var stmt: ExpressionRef;\n    switch (statement.kind) {\n      case NodeKind.BLOCK: {\n        stmt = this.compileBlockStatement(<BlockStatement>statement);\n        break;\n      }\n      case NodeKind.BREAK: {\n        stmt = this.compileBreakStatement(<BreakStatement>statement);\n        break;\n      }\n      case NodeKind.CONTINUE: {\n        stmt = this.compileContinueStatement(<ContinueStatement>statement);\n        break;\n      }\n      case NodeKind.DO: {\n        stmt = this.compileDoStatement(<DoStatement>statement);\n        break;\n      }\n      case NodeKind.EMPTY: {\n        stmt = this.compileEmptyStatement(<EmptyStatement>statement);\n        break;\n      }\n      case NodeKind.EXPRESSION: {\n        stmt = this.compileExpressionStatement(<ExpressionStatement>statement);\n        break;\n      }\n      case NodeKind.FOR: {\n        stmt = this.compileForStatement(<ForStatement>statement);\n        break;\n      }\n      case NodeKind.FOROF: {\n        stmt = this.compileForOfStatement(<ForOfStatement>statement);\n        break;\n      }\n      case NodeKind.IF: {\n        stmt = this.compileIfStatement(<IfStatement>statement);\n        break;\n      }\n      case NodeKind.RETURN: {\n        stmt = this.compileReturnStatement(<ReturnStatement>statement, isLastInBody);\n        break;\n      }\n      case NodeKind.SWITCH: {\n        stmt = this.compileSwitchStatement(<SwitchStatement>statement);\n        break;\n      }\n      case NodeKind.THROW: {\n        stmt = this.compileThrowStatement(<ThrowStatement>statement);\n        break;\n      }\n      case NodeKind.TRY: {\n        stmt = this.compileTryStatement(<TryStatement>statement);\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        stmt = this.compileVariableStatement(<VariableStatement>statement);\n        if (!stmt) stmt = module.nop();\n        break;\n      }\n      case NodeKind.VOID: {\n        stmt = this.compileVoidStatement(<VoidStatement>statement);\n        break;\n      }\n      case NodeKind.WHILE: {\n        stmt = this.compileWhileStatement(<WhileStatement>statement);\n        break;\n      }\n      case NodeKind.TYPEDECLARATION: {\n        // TODO: integrate inner type declaration into flow\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          statement.range,\n          \"Inner type alias\"\n        );\n        stmt = module.unreachable();\n        break;\n      }\n      default: {\n        assert(false);\n        stmt = module.unreachable();\n      }\n    }\n    if (this.options.sourceMap) this.addDebugLocation(stmt, statement.range);\n    return stmt;\n  }\n\n  /** Compiles a series of statements. */\n  compileStatements(\n    /** Statements to compile. */\n    statements: Statement[],\n    /** Whether this is an immediate body statement. */\n    isBody: bool = false,\n    /** Statements to append to that is also returned. Created if omitted. */\n    stmts: ExpressionRef[] | null = null\n  ): ExpressionRef[] {\n    var numStatements = statements.length;\n    if (!stmts) {\n      stmts = new Array<ExpressionRef>(numStatements);\n      stmts.length = 0;\n    }\n    var module = this.module;\n    var flow = this.currentFlow;\n    for (let i = 0; i < numStatements; ++i) {\n      let stmt = this.compileStatement(statements[i], isBody && i == numStatements - 1);\n      switch (getExpressionId(stmt)) {\n        case ExpressionId.Block: {\n          if (!getBlockName(stmt)) {\n            for (let j: Index = 0, k = getBlockChildCount(stmt); j < k; ++j) stmts.push(getBlockChildAt(stmt, j));\n            break;\n          }\n          // fall-through\n        }\n        default: stmts.push(stmt);\n        case ExpressionId.Nop:\n      }\n      if (flow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n        if (needsExplicitUnreachable(stmt)) stmts.push(module.unreachable());\n        break;\n      }\n    }\n    return stmts;\n  }\n\n  private compileBlockStatement(\n    statement: BlockStatement\n  ): ExpressionRef {\n    var statements = statement.statements;\n    var outerFlow = this.currentFlow;\n    var innerFlow = outerFlow.fork();\n    this.currentFlow = innerFlow;\n\n    var stmts = this.compileStatements(statements);\n    innerFlow.freeScopedLocals();\n    outerFlow.inherit(innerFlow);\n    this.currentFlow = outerFlow;\n    return this.module.flatten(stmts);\n  }\n\n  private compileBreakStatement(\n    statement: BreakStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var labelNode = statement.label;\n    if (labelNode) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        labelNode.range,\n        \"Break label\"\n      );\n      return module.unreachable();\n    }\n    var flow = this.currentFlow;\n    var breakLabel = flow.breakLabel;\n    if (breakLabel == null) {\n      this.error(\n        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.freeScopedLocals();\n    flow.set(FlowFlags.BREAKS);\n    return module.br(breakLabel);\n  }\n\n  private compileContinueStatement(\n    statement: ContinueStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var label = statement.label;\n    if (label) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        label.range,\n        \"Continue label\"\n      );\n      return module.unreachable();\n    }\n    // Check if 'continue' is allowed here\n    var flow = this.currentFlow;\n    var continueLabel = flow.continueLabel;\n    if (continueLabel == null) {\n      this.error(\n        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.CONTINUES | FlowFlags.TERMINATES);\n    flow.freeScopedLocals();\n    return module.br(continueLabel);\n  }\n\n  private compileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    return this.doCompileDoStatement(statement, null);\n  }\n\n  private doCompileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (block $break                          └►┐ flow\n    //  (loop $loop                             ├◄───────────┐ recompile?\n    //   (?block $continue                      └─┐          │\n    //    (body)                                  │ bodyFlow │\n    //   )                                      ┌─┘          │\n    //                                        ┌◄┼►╢          │ breaks or terminates?\n    //                                        │ └─┐          │ but does not continue\n    //   (br_if (cond) $loop)                 │   │ condFlow │\n    //                                        │ ┌─┘          │\n    //                                        ├◄┴────────────┘ condition?\n    //  )                                     └─┐\n    // )                                      ┌─┘\n\n    var label = outerFlow.pushBreakLabel();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n    this.currentFlow = flow;\n\n    var breakLabel = \"do-break|\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"do-continue|\" + label;\n    flow.continueLabel = continueLabel;\n    var loopLabel = \"do-loop|\" + label;\n\n    // Compile the body (always executes)\n    var bodyFlow = flow.fork();\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Shortcut if body never falls through\n    var possiblyContinues = bodyFlow.isAny(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES);\n    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS) && !possiblyContinues) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      flow.inherit(bodyFlow);\n\n    // Otherwise evaluate the condition\n    } else {\n      let condFlow = flow.fork();\n      this.currentFlow = condFlow;\n      let condExpr = this.makeIsTrueish(\n        this.compileExpression(statement.condition, Type.i32),\n        this.currentType,\n        statement.condition\n      );\n      let condKind = this.evaluateCondition(condExpr);\n\n      if (possiblyContinues) {\n        bodyStmts = [\n          module.block(continueLabel, bodyStmts)\n        ];\n      }\n\n      // Shortcut if condition is always false\n      if (condKind == ConditionKind.FALSE) {\n        bodyStmts.push(\n          module.drop(condExpr)\n        );\n        flow.inherit(bodyFlow);\n\n      // Terminate if condition is always true and body never breaks\n      } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        bodyStmts.push(\n          module.drop(condExpr)\n        );\n        bodyStmts.push(\n          module.br(loopLabel)\n        );\n        flow.set(FlowFlags.TERMINATES);\n\n      } else {\n        bodyStmts.push(\n          module.br(loopLabel,\n            condExpr\n          )\n        );\n        flow.inherit(condFlow);\n\n        // Detect if local flags are incompatible before and after looping, and\n        // if so recompile by unifying local flags between iterations. Note that\n        // this may be necessary multiple times where locals depend on each other.\n        if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n          outerFlow.popBreakLabel();\n          this.currentFlow = outerFlow;\n          return this.doCompileDoStatement(statement, flow);\n        }\n      }\n    }\n\n    // Finalize\n    assert(!flow.hasScopedLocals);\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    this.currentFlow = outerFlow;\n    var expr = module.block(breakLabel, [\n      module.loop(loopLabel,\n        module.flatten(bodyStmts)\n      )\n    ]);\n    if (outerFlow.is(FlowFlags.TERMINATES)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  private compileEmptyStatement(\n    statement: EmptyStatement\n  ): ExpressionRef {\n    return this.module.nop();\n  }\n\n  private compileExpressionStatement(\n    statement: ExpressionStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void, Constraints.CONV_IMPLICIT);\n  }\n\n  private compileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    return this.doCompileForStatement(statement, null);\n  }\n\n  private doCompileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (initializer)                  └►┐ flow\n    // (block $break                    │\n    //  (loop $loop                     ├◄───────────┐ recompile?\n    //   (local.set $tcond (condition)) └─┐ condFlow │\n    //                                  ┌─┘          │\n    //   (if (local.get $tcond)       ┌◄┤            │ condition?\n    //    (block $continue            │ │            │\n    //     (body)                     │ └─┐ bodyFlow │\n    //                                │ ┌─┘          │\n    //    )                           ├◄┼►╢          │ breaks or terminates?\n    //    (incrementor)               │ └─┐ incrFlow │\n    //                                │ ┌─┘          │\n    //                                │ └────────────┘\n    //    (br $loop)                  └─┐\n    //   )                              │\n    //  )                               │\n    // )                                │\n    //                                ┌─┘\n\n    var label = outerFlow.pushBreakLabel();\n    var stmts = new Array<ExpressionRef>();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    this.currentFlow = flow;\n\n    var breakLabel = \"for-break\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"for-continue|\" + label;\n    flow.continueLabel = continueLabel;\n    var loopLabel = \"for-loop|\" + label;\n\n    // Compile initializer if present\n    var initializer = statement.initializer;\n    if (initializer) {\n      assert(\n        initializer.kind == NodeKind.EXPRESSION ||\n        initializer.kind == NodeKind.VARIABLE\n      );\n      stmts.push(this.compileStatement(initializer));\n    }\n\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n\n    // Precompute the condition\n    var condFlow = flow.fork();\n    this.currentFlow = condFlow;\n    var condExpr: ExpressionRef;\n    var condKind: ConditionKind;\n    var condition = statement.condition;\n    if (condition) {\n      condExpr = this.makeIsTrueish(\n        this.compileExpression(condition, Type.bool),\n        this.currentType,\n        condition\n      );\n      condKind = this.evaluateCondition(condExpr);\n\n      // Shortcut if condition is always false (body never runs)\n      if (condKind == ConditionKind.FALSE) {\n        stmts.push(\n          module.drop(condExpr)\n        );\n        condFlow.freeScopedLocals();\n        flow.inherit(condFlow);\n        flow.freeScopedLocals();\n        outerFlow.inherit(flow);\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return module.flatten(stmts);\n      }\n    } else {\n      condExpr = module.i32(1);\n      condKind = ConditionKind.TRUE;\n    }\n\n    // From here on condition is either always true or unknown\n\n    // Store condition result in a temp\n    var tcond = flow.getTempLocal(Type.bool);\n    var loopStmts = new Array<ExpressionRef>();\n    loopStmts.push(\n      module.local_set(tcond.index, condExpr, false) // bool\n    );\n    condFlow.freeScopedLocals();\n\n    flow.inherit(condFlow); // always executes\n    this.currentFlow = flow;\n\n    // Compile the body assuming the condition turned out true\n    var bodyFlow = flow.fork();\n    bodyFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Check if body terminates\n    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n      bodyStmts.push(module.unreachable());\n    }\n    if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n    else flow.inheritBranch(bodyFlow);\n    bodyFlow.freeScopedLocals();\n\n    var ifStmts = new Array<ExpressionRef>();\n    ifStmts.push(\n      module.block(continueLabel, bodyStmts)\n    );\n\n    // Compile the incrementor if it runs\n    // Can still fall through to here if body continues, hence is already known to terminate\n    if (!bodyFlow.is(FlowFlags.TERMINATES) || bodyFlow.isAny(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES)) {\n      let incrementor = statement.incrementor;\n      if (incrementor) {\n        let incrFlow = flow.fork();\n        this.currentFlow = incrFlow;\n        ifStmts.push(\n          this.compileExpression(incrementor, Type.void, Constraints.CONV_IMPLICIT | Constraints.WILL_DROP)\n        );\n        incrFlow.freeScopedLocals();\n        flow.inherit(incrFlow); // mostly local flags, also covers late termination by throwing\n        this.currentFlow = flow;\n      }\n\n      ifStmts.push(\n        module.br(loopLabel)\n      );\n\n      // Detect if local flags are incompatible before and after looping, and if\n      // so recompile by unifying local flags between iterations. Note that this\n      // may be necessary multiple times where locals depend on each other.\n      if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n        assert(!bodyFlow.hasScopedLocals);\n        flow.freeScopedLocals();\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return this.doCompileForStatement(statement, flow);\n      }\n    }\n    loopStmts.push(\n      module.if(module.local_get(tcond.index, TypeRef.I32),\n        module.flatten(ifStmts)\n      )\n    );\n\n    stmts.push(\n      module.block(breakLabel, [\n        module.loop(loopLabel,\n          module.flatten(loopStmts)\n        )\n      ])\n    );\n    flow.freeTempLocal(tcond);\n    this.currentFlow = flow;\n\n    // Finalize\n    flow.freeScopedLocals();\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    if (outerFlow.is(FlowFlags.TERMINATES)) {\n      stmts.push(module.unreachable());\n    }\n    this.currentFlow = outerFlow;\n    return module.flatten(stmts);\n  }\n\n  private compileForOfStatement(\n    statement: ForOfStatement\n  ): ExpressionRef {\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Iterators\"\n    );\n    return this.module.unreachable();\n  }\n\n  private compileIfStatement(\n    statement: IfStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var ifTrue = statement.ifTrue;\n    var ifFalse = statement.ifFalse;\n\n    // (if              └►┐ flow\n    //  (condition)      ┌┴───────────┐ condition?\n    //  (block           │            │\n    //   (ifTrue)        └►┐ thenFlow │\n    //                   ┌─┘          │\n    //  )                ├─╢          │\n    //  (block           │          ┌◄┤ present?\n    //   (ifFalse)       │          │ └►┐ elseFlow\n    //                   │          │ ┌─┘\n    //  )                │          │ ├─╢\n    // )                 └┬─────────┴─┘\n    // ...              ┌◄┘\n\n    // Precompute the condition (always executes)\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(statement.condition, Type.bool),\n      this.currentType,\n      statement.condition\n    );\n    var condKind = this.evaluateCondition(condExpr);\n\n    // Shortcut if the condition is constant\n    switch (condKind) {\n      case ConditionKind.TRUE: {\n        return module.block(null, [\n          module.drop(condExpr),\n          this.compileStatement(ifTrue)\n        ]);\n      }\n      case ConditionKind.FALSE: {\n        return ifFalse\n          ? module.block(null, [\n              module.drop(condExpr),\n              this.compileStatement(ifFalse)\n            ])\n          : module.drop(condExpr);\n      }\n    }\n\n    // From here on condition is always unknown\n\n    var flow = this.currentFlow;\n\n    // Compile ifTrue assuming the condition turned out true\n    var thenStmts = new Array<ExpressionRef>();\n    var thenFlow = flow.fork();\n    this.currentFlow = thenFlow;\n    thenFlow.inheritNonnullIfTrue(condExpr);\n    if (ifTrue.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>ifTrue).statements, false, thenStmts);\n    } else {\n      thenStmts.push(this.compileStatement(ifTrue));\n    }\n    var thenTerminates = thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);\n    if (thenTerminates) {\n      thenStmts.push(module.unreachable());\n    }\n    thenFlow.freeScopedLocals();\n    this.currentFlow = flow;\n\n    // Compile ifFalse assuming the condition turned out false, if present\n    if (ifFalse) {\n      let elseStmts = new Array<ExpressionRef>();\n      let elseFlow = flow.fork();\n      this.currentFlow = elseFlow;\n      elseFlow.inheritNonnullIfFalse(condExpr);\n      if (ifFalse.kind == NodeKind.BLOCK) {\n        this.compileStatements((<BlockStatement>ifFalse).statements, false, elseStmts);\n      } else {\n        elseStmts.push(this.compileStatement(ifFalse));\n      }\n      let elseTerminates = elseFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);\n      if (elseTerminates) {\n        elseStmts.push(module.unreachable());\n      }\n      elseFlow.freeScopedLocals();\n      this.currentFlow = flow;\n      flow.inheritMutual(thenFlow, elseFlow);\n      return module.if(condExpr,\n        module.flatten(thenStmts),\n        module.flatten(elseStmts)\n      );\n    } else {\n      flow.inheritBranch(thenFlow);\n      flow.inheritNonnullIfFalse(condExpr,\n        thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)\n          ? null     // thenFlow terminates: just inherit\n          : thenFlow // must become nonnull in thenFlow otherwise\n      );\n      return module.if(condExpr,\n        module.flatten(thenStmts)\n      );\n    }\n  }\n\n  private compileReturnStatement(\n    statement: ReturnStatement,\n    isLastInBody: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var expr: ExpressionRef = 0;\n    var flow = this.currentFlow;\n    var returnType = flow.returnType;\n\n    var valueExpression = statement.value;\n    if (valueExpression) {\n      let constraints = Constraints.CONV_IMPLICIT;\n      if (flow.actualFunction.is(CommonFlags.MODULE_EXPORT)) constraints |= Constraints.MUST_WRAP;\n\n      expr = this.compileExpression(valueExpression, returnType, constraints);\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\n      if (flow.actualFunction.is(CommonFlags.CONSTRUCTOR) && valueExpression.kind != NodeKind.THIS) {\n        flow.set(FlowFlags.MAY_RETURN_NONTHIS);\n      }\n    } else if (returnType != Type.void) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        statement.range, \"void\", returnType.toString()\n      );\n      this.currentType = returnType;\n      return module.unreachable();\n    }\n    flow.freeScopedLocals();\n\n    // Remember that this flow returns\n    flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);\n\n    // Handle inline return\n    if (flow.isInline) {\n      return !expr\n        ? isLastInBody\n          ? module.nop()\n          : module.br(assert(flow.inlineReturnLabel))\n        : isLastInBody\n          ? expr\n          : this.currentType == Type.void\n            ? module.block(null, [ expr, module.br(assert(flow.inlineReturnLabel)) ])\n            : module.br(assert(flow.inlineReturnLabel), 0, expr);\n    }\n\n    // Otherwise emit a normal return\n    return !expr\n      ? isLastInBody\n        ? module.nop()\n        : module.return()\n      : isLastInBody\n        ? expr\n        : this.currentType == Type.void\n          ? module.block(null, [ expr, module.return() ])\n          : module.return(expr);\n  }\n\n  private compileSwitchStatement(\n    statement: SwitchStatement\n  ): ExpressionRef {\n    var module = this.module;\n\n    var cases = statement.cases;\n    var numCases = cases.length;\n    if (!numCases) {\n      return this.compileExpression(statement.condition, Type.void,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n\n    // Everything within a switch uses the same break context\n    var outerFlow = this.currentFlow;\n    var context = outerFlow.pushBreakLabel();\n\n    // introduce a local for evaluating the condition (exactly once)\n    var tempLocal = outerFlow.getTempLocal(Type.u32);\n    var tempLocalIndex = tempLocal.index;\n\n    // Prepend initializer to inner block. Does not initiate a new branch, yet.\n    var breaks = new Array<ExpressionRef>(1 + numCases);\n    breaks[0] = module.local_set( // initializer\n      tempLocalIndex,\n      this.compileExpression(statement.condition, Type.u32,\n        Constraints.CONV_IMPLICIT\n      ),\n      false // u32\n    );\n\n    // make one br_if per (possibly dynamic) labeled case (binaryen optimizes to br_table where possible)\n    var breakIndex = 1;\n    var defaultIndex = -1;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let label = case_.label;\n      if (label) {\n        breaks[breakIndex++] = module.br(\"case\" + i.toString() + \"|\" + context,\n          module.binary(BinaryOp.EqI32,\n            module.local_get(tempLocalIndex, TypeRef.I32),\n            this.compileExpression(label, Type.u32,\n              Constraints.CONV_IMPLICIT\n            )\n          )\n        );\n      } else {\n        defaultIndex = i;\n      }\n    }\n\n    outerFlow.freeTempLocal(tempLocal);\n\n    // otherwise br to default respectively out of the switch if there is no default case\n    breaks[breakIndex] = module.br((defaultIndex >= 0\n      ? \"case\" + defaultIndex.toString()\n      : \"break\"\n    ) + \"|\" + context);\n\n    // nest blocks in order\n    var currentBlock = module.block(\"case0|\" + context, breaks, TypeRef.None);\n    var commonCategorical = FlowFlags.ANY_CATEGORICAL;\n    var commonConditional = 0;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let statements = case_.statements;\n      let numStatements = statements.length;\n\n      // Each switch case initiates a new branch\n      let innerFlow = outerFlow.fork();\n      this.currentFlow = innerFlow;\n      let breakLabel = \"break|\" + context;\n      innerFlow.breakLabel = breakLabel;\n\n      let isLast = i == numCases - 1;\n      let nextLabel = isLast ? breakLabel : \"case\" + (i + 1).toString() + \"|\" + context;\n      let stmts = new Array<ExpressionRef>(1 + numStatements);\n      stmts[0] = currentBlock;\n      let count = 1;\n      let terminates = false;\n      for (let j = 0; j < numStatements; ++j) {\n        let stmt = this.compileStatement(statements[j]);\n        if (getExpressionId(stmt) != ExpressionId.Nop) {\n          stmts[count++] = stmt;\n        }\n        if (innerFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n          if (innerFlow.is(FlowFlags.TERMINATES)) terminates = true;\n          break;\n        }\n      }\n      stmts.length = count;\n      if (terminates || isLast || innerFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        commonCategorical &= innerFlow.flags;\n      }\n\n      commonConditional |= innerFlow.deriveConditionalFlags();\n\n      // Switch back to the parent flow\n      innerFlow.unset(\n        FlowFlags.BREAKS |\n        FlowFlags.CONDITIONALLY_BREAKS\n      );\n      innerFlow.freeScopedLocals();\n      this.currentFlow = outerFlow;\n      currentBlock = module.block(nextLabel, stmts, TypeRef.None); // must be a labeled block\n    }\n    outerFlow.popBreakLabel();\n\n    // If the switch has a default (guaranteed to handle any value), propagate common flags\n    if (defaultIndex >= 0) outerFlow.flags |= commonCategorical & ~FlowFlags.BREAKS;\n    outerFlow.flags |= commonConditional & ~FlowFlags.CONDITIONALLY_BREAKS;\n    // TODO: what about local states?\n    return currentBlock;\n  }\n\n  private compileThrowStatement(\n    statement: ThrowStatement\n  ): ExpressionRef {\n    // TODO: requires exception-handling spec.\n    var flow = this.currentFlow;\n\n    // Remember that this branch throws\n    flow.set(FlowFlags.THROWS | FlowFlags.TERMINATES);\n\n    var stmts = new Array<ExpressionRef>();\n    var value = statement.value;\n    var message: Expression | null = null;\n    if (value.kind == NodeKind.NEW) {\n      let newArgs = (<NewExpression>value).args;\n      if (newArgs.length) message = newArgs[0]; // FIXME: naively assumes type string\n    }\n    stmts.push(\n      this.makeAbort(message, statement)\n    );\n    flow.freeScopedLocals();\n    return this.module.flatten(stmts);\n  }\n\n  private compileTryStatement(\n    statement: TryStatement\n  ): ExpressionRef {\n    // TODO: can't yet support something like: try { return ... } finally { ... }\n    // worthwhile to investigate lowering returns to block results (here)?\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Exceptions\"\n    );\n    return this.module.unreachable();\n  }\n\n  /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */\n  private compileVariableStatement(\n    statement: VariableStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var declarations = statement.declarations;\n    var numDeclarations = declarations.length;\n    var flow = this.currentFlow;\n    var initializers = new Array<ExpressionRef>();\n    var resolver = this.resolver;\n\n    for (let i = 0; i < numDeclarations; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let type: Type | null = null;\n      let initExpr: ExpressionRef = 0;\n\n      // Resolve type if annotated\n      let typeNode = declaration.type;\n      let initializerNode = declaration.initializer;\n      if (typeNode) {\n        type = resolver.resolveType( // reports\n          typeNode,\n          flow.actualFunction,\n          uniqueMap(flow.contextualTypeArguments)\n        );\n        if (!type) continue;\n        this.checkTypeSupported(type, typeNode);\n\n        if (initializerNode) {\n          let pendingElements = this.pendingElements;\n          let dummy = flow.addScopedDummyLocal(name, type, statement); // pending dummy\n          pendingElements.add(dummy);\n          initExpr = this.compileExpression(initializerNode, type, // reports\n            Constraints.CONV_IMPLICIT\n          );\n          pendingElements.delete(dummy);\n          flow.freeScopedDummyLocal(name);\n        }\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let pendingElements = this.pendingElements;\n        let temp = flow.addScopedDummyLocal(name, Type.auto, statement); // pending dummy\n        pendingElements.add(temp);\n        initExpr = this.compileExpression(initializerNode, Type.auto); // reports\n        pendingElements.delete(temp);\n        flow.freeScopedDummyLocal(name);\n\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            declaration.range, this.currentType.toString(), \"<auto>\"\n          );\n          continue;\n        }\n        type = this.currentType;\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          declaration.name.range.atEnd\n        );\n        continue;\n      }\n\n      // Handle constants, and try to inline if value is static\n      let isConst = declaration.is(CommonFlags.CONST);\n      let isStatic = false;\n      if (isConst) {\n        if (initExpr) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp; // always use precomputed initExpr\n            let local: Local | null = null;\n            switch (<u32>getExpressionType(initExpr)) {\n              case <u32>TypeRef.I32: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI32(initExpr),\n                    0\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.I64: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI64Low(initExpr),\n                    getConstValueI64High(initExpr)\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>TypeRef.F32: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantFloatValue(<f64>getConstValueF32(initExpr), type);\n                break;\n              }\n              case <u32>TypeRef.F64: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantFloatValue(getConstValueF64(initExpr), type);\n                break;\n              }\n            }\n            if (local) {\n              // Add as a virtual local that doesn't actually exist in WebAssembly\n              let scopedLocals = flow.scopedLocals;\n              if (!scopedLocals) flow.scopedLocals = scopedLocals = new Map();\n              else if (scopedLocals.has(name)) {\n                let existing = assert(scopedLocals.get(name));\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  declaration.name.range,\n                  existing.declaration.name.range,\n                  name\n                );\n                return this.module.unreachable();\n              }\n              scopedLocals.set(name, local);\n              isStatic = true;\n            }\n          }\n        } else {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            declaration.range\n          );\n        }\n      }\n\n      // Otherwise compile as mutable\n      if (!isStatic) {\n        let local: Local;\n        if (\n          declaration.isAny(CommonFlags.LET | CommonFlags.CONST) ||\n          flow.isInline\n        ) { // here: not top-level\n          let existingLocal = flow.getScopedLocal(name);\n          if (existingLocal) {\n            if (!existingLocal.declaration.range.source.isNative) {\n              this.errorRelated(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range,\n                existingLocal.declaration.name.range,\n                name\n              );\n            } else { // scoped locals are shared temps that don't track declarations\n              this.error(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range, name\n              );\n            }\n            local = existingLocal;\n          } else {\n            local = flow.addScopedLocal(name, type);\n          }\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\n        } else {\n          let existing = flow.lookupLocal(name);\n          if (existing) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              declaration.name.range,\n              existing.declaration.name.range,\n              name\n            );\n            continue;\n          }\n          local = flow.parentFunction.addLocal(type, name, declaration);\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\n        }\n        if (initExpr) {\n          initializers.push(\n            this.makeLocalAssignment(local, initExpr, type, false)\n          );\n        } else {\n          // no need to assign zero\n          if (local.type.isShortIntegerValue) {\n            flow.setLocalFlag(local.index, LocalFlags.WRAPPED);\n          }\n        }\n      }\n    }\n    this.currentType = Type.void;\n    return initializers.length == 0\n      ? 0\n      : module.flatten(initializers);\n  }\n\n  private compileVoidStatement(\n    statement: VoidStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void,\n      Constraints.CONV_EXPLICIT | Constraints.WILL_DROP\n    );\n  }\n\n  private compileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    return this.doCompileWhileStatement(statement, null);\n  }\n\n  private doCompileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (block $break                  └►┐ flow\n    //  (loop $continue                 ├◄───────────┐ recompile?\n    //   (local.set $tcond (condition)) └─┐ condFlow │\n    //                                  ┌─┘          │\n    //   (if (local.get $tcond)       ┌◄┤            │ condition?\n    //    (body)                      │ └─┐ bodyFlow │\n    //                                │ ┌─┘          │\n    //                                ├◄┼►╢          │ breaks or terminates?\n    //    (br $continue)              │ └────────────┘\n    //   )                            └─┐\n    //  )                               │\n    // )                              ┌─┘\n\n    var label = outerFlow.pushBreakLabel();\n    var stmts = new Array<ExpressionRef>();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n    this.currentFlow = flow;\n\n    var breakLabel = \"while-break|\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"while-continue|\" + label;\n    flow.continueLabel = continueLabel;\n\n    // Precompute the condition\n    var condFlow = flow.fork();\n    this.currentFlow = condFlow;\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(statement.condition, Type.bool),\n      this.currentType,\n      statement.condition\n    );\n    var condKind = this.evaluateCondition(condExpr);\n\n    // Shortcut if condition is always false (body never runs)\n    if (condKind == ConditionKind.FALSE) {\n      stmts.push(\n        module.drop(condExpr)\n      );\n      assert(!flow.hasScopedLocals);\n      outerFlow.popBreakLabel();\n      this.currentFlow = outerFlow;\n      return module.flatten(stmts);\n    }\n\n    // From here on condition is either always true or unknown\n\n    // Store condition result in a temp\n    var tcond = flow.getTempLocal(Type.bool);\n    stmts.push(\n      module.local_set(tcond.index, condExpr, false) // bool\n    );\n    condFlow.freeScopedLocals();\n\n    flow.inherit(condFlow); // always executes\n    this.currentFlow = flow;\n\n    // Compile the body assuming the condition turned out true\n    var bodyFlow = flow.fork();\n    bodyFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Simplify if body always terminates\n    if (bodyFlow.is(FlowFlags.TERMINATES)) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n      else flow.inheritBranch(bodyFlow);\n\n    // Terminate if condition is always true and body never breaks\n    } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n      bodyStmts.push(\n        module.br(continueLabel)\n      );\n      flow.set(FlowFlags.TERMINATES);\n\n    } else {\n      let breaks = bodyFlow.is(FlowFlags.BREAKS);\n      if (breaks) {\n        bodyStmts.push(\n          module.unreachable()\n        );\n      } else {\n        bodyStmts.push(\n          module.br(continueLabel)\n        );\n      }\n      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n      else flow.inheritBranch(bodyFlow);\n\n      // Detect if local flags are incompatible before and after looping, and\n      // if so recompile by unifying local flags between iterations. Note that\n      // this may be necessary multiple times where locals depend on each other.\n      // Here: Only relevant if flow does not always break.\n      if (!breaks && Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n        flow.freeTempLocal(tcond);\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return this.doCompileWhileStatement(statement, flow);\n      }\n    }\n    stmts.push(\n      module.if(module.local_get(tcond.index, TypeRef.I32),\n        module.flatten(bodyStmts)\n      )\n    );\n    flow.freeTempLocal(tcond);\n    this.currentFlow = flow;\n\n    // Finalize\n    assert(!flow.hasScopedLocals);\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    this.currentFlow = outerFlow;\n    var expr = module.block(breakLabel, [\n      module.loop(continueLabel,\n        module.flatten(stmts)\n      )\n    ]);\n    if (condKind == ConditionKind.TRUE && outerFlow.is(FlowFlags.TERMINATES)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  // === Expressions ==============================================================================\n\n  /** Compiles the value of an inlined constant element. */\n  compileInlineConstant(\n    element: VariableLikeElement,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    assert(element.is(CommonFlags.INLINED | CommonFlags.RESOLVED));\n    var type = element.type;\n    this.currentType = type;\n    switch (type.kind) {\n      case TypeKind.BOOL: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            // @ts-ignore\n            ? <i32>i64_ne(element.constantIntegerValue, i64_zero)\n            : 0\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        let shift = type.computeSmallIntegerShift(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue) << shift >> shift\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        let mask = element.type.computeSmallIntegerMask(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue) & mask\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue)\n            : 0\n        );\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!element.program.options.isWasm64) {\n          return this.module.i32(\n            element.constantValueKind == ConstantValueKind.INTEGER\n              ? i64_low(element.constantIntegerValue)\n              : 0\n          );\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return element.constantValueKind == ConstantValueKind.INTEGER\n          ? this.module.i64(\n              i64_low(element.constantIntegerValue),\n              i64_high(element.constantIntegerValue)\n            )\n          : this.module.i64(0);\n      }\n      case TypeKind.F64: {\n        // monkey-patch for converting built-in floats to f32 implicitly\n        if (!(element.hasDecorator(DecoratorFlags.BUILTIN) && contextualType == Type.f32)) {\n          return this.module.f64(element.constantFloatValue);\n        }\n        // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity\n        this.currentType = Type.f32;\n      }\n      case TypeKind.F32: {\n        return this.module.f32(<f32>element.constantFloatValue);\n      }\n      default: {\n        assert(false);\n        return this.module.unreachable();\n      }\n    }\n  }\n\n  compileExpression(\n    expression: Expression,\n    contextualType: Type,\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    while (expression.kind == NodeKind.PARENTHESIZED) { // skip\n      expression = (<ParenthesizedExpression>expression).expression;\n    }\n    this.currentType = contextualType;\n    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;\n    var expr: ExpressionRef;\n    switch (expression.kind) {\n      case NodeKind.ASSERTION: {\n        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.BINARY: {\n        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.CALL: {\n        expr = this.compileCallExpression(<CallExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.COMMA: {\n        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.ELEMENTACCESS: {\n        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.FUNCTION: {\n        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.THIS:\n      case NodeKind.SUPER:\n      case NodeKind.TRUE: {\n        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.INSTANCEOF: {\n        expr = this.compileInstanceOfExpression(<InstanceOfExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.LITERAL: {\n        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.NEW: {\n        expr = this.compileNewExpression(<NewExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.PROPERTYACCESS: {\n        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.TERNARY: {\n        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.COMPILED: {\n        let compiled = <CompiledExpression>expression;\n        expr = compiled.expr;\n        this.currentType = compiled.type;\n        break;\n      }\n      case NodeKind.CLASS: {\n        // TODO: compile as class expression\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Block-scoped class declarations or expressions\"\n        );\n        expr = this.module.unreachable();\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    // ensure conversion and wrapping in case the respective function doesn't on its own\n    var currentType = this.currentType;\n    var wrap = (constraints & Constraints.MUST_WRAP) != 0;\n    if (currentType != contextualType.nonNullableType) { // allow assigning non-nullable to nullable\n      if (constraints & Constraints.CONV_EXPLICIT) {\n        expr = this.convertExpression(expr, currentType, contextualType, true, expression);\n        this.currentType = currentType = contextualType;\n      } else if (constraints & Constraints.CONV_IMPLICIT) {\n        expr = this.convertExpression(expr, currentType, contextualType, false, expression);\n        this.currentType = currentType = contextualType;\n      }\n    }\n    if (wrap) expr = this.ensureSmallIntegerWrap(expr, currentType);\n    // debug location is added here so the caller doesn't have to. means: compilation of an expression\n    // must go through this function, with the respective per-kind functions not being used directly.\n    if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n    return expr;\n  }\n\n  /** Converts an expression's result from one type to another. */\n  convertExpression(\n    expr: ExpressionRef,\n    /** Original type. */\n    fromType: Type,\n    /** New type. */\n    toType: Type,\n    /** Whether the conversion is explicit. */\n    explicit: bool,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    var module = this.module;\n\n    // void to any\n    if (fromType.kind == TypeKind.VOID) {\n      assert(toType.kind != TypeKind.VOID); // convertExpression should not be called with void -> void\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    // any to void\n    if (toType.kind == TypeKind.VOID) return module.drop(expr);\n\n    // reference involved\n    if (fromType.isReference || toType.isReference) {\n      if (this.currentFlow.isNonnull(expr, fromType)) {\n        fromType = fromType.nonNullableType;\n      } else if (explicit && fromType.isNullableReference && !toType.isNullableReference) {\n        // explicit conversion from nullable to non-nullable requires a runtime\n        // check here because nonnull state above already didn't know better\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, fromType, reportNode);\n        }\n        fromType = fromType.nonNullableType;\n      }\n      if (fromType.isAssignableTo(toType)) { // downcast or same\n        assert(toType.isExternalReference || fromType.kind == toType.kind);\n        this.currentType = toType;\n        return expr;\n      }\n      if (explicit && toType.nonNullableType.isAssignableTo(fromType)) { // upcast\n        // <Cat | null>(<Animal>maybeCat)\n        if (toType.isExternalReference) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            reportNode.range,\n            \"ref.cast\"\n          );\n          this.currentType = toType;\n          return module.unreachable();\n        }\n        assert(fromType.kind == toType.kind);\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeUpcastCheck(expr, fromType, toType, reportNode);\n        }\n        this.currentType = toType;\n        return expr;\n      }\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      this.currentType = toType;\n      return module.unreachable();\n    }\n\n    // not dealing with references from here on\n    assert(!fromType.isReference && !toType.isReference);\n\n    if (!fromType.isAssignableTo(toType)) {\n      if (!explicit) {\n        this.error(\n          DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,\n          reportNode.range, fromType.toString(), toType.toString()\n        ); // recoverable\n      }\n    }\n\n    if (fromType.isFloatValue) {\n\n      // float to float\n      if (toType.isFloatValue) {\n        if (fromType.kind == TypeKind.F32) {\n\n          // f32 to f64\n          if (toType.kind == TypeKind.F64) {\n            expr = module.unary(UnaryOp.PromoteF32ToF64, expr);\n          }\n\n          // otherwise f32 to f32\n\n        // f64 to f32\n        } else if (toType.kind == TypeKind.F32) {\n          expr = module.unary(UnaryOp.DemoteF64ToF32, expr);\n        }\n\n        // otherwise f64 to f64\n\n      // float to int\n      } else if (toType.isIntegerValue) {\n\n        // f32 to int\n        if (fromType.kind == TypeKind.F32) {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f32, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI64 : UnaryOp.TruncF32ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI32 : UnaryOp.TruncF32ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU64 : UnaryOp.TruncF32ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU32 : UnaryOp.TruncF32ToU32, expr);\n            }\n          }\n\n        // f64 to int\n        } else {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f64, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI64 : UnaryOp.TruncF64ToI64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI32 : UnaryOp.TruncF64ToI32, expr);\n            }\n          } else {\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU64 : UnaryOp.TruncF64ToU64, expr);\n            } else {\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU32 : UnaryOp.TruncF64ToU32, expr);\n            }\n          }\n        }\n\n      // float to void\n      } else {\n        assert(toType.flags == TypeFlags.NONE, \"void type expected\");\n        expr = module.drop(expr);\n      }\n\n    // int to float\n    } else if (fromType.isIntegerValue && toType.isFloatValue) {\n\n      // int to f32\n      if (toType.kind == TypeKind.F32) {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF32\n              : UnaryOp.ConvertU64ToF32,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF32\n              : UnaryOp.ConvertU32ToF32,\n            expr\n          );\n        }\n\n      // int to f64\n      } else {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF64\n              : UnaryOp.ConvertU64ToF64,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF64\n              : UnaryOp.ConvertU32ToF64,\n            expr\n          );\n        }\n      }\n\n    // v128 to bool\n    } else if (fromType == Type.v128 && toType.isBooleanValue) {\n      expr = this.makeIsTrueish(expr, Type.v128, reportNode);\n\n    // int to int\n    } else {\n      // i64 to ...\n      if (fromType.isLongIntegerValue) {\n\n        // i64 to i32 or smaller\n        if (toType.isBooleanValue) {\n          expr = module.binary(BinaryOp.NeI64, expr, module.i64(0));\n        } else if (!toType.isLongIntegerValue) {\n          expr = module.unary(UnaryOp.WrapI64ToI32, expr); // discards upper bits\n        }\n\n      // i32 or smaller to i64\n      } else if (toType.isLongIntegerValue) {\n        expr = module.unary(\n          fromType.isSignedIntegerValue ? UnaryOp.ExtendI32ToI64 : UnaryOp.ExtendU32ToU64,\n          this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits\n        );\n\n      // i32 to i32\n      } else {\n        // small i32 to ...\n        if (fromType.isShortIntegerValue) {\n          // small i32 to larger i32\n          if (fromType.size < toType.size) {\n            expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits\n          }\n        // same size\n        } else {\n          if (!explicit && !this.options.isWasm64 && fromType.isVaryingIntegerValue && !toType.isVaryingIntegerValue) {\n            this.warning(\n              DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,\n              reportNode.range, fromType.toString(), toType.toString()\n            );\n          }\n        }\n      }\n    }\n\n    this.currentType = toType;\n    return expr;\n  }\n\n  private compileAssertionExpression(\n    expression: AssertionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var inheritedConstraints = constraints & ~(Constraints.CONV_IMPLICIT | Constraints.CONV_EXPLICIT);\n    switch (expression.assertionKind) {\n      case AssertionKind.PREFIX:\n      case AssertionKind.AS: {\n        let flow = this.currentFlow;\n        let toType = this.resolver.resolveType( // reports\n          assert(expression.toType),\n          flow.actualFunction,\n          uniqueMap(flow.contextualTypeArguments)\n        );\n        if (!toType) return this.module.unreachable();\n        return this.compileExpression(expression.expression, toType, inheritedConstraints | Constraints.CONV_EXPLICIT);\n      }\n      case AssertionKind.NONNULL: {\n        assert(!expression.toType);\n        let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);\n        let type = this.currentType;\n        if (this.currentFlow.isNonnull(expr, type)) {\n          this.info(\n            DiagnosticCode.Expression_is_never_null,\n            expression.expression.range\n          );\n        } else if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, type, expression);\n        }\n        this.currentType = type.nonNullableType;\n        return expr;\n      }\n      case AssertionKind.CONST: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let operand = expression.expression;\n        // if (operand.kind == NodeKind.LITERAL && (<LiteralExpression>operand).literalKind == LiteralKind.ARRAY) {\n        //   let element = this.resolver.lookupExpression(expression /* ! */, this.currentFlow, contextualType);\n        //   if (!element) return this.module.unreachable();\n        //   if (element.kind == ElementKind.CLASS) {\n        //     let arrayInstance = <Class>element;\n        //     if (arrayInstance.extends(this.program.readonlyArrayPrototype)) {\n        //       return this.compileStaticArrayLiteral(<ArrayLiteralExpression>operand, arrayInstance.type, constraints);\n        //     }\n        //   }\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Const assertion\"\n        );\n        return this.module.unreachable();\n      }\n      default: assert(false);\n    }\n    return this.module.unreachable();\n  }\n\n  private f32ModInstance: Function | null = null;\n  private f64ModInstance: Function | null = null;\n  private f32PowInstance: Function | null = null;\n  private f64PowInstance: Function | null = null;\n  private i32PowInstance: Function | null = null;\n  private i64PowInstance: Function | null = null;\n\n  private compileBinaryExpression(\n    expression: BinaryExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var left = expression.left;\n    var right = expression.right;\n\n    var leftExpr: ExpressionRef;\n    var leftType: Type;\n    var rightExpr: ExpressionRef;\n    var rightType: Type;\n    var commonType: Type | null;\n\n    var expr: ExpressionRef;\n    var compound = false;\n\n    var operator = expression.operator;\n    switch (operator) {\n      case Token.LESSTHAN: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.LT);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.GT);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.LESSTHAN_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.LE);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GREATERTHAN_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.GE);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n\n      case Token.EQUALS_EQUALS_EQUALS:\n      case Token.EQUALS_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        if (operator == Token.EQUALS_EQUALS) { // can't overload '==='\n          let classReference = leftType.getClassOrWrapper(this.program);\n          if (classReference) {\n            let overload = classReference.lookupOverload(OperatorKind.EQ);\n            if (overload) {\n              expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n              break;\n            }\n          }\n          // fall back to compare by value\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeEq(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.EXCLAMATION_EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        if (operator == Token.EXCLAMATION_EQUALS) { // can't overload '!=='\n          let classReference = leftType.getClass();\n          if (classReference) {\n            let overload = classReference.lookupOverload(OperatorKind.NE);\n            if (overload) {\n              expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n              break;\n            }\n          }\n          // fall back to compare by value\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeNe(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.EQUALS: {\n        return this.compileAssignment(left, right, contextualType);\n      }\n      case Token.PLUS_EQUALS: compound = true;\n      case Token.PLUS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.ADD);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"+\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"+\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAdd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.MINUS_EQUALS: compound = true;\n      case Token.MINUS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.SUB);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"-\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeSub(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.ASTERISK_EQUALS: compound = true;\n      case Token.ASTERISK: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.MUL);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"*\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"*\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeMul(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.ASTERISK_ASTERISK_EQUALS: compound = true;\n      case Token.ASTERISK_ASTERISK: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POW);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"**\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"**\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makePow(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.SLASH_EQUALS: compound = true;\n      case Token.SLASH: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.DIV);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"/\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"/\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeDiv(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.PERCENT_EQUALS: compound = true;\n      case Token.PERCENT: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.REM);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"%\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"%\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeRem(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.LESSTHAN_LESSTHAN_EQUALS: compound = true;\n      case Token.LESSTHAN_LESSTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHL);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"<<\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShl(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: compound = true;\n      case Token.GREATERTHAN_GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>\", leftType.toString()\n          );\n          return this.module.unreachable();\n        }\n\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShr(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: compound = true;\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR_U);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>>\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShru(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.AMPERSAND_EQUALS: compound = true;\n      case Token.AMPERSAND: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overloadd\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_AND);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"&\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"&\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAnd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.BAR_EQUALS: compound = true;\n      case Token.BAR: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_OR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"|\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"|\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeOr(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.CARET_EQUALS: compound = true;\n      case Token.CARET: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_XOR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, leftType, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"^\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"^\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeXor(leftExpr, rightExpr, commonType);\n        break;\n      }\n\n      // logical (no overloading)\n\n      case Token.AMPERSAND_AMPERSAND: { // left && right -> (t = left) ? right : t\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MUST_WRAP;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.fork();\n        this.currentFlow = rightFlow;\n        rightFlow.inheritNonnullIfTrue(leftExpr);\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always false\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.FALSE) {\n            expr = leftExpr;\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightFlow.freeScopedLocals();\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always true\n            if (condKind == ConditionKind.TRUE) {\n              expr = rightExpr;\n            } else {\n              expr = module.if(leftExpr, rightExpr, module.i32(0));\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);\n          rightType = this.currentType;\n          rightFlow.freeScopedLocals();\n          this.currentFlow = flow;\n\n          // simplify if copying left is trivial\n          if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, this.currentType, left),\n              rightExpr,\n              expr\n            );\n\n          // if not possible, tee left to a temp\n          } else {\n            let tempLocal = flow.getTempLocal(leftType);\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.WRAPPED);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.NONNULL);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr, leftType.isManaged), leftType, left),\n              rightExpr,\n              module.local_get(tempLocal.index, leftType.toRef())\n            );\n            flow.freeTempLocal(tempLocal);\n          }\n          this.currentType = leftType;\n        }\n        break;\n      }\n      case Token.BAR_BAR: { // left || right -> ((t = left) ? t : right)\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & Constraints.MUST_WRAP;\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.fork();\n        this.currentFlow = rightFlow;\n        rightFlow.inheritNonnullIfFalse(leftExpr);\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\n\n          // shortcut if lhs is always true\n          let condKind = this.evaluateCondition(leftExpr);\n          if (condKind == ConditionKind.TRUE) {\n            expr = leftExpr;\n          } else {\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n            rightType = this.currentType;\n            rightFlow.freeScopedLocals();\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\n\n            // simplify if lhs is always false\n            if (condKind == ConditionKind.FALSE) {\n              expr = rightExpr;\n            } else {\n              expr = module.if(leftExpr, module.i32(1), rightExpr);\n            }\n          }\n          this.currentFlow = flow;\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);\n          rightType = this.currentType;\n          rightFlow.freeScopedLocals();\n          this.currentFlow = flow;\n\n          // simplify if copying left is trivial\n          if (expr = module.tryCopyTrivialExpression(leftExpr)) {\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, leftType, left),\n              expr,\n              rightExpr\n            );\n\n          // if not possible, tee left to a temp. local\n          } else {\n            let temp = flow.getTempLocal(leftType);\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n            expr = module.if(\n              this.makeIsTrueish(module.local_tee(temp.index, leftExpr, leftType.isManaged), leftType, left),\n              module.local_get(temp.index, leftType.toRef()),\n              rightExpr\n            );\n            flow.freeTempLocal(temp);\n          }\n          this.currentType = leftType;\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(left, this.currentFlow);\n    if (!target) return module.unreachable();\n    var targetType = resolver.getTypeOfElement(target);\n    if (!targetType) targetType = Type.void;\n    if (!this.currentType.isStrictlyAssignableTo(targetType)) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, this.currentType.toString(), targetType.toString()\n      );\n      return module.unreachable();\n    }\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      right,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  makeLt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.LtI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.LtI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LtI64\n            : BinaryOp.LtI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.LtU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LtU64\n            : BinaryOp.LtU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.LtU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.LtF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.LtF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.GtI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GtI64\n            : BinaryOp.GtI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.GtI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.GtU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GtU64\n            : BinaryOp.GtU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.GtU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.GtF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.GtF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeLe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.LeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LeI64\n            : BinaryOp.LeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.LeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.LeU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LeU64\n            : BinaryOp.LeU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.LeU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.LeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.LeF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.GeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GeI64\n            : BinaryOp.GeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.GeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.GeU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GeU64\n            : BinaryOp.GeU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.GeU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.GeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.GeF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeEq(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.EqI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.EqI64\n            : BinaryOp.EqI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.EqI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.EqF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.EqF64, leftExpr, rightExpr);\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AllTrueI8x16,\n          module.binary(BinaryOp.EqI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.EQREF:\n      case TypeKind.I31REF:\n      case TypeKind.DATAREF: {\n        return module.ref_eq(leftExpr, rightExpr);\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeNe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.NeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.NeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.NeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.NeF64, leftExpr, rightExpr);\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128,\n          module.binary(BinaryOp.NeI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.EQREF:\n      case TypeKind.I31REF:\n      case TypeKind.DATAREF: {\n        return module.unary(UnaryOp.EqzI32,\n          module.ref_eq(leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAdd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.AddI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.AddI64\n            : BinaryOp.AddI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.AddI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.AddF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.AddF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeSub(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.SubI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.SubI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.SubF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.SubF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeMul(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.MulI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.MulI64\n            : BinaryOp.MulI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.MulI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.MulF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.MulF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makePow(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: {\n        return module.select(\n          module.i32(1),\n          module.binary(BinaryOp.EqI32, rightExpr, module.i32(0)),\n          leftExpr,\n          TypeRef.I32\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let instance = this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.i32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        let expr = this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n        if (type.size < 32) {\n          // TODO: this is necessary because i32PowInstance is generic, and deals with 32-bit integers,\n          // so its flow does not indicate whether returned SMIs are wrapped. worth to avoid?\n          expr = this.ensureSmallIntegerWrap(expr, type);\n        }\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let instance = this.i64PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(CommonNames.ipow64);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow64\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.i64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let isWasm64 = this.options.isWasm64;\n        let instance = isWasm64 ? this.i64PowInstance : this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookup(isWasm64 ? CommonNames.ipow64 : CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, isWasm64 ? \"ipow64\" : \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n          if (isWasm64) {\n            this.i64PowInstance = instance;\n          } else {\n            this.i32PowInstance = instance;\n          }\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F32: {\n        let instance = this.f32PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.pow\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      // Math.pow otherwise (result is f64)\n      case TypeKind.F64: {\n        let instance = this.f64PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.pow\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeDiv(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.DivI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.DivI64\n            : BinaryOp.DivI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.DivI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.DivU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.DivU64\n            : BinaryOp.DivU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.DivU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.DivF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.DivF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeRem(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.RemI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.RemI64\n            : BinaryOp.RemI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.RemI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.RemU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.RemU64\n            : BinaryOp.RemU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.RemU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        let instance = this.f32ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.mod\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f32ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F64: {\n        let instance = this.f64ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookup(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.mod\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f64ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShl(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the RHS, but only for types smaller than 5 bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr << (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShlI32,\n          leftExpr,\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShlI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShlI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShlI64\n            : BinaryOp.ShlI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits,\n    // and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        // leftExpr >> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrI32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.ShrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.ShrI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrI64\n            : BinaryOp.ShrI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrU64\n            : BinaryOp.ShrU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShru(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrU64\n            : BinaryOp.ShrU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAnd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.AndI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.AndI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.AndI64\n            : BinaryOp.AndI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeOr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.OrI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.OrI64\n            : BinaryOp.OrI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeXor(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.XorI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.XorI64\n            : BinaryOp.XorI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileUnaryOverload(\n    operatorInstance: Function,\n    value: Expression,\n    valueExpr: ExpressionRef,\n    reportNode: Node\n  ): ExpressionRef {\n    // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch\n    // is a bad idea currently. so this assumes that the type matches.\n    return this.makeCallDirect(operatorInstance, [ valueExpr ], reportNode, false);\n  }\n\n  private compileBinaryOverload(\n    operatorInstance: Function,\n    left: Expression,\n    leftExpr: ExpressionRef,\n    leftType: Type,\n    right: Expression,\n    reportNode: Node\n  ): ExpressionRef {\n    var rightType: Type;\n    if (operatorInstance.is(CommonFlags.INSTANCE)) {\n      assert(leftType.isStrictlyAssignableTo(operatorInstance.signature.parameterTypes[0]));\n      let classInstance = assert(operatorInstance.parent); assert(classInstance.kind == ElementKind.CLASS);\n      rightType = operatorInstance.signature.parameterTypes[0];\n    } else {\n      rightType = operatorInstance.signature.parameterTypes[1];\n    }\n    leftExpr = this.convertExpression(leftExpr, leftType, operatorInstance.signature.parameterTypes[0], false, left);\n    var rightExpr = this.compileExpression(right, rightType, Constraints.CONV_IMPLICIT);\n    return this.makeCallDirect(operatorInstance, [ leftExpr, rightExpr ], reportNode);\n  }\n\n  private compileAssignment(\n    expression: Expression,\n    valueExpression: Expression,\n    contextualType: Type\n  ): ExpressionRef {\n    var program = this.program;\n    var resolver = program.resolver;\n    var flow = this.currentFlow;\n    var target = resolver.lookupExpression(expression, flow); // reports\n    if (!target) return this.module.unreachable();\n    var thisExpression = resolver.currentThisExpression;\n    var elementExpression = resolver.currentElementExpression;\n\n    // to compile just the value, we need to know the target's type\n    var targetType: Type;\n    switch (target.kind) {\n      case ElementKind.GLOBAL: {\n        // not yet compiled if a static field compiled as a global\n        if (!this.compileGlobal(<Global>target)) return this.module.unreachable(); // reports\n        // fall-through\n      }\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: {\n        if (this.pendingElements.has(target)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            target.internalName\n          );\n          return this.module.unreachable();\n        }\n        targetType = (<VariableLikeElement>target).type;\n        if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return this.module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            expression.range, propertyInstance.internalName\n          );\n          return this.module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this\n        targetType = setterInstance.signature.parameterTypes[0];\n        if (setterInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.INDEXSIGNATURE: {\n        let parent = (<IndexSignature>target).parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let indexedSet = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n        if (!indexedSet) {\n          let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n          if (!indexedGet) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              expression.range, classInstance.internalName\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n              expression.range, classInstance.internalName\n            );\n          }\n          return this.module.unreachable();\n        }\n        assert(indexedSet.signature.parameterTypes.length == 2); // parser must guarantee this\n        targetType = indexedSet.signature.parameterTypes[1];     // 2nd parameter is the element\n        if (indexedSet.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        if (!isUnchecked && this.options.pedantic) {\n          this.pedantic(\n            DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n            expression.range\n          );\n        }\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n          expression.range, target.internalName\n        );\n        return this.module.unreachable();\n      }\n    }\n\n    // compile the value and do the assignment\n    assert(targetType != Type.void);\n    var valueExpr = this.compileExpression(valueExpression, targetType);\n    var valueType = this.currentType;\n    return this.makeAssignment(\n      target,\n      this.convertExpression(valueExpr, valueType, targetType, false, valueExpression),\n      valueType,\n      valueExpression,\n      thisExpression,\n      elementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  /** Makes an assignment expression or block, assigning a value to a target. */\n  makeAssignment(\n    /** Target element, e.g. a Local. */\n    target: Element,\n    /** Value expression that has been compiled in a previous step already. */\n    valueExpr: ExpressionRef,\n    /** Value expression type. */\n    valueType: Type,\n    /** Expression reference. Has already been compiled to `valueExpr`. */\n    valueExpression: Expression,\n    /** `this` expression reference if a field or property set. */\n    thisExpression: Expression | null,\n    /** Index expression reference if an indexed set. */\n    indexExpression: Expression | null,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    switch (target.kind) {\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        if (flow.isLocalFlag(local.index, LocalFlags.CONSTANT, true)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          this.currentType = tee ? local.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeLocalAssignment(local, valueExpr, valueType, tee);\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable();\n        if (target.isAny(CommonFlags.CONST | CommonFlags.READONLY)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range,\n            target.internalName\n          );\n          this.currentType = tee ? global.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeGlobalAssignment(global, valueExpr, valueType, tee);\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let initializerNode = fieldInstance.initializerNode;\n        let isConstructor = flow.actualFunction.is(CommonFlags.CONSTRUCTOR);\n\n        // Cannot assign to readonly fields except in constructors if there's no initializer\n        if (fieldInstance.is(CommonFlags.READONLY)) {\n          if (!isConstructor || initializerNode !== null) {\n            this.error(\n              DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n              valueExpression.range, fieldInstance.internalName\n            );\n            return module.unreachable();\n          }\n        }\n\n        // Mark initialized fields in constructors\n        thisExpression = assert(thisExpression);\n        if (isConstructor && thisExpression.kind == NodeKind.THIS) {\n          flow.setThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED);\n        }\n\n        let fieldParent = fieldInstance.parent;\n        assert(fieldParent.kind == ElementKind.CLASS);\n        return this.makeFieldAssignment(fieldInstance,\n          valueExpr,\n          valueType,\n          this.compileExpression(\n            thisExpression,\n            (<Class>fieldParent).type,\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          ),\n          tee\n        );\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1);\n        if (propertyInstance.is(CommonFlags.INSTANCE)) {\n          let thisType = assert(setterInstance.signature.thisType);\n          let thisExpr = this.compileExpression(\n            assert(thisExpression),\n            thisType,\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n          if (!tee) return this.makeCallDirect(setterInstance, [ thisExpr, valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          assert(getterInstance.signature.thisType == thisType);\n          let returnType = getterInstance.signature.returnType;\n          let returnTypeRef = returnType.toRef();\n          let tempThis = flow.getTempLocal(returnType);\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempThis.index, thisExpr, returnType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempThis.index, returnTypeRef)\n            ], valueExpression)\n          ], returnTypeRef);\n          flow.freeTempLocal(tempThis);\n          return ret;\n        } else {\n          if (!tee) return this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          return module.block(null, [\n            this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression),\n            this.makeCallDirect(getterInstance, null, valueExpression)\n          ], getterInstance.signature.returnType.toRef());\n        }\n      }\n      case ElementKind.INDEXSIGNATURE: {\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        assert(classInstance.kind == ElementKind.CLASS);\n        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let getterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_is_missing_in_type_0,\n            valueExpression.range, classInstance.internalName\n          );\n          return module.unreachable();\n        }\n        let setterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n            valueExpression.range, classInstance.internalName\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 2);\n        let thisType = classInstance.type;\n        let thisExpr = this.compileExpression(\n          assert(thisExpression),\n          thisType,\n          Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n        );\n        let elementExpr = this.compileExpression(assert(indexExpression), Type.i32, Constraints.CONV_IMPLICIT);\n        let elementType = this.currentType;\n        if (tee) {\n          let tempTarget = flow.getTempLocal(thisType);\n          let tempElement = flow.getTempLocal(elementType);\n          let returnType = getterInstance.signature.returnType;\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempTarget.index, thisExpr, thisType.isManaged),\n              module.local_tee(tempElement.index, elementExpr, elementType.isManaged),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempTarget.index, tempTarget.type.toRef()),\n              module.local_get(tempElement.index, tempElement.type.toRef())\n            ], valueExpression)\n          ], returnType.toRef());\n          flow.freeTempLocal(tempElement);\n          flow.freeTempLocal(tempTarget);\n          return ret;\n        } else {\n          return this.makeCallDirect(setterInstance, [\n            thisExpr,\n            elementExpr,\n            valueExpr\n          ], valueExpression);\n        }\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  /** Makes an assignment to a local, keeping track of wrap and null states. */\n  private makeLocalAssignment(\n    /** Local to assign to. */\n    local: Local,\n    /** Value to assign. */\n    valueExpr: ExpressionRef,\n    /** Value type. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var type = local.type;\n    assert(type != Type.void);\n    var localIndex = local.index;\n\n    if (type.isNullableReference) {\n      if (!valueType.isNullableReference || flow.isNonnull(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.NONNULL);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.NONNULL);\n    }\n    flow.setLocalFlag(localIndex, LocalFlags.INITIALIZED);\n    if (type.isShortIntegerValue) {\n      if (!flow.canOverflow(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.WRAPPED);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.WRAPPED);\n    }\n    if (tee) { // local = value\n      this.currentType = type;\n      return module.local_tee(localIndex, valueExpr, type.isManaged);\n    } else { // void(local = value)\n      this.currentType = Type.void;\n      return module.local_set(localIndex, valueExpr, type.isManaged);\n    }\n  }\n\n  /** Makes an assignment to a global. */\n  private makeGlobalAssignment(\n    /** The global variable to assign to. */\n    global: VariableLikeElement,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var type = global.type;\n    assert(type != Type.void);\n    var typeRef = type.toRef();\n\n    valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped\n    if (tee) { // (global = value), global\n      this.currentType = type;\n      return module.block(null, [\n        module.global_set(global.internalName, valueExpr),\n        module.global_get(global.internalName, typeRef)\n      ], typeRef);\n    } else { // global = value\n      this.currentType = Type.void;\n      return module.global_set(global.internalName,\n        valueExpr\n      );\n    }\n  }\n\n  /** Makes an assignment to a field. */\n  private makeFieldAssignment(\n    /** The field to assign to. */\n    field: Field,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** The value of `this`. */\n    thisExpr: ExpressionRef,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var fieldType = field.type;\n    var fieldTypeRef = fieldType.toRef();\n    assert(field.parent.kind == ElementKind.CLASS);\n    var thisType = (<Class>field.parent).type;\n\n    if (!field.is(CommonFlags.COMPILED)) {\n      field.set(CommonFlags.COMPILED);\n      let typeNode = field.typeNode;\n      if (typeNode) this.checkTypeSupported(field.type, typeNode);\n    }\n\n    if (tee) {\n      this.compileField(field);\n      let tempThis = flow.getTempLocal(thisType);\n      let expr = module.block(null, [\n        module.call(field.internalSetterName, [ module.local_tee(tempThis.index, thisExpr, thisType.isManaged), valueExpr ], TypeRef.None),\n        module.call(field.internalGetterName, [ module.local_get(tempThis.index, thisType.toRef()) ], fieldTypeRef)\n      ], fieldTypeRef);\n      flow.freeTempLocal(tempThis);\n      this.currentType = fieldType;\n      return expr;\n    } else {\n      this.compileFieldSetter(field);\n      let expr = module.call(field.internalSetterName, [ thisExpr, valueExpr ], TypeRef.None);\n      this.currentType = Type.void;\n      return expr;\n    }\n  }\n\n  /** Compiles a call expression according to the specified context. */\n  private compileCallExpression(\n    /** Call expression to compile. */\n    expression: CallExpression,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints\n  ): ExpressionRef {\n\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // handle call to super\n    if (expression.expression.kind == NodeKind.SUPER) {\n      let flow = this.currentFlow;\n      let actualFunction = flow.actualFunction;\n      if (!actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n        this.error(\n          DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,\n          expression.range\n        );\n        return module.unreachable();\n      }\n\n      let parent = assert(actualFunction.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n      let baseClassInstance = classInstance.base;\n      if (!baseClassInstance) {\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.expression.range\n        );\n        return module.unreachable();\n      }\n      let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n      let sizeTypeRef = this.options.sizeTypeRef;\n\n      let baseCtorInstance = this.ensureConstructor(baseClassInstance, expression);\n      this.checkFieldInitialization(baseClassInstance, expression);\n      let superCall = this.compileCallDirect(\n        baseCtorInstance,\n        expression.args,\n        expression,\n        module.local_get(thisLocal.index, sizeTypeRef)\n      );\n\n      // check that super had been called before accessing `this`\n      if (flow.isAny(\n        FlowFlags.ACCESSES_THIS |\n        FlowFlags.CONDITIONALLY_ACCESSES_THIS\n      )) {\n        this.error(\n          DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,\n          expression.range\n        );\n        return module.unreachable();\n      }\n      flow.set(FlowFlags.ACCESSES_THIS | FlowFlags.CALLS_SUPER);\n      this.currentType = Type.void;\n      return module.local_set(thisLocal.index, superCall, classInstance.type.isManaged);\n    }\n\n    // otherwise resolve normally\n    var target = this.resolver.lookupExpression(expression.expression, flow); // reports\n    if (!target) return module.unreachable();\n    var thisExpression = this.resolver.currentThisExpression;\n\n    var signature: Signature | null;\n    var functionArg: ExpressionRef;\n    switch (target.kind) {\n\n      // direct call: concrete function\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        if (functionPrototype.hasDecorator(DecoratorFlags.BUILTIN)) {\n          // builtins handle present respectively omitted type arguments on their own\n          return this.compileCallExpressionBuiltin(functionPrototype, expression, contextualType);\n        }\n        let functionInstance = this.resolver.maybeInferCall(expression, functionPrototype, flow);\n        if (!functionInstance) return this.module.unreachable();\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.FUNCTION: {\n        let functionInstance = <Function>target;\n        let thisArg: ExpressionRef = 0;\n        if (functionInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(functionInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        return this.compileCallDirect(\n          functionInstance,\n          expression.args,\n          expression,\n          thisArg,\n          constraints\n        );\n      }\n\n      // indirect call: first-class function (non-generic, can't be inlined)\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        signature = local.type.signatureReference;\n        if (signature) {\n          if (local.is(CommonFlags.INLINED)) {\n            let inlinedValue = local.constantIntegerValue;\n            if (this.options.isWasm64) {\n              functionArg = module.i64(i64_low(inlinedValue), i64_high(inlinedValue));\n            } else {\n              assert(!i64_high(inlinedValue));\n              functionArg = module.i32(i64_low(inlinedValue));\n            }\n          } else {\n            functionArg = module.local_get(local.index, this.options.sizeTypeRef);\n          }\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, local.type.toString()\n        );\n        return module.unreachable();\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        signature = global.type.signatureReference;\n        if (signature) {\n          functionArg = module.global_get(global.internalName, global.type.toRef());\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, global.type.toString()\n        );\n        return module.unreachable();\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let fieldType = fieldInstance.type;\n        signature = fieldType.signatureReference;\n        if (signature) {\n          let fieldParent = fieldInstance.parent;\n          assert(fieldParent.kind == ElementKind.CLASS);\n          let usizeType = this.options.usizeType;\n          functionArg = module.load(usizeType.byteSize, false,\n            this.compileExpression(\n              assert(thisExpression),\n              (<Class>fieldParent).type,\n              Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n            ),\n            usizeType.toRef(),\n            fieldInstance.memoryOffset\n          );\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, fieldType.toString()\n        );\n        return module.unreachable();\n      }\n\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>target);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let getterInstance = propertyInstance.getterInstance;\n        let type = assert(this.resolver.getTypeOfElement(target));\n\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n            expression.range, type.toString()\n          );\n          return module.unreachable();\n        }\n\n        let thisArg: ExpressionRef = 0;\n        if (propertyInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        functionArg = this.compileCallDirect(getterInstance, [], expression.expression, thisArg);\n        signature = this.currentType.signatureReference;\n        if (!signature) {\n          this.error(\n            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n            expression.range, this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n        break;\n      }\n      case ElementKind.CLASS: {\n        let classInstance = <Class>target;\n        let typeArguments = classInstance.getTypeArgumentsTo(this.program.functionPrototype);\n        if (typeArguments !== null && typeArguments.length > 0) {\n          let ftype = typeArguments[0];\n          signature = ftype.getSignature();\n          functionArg = this.compileExpression(expression.expression, ftype, Constraints.CONV_IMPLICIT);\n          break;\n        }\n        // fall-through\n      }\n\n      // not supported\n      default: {\n        let type = this.resolver.getTypeOfElement(target);\n        if (type) {\n          this.error(\n            DiagnosticCode.Type_0_has_no_call_signatures,\n            expression.range, type.toString()\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            expression.range\n          );\n        }\n        return module.unreachable();\n      }\n    }\n    return this.compileCallIndirect(\n      assert(signature), // FIXME: bootstrap can't see this yet\n      functionArg,\n      expression.args,\n      expression,\n      0,\n      contextualType == Type.void\n    );\n  }\n\n  /** Compiles the given arguments like a call expression according to the specified context. */\n  private compileCallExpressionLike(\n    /** Called expression. */\n    expression: Expression,\n    /** Call type arguments. */\n    typeArguments: TypeNode[] | null,\n    /** Call arguments. */\n    args: Expression[],\n    /** Diagnostic range. */\n    range: Range,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    // Desugaring like this can happen many times. Let's cache the intermediate allocation.\n    var call = this._reusableCallExpression;\n    if (call) {\n      call.expression = expression;\n      call.typeArguments = typeArguments;\n      call.args = args;\n      call.range = range;\n    } else {\n      this._reusableCallExpression = call = Node.createCallExpression(expression, typeArguments, args, range);\n    }\n    return this.compileCallExpression(call, contextualType, constraints);\n  }\n  private _reusableCallExpression: CallExpression | null = null;\n\n  private compileCallExpressionBuiltin(\n    prototype: FunctionPrototype,\n    expression: CallExpression,\n    contextualType: Type\n  ): ExpressionRef {\n    if (prototype.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n\n    var typeArguments: Type[] | null = null;\n\n    // builtins handle omitted type arguments on their own. if present, however, resolve them here\n    // and pass them to the builtin, even if it's still up to the builtin how to handle them.\n    var typeParameterNodes = prototype.typeParameterNodes;\n    var typeArgumentNodes = expression.typeArguments;\n    if (expression.typeArguments) {\n      if (!prototype.is(CommonFlags.GENERIC)) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          expression.range, prototype.internalName\n        );\n      }\n      typeArguments = this.resolver.resolveTypeArguments(\n        assert(typeParameterNodes),\n        typeArgumentNodes,\n        this.currentFlow.actualFunction.parent,\n        uniqueMap<string,Type>(this.currentFlow.contextualTypeArguments), // don't update\n        expression\n      );\n    }\n    var callee = expression.expression;\n    var ctx = new BuiltinContext(\n      this,\n      prototype,\n      typeArguments,\n      expression.args,\n      callee.kind == NodeKind.PROPERTYACCESS\n        ? (<PropertyAccessExpression>callee).expression\n        : null,\n      contextualType,\n      expression,\n      false\n    );\n    // global builtins\n    var internalName = prototype.internalName;\n    if (builtins.has(internalName)) {\n      let fn = assert(builtins.get(internalName));\n      return fn(ctx);\n    }\n    // class builtins\n    var parent = prototype.parent;\n    if (parent.kind == ElementKind.CLASS) {\n      let classPrototype = (<Class>parent).prototype;\n      if (classPrototype == this.program.functionPrototype) {\n        let methodName = prototype.name;\n        if (function_builtins.has(methodName)) {\n          let fn = assert(function_builtins.get(methodName));\n          return fn(ctx);\n        }\n      }\n    }\n    assert(false);\n    return this.module.unreachable();\n  }\n\n  /**\n   * Checks that a call with the given number as arguments can be performed according to the\n   * specified signature.\n   */\n  checkCallSignature(\n    signature: Signature,\n    numArguments: i32,\n    hasThis: bool,\n    reportNode: Node\n  ): bool {\n\n    // cannot call an instance method without a `this` argument (TODO: `.call`?)\n    var thisType = signature.thisType;\n    if (hasThis != (thisType != null)) {\n      this.error(\n        DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n        reportNode.range\n      );\n      return false;\n    }\n\n    // not yet implemented (TODO: maybe some sort of an unmanaged/lightweight array?)\n    var hasRest = signature.hasRest;\n    if (hasRest) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        reportNode.range, \"Rest parameters\"\n      );\n      return false;\n    }\n\n    var minimum = signature.requiredParameters;\n    var maximum = signature.parameterTypes.length;\n\n    // must at least be called with required arguments\n    if (numArguments < minimum) {\n      this.error(\n        minimum < maximum\n          ? DiagnosticCode.Expected_at_least_0_arguments_but_got_1\n          : DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, minimum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    // must not be called with more than the maximum arguments\n    if (numArguments > maximum && !hasRest) {\n      this.error(\n        DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, maximum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  /** Checks that an unsafe expression is allowed. */\n  private checkUnsafe(reportNode: Node, relatedReportNode: Node | null = null): void {\n    // Library files may always use unsafe features\n    if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {\n      if (relatedReportNode) {\n        this.errorRelated(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range, relatedReportNode.range\n        );\n      } else {\n        this.error(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range\n        );\n      }\n    }\n  }\n\n  /** Compiles a direct call to a concrete function. */\n  compileCallDirect(\n    instance: Function,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    var numArguments = argumentExpressions.length;\n    var signature = instance.signature;\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      this.currentType = signature.returnType;\n      return this.module.unreachable();\n    }\n    if (instance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);\n\n    // handle call on `this` in constructors\n    let actualFunction = this.currentFlow.actualFunction;\n    if (actualFunction.is(CommonFlags.CONSTRUCTOR) && reportNode.isAccessOnThis) {\n      let parent = actualFunction.parent;\n      assert(parent.kind == ElementKind.CLASS);\n      this.checkFieldInitialization(<Class>parent, reportNode);\n    }\n\n    // Inline if explicitly requested\n    if (instance.hasDecorator(DecoratorFlags.INLINE) && (!instance.is(CommonFlags.VIRTUAL) || reportNode.isAccessOnSuper)) {\n      assert(!instance.is(CommonFlags.STUB)); // doesn't make sense\n      let inlineStack = this.inlineStack;\n      if (inlineStack.includes(instance)) {\n        this.warning(\n          DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n          reportNode.range, instance.internalName\n        );\n      } else {\n        inlineStack.push(instance);\n        let parameterTypes = signature.parameterTypes;\n        assert(numArguments <= parameterTypes.length);\n        // compile argument expressions\n        let args = new Array<ExpressionRef>(numArguments);\n        for (let i = 0; i < numArguments; ++i) {\n          args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i], Constraints.CONV_IMPLICIT);\n        }\n        // make the inlined call\n        let expr = this.makeCallInline(instance, args, thisArg, (constraints & Constraints.WILL_DROP) != 0);\n        inlineStack.pop();\n        return expr;\n      }\n    }\n\n    // Otherwise compile to just a call\n    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    var operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    var index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    var parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      let paramType = parameterTypes[i];\n      let paramExpr = this.compileExpression(argumentExpressions[i], paramType, Constraints.CONV_IMPLICIT);\n      operands[index] = paramExpr;\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallDirect(instance, operands, reportNode, (constraints & Constraints.WILL_DROP) != 0);\n  }\n\n  makeCallInline(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    var numArguments = operands ? operands.length : 0;\n    var signature = instance.signature;\n    var parameterTypes = signature.parameterTypes;\n    var numParameters = parameterTypes.length;\n\n    // Create a new inline flow and use it to compile the function as a block\n    var previousFlow = this.currentFlow;\n    var flow = Flow.createInline(previousFlow.parentFunction, instance);\n    var body = [];\n    var usedLocals = new Set<i32>();\n\n    // Prepare compiled arguments right to left, keeping track of used locals.\n    for (let i = numArguments - 1; i >= 0; --i) {\n      // This is necessary because a later expression must not set an earlier argument local, which\n      // is also just a temporary, when being executed. Take for example `t1=1, t2=(t1 = 2)`, where\n      // the right expression would reassign the foregoing argument local. So, we iterate from right\n      // to left, remembering what's used later, and don't use these for earlier arguments, making\n      // the example above essentially `t2=1, t1=(t1 = 2)`.\n      let paramExpr = operands![i];\n      let paramType = parameterTypes[i];\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), paramType, usedLocals);\n      findUsedLocals(paramExpr, usedLocals);\n      // inlining is aware of wrap/nonnull states:\n      if (!previousFlow.canOverflow(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.WRAPPED);\n      if (flow.isNonnull(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NONNULL);\n      body.unshift(\n        module.local_set(argumentLocal.index, paramExpr, paramType.isManaged)\n      );\n    }\n    if (thisArg) {\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n      let thisType = assert(instance.signature.thisType);\n      let thisLocal = flow.addScopedLocal(CommonNames.this_, thisType, usedLocals);\n      body.unshift(\n        module.local_set(thisLocal.index, thisArg, thisType.isManaged)\n      );\n      let base = classInstance.base;\n      if (base) flow.addScopedAlias(CommonNames.super_, base.type, thisLocal.index);\n    } else {\n      assert(!instance.signature.thisType);\n    }\n\n    // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of\n    // side-effects within earlier expressions because these already happened on set.\n    this.currentFlow = flow;\n    var isConstructor = instance.is(CommonFlags.CONSTRUCTOR);\n    if (isConstructor) flow.set(FlowFlags.CTORPARAM_CONTEXT);\n    for (let i = numArguments; i < numParameters; ++i) {\n      let initType = parameterTypes[i];\n      let initExpr = this.compileExpression(\n        assert(instance.prototype.functionTypeNode.parameters[i].initializer),\n        initType,\n        Constraints.CONV_IMPLICIT\n      );\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), initType);\n      body.push(\n        this.makeLocalAssignment(argumentLocal, initExpr, initType, false)\n      );\n    }\n    flow.unset(FlowFlags.CTORPARAM_CONTEXT);\n\n    // Compile the called function's body in the scope of the inlined flow\n    this.compileFunctionBody(instance, body);\n\n    // If a constructor, perform field init checks on its flow directly\n    if (isConstructor) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.CLASS);\n      this.checkFieldInitializationInFlow(<Class>parent, flow);\n    }\n\n    // Free any new scoped locals and reset to the original flow\n    flow.freeScopedLocals();\n    var returnType = flow.returnType;\n    this.currentFlow = previousFlow;\n\n    // Create an outer block that we can break to when returning a value out of order\n    this.currentType = returnType;\n    return module.block(flow.inlineReturnLabel, body, returnType.toRef());\n  }\n\n  /** Makes sure that the arguments length helper global is present. */\n  ensureArgumentsLength(): string {\n    var name = BuiltinNames.argumentsLength;\n    if (!this.builtinArgumentsLength) {\n      let module = this.module;\n      this.builtinArgumentsLength = module.addGlobal(name, TypeRef.I32, true, module.i32(0));\n    }\n    return name;\n  }\n\n  /** Ensures compilation of the varargs stub for the specified function. */\n  ensureVarargsStub(original: Function): Function {\n    // A varargs stub is a function called with omitted arguments being zeroed,\n    // reading the `argumentsLength` helper global to decide which initializers\n    // to inject before calling the original function. It is typically attempted\n    // to circumvent the varargs stub where possible, for example where omitted\n    // arguments are constants and can be inlined into the original call.\n    var stub = original.varargsStub;\n    if (stub) return stub;\n\n    var originalSignature = original.signature;\n    var originalParameterTypes = originalSignature.parameterTypes;\n    var originalParameterDeclarations = original.prototype.functionTypeNode.parameters;\n    var returnType = originalSignature.returnType;\n    var isInstance = original.is(CommonFlags.INSTANCE);\n\n    // arguments excl. `this`, operands incl. `this`\n    var minArguments = originalSignature.requiredParameters;\n    var minOperands = minArguments;\n    var maxArguments = originalParameterTypes.length;\n    var maxOperands = maxArguments;\n    if (isInstance) {\n      ++minOperands;\n      ++maxOperands;\n    }\n    var numOptional = assert(maxOperands - minOperands);\n\n    var forwardedOperands = new Array<ExpressionRef>(minOperands);\n    var operandIndex = 0;\n    var stmts = new Array<ExpressionRef>();\n\n    // forward `this` if applicable\n    var module = this.module;\n    var thisType = originalSignature.thisType;\n    if (thisType) {\n      forwardedOperands[0] = module.local_get(0, thisType.toRef());\n      operandIndex = 1;\n    }\n\n    // forward required arguments\n    for (let i = 0; i < minArguments; ++i, ++operandIndex) {\n      let paramType = originalParameterTypes[i];\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, paramType.toRef());\n    }\n    assert(operandIndex == minOperands);\n\n    // create the varargs stub\n    stub = original.newStub(\"varargs\");\n    stub.signature.requiredParameters = maxArguments;\n    original.varargsStub = stub;\n\n    // compile initializers of omitted arguments in the scope of the stub,\n    // accounting for additional locals and a proper `this` context.\n    var previousFlow = this.currentFlow;\n    var flow = stub.flow;\n    if (original.is(CommonFlags.CONSTRUCTOR)) flow.set(FlowFlags.CTORPARAM_CONTEXT);\n    this.currentFlow = flow;\n\n    // create a br_table switching over the number of optional parameters provided\n    var numNames = numOptional + 1; // incl. outer block\n    var names = new Array<string>(numNames);\n    var ofN = \"of\" + numOptional.toString();\n    for (let i = 0; i < numNames; ++i) {\n      let label = i.toString() + ofN;\n      names[i] = label;\n    }\n    var argumentsLength = this.ensureArgumentsLength();\n    var table = module.block(names[0], [\n      module.block(\"outOfRange\", [\n        module.switch(names, \"outOfRange\",\n          // condition is number of provided optional arguments, so subtract required arguments\n          minArguments\n            ? module.binary(\n                BinaryOp.SubI32,\n                module.global_get(argumentsLength, TypeRef.I32),\n                module.i32(minArguments)\n              )\n            : module.global_get(argumentsLength, TypeRef.I32)\n        )\n      ]),\n      module.unreachable()\n    ]);\n    for (let i = 0; i < numOptional; ++i, ++operandIndex) {\n      let type = originalParameterTypes[minArguments + i];\n      let declaration = originalParameterDeclarations[minArguments + i];\n      let initializer = declaration.initializer;\n      let initExpr: ExpressionRef;\n      if (initializer) {\n        initExpr = this.compileExpression(\n          initializer,\n          type,\n          Constraints.CONV_IMPLICIT\n        );\n        initExpr = module.local_set(operandIndex, initExpr, type.isManaged);\n      } else {\n        this.error(\n          DiagnosticCode.Optional_parameter_must_have_an_initializer,\n          declaration.range\n        );\n        initExpr = module.unreachable();\n      }\n      table = module.block(names[i + 1], [\n        table,\n        initExpr,\n      ]);\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toRef());\n    }\n    assert(operandIndex == maxOperands);\n\n    stmts.push(\n      table\n    );\n    stmts.push(\n      // assume this will always succeed (can just use name as the reportNode)\n      this.makeCallDirect(original, forwardedOperands, original.declaration.name)\n    );\n    flow.freeScopedLocals();\n    this.currentFlow = previousFlow;\n\n    var funcRef = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      typesToRefs(stub.additionalLocals),\n      module.flatten(stmts, returnType.toRef())\n    );\n    stub.set(CommonFlags.COMPILED);\n    stub.finalize(module, funcRef);\n    return stub;\n  }\n\n  /** Ensures compilation of the virtual stub for the specified function. */\n  ensureVirtualStub(original: Function): Function {\n    // A virtual stub is a function redirecting virtual calls to the actual\n    // overload targeted by the call. It utilizes varargs stubs where necessary\n    // and as such has the same semantics as one. Here, we only make sure that\n    // a placeholder exist, with actual code being generated as a finalization\n    // step once module compilation is otherwise complete.\n    var stub = original.virtualStub;\n    if (stub) return stub;\n    stub = original.newStub(\"virtual\");\n    original.virtualStub = stub;\n    var module = this.module;\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      null,\n      module.unreachable()\n    );\n    this.virtualStubs.add(original);\n    return stub;\n  }\n\n  /** Finalizes the virtual stub of the specified function. */\n  private finalizeVirtualStub(instance: Function): void {\n    var stub = this.ensureVirtualStub(instance);\n    if (stub.is(CommonFlags.COMPILED)) return;\n\n    assert(instance.parent.kind == ElementKind.CLASS || instance.parent.kind == ElementKind.INTERFACE);\n    var module = this.module;\n    var usizeType = this.options.usizeType;\n    var sizeTypeRef = usizeType.toRef();\n    var parameterTypes = instance.signature.parameterTypes;\n    var returnType = instance.signature.returnType;\n    var numParameters = parameterTypes.length;\n    var tempIndex = 1 + parameterTypes.length; // incl. `this`\n\n    // Switch over this's rtId and map it to the respective overload\n    var builder = new SwitchBuilder(this.module,\n      module.load(4, false,\n        module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          module.local_get(0, sizeTypeRef),\n          sizeTypeRef == TypeRef.I64\n            ? module.i64(8) // rtId offset = -8\n            : module.i32(8)\n        ),\n        TypeRef.I32\n      )\n    );\n    var overloadInstances = this.resolver.resolveOverloads(instance);\n    if (overloadInstances) {\n      for (let i = 0, k = overloadInstances.length; i < k; ++i) {\n        let overloadInstance = overloadInstances[i];\n        if (!overloadInstance.is(CommonFlags.COMPILED)) continue; // errored\n        let overloadType = overloadInstance.type;\n        let originalType = instance.type;\n        if (!overloadType.isAssignableTo(originalType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            overloadInstance.identifierNode.range, overloadType.toString(), originalType.toString()\n          );\n          continue;\n        }\n        // TODO: additional optional parameters are not permitted by `isAssignableTo` yet\n        let overloadSignature = overloadInstance.signature;\n        let overloadParameterTypes = overloadSignature.parameterTypes;\n        let overloadNumParameters = overloadParameterTypes.length;\n        let paramExprs = new Array<ExpressionRef>(1 + overloadNumParameters);\n        paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n        for (let n = 1; n <= numParameters; ++n) {\n          paramExprs[n] = module.local_get(n, parameterTypes[n - 1].toRef());\n        }\n        let needsVarargsStub = false;\n        for (let n = numParameters; n < overloadNumParameters; ++n) {\n          // TODO: inline constant initializers and skip varargs stub\n          paramExprs[1 + n] = this.makeZero(overloadParameterTypes[n], overloadInstance.declaration);\n          needsVarargsStub = true;\n        }\n        let calledName = needsVarargsStub\n          ? this.ensureVarargsStub(overloadInstance).internalName\n          : overloadInstance.internalName;\n        let returnTypeRef = overloadSignature.returnType.toRef();\n        let stmts = new Array<ExpressionRef>();\n        if (needsVarargsStub) {\n          // Safe to prepend since paramExprs are local.get's\n          stmts.push(module.global_set(this.ensureArgumentsLength(), module.i32(numParameters)));\n        }\n        if (returnType == Type.void) {\n          stmts.push(\n            module.call(calledName, paramExprs, returnTypeRef)\n          );\n          stmts.push(\n            module.return()\n          );\n        } else {\n          stmts.push(\n            module.return(\n              module.call(calledName, paramExprs, returnTypeRef)\n            )\n          );\n        }\n        let classInstance = assert(overloadInstance.getClassOrInterface());\n        builder.addCase(classInstance.id, stmts);\n        // Also alias each extendee inheriting this exact overload\n        let extendees = classInstance.getAllExtendees(instance.declaration.name.text); // without get:/set:\n        for (let _values = Set_values(extendees), a = 0, b = _values.length; a < b; ++a) {\n          let extendee = _values[a];\n          builder.addCase(extendee.id, stmts);\n        }\n      }\n    }\n\n    // Call the original function if no other id matches and the method is not\n    // abstract or part of an interface. Note that doing so will not catch an\n    // invalid id, but can reduce code size significantly since we also don't\n    // have to add branches for extendees inheriting the original function.\n    var body: ExpressionRef;\n    if (instance.prototype.bodyNode) {\n      let paramExprs = new Array<ExpressionRef>(numParameters);\n      paramExprs[0] = module.local_get(0, sizeTypeRef); // this\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        paramExprs[1 + i] = module.local_get(1 + i, parameterTypes[i].toRef());\n      }\n      body = module.call(instance.internalName, paramExprs, returnType.toRef());\n\n    // Otherwise trap\n    } else {\n      body = module.unreachable();\n    }\n\n    // Create the virtual stub function\n    var ref = stub.ref;\n    if (ref) module.removeFunction(stub.internalName);\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.paramRefs,\n      stub.signature.resultRefs,\n      [ TypeRef.I32 ],\n      module.block(null, [\n        builder.render(tempIndex),\n        body\n      ], returnType.toRef())\n    );\n    stub.set(CommonFlags.COMPILED);\n  }\n\n  /** Marks managed call operands for the shadow stack. */\n  private operandsTostack(signature: Signature, operands: ExpressionRef[]): void {\n    if (!this.options.stackSize) return;\n    var module = this.module;\n    var operandIndex = 0;\n    var thisType = signature.thisType;\n    if (thisType) {\n      if (thisType.isManaged) {\n        let operand = operands[0];\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\n        if (!isConstZero(precomp)) { // otherwise unnecessary\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n    }\n    var parameterIndex = 0;\n    var parameterTypes = signature.parameterTypes;\n    assert(parameterTypes.length >= operands.length - operandIndex);\n    while (operandIndex < operands.length) {\n      let paramType = parameterTypes[parameterIndex];\n      if (paramType.isManaged) {\n        let operand = operands[operandIndex];\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\n        if (!isConstZero(precomp)) { // otherwise unnecessary\n          operands[operandIndex] = module.tostack(operand);\n        }\n      }\n      ++operandIndex;\n      ++parameterIndex;\n    }\n  }\n\n  /** Creates a direct call to the specified function. */\n  makeCallDirect(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    reportNode: Node,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    if (instance.hasDecorator(DecoratorFlags.INLINE)) {\n      if (!instance.is(CommonFlags.VIRTUAL)) {\n        assert(!instance.is(CommonFlags.STUB)); // doesn't make sense\n        let inlineStack = this.inlineStack;\n        if (inlineStack.includes(instance)) {\n          this.warning(\n            DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n            reportNode.range, instance.internalName\n          );\n        } else {\n          inlineStack.push(instance);\n          let expr: ExpressionRef;\n          if (instance.is(CommonFlags.INSTANCE)) {\n            let theOperands = assert(operands);\n            assert(theOperands.length);\n            expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);\n          } else {\n            expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);\n          }\n          inlineStack.pop();\n          return expr;\n        }\n      } else {\n        this.warning(\n          DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,\n          reportNode.range, instance.internalName\n        );\n      }\n    }\n    var module = this.module;\n    var numOperands = operands ? operands.length : 0;\n    var numArguments = numOperands;\n    var minArguments = instance.signature.requiredParameters;\n    var minOperands = minArguments;\n    var parameterTypes = instance.signature.parameterTypes;\n    var maxArguments = parameterTypes.length;\n    var maxOperands = maxArguments;\n    if (instance.is(CommonFlags.INSTANCE)) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    if (!this.compileFunction(instance)) return module.unreachable();\n    var returnType = instance.signature.returnType;\n\n    // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterNodes = instance.prototype.functionTypeNode.parameters;\n      assert(parameterNodes.length == parameterTypes.length);\n      let allOptionalsAreConstant = true;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        let initializer = parameterNodes[i].initializer;\n        if (initializer) {\n          if (initializer.compilesToConst) {\n            operands.push(this.compileExpression(\n              initializer,\n              parameterTypes[i],\n              Constraints.CONV_IMPLICIT\n            ));\n            continue;\n          }\n          let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i], ReportMode.SWALLOW);\n          if (resolved) {\n            if (resolved.kind == ElementKind.GLOBAL) {\n              let global = <Global>resolved;\n              if (this.compileGlobal(global)) {\n                if (global.is(CommonFlags.INLINED)) {\n                  operands.push(\n                    this.compileInlineConstant(global, parameterTypes[i], Constraints.CONV_IMPLICIT)\n                  );\n                } else {\n                  operands.push(\n                    this.convertExpression(\n                      module.global_get(global.internalName, global.type.toRef()),\n                      global.type, parameterTypes[i], false, initializer\n                    )\n                  );\n                }\n                continue;\n              }\n            }\n          }\n        }\n        operands.push(this.makeZero(parameterTypes[i], instance.declaration));\n        allOptionalsAreConstant = false;\n      }\n      if (!allOptionalsAreConstant && !instance.is(CommonFlags.MODULE_IMPORT)) {\n        let original = instance;\n        instance = this.ensureVarargsStub(instance);\n        if (!this.compileFunction(instance)) return module.unreachable();\n        instance.flow.flags = original.flow.flags;\n        let returnTypeRef = returnType.toRef();\n        // We know the last operand is optional and omitted, so inject setting\n        // ~argumentsLength into that operand, which is always safe.\n        let lastOperand = operands[maxOperands - 1];\n        assert(!(getSideEffects(lastOperand, module.ref) & SideEffects.WritesGlobal));\n        let lastOperandType = parameterTypes[maxArguments - 1];\n        operands[maxOperands - 1] = module.block(null, [\n          module.global_set(this.ensureArgumentsLength(), module.i32(numArguments)),\n          lastOperand\n        ], lastOperandType.toRef());\n        this.operandsTostack(instance.signature, operands);\n        let expr = module.call(instance.internalName, operands, returnTypeRef);\n        if (returnType != Type.void && immediatelyDropped) {\n          expr = module.drop(expr);\n          this.currentType = Type.void;\n        } else {\n          this.currentType = returnType;\n        }\n        return expr;\n      }\n    }\n\n    // Call the virtual stub with the vtable if the function has overloads\n    if (instance.is(CommonFlags.VIRTUAL) && !reportNode.isAccessOnSuper) {\n      instance = this.ensureVirtualStub(instance);\n    }\n\n    if (operands) this.operandsTostack(instance.signature, operands);\n    var expr = module.call(instance.internalName, operands, returnType.toRef());\n    this.currentType = returnType;\n    return expr;\n  }\n\n  /** Compiles an indirect call to a first-class function. */\n  compileCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    var numArguments = argumentExpressions.length;\n\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      return this.module.unreachable();\n    }\n\n    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    var operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    var index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    var parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallIndirect(signature, functionArg, reportNode, operands, immediatelyDropped);\n  }\n\n  /** Creates an indirect call to a first-class function. */\n  makeCallIndirect(\n    signature: Signature,\n    functionArg: ExpressionRef,\n    reportNode: Node,\n    operands: ExpressionRef[] | null = null,\n    immediatelyDropped: bool = false,\n  ): ExpressionRef {\n    var module = this.module;\n    var numOperands = operands ? operands.length : 0;\n    var numArguments = numOperands;\n    var minArguments = signature.requiredParameters;\n    var minOperands = minArguments;\n    var parameterTypes = signature.parameterTypes;\n    var returnType = signature.returnType;\n    var maxArguments = parameterTypes.length;\n    var maxOperands = maxArguments;\n    if (signature.thisType) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    // fill up omitted arguments with zeroes\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        operands.push(this.makeZero(parameterTypes[i], reportNode));\n      }\n    }\n\n    // We might be calling a varargs stub here, even if all operands have been\n    // provided, so we must set `argumentsLength` in any case. Inject setting it\n    // into the index argument, which becomes executed last after any operands.\n    var argumentsLength = this.ensureArgumentsLength();\n    var sizeTypeRef = this.options.sizeTypeRef;\n    if (getSideEffects(functionArg, module.ref) & SideEffects.WritesGlobal) {\n      let flow = this.currentFlow;\n      let temp = flow.getTempLocal(this.options.usizeType, findUsedLocals(functionArg));\n      functionArg = module.block(null, [\n        module.local_set(temp.index, functionArg, true), // Function\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        module.local_get(temp.index, sizeTypeRef)\n      ], sizeTypeRef);\n      flow.freeTempLocal(temp);\n    } else { // simplify\n      functionArg = module.block(null, [\n        module.global_set(argumentsLength, module.i32(numArguments)),\n        functionArg\n      ], sizeTypeRef);\n    }\n    if (operands) this.operandsTostack(signature, operands);\n    var expr = module.call_indirect(\n      null, // TODO: handle multiple tables\n      module.load(4, false, functionArg, TypeRef.I32), // ._index\n      operands,\n      signature.paramRefs,\n      signature.resultRefs\n    );\n    this.currentType = returnType;\n    return expr;\n  }\n\n  private compileCommaExpression(\n    expression: CommaExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var expressions = expression.expressions;\n    var numExpressions = expressions.length;\n    var exprs = new Array<ExpressionRef>(numExpressions--);\n    for (let i = 0; i < numExpressions; ++i) {\n      exprs[i] = this.compileExpression(expressions[i], Type.void, // drop all except last\n        Constraints.CONV_IMPLICIT | Constraints.WILL_DROP\n      );\n    }\n    exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);\n    return this.module.flatten(exprs, this.currentType.toRef());\n  }\n\n  private compileElementAccessExpression(\n    expression: ElementAccessExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var targetExpression = expression.expression;\n    var targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports\n    if (targetType) {\n      let classReference = targetType.getClassOrWrapper(this.program);\n      if (classReference) {\n        let isUnchecked = this.currentFlow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let indexedGet = classReference.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n        if (indexedGet) {\n          let thisType = assert(indexedGet.signature.thisType);\n          let thisArg = this.compileExpression(targetExpression, thisType,\n            Constraints.CONV_IMPLICIT\n          );\n          if (!isUnchecked && this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n              expression.range\n            );\n          }\n          return this.compileCallDirect(indexedGet, [\n            expression.elementExpression\n          ], expression, thisArg, constraints);\n        }\n      }\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        expression.expression.range, targetType.toString()\n      );\n    }\n    return module.unreachable();\n  }\n\n  private compileFunctionExpression(\n    expression: FunctionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var declaration = expression.declaration.clone(); // generic contexts can have multiple\n    assert(!declaration.typeParameters); // function expression cannot be generic\n    var flow = this.currentFlow;\n    var actualFunction = flow.actualFunction;\n    var isNamed = declaration.name.text.length > 0;\n    var isSemanticallyAnonymous = !isNamed || contextualType != Type.void;\n    var prototype = new FunctionPrototype(\n      isSemanticallyAnonymous\n        ? (isNamed ? declaration.name.text + \"|\" : \"anonymous|\") + (actualFunction.nextAnonymousId++).toString()\n        : declaration.name.text,\n      actualFunction,\n      declaration,\n      DecoratorFlags.NONE\n    );\n    var instance: Function | null;\n    var contextualTypeArguments = uniqueMap(flow.contextualTypeArguments);\n    var module = this.module;\n\n    // compile according to context. this differs from a normal function in that omitted parameter\n    // and return types can be inferred and omitted arguments can be replaced with dummies.\n    var contextualSignature = contextualType.signatureReference;\n    if (contextualSignature) {\n      let signatureNode = prototype.functionTypeNode;\n      let parameterNodes = signatureNode.parameters;\n      let numPresentParameters = parameterNodes.length;\n\n      // must not require more than the maximum number of parameters\n      let parameterTypes = contextualSignature.parameterTypes;\n      let numParameters = parameterTypes.length;\n      if (numPresentParameters > numParameters) {\n        this.error(\n          DiagnosticCode.Expected_0_arguments_but_got_1,\n          expression.range, numParameters.toString(), numPresentParameters.toString()\n        );\n        return module.unreachable();\n      }\n\n      // check non-omitted parameter types\n      for (let i = 0; i < numPresentParameters; ++i) {\n        let parameterNode = parameterNodes[i];\n        if (!isTypeOmitted(parameterNode.type)) {\n          let resolvedType = this.resolver.resolveType(\n            parameterNode.type,\n            actualFunction.parent,\n            contextualTypeArguments\n          );\n          if (!resolvedType) return module.unreachable();\n          if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n              parameterNode.range, parameterTypes[i].toString(), resolvedType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        // any unused parameters are inherited but ignored\n      }\n\n      // check non-omitted return type\n      let returnType = contextualSignature.returnType;\n      if (!isTypeOmitted(signatureNode.returnType)) {\n        let resolvedType = this.resolver.resolveType(\n          signatureNode.returnType,\n          actualFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (\n          returnType == Type.void\n            ? resolvedType != Type.void\n            : !resolvedType.isStrictlyAssignableTo(returnType)\n        ) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            signatureNode.returnType.range, resolvedType.toString(), returnType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      // check explicit this type\n      let thisType = contextualSignature.thisType;\n      let thisTypeNode = signatureNode.explicitThisType;\n      if (thisTypeNode) {\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            thisTypeNode.range\n          );\n          return module.unreachable();\n        }\n        let resolvedType = this.resolver.resolveType(\n          thisTypeNode,\n          actualFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return module.unreachable();\n        if (!thisType.isStrictlyAssignableTo(resolvedType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            thisTypeNode.range, thisType.toString(), resolvedType.toString()\n          );\n          return module.unreachable();\n        }\n      }\n\n      let signature = new Signature(this.program, parameterTypes, returnType, thisType);\n      signature.requiredParameters = numParameters; // !\n      instance = new Function(\n        prototype.name,\n        prototype,\n        null,\n        signature,\n        contextualTypeArguments\n      );\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = contextualSignature.type;\n      if (!worked) return module.unreachable();\n\n    // otherwise compile like a normal function\n    } else {\n      instance = this.resolver.resolveFunction(prototype, null, contextualTypeArguments);\n      if (!instance) return this.module.unreachable();\n      instance.flow.outer = flow;\n      let worked = this.compileFunction(instance);\n      this.currentType = instance.signature.type;\n      if (!worked) return module.unreachable();\n    }\n\n    var offset = this.ensureRuntimeFunction(instance); // reports\n    var expr = this.options.isWasm64\n      ? module.i64(i64_low(offset), i64_high(offset))\n      : module.i32(i64_low(offset));\n\n    // add a constant local referring to the function if applicable\n    if (!isSemanticallyAnonymous) {\n      let fname = instance.name;\n      let existingLocal = flow.getScopedLocal(fname);\n      if (existingLocal) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existingLocal.declaration.name.range,\n            fname\n          );\n        } else { // scoped locals are shared temps that don't track declarations\n          this.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range, fname\n          );\n        }\n      } else {\n        let ftype = instance.type;\n        let local = flow.addScopedLocal(instance.name, ftype);\n        flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\n        expr = module.local_tee(local.index, expr, ftype.isManaged);\n      }\n    }\n\n    return expr;\n  }\n\n  /** Makes sure the enclosing source file of the specified expression has been compiled. */\n  private maybeCompileEnclosingSource(expression: Expression): void {\n    var internalPath = expression.range.source.internalPath;\n    var filesByName = this.program.filesByName;\n    assert(filesByName.has(internalPath));\n    var enclosingFile = assert(filesByName.get(internalPath));\n    if (!enclosingFile.is(CommonFlags.COMPILED)) {\n      this.compileFileByPath(internalPath, expression);\n    }\n  }\n\n  private compileIdentifierExpression(\n    expression: IdentifierExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var actualFunction = flow.actualFunction;\n\n    // check special keywords first\n    switch (expression.kind) {\n      case NodeKind.NULL: {\n        let options = this.options;\n        if (contextualType.isReference) {\n          let classReference = contextualType.getClass();\n          if (classReference) {\n            this.currentType = classReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          let signatureReference = contextualType.getSignature();\n          if (signatureReference) {\n            this.currentType = signatureReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          return this.makeZero(contextualType, expression);\n        }\n        this.currentType = options.usizeType;\n        this.warning(\n          DiagnosticCode.Expression_resolves_to_unusual_type_0,\n          expression.range, this.currentType.toString()\n        );\n        return options.isWasm64\n          ? module.i64(0)\n          : module.i32(0);\n      }\n      case NodeKind.TRUE: {\n        this.currentType = Type.bool;\n        return module.i32(1);\n      }\n      case NodeKind.FALSE: {\n        this.currentType = Type.bool;\n        return module.i32(0);\n      }\n      case NodeKind.THIS: {\n        let thisType = actualFunction.signature.thisType;\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            expression.range\n          );\n          this.currentType = this.options.usizeType;\n          return module.unreachable();\n        }\n        if (actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n          if (flow.is(FlowFlags.CTORPARAM_CONTEXT)) {\n            this.error(\n              DiagnosticCode._this_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          }\n          if (!(constraints & Constraints.IS_THIS)) {\n            let parent = actualFunction.parent;\n            assert(parent.kind == ElementKind.CLASS);\n            this.checkFieldInitialization(<Class>parent, expression);\n          }\n        }\n        let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n        flow.set(FlowFlags.ACCESSES_THIS);\n        this.currentType = thisType;\n        return module.local_get(thisLocal.index, thisType.toRef());\n      }\n      case NodeKind.SUPER: {\n        if (actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n          if (flow.is(FlowFlags.CTORPARAM_CONTEXT)) {\n            this.error(\n              DiagnosticCode._super_cannot_be_referenced_in_constructor_arguments,\n              expression.range\n            );\n          } else if (!flow.is(FlowFlags.CALLS_SUPER)) {\n            // TS1034 in the parser effectively limits this to property accesses\n            this.error(\n              DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,\n              expression.range\n            );\n          }\n        }\n        if (flow.isInline) {\n          let scopedThis = flow.lookupLocal(CommonNames.this_);\n          if (scopedThis) {\n            let scopedThisClass = assert(scopedThis.type.getClass());\n            let base = scopedThisClass.base;\n            if (base) {\n              this.currentType = base.type;\n              return module.local_get(scopedThis.index, base.type.toRef());\n            }\n          }\n        }\n        if (actualFunction.is(CommonFlags.INSTANCE)) {\n          let parent = assert(actualFunction.parent);\n          assert(parent.kind == ElementKind.CLASS);\n          let classInstance = <Class>parent;\n          let baseClassInstance = classInstance.base;\n          if (baseClassInstance) {\n            let superType = baseClassInstance.type;\n            this.currentType = superType;\n            return module.local_get(0, superType.toRef());\n          }\n        }\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.range\n        );\n        this.currentType = this.options.usizeType;\n        return module.unreachable();\n      }\n    }\n\n    this.maybeCompileEnclosingSource(expression);\n\n    // otherwise resolve\n    var currentParent = this.currentParent;\n    if (!currentParent) currentParent = actualFunction;\n    var target = this.resolver.lookupIdentifierExpression( // reports\n      expression,\n      flow,\n      currentParent\n    );\n    if (!target) {\n      // make a guess to avoid assertions in calling code\n      if (this.currentType == Type.void) this.currentType = Type.i32;\n      return module.unreachable();\n    }\n\n    switch (target.kind) {\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        let localType = local.type;\n        assert(localType != Type.void);\n        if (this.pendingElements.has(local)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            local.internalName\n          );\n          this.currentType = localType;\n          return module.unreachable();\n        }\n        if (local.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(local, contextualType, constraints);\n        }\n        let localIndex = local.index;\n        assert(localIndex >= 0);\n        if (localType.isNullableReference && flow.isLocalFlag(localIndex, LocalFlags.NONNULL, false)) {\n          localType = localType.nonNullableType;\n        }\n        this.currentType = localType;\n\n        if (target.parent != flow.parentFunction) {\n          // TODO: closures\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range,\n            \"Closures\"\n          );\n          return module.unreachable();\n        }\n        return module.local_get(localIndex, localType.toRef());\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) { // reports; not yet compiled if a static field\n          return module.unreachable();\n        }\n        let globalType = global.type;\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        assert(globalType != Type.void);\n        if (global.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(global, contextualType, constraints);\n        }\n        this.currentType = globalType;\n        return module.global_get(global.internalName, globalType.toRef());\n      }\n      case ElementKind.ENUMVALUE: { // here: if referenced from within the same enum\n        let enumValue = <EnumValue>target;\n        if (!target.is(CommonFlags.COMPILED)) {\n          this.error(\n            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,\n            expression.range\n          );\n          this.currentType = Type.i32;\n          return module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.INLINED)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n          return module.i32(i64_low(enumValue.constantIntegerValue));\n        }\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        let typeParameterNodes = functionPrototype.typeParameterNodes;\n\n        if (typeParameterNodes !== null && typeParameterNodes.length != 0) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            expression.range\n          );\n          break; // also diagnose 'not a value at runtime'\n        }\n\n        let functionInstance = this.resolver.resolveFunction(\n          functionPrototype,\n          null,\n          uniqueMap<string,Type>(flow.contextualTypeArguments)\n        );\n        if (!functionInstance || !this.compileFunction(functionInstance)) return module.unreachable();\n        if (contextualType.isExternalReference) {\n          this.currentType = Type.funcref;\n          return module.ref_func(functionInstance.internalName, TypeRef.Funcref); // TODO\n        }\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        this.currentType = functionInstance.signature.type;\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return module.unreachable();\n  }\n\n  private compileInstanceOfExpression(\n    expression: InstanceOfExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var flow = this.currentFlow;\n    var isType = expression.isType;\n\n    // Mimic `instanceof CLASS`\n    if (isType.kind == NodeKind.NAMEDTYPE) {\n      let namedType = <NamedTypeNode>isType;\n      if (!(namedType.isNullable || namedType.hasTypeArguments)) {\n        let element = this.resolver.resolveTypeName(namedType.name, flow.actualFunction, ReportMode.SWALLOW);\n        if (element !== null && element.kind == ElementKind.CLASS_PROTOTYPE) {\n          let prototype = <ClassPrototype>element;\n          if (prototype.is(CommonFlags.GENERIC)) {\n            return this.makeInstanceofClass(expression, prototype);\n          }\n        }\n      }\n    }\n\n    // Fall back to `instanceof TYPE`\n    var expectedType = this.resolver.resolveType(\n      expression.isType,\n      flow.actualFunction,\n      uniqueMap(flow.contextualTypeArguments)\n    );\n    if (!expectedType) {\n      this.currentType = Type.bool;\n      return this.module.unreachable();\n    }\n    return this.makeInstanceofType(expression, expectedType);\n  }\n\n  private makeInstanceofType(expression: InstanceOfExpression, expectedType: Type): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var expr = this.compileExpression(expression.expression, expectedType);\n    var actualType = this.currentType;\n    this.currentType = Type.bool;\n\n    // instanceof <value> - must be exact\n    if (expectedType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(actualType == expectedType ? 1 : 0));\n    }\n\n    // <value> instanceof <nonValue> - always false\n    if (actualType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(0));\n    }\n\n    // both LHS and RHS are references now\n    var sizeTypeRef = actualType.toRef();\n\n    // <nullable> instanceof <nonNullable> - LHS must be != 0\n    if (actualType.isNullableReference && !expectedType.isNullableReference) {\n\n      // downcast - check statically\n      if (actualType.nonNullableType.isAssignableTo(expectedType)) {\n        return module.binary(\n          sizeTypeRef == TypeRef.I64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          expr,\n          this.makeZero(actualType, expression.expression)\n        );\n      }\n\n      // upcast - check dynamically\n      if (expectedType.isAssignableTo(actualType)) {\n        let program = this.program;\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          let temp = flow.getTempLocal(actualType);\n          let instanceofInstance = assert(program.instanceofInstance);\n          this.compileFunction(instanceofInstance);\n          let ret = module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(temp.index, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            this.makeCallDirect(instanceofInstance, [\n              module.local_get(temp.index, sizeTypeRef),\n              module.i32(expectedType.classReference!.id)\n            ], expression)\n          );\n          flow.freeTempLocal(temp);\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,\n              expression.range\n            );\n          }\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n\n    // either none or both nullable\n    } else {\n\n      // downcast - check statically\n      if (actualType.isAssignableTo(expectedType)) {\n        return module.maybeDropCondition(expr, module.i32(1));\n\n      // upcast - check dynamically\n      } else if (expectedType.isAssignableTo(actualType)) {\n        let program = this.program;\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          // FIXME: the temp local and the if can be removed here once flows\n          // perform null checking, which would error earlier when checking\n          // uninitialized (thus zero) `var a: A` to be an instance of something.\n          let temp = flow.getTempLocal(actualType);\n          let instanceofInstance = assert(program.instanceofInstance);\n          this.compileFunction(instanceofInstance);\n          let ret = module.if(\n            module.unary(\n              sizeTypeRef == TypeRef.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(temp.index, expr, actualType.isManaged),\n            ),\n            module.i32(0),\n            this.makeCallDirect(instanceofInstance, [\n              module.local_get(temp.index, sizeTypeRef),\n              module.i32(expectedType.classReference!.id)\n            ], expression)\n          );\n          flow.freeTempLocal(temp);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  private makeInstanceofClass(expression: InstanceOfExpression, prototype: ClassPrototype): ExpressionRef {\n    var module = this.module;\n    var expr = this.compileExpression(expression.expression, Type.auto);\n    var actualType = this.currentType;\n    var sizeTypeRef = actualType.toRef();\n\n    this.currentType = Type.bool;\n\n    // exclusively interested in class references here\n    var classReference = actualType.getClass();\n    if (classReference) {\n\n      // static check\n      if (classReference.extends(prototype)) {\n\n        // <nullable> instanceof <PROTOTYPE> - LHS must be != 0\n        if (actualType.isNullableReference) {\n          return module.binary(\n            sizeTypeRef == TypeRef.I64\n              ? BinaryOp.NeI64\n              : BinaryOp.NeI32,\n            expr,\n            this.makeZero(actualType, expression.expression)\n          );\n\n        // <nonNullable> is just `true`\n        } else {\n          return module.maybeDropCondition(expr, module.i32(1));\n        }\n\n      // dynamic check against all possible concrete ids\n      } else if (prototype.extends(classReference.prototype)) {\n        this.pendingClassInstanceOf.add(prototype);\n        return module.call(prototype.internalName + \"~instanceof\", [ expr ], TypeRef.I32);\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  private compileLiteralExpression(\n    expression: LiteralExpression,\n    contextualType: Type,\n    constraints: Constraints,\n    implicitlyNegate: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    switch (expression.literalKind) {\n      case LiteralKind.ARRAY: {\n        assert(!implicitlyNegate);\n        return this.compileArrayLiteral(\n          <ArrayLiteralExpression>expression,\n          contextualType,\n          constraints\n        );\n      }\n      case LiteralKind.FLOAT: {\n        let floatValue = (<FloatLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          floatValue = -floatValue;\n        }\n        if (contextualType == Type.f32) {\n          return module.f32(<f32>floatValue);\n        }\n        this.currentType = Type.f64;\n        return module.f64(floatValue);\n      }\n      case LiteralKind.INTEGER: {\n        let intValue = (<IntegerLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          intValue = i64_sub(\n            i64_new(0),\n            intValue\n          );\n        }\n        let type = this.resolver.determineIntegerLiteralType(intValue, contextualType);\n        this.currentType = type;\n        switch (type.kind) {\n          case TypeKind.ISIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.I64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.USIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.U64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.F32: return module.f32(i64_to_f32(intValue));\n          case TypeKind.F64: return module.f64(i64_to_f64(intValue));\n          default: return module.i32(i64_low(intValue));\n        }\n      }\n      case LiteralKind.STRING: {\n        assert(!implicitlyNegate);\n        return this.compileStringLiteral(<StringLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.TEMPLATE: {\n        assert(!implicitlyNegate);\n        return this.compileTemplateLiteral(<TemplateLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.OBJECT: {\n        assert(!implicitlyNegate);\n        return this.compileObjectLiteral(<ObjectLiteralExpression>expression, contextualType);\n      }\n      case LiteralKind.REGEXP: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Regular expressions\"\n        );\n        this.currentType = contextualType;\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileStringLiteral(\n    expression: StringLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    return this.ensureStaticString(expression.value);\n  }\n\n  private compileTemplateLiteral(\n    expression: TemplateLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    var tag = expression.tag;\n    var parts = expression.parts;\n    var numParts = parts.length;\n    var expressions = expression.expressions;\n    var numExpressions = expressions.length;\n    assert(numExpressions == numParts - 1);\n\n    var module = this.module;\n    var stringInstance = this.program.stringInstance;\n    var stringType = stringInstance.type;\n\n    if (tag === null) {\n      // Shortcut if just a (multi-line) string\n      if (numParts == 1) {\n        return this.ensureStaticString(parts[0]);\n      }\n\n      // Shortcut for `${expr}`, `<prefix>${expr}`, `${expr}<suffix>`\n      if (numParts == 2) {\n        let expression = expressions[0];\n        let lhsLen = parts[0].length;\n        let rhsLen = parts[1].length;\n        // Shortcut for `${expr}`  ->   expr.toString()\n        if (!lhsLen && !rhsLen) {\n          return this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          );\n        }\n        // Shortcuts for\n        // `<prefix>${expr}`  ->  \"<prefix>\" + expr.toString()\n        // `${expr}<suffix>`  ->  expr.toString() + \"<suffix>\"\n        let hasPrefix = lhsLen != 0;\n        // @ts-ignore: cast\n        if (hasPrefix ^ (rhsLen != 0)) {\n          let lhs: ExpressionRef;\n          let rhs: ExpressionRef;\n          let expr = this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          );\n          if (hasPrefix) {\n            lhs = this.ensureStaticString(parts[0]);\n            rhs = expr;\n          } else {\n            // suffix\n            lhs = expr;\n            rhs = this.ensureStaticString(parts[1]);\n          }\n          let concatMethod = assert(stringInstance.getMethod(\"concat\"));\n          return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);\n        }\n      }\n\n      // Shortcut for `${exprA}${exprB}`  ->  exprA.toString() + exprB.toString()\n      if (numParts == 3 && !parts[0].length && !parts[1].length && !parts[2].length) {\n        let exprA = expressions[0];\n        let exprB = expressions[1];\n\n        let lhs = this.makeToString(\n          this.compileExpression(exprA, stringType),\n          this.currentType, exprA\n        );\n        let rhs = this.makeToString(\n          this.compileExpression(exprB, stringType),\n          this.currentType, exprB\n        );\n        let concatMethod = assert(stringInstance.getMethod(\"concat\"));\n        return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);\n      }\n\n      // Compile to a `StaticArray<string>#join(\"\") in the general case\n      let length = numParts + numExpressions;\n      let values = new Array<usize>(length);\n      values[0] = this.ensureStaticString(parts[0]);\n      for (let i = 1; i < numParts; ++i) {\n        values[2 * i - 1] = module.usize(0);\n        values[2 * i] = this.ensureStaticString(parts[i]);\n      }\n      let arrayInstance = assert(this.resolver.resolveClass(this.program.staticArrayPrototype, [ stringType ]));\n      let segment = this.addStaticBuffer(stringType, values, arrayInstance.id);\n      let offset = i64_add(segment.offset, i64_new(this.program.totalOverhead));\n      let joinInstance = assert(arrayInstance.getMethod(\"join\"));\n      let indexedSetInstance = assert(arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true));\n      let stmts = new Array<ExpressionRef>(2 * numExpressions + 1);\n      // Use one local per toString'ed subexpression, since otherwise recursion on the same\n      // static array would overwrite already prepared parts. Avoids a temporary array.\n      let temps = new Array<Local>(numExpressions);\n      let flow = this.currentFlow;\n      for (let i = 0; i < numExpressions; ++i) {\n        let expression = expressions[i];\n        let temp = flow.getTempLocal(stringType);\n        temps[i] = temp;\n        stmts[i] = module.local_set(temp.index,\n          this.makeToString(\n            this.compileExpression(expression, stringType),\n            this.currentType, expression\n          ),\n          true\n        );\n      }\n      // Populate the static array with the toString'ed subexpressions and call .join(\"\")\n      for (let i = 0; i < numExpressions; ++i) {\n        stmts[numExpressions + i] = this.makeCallDirect(indexedSetInstance, [\n          module.usize(offset),\n          module.i32(2 * i + 1),\n          module.local_get(temps[i].index, stringType.toRef())\n        ], expression);\n        flow.freeTempLocal(temps[i]);\n      }\n      stmts[2 * numExpressions] = this.makeCallDirect(joinInstance, [\n        module.usize(offset),\n        this.ensureStaticString(\"\")\n      ], expression);\n      return module.flatten(stmts, stringType.toRef());\n    }\n\n    // Try to find out whether the template function takes a full-blown TemplateStringsArray or if\n    // it is sufficient to compile to a normal array. While technically incorrect, this allows us\n    // to avoid generating unnecessary static data that is not explicitly signaled to be used.\n    var tsaArrayInstance = this.program.templateStringsArrayInstance;\n    var arrayInstance = tsaArrayInstance;\n    var target = this.resolver.lookupExpression(tag, this.currentFlow, Type.auto, ReportMode.SWALLOW);\n    if (target) {\n      switch (target.kind) {\n        case ElementKind.FUNCTION_PROTOTYPE: {\n          let instance = this.resolver.resolveFunction(\n            <FunctionPrototype>target,\n            null,\n            uniqueMap<string,Type>(),\n            ReportMode.SWALLOW\n          );\n          if (!instance) break;\n          target = instance;\n          // fall-through\n        }\n        case ElementKind.FUNCTION: {\n          let instance = <Function>target;\n          let parameterTypes = instance.signature.parameterTypes;\n          if (parameterTypes.length) {\n            let first = parameterTypes[0].getClass();\n            if (first !== null && !first.extends(tsaArrayInstance.prototype)) {\n              arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ stringType ]));\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    // Compile to a call to the tag function\n    var rawParts = expression.rawParts;\n    assert(rawParts.length == numParts);\n    var partExprs = new Array<ExpressionRef>(numParts);\n    for (let i = 0; i < numParts; ++i) {\n      partExprs[i] = this.ensureStaticString(parts[i]);\n    }\n    var arraySegment: MemorySegment;\n    if (arrayInstance == tsaArrayInstance) {\n      var rawExprs = new Array<ExpressionRef>(numParts);\n      for (let i = 0; i < numParts; ++i) {\n        rawExprs[i] = this.ensureStaticString(rawParts[i]);\n      }\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n      var rawHeaderSegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, rawExprs)\n      );\n      arrayInstance.writeField(\"raw\",\n        i64_add(rawHeaderSegment.offset, i64_new(this.program.totalOverhead)),\n        arraySegment.buffer\n      );\n    } else {\n      arraySegment = this.addStaticArrayHeader(stringType,\n        this.addStaticBuffer(this.options.usizeType, partExprs),\n        arrayInstance\n      );\n    }\n\n    // Desugar to compileCallExpression\n    var args = expressions.slice();\n    args.unshift(\n      Node.createCompiledExpression(\n        module.usize(i64_add(arraySegment.offset, i64_new(this.program.totalOverhead))),\n        arrayInstance.type,\n        this.program.nativeRange\n      )\n    );\n    // TODO: Requires ReadonlyArray to be safe\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      expression.range, \"Tagged template literals\"\n    );\n    return this.compileCallExpressionLike(tag, null, args, expression.range, stringType);\n  }\n\n  private compileArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var program = this.program;\n\n    // handle static arrays\n    let contextualClass = contextualType.getClass();\n    if (contextualClass !== null && contextualClass.extends(program.staticArrayPrototype)) {\n      return this.compileStaticArrayLiteral(expression, contextualType, constraints);\n    }\n\n    // handle normal arrays\n    var element = this.resolver.lookupExpression(expression, flow, this.currentType);\n    if (!element) return module.unreachable();\n    assert(element.kind == ElementKind.CLASS);\n    var arrayInstance = <Class>element;\n    var arrayType = arrayInstance.type;\n    var elementType = arrayInstance.getTypeArgumentsTo(program.arrayPrototype)![0];\n    var arrayBufferInstance = assert(program.arrayBufferInstance);\n\n    // block those here so compiling expressions doesn't conflict\n    var tempThis = flow.getTempLocal(this.options.usizeType);\n    var tempDataStart = flow.getTempLocal(arrayBufferInstance.type);\n\n    // compile value expressions and find out whether all are constant\n    var expressions = expression.elementExpressions;\n    var length = expressions.length;\n    var values = new Array<ExpressionRef>(length);\n    var isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = this.compileExpression(<Expression>elementExpression, elementType, Constraints.CONV_IMPLICIT);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType, elementExpression);\n      }\n    }\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      flow.freeTempLocal(tempThis);\n      flow.freeTempLocal(tempDataStart);\n\n      let totalOverhead = program.totalOverhead;\n      let bufferSegment = this.addStaticBuffer(elementType, values);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(totalOverhead));\n\n      // make both the buffer and array header static if assigned to a global. this can't be done\n      // if inside of a function because each invocation must create a new array reference then.\n      if (constraints & Constraints.PREFER_STATIC) {\n        let arraySegment = this.addStaticArrayHeader(elementType, bufferSegment);\n        let arrayAddress = i64_add(arraySegment.offset, i64_new(totalOverhead));\n        this.currentType = arrayType;\n        return program.options.isWasm64\n          ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))\n          : this.module.i32(i64_low(arrayAddress));\n\n      // otherwise allocate a new array header and make it wrap a copy of the static buffer\n      } else {\n        return this.makeNewArray(arrayInstance, length, bufferAddress, expression);\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    var indexedSet = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);\n    if (!indexedSet) {\n      flow.freeTempLocal(tempThis);\n      flow.freeTempLocal(tempDataStart);\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    var arrayTypeRef = arrayType.toRef();\n\n    var stmts = new Array<ExpressionRef>();\n    // tempThis = __newArray(length, alignLog2, classId, source = 0)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeNewArray(arrayInstance, length, i64_new(0), expression),\n        arrayType.isManaged\n      )\n    );\n    // tempData = tempThis.dataStart\n    var dataStartMember = assert(arrayInstance.getMember(\"dataStart\"));\n    assert(dataStartMember.kind == ElementKind.FIELD);\n    stmts.push(\n      module.local_set(tempDataStart.index,\n        module.load(arrayType.byteSize, false,\n          module.local_get(tempThis.index, arrayTypeRef),\n          arrayTypeRef,\n          (<Field>dataStartMember).memoryOffset\n        ),\n        true // ArrayBuffer\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // this[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    flow.freeTempLocal(tempThis);\n    flow.freeTempLocal(tempDataStart);\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  /** Makes a new array instance from a static buffer segment. */\n  private makeNewArray(\n    /** Concrete array class. */\n    arrayInstance: Class,\n    /** Length of the array. */\n    length: i32,\n    /** Source address to copy from. Array is zeroed if `0`. */\n    source: i64,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    var program = this.program;\n    var module = this.module;\n    assert(!arrayInstance.extends(program.staticArrayPrototype));\n    var elementType = arrayInstance.getArrayValueType(); // asserts\n\n    // __newArray(length, alignLog2, classId, staticBuffer)\n    var expr = this.makeCallDirect(program.newArrayInstance, [\n      module.i32(length),\n      program.options.isWasm64\n        ? module.i64(elementType.alignLog2)\n        : module.i32(elementType.alignLog2),\n      module.i32(arrayInstance.id),\n      program.options.isWasm64\n        ? module.i64(i64_low(source), i64_high(source))\n        : module.i32(i64_low(source))\n    ], reportNode);\n    this.currentType = arrayInstance.type;\n    return expr;\n  }\n\n  /** Compiles a special `fixed` array literal. */\n  private compileStaticArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var program = this.program;\n\n    // make sure this method is only called with a valid contextualType\n    var arrayInstance = assert(contextualType.getClass());\n    var arrayType = arrayInstance.type;\n    var typeArguments = assert(arrayInstance.getTypeArgumentsTo(program.staticArrayPrototype));\n    var elementType = typeArguments[0];\n\n    // block those here so compiling expressions doesn't conflict\n    var tempThis = flow.getTempLocal(this.options.usizeType);\n\n    // compile value expressions and check if all are compile-time constants\n    var expressions = expression.elementExpressions;\n    var length = expressions.length;\n    var values = new Array<ExpressionRef>(length);\n    var isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = this.compileExpression(elementExpression, elementType, Constraints.CONV_IMPLICIT);\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType, elementExpression);\n      }\n    }\n\n    var isWasm64 = this.options.isWasm64;\n    var bufferSize = values.length << elementType.alignLog2;\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      flow.freeTempLocal(tempThis);\n\n      let bufferSegment = this.addStaticBuffer(elementType, values, arrayInstance.id);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\n\n      // return the static buffer directly if assigned to a global\n      if (constraints & Constraints.PREFER_STATIC) {\n        let expr = this.options.isWasm64\n          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n          : module.i32(i64_low(bufferAddress));\n        this.currentType = arrayType;\n        return expr;\n\n      // otherwise allocate a new chunk of memory and return a copy of the buffer\n      } else {\n        // __newBuffer(bufferSize, id, buffer)\n        let expr = this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id),\n          isWasm64\n            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n            : module.i32(i64_low(bufferAddress))\n        ], expression);\n        this.currentType = arrayType;\n        return expr;\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    var indexedSet = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);\n    if (!indexedSet) {\n      flow.freeTempLocal(tempThis);\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    var arrayTypeRef = arrayType.toRef();\n\n    var stmts = new Array<ExpressionRef>();\n    // tempThis = __newBuffer(bufferSize, classId)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeCallDirect(program.newBufferInstance, [\n          isWasm64\n            ? module.i64(bufferSize)\n            : module.i32(bufferSize),\n          module.i32(arrayInstance.id)\n        ], expression),\n        arrayType.isManaged\n      )\n    );\n    for (let i = 0; i < length; ++i) {\n      // array[i] = value\n      stmts.push(\n        module.call(indexedSet.internalName, [\n          module.local_get(tempThis.index, arrayTypeRef),\n          module.i32(i),\n          values[i]\n        ], TypeRef.None)\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, arrayTypeRef)\n    );\n    flow.freeTempLocal(tempThis);\n    if (length) this.compileFunction(indexedSet);\n    this.currentType = arrayType;\n    return module.flatten(stmts, arrayTypeRef);\n  }\n\n  private compileObjectLiteral(expression: ObjectLiteralExpression, contextualType: Type): ExpressionRef {\n    var module = this.module;\n\n    // Check that contextual type is a class (TODO: hidden class for interfaces?)\n    var classReference = contextualType.getClass();\n    if (!classReference) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, \"<object>\", contextualType.toString()\n      );\n      return module.unreachable();\n    }\n    var classType = classReference.type;\n    this.currentType = classType.nonNullableType;\n    if (classReference.kind == ElementKind.INTERFACE) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        expression.range, \"Interface hidden classes\"\n      );\n      return module.unreachable();\n    }\n    if (classReference.is(CommonFlags.ABSTRACT)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.range\n      );\n      return module.unreachable();\n    }\n\n    // Check that the class is compatible with object literals\n    var ctorPrototype = classReference.prototype.constructorPrototype;\n    if (ctorPrototype) {\n      this.errorRelated(\n        DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,\n        expression.range, ctorPrototype.identifierNode.range, classType.toString()\n      );\n      return module.unreachable();\n    }\n\n    var isManaged = classType.isManaged;\n    if (!isManaged) {\n      this.checkUnsafe(expression, findDecorator(DecoratorKind.UNMANAGED, classReference.decoratorNodes));\n    }\n\n    // check and compile field values\n    var names = expression.names;\n    var numNames = names.length;\n    var values = expression.values;\n    var members = classReference.members;\n    var hasErrors = false;\n    var exprs = new Array<ExpressionRef>();\n    var flow = this.currentFlow;\n    var tempLocal = flow.getTempLocal(classType);\n    var classTypeRef = classType.toRef();\n    assert(numNames == values.length);\n\n    // Assume all class fields will be omitted, and add them to our omitted list\n    var omittedFields = new Set<Field>();\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberKey = _keys[i];\n        let member = assert(members.get(memberKey));\n        if (member !== null && member.kind == ElementKind.FIELD) {\n          omittedFields.add(<Field>member); // incl. private/protected\n        }\n      }\n    }\n\n    // Iterate through the members defined in our expression\n    for (let i = 0; i < numNames; ++i) {\n      let memberName = names[i].text;\n      let member = classReference.getMember(memberName);\n      if (!member || member.kind != ElementKind.FIELD) {\n        this.error(\n          DiagnosticCode.Property_0_does_not_exist_on_type_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.PRIVATE)) {\n        this.error(\n          DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.PROTECTED)) {\n        this.error(\n          DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      let fieldInstance = <Field>member;\n      let fieldType = fieldInstance.type;\n\n      let expr = this.compileExpression(values[i], fieldType, Constraints.CONV_IMPLICIT);\n      exprs.push(\n        module.call(fieldInstance.internalSetterName, [\n          module.local_get(tempLocal.index, classTypeRef),\n          expr\n        ], TypeRef.None)\n      );\n      this.compileFieldSetter(fieldInstance);\n\n      // This member is no longer omitted, so delete from our omitted fields\n      omittedFields.delete(fieldInstance);\n    }\n    this.currentType = classType.nonNullableType;\n    if (hasErrors) return module.unreachable();\n\n    // Check remaining omitted fields\n    for (let _values = Set_values(omittedFields), j = 0, l = _values.length; j < l; ++j) {\n      let fieldInstance = _values[j];\n      let fieldType = fieldInstance.type;\n\n      if (fieldInstance.initializerNode) {\n        continue; // set by generated ctor\n      }\n\n      if (fieldType.isReference) {\n        if (!fieldType.isNullableReference) {\n          this.error(\n            DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n            expression.range, fieldInstance.name, \"<object>\", classType.toString()\n          );\n          hasErrors = true;\n          continue;\n        }\n      }\n\n      switch (fieldType.kind) {\n        // Number Types (and Number alias types)\n        case TypeKind.I8:\n        case TypeKind.I16:\n        case TypeKind.I32:\n        case TypeKind.I64:\n        case TypeKind.ISIZE:\n        case TypeKind.U8:\n        case TypeKind.U16:\n        case TypeKind.U32:\n        case TypeKind.U64:\n        case TypeKind.USIZE:\n        case TypeKind.BOOL:\n        case TypeKind.F32:\n        case TypeKind.F64: {\n          exprs.push(\n            module.call(fieldInstance.internalSetterName, [\n              module.local_get(tempLocal.index, classTypeRef),\n              this.makeZero(fieldType, expression)\n            ], TypeRef.None)\n          );\n          this.compileFieldSetter(fieldInstance);\n          continue;\n        }\n      }\n\n      // Otherwise error\n      this.error(\n        DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n        expression.range, fieldInstance.name, \"<object>\", classType.toString()\n      );\n      hasErrors = true;\n    }\n    if (hasErrors) return module.unreachable();\n\n    // generate the default constructor\n    var ctor = this.ensureConstructor(classReference, expression);\n    // note that this is not checking field initialization within the ctor, but\n    // instead checks conditions above with provided fields taken into account.\n\n    // allocate a new instance first and assign 'this' to the temp. local\n    exprs.unshift(\n      module.local_set(tempLocal.index,\n        this.compileInstantiate(ctor, [], Constraints.NONE, expression),\n        classType.isManaged\n      )\n    );\n\n    // once all field values have been set, return 'this'\n    exprs.push(\n      module.local_get(tempLocal.index, classTypeRef)\n    );\n\n    if (!isManaged) flow.freeTempLocal(tempLocal);\n    this.currentType = classType.nonNullableType;\n    return module.flatten(exprs, classTypeRef);\n  }\n\n  private compileNewExpression(\n    expression: NewExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // obtain the class being instantiated\n    var target = this.resolver.resolveTypeName(expression.typeName, flow.actualFunction);\n    if (!target) return module.unreachable();\n    if (target.kind != ElementKind.CLASS_PROTOTYPE) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    if (target.is(CommonFlags.ABSTRACT)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    var classPrototype = <ClassPrototype>target;\n    var classInstance: Class | null = null;\n    var typeArguments = expression.typeArguments;\n    var classReference: Class | null;\n    if (\n      !typeArguments &&\n      (classReference = contextualType.classReference) !== null &&\n      classReference.prototype == classPrototype &&\n      classReference.is(CommonFlags.GENERIC)\n    ) {\n      // e.g. `arr: Array<T> = new Array()`\n      classInstance = this.resolver.resolveClass(\n        classPrototype,\n        classReference.typeArguments,\n        uniqueMap<string,Type>(flow.contextualTypeArguments)\n      );\n    } else {\n      classInstance = this.resolver.resolveClassInclTypeArguments(\n        classPrototype,\n        typeArguments,\n        flow.actualFunction.parent, // relative to caller\n        uniqueMap<string,Type>(flow.contextualTypeArguments),\n        expression\n      );\n    }\n    if (!classInstance) return module.unreachable();\n    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;\n    var ctor = this.ensureConstructor(classInstance, expression);\n    if (!ctor.hasDecorator(DecoratorFlags.INLINE)) {\n      // Inlined ctors haven't been compiled yet and are checked upon inline\n      // compilation of their body instead.\n      this.checkFieldInitialization(classInstance, expression);\n    }\n    return this.compileInstantiate(ctor, expression.args, constraints, expression);\n  }\n\n  /** Gets the compiled constructor of the specified class or generates one if none is present. */\n  ensureConstructor(\n    /** Class wanting a constructor. */\n    classInstance: Class,\n    /** Report node. */\n    reportNode: Node\n  ): Function {\n    var instance = classInstance.constructorInstance;\n    if (instance) {\n      // shortcut if already compiled\n      if (instance.is(CommonFlags.COMPILED)) return instance;\n      // do not attempt to compile if inlined anyway\n      if (!instance.hasDecorator(DecoratorFlags.INLINE)) this.compileFunction(instance);\n    } else {\n      // clone base constructor if a derived class. note that we cannot just\n      // call the base ctor since the derived class may have additional fields.\n      let baseClass = classInstance.base;\n      let contextualTypeArguments = uniqueMap(classInstance.contextualTypeArguments);\n      if (baseClass) {\n        let baseCtor = this.ensureConstructor(baseClass, reportNode);\n        this.checkFieldInitialization(baseClass, reportNode);\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance,\n            // declaration is important, i.e. to access optional parameter initializers\n            (<FunctionDeclaration>baseCtor.declaration).clone()\n          ),\n          null,\n          baseCtor.signature,\n          contextualTypeArguments\n        );\n\n      // otherwise make a default constructor\n      } else {\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance, // bound\n            this.program.makeNativeFunctionDeclaration(CommonNames.constructor,\n              CommonFlags.INSTANCE | CommonFlags.CONSTRUCTOR\n            )\n          ),\n          null,\n          new Signature(this.program, null, classInstance.type, classInstance.type),\n          contextualTypeArguments\n        );\n      }\n\n      instance.set(CommonFlags.COMPILED);\n      instance.prototype.setResolvedInstance(\"\", instance);\n      if (classInstance.is(CommonFlags.MODULE_EXPORT)) {\n        instance.set(CommonFlags.MODULE_EXPORT);\n      }\n      classInstance.constructorInstance = instance;\n      let members = classInstance.members;\n      if (!members) classInstance.members = members = new Map();\n      members.set(\"constructor\", instance.prototype);\n\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n\n      // generate body\n      let signature = instance.signature;\n      let module = this.module;\n      let sizeTypeRef = this.options.sizeTypeRef;\n      let stmts = new Array<ExpressionRef>();\n\n      // {\n      //   this = <COND_ALLOC>\n      //   IF_DERIVED: this = super(this, ...args)\n      //   this.a = X\n      //   this.b = Y\n      //   return this\n      // }\n      stmts.push(\n        this.makeConditionalAllocation(classInstance, 0)\n      );\n      if (baseClass) {\n        let parameterTypes = signature.parameterTypes;\n        let numParameters = parameterTypes.length;\n        let operands = new Array<ExpressionRef>(1 + numParameters);\n        operands[0] = module.local_get(0, sizeTypeRef);\n        for (let i = 1; i <= numParameters; ++i) {\n          operands[i] = module.local_get(i, parameterTypes[i - 1].toRef());\n        }\n        stmts.push(\n          module.local_set(0,\n            this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false),\n            baseClass.type.isManaged\n          )\n        );\n      }\n      this.makeFieldInitializationInConstructor(classInstance, stmts);\n      stmts.push(\n        module.local_get(0, sizeTypeRef)\n      );\n      flow.freeScopedLocals();\n      this.currentFlow = previousFlow;\n\n      // make the function\n      let locals = instance.localsByIndex;\n      let varTypes = new Array<TypeRef>(); // of temp. vars added while compiling initializers\n      let numOperands = 1 + signature.parameterTypes.length;\n      let numLocals = locals.length;\n      if (numLocals > numOperands) {\n        for (let i = numOperands; i < numLocals; ++i) varTypes.push(locals[i].type.toRef());\n      }\n      let funcRef = module.addFunction(\n        instance.internalName,\n        signature.paramRefs,\n        signature.resultRefs,\n        varTypes,\n        module.flatten(stmts, sizeTypeRef)\n      );\n      instance.finalize(module, funcRef);\n    }\n\n    return instance;\n  }\n\n  /** Checks that all class fields have been initialized. */\n  checkFieldInitialization(classInstance: Class, relatedNode: Node | null = null): void {\n    if (classInstance.didCheckFieldInitialization) return;\n    classInstance.didCheckFieldInitialization = true;\n    var ctor = assert(classInstance.constructorInstance);\n    this.checkFieldInitializationInFlow(classInstance, ctor.flow, relatedNode);\n  }\n\n  /** Checks that all class fields have been initialized in the specified flow. */\n  checkFieldInitializationInFlow(classInstance: Class, flow: Flow, relatedNode: Node | null = null): void {\n    var members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let element = _values[i];\n        if (element.kind == ElementKind.FIELD && element.parent == classInstance) {\n          let field = <Field>element;\n          if (!field.initializerNode && !flow.isThisFieldFlag(field, FieldFlags.INITIALIZED)) {\n            if (!field.is(CommonFlags.DEFINITELY_ASSIGNED)) {\n              if (relatedNode) {\n                this.errorRelated(\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                  field.declaration.name.range,\n                  relatedNode.range,\n                  field.internalName\n                );\n              } else {\n                this.error(\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                  field.declaration.name.range,\n                  field.internalName\n                );\n              }\n            }\n          } else if (field.is(CommonFlags.DEFINITELY_ASSIGNED)) {\n            if (field.type.isReference) {\n              this.warning( // involves a runtime check\n                DiagnosticCode.Property_0_is_always_assigned_before_being_used,\n                field.identifierNode.range,\n                field.internalName\n              );\n            } else {\n              this.pedantic( // is a nop anyway\n                DiagnosticCode.Unnecessary_definite_assignment,\n                field.identifierNode.range\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  compileInstantiate(\n    /** Constructor to call. */\n    ctorInstance: Function,\n    /** Constructor arguments. */\n    argumentExpressions: Expression[],\n    /** Contextual flags. */\n    constraints: Constraints,\n    /** Node to report on. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(ctorInstance.is(CommonFlags.CONSTRUCTOR));\n    var parent = ctorInstance.parent;\n    assert(parent.kind == ElementKind.CLASS);\n    var classInstance = <Class>parent;\n    if (classInstance.type.isUnmanaged || ctorInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);\n    var expr = this.compileCallDirect(\n      ctorInstance,\n      argumentExpressions,\n      reportNode,\n      this.makeZero(this.options.usizeType, reportNode),\n      constraints\n    );\n    if (getExpressionType(expr) != TypeRef.None) { // possibly WILL_DROP\n      this.currentType = classInstance.type; // important because a super ctor could be called\n    }\n    return expr;\n  }\n\n  private compilePropertyAccessExpression(\n    expression: PropertyAccessExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    this.maybeCompileEnclosingSource(expression);\n\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression, flow, ctxType); // reports\n    if (!target) return module.unreachable();\n    var thisExpression = resolver.currentThisExpression;\n    if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n\n    switch (target.kind) {\n      case ElementKind.GLOBAL: { // static field\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable(); // reports\n        let globalType = global.type;\n        assert(globalType != Type.void);\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        if (global.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(global, ctxType, constraints);\n        }\n        this.currentType = globalType;\n        return module.global_get(global.internalName, globalType.toRef());\n      }\n      case ElementKind.ENUMVALUE: { // enum value\n        let enumValue = <EnumValue>target;\n        let parent = assert(enumValue.parent);\n        assert(parent.kind == ElementKind.ENUM);\n        let parentEnum = <Enum>parent;\n        if (!this.compileEnum(parentEnum)) {\n          this.currentType = Type.i32;\n          return this.module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.INLINED)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n          return this.compileInlineConstant(enumValue, ctxType, constraints);\n        }\n        assert(enumValue.type == Type.i32);\n        return module.global_get(enumValue.internalName, TypeRef.I32);\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let fieldType = fieldInstance.type;\n        assert(fieldInstance.memoryOffset >= 0);\n        let fieldParent = fieldInstance.parent;\n        assert(fieldParent.kind == ElementKind.CLASS);\n        thisExpression = assert(thisExpression);\n        let thisExpr = this.compileExpression(\n          thisExpression,\n          (<Class>fieldParent).type,\n          Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n        );\n        let thisType = this.currentType;\n        if (\n          flow.actualFunction.is(CommonFlags.CONSTRUCTOR) &&\n          thisExpression.kind == NodeKind.THIS &&\n          !flow.isThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED) &&\n          !fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED)\n        ) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_used_before_being_assigned,\n            expression.range,\n            fieldInstance.identifierNode.range,\n            fieldInstance.internalName\n          );\n        }\n        if (thisType.isNullableReference) {\n          if (!flow.isNonnull(thisExpr, thisType)) {\n            this.error(\n              DiagnosticCode.Object_is_possibly_null,\n              thisExpression.range\n            );\n          }\n        }\n        if (!fieldInstance.is(CommonFlags.COMPILED)) {\n          fieldInstance.set(CommonFlags.COMPILED);\n          let typeNode = fieldInstance.typeNode;\n          if (typeNode) this.checkTypeSupported(fieldInstance.type, typeNode);\n        }\n        this.currentType = fieldType;\n        let ret = module.load(\n          fieldType.byteSize,\n          fieldType.isSignedIntegerValue,\n          thisExpr,\n          fieldType.toRef(),\n          fieldInstance.memoryOffset\n        );\n        if (fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED) && fieldType.isReference && !fieldType.isNullableReference) {\n          ret = this.makeRuntimeNonNullCheck(ret, fieldType, expression);\n        }\n        return ret;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = this.resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let getterInstance = propertyInstance.getterInstance;\n        if (!getterInstance) return module.unreachable(); // failed earlier\n        let thisArg: ExpressionRef = 0;\n        if (getterInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        return this.compileCallDirect(getterInstance, [], expression, thisArg);\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n        if (!functionInstance) return module.unreachable();\n        if (!this.compileFunction(functionInstance)) return module.unreachable();\n        this.currentType = functionInstance.type;\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    this.error(\n      DiagnosticCode.Expression_does_not_compile_to_a_value_at_runtime,\n      expression.range\n    );\n    return this.module.unreachable();\n  }\n\n  private compileTernaryExpression(\n    expression: TernaryExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var ifThen = expression.ifThen;\n    var ifElse = expression.ifElse;\n\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(expression.condition, Type.bool),\n      this.currentType,\n      expression.condition\n    );\n    // Try to eliminate unnecesssary branches if the condition is constant\n    // FIXME: skips common denominator, inconsistently picking branch type\n    var condKind = this.evaluateCondition(condExpr);\n    if (condKind == ConditionKind.TRUE) {\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifThen, ctxType));\n    }\n    if (condKind == ConditionKind.FALSE) {\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifElse, ctxType));\n    }\n\n    var outerFlow = this.currentFlow;\n    var ifThenFlow = outerFlow.fork();\n    ifThenFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = ifThenFlow;\n    var ifThenExpr = this.compileExpression(ifThen, ctxType);\n    var ifThenType = this.currentType;\n\n    var ifElseFlow = outerFlow.fork();\n    ifElseFlow.inheritNonnullIfFalse(condExpr);\n    this.currentFlow = ifElseFlow;\n    var ifElseExpr = this.compileExpression(ifElse, ctxType == Type.auto ? ifThenType : ctxType);\n    var ifElseType = this.currentType;\n\n    if (ctxType == Type.void) { // values, including type mismatch, are irrelevant\n      if (ifThenType != Type.void) {\n        ifThenExpr = module.drop(ifThenExpr);\n        ifThenType = Type.void;\n      }\n      if (ifElseType != Type.void) {\n        ifElseExpr = module.drop(ifElseExpr);\n        ifElseType = Type.void;\n      }\n      this.currentType = Type.void;\n    } else {\n      let commonType = Type.commonDenominator(ifThenType, ifElseType, false);\n      if (!commonType) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n          ifElse.range, ifElseType.toString(), ifThenType.toString()\n        );\n        this.currentType = ctxType;\n        return module.unreachable();\n      }\n      ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, ifThen);\n      ifThenType = commonType;\n      ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, ifElse);\n      ifElseType = commonType;\n      this.currentType = commonType;\n    }\n\n    ifThenFlow.freeScopedLocals();\n    ifElseFlow.freeScopedLocals();\n\n    this.currentFlow = outerFlow;\n    outerFlow.inheritMutual(ifThenFlow, ifElseFlow);\n\n    return module.if(condExpr, ifThenExpr, ifElseExpr);\n  }\n\n  private compileUnaryPostfixExpression(\n    expression: UnaryPostfixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // make a getter for the expression (also obtains the type)\n    var getValue = this.compileExpression( // reports\n      expression.operand,\n      contextualType.exceptVoid,\n      Constraints.NONE\n    );\n\n    // shortcut if compiling the getter already failed\n    if (getExpressionId(getValue) == ExpressionId.Unreachable) return getValue;\n\n    // if the value isn't dropped, a temp. local is required to remember the original value,\n    // except if a static overload is found, which reverses the use of a temp. (see below)\n    var tempLocal: Local | null = null;\n    if (contextualType != Type.void) {\n      tempLocal = flow.getTempLocal(this.currentType);\n      getValue = module.local_tee(\n        tempLocal.index,\n        getValue,\n        this.currentType.isManaged\n      );\n    }\n\n    var expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.PLUS_PLUS: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_INC);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.INSTANCE);\n            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              flow.freeTempLocal(tempLocal);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (isInstance) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          if (tempLocal) flow.freeTempLocal(tempLocal);\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(\n              BinaryOp.AddI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            let options = this.options;\n            expr = module.binary(\n              options.isWasm64\n                ? BinaryOp.AddI64\n                : BinaryOp.AddI32,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.AddI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.AddF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.AddF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.MINUS_MINUS: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_DEC);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.INSTANCE);\n            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              flow.freeTempLocal(tempLocal);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          if (tempLocal) flow.freeTempLocal(tempLocal);\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(\n              BinaryOp.SubI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            let options = this.options;\n            expr = module.binary(\n              options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.SubI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.SubF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.SubF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression.operand, flow); // reports\n    if (!target) {\n      if (tempLocal) flow.freeTempLocal(tempLocal);\n      return module.unreachable();\n    }\n\n    // simplify if dropped anyway\n    if (!tempLocal) {\n      return this.makeAssignment(\n        target,\n        expr,\n        this.currentType,\n        expression.operand,\n        resolver.currentThisExpression,\n        resolver.currentElementExpression,\n        false\n      );\n    }\n\n    // otherwise use the temp. local for the intermediate value (always possibly overflows)\n    var setValue = this.makeAssignment(\n      target,\n      expr, // includes a tee of getValue to tempLocal\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      false\n    );\n\n    this.currentType = tempLocal.type;\n    flow.freeTempLocal(tempLocal);\n    var typeRef = tempLocal.type.toRef();\n\n    return module.block(null, [\n      setValue,\n      module.local_get(tempLocal.index, typeRef)\n    ], typeRef); // result of 'x++' / 'x--' might overflow\n  }\n\n  private compileUnaryPrefixExpression(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var compound = false;\n    var expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.PLUS: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PLUS);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"+\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        // nop\n        break;\n      }\n      case Token.MINUS: {\n        let operand = expression.operand;\n        if (operand.isNumericLiteral) {\n          // implicitly negate integer and float literals. also enables proper checking of literal ranges.\n          expr = this.compileLiteralExpression(<LiteralExpression>operand, contextualType, Constraints.NONE, true);\n          // compileExpression normally does this:\n          if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n          break;\n        }\n\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.MINUS);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"-\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.SubI32, module.i32(0), expr);\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              this.makeZero(this.currentType, expression.operand),\n              expr\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, module.i64(0), expr);\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.unary(UnaryOp.NegF32, expr);\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.unary(UnaryOp.NegF64, expr);\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.PLUS_PLUS: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PREFIX_INC);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.AddI32, expr, this.module.i32(1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.AddI64\n                : BinaryOp.AddI32,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.AddI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.AddF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.AddF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.MINUS_MINUS: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PREFIX_DEC);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.SubI32, expr, module.i32(1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.SubF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.SubF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.EXCLAMATION: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.NOT);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n          // fall back to compare by value\n        }\n\n        expr = module.unary(UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType, expression.operand));\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.TILDE: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType == Type.void\n            ? Type.i32\n            : contextualType.isFloatValue\n              ? Type.i64\n              : contextualType,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"~\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, expression.operand);\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.XorI32, expr, module.i32(-1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.XorI64\n                : BinaryOp.XorI32,\n              expr,\n              this.makeNegOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.XorI64, expr, module.i64(-1, -1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"~\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.TYPEOF: {\n        return this.compileTypeof(expression, contextualType, constraints);\n      }\n      case Token.DOT_DOT_DOT: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range, \"Spread operator\"\n        );\n        return module.unreachable();\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression.operand, this.currentFlow);\n    if (!target) return module.unreachable();\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  private compileTypeof(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var operand = expression.operand;\n    var expr: ExpressionRef = 0;\n    var stringInstance = this.program.stringInstance;\n    var typeString: string;\n    if (operand.kind == NodeKind.NULL) {\n      typeString = \"object\"; // special since `null` without type context is usize\n    } else {\n      let element = this.resolver.lookupExpression(operand, this.currentFlow, Type.auto, ReportMode.SWALLOW);\n      if (!element) {\n        switch (operand.kind) {\n          case NodeKind.IDENTIFIER: break; // ignore error: typeof doesntExist -> undefined\n          case NodeKind.PROPERTYACCESS:\n          case NodeKind.ELEMENTACCESS: {\n            operand = operand.kind == NodeKind.PROPERTYACCESS\n              ? (<PropertyAccessExpression>operand).expression\n              : (<ElementAccessExpression>operand).expression;\n            let targetType = this.resolver.resolveExpression(operand, this.currentFlow, Type.auto, ReportMode.REPORT);\n            if (!targetType) { // access on non-object\n              this.currentType = stringInstance.type;\n              return this.module.unreachable();\n            }\n            // fall-through\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto); // may trigger an error\n            expr = this.convertExpression(expr, this.currentType, Type.void, true, operand);\n          }\n        }\n        typeString = \"undefined\";\n      } else {\n        switch (element.kind) {\n          case ElementKind.CLASS_PROTOTYPE:\n          case ElementKind.NAMESPACE:\n          case ElementKind.ENUM: {\n            typeString = \"object\";\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            typeString = \"function\";\n            break;\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto);\n            let type = this.currentType;\n            expr = this.convertExpression(expr, type, Type.void, true, operand);\n            if (type.isReference) {\n              let signatureReference = type.getSignature();\n              if (signatureReference) {\n                typeString = \"function\";\n              } else {\n                let classReference = type.getClass();\n                if (classReference) {\n                  if (classReference.prototype === stringInstance.prototype) {\n                    typeString = \"string\";\n                  } else {\n                    typeString = \"object\";\n                  }\n                } else {\n                  typeString = \"externref\"; // TODO?\n                }\n              }\n            } else if (type == Type.bool) {\n              typeString = \"boolean\";\n            } else if (type.isNumericValue) {\n              typeString = \"number\";\n            } else {\n              typeString = \"undefined\"; // failed to compile?\n            }\n            break;\n          }\n        }\n      }\n    }\n    this.currentType = stringInstance.type;\n    return expr\n      ? this.module.block(null, [ expr, this.ensureStaticString(typeString) ], this.options.sizeTypeRef)\n      : this.ensureStaticString(typeString);\n  }\n\n  /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */\n  ensureSmallIntegerWrap(expr: ExpressionRef, type: Type): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    switch (type.kind) {\n      case TypeKind.I8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)\n            ? module.unary(UnaryOp.Extend8I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(24)\n                ),\n                module.i32(24)\n              );\n        }\n        break;\n      }\n      case TypeKind.I16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)\n            ? module.unary(UnaryOp.Extend16I32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(16)\n                ),\n                module.i32(16)\n              );\n        }\n        break;\n      }\n      case TypeKind.U8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xff)\n          );\n        }\n        break;\n      }\n      case TypeKind.U16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xffff)\n          );\n        }\n        break;\n      }\n      case TypeKind.BOOL: {\n        if (flow.canOverflow(expr, type)) {\n          // bool is special in that it compares to 0 instead of masking with 0x1\n          expr = module.binary(BinaryOp.NeI32,\n            expr,\n            module.i32(0)\n          );\n        }\n        break;\n      }\n    }\n    return expr;\n  }\n\n  /** Adds the debug location of the specified expression at the specified range to the source map. */\n  addDebugLocation(expr: ExpressionRef, range: Range): void {\n    var parentFunction = this.currentFlow.parentFunction;\n    var source = range.source;\n    if (source.debugInfoIndex < 0) source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\n    range.debugInfoRef = expr;\n    parentFunction.debugLocations.push(range);\n  }\n\n  /** Checks whether a particular feature is enabled. */\n  checkFeatureEnabled(feature: Feature, reportNode: Node): bool {\n    if (!this.options.hasFeature(feature)) {\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        reportNode.range, featureToString(feature)\n      );\n      return false;\n    }\n    return true;\n  }\n\n  /** Checks whether a particular type is supported. */\n  checkTypeSupported(type: Type, reportNode: Node): bool {\n    switch (type.kind) {\n      case TypeKind.V128: return this.checkFeatureEnabled(Feature.SIMD, reportNode);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode);\n      case TypeKind.ANYREF:\n      case TypeKind.EQREF:\n      case TypeKind.I31REF:\n      case TypeKind.DATAREF: {\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode)\n            && this.checkFeatureEnabled(Feature.GC, reportNode);\n      }\n    }\n    let classReference = type.getClass();\n    if (classReference) {\n      do {\n        let typeArguments = classReference.typeArguments;\n        if (typeArguments) {\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (!this.checkTypeSupported(typeArguments[i], reportNode)) {\n              return false;\n            }\n          }\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    } else {\n      let signatureReference = type.getSignature();\n      if (signatureReference) {\n        let thisType = signatureReference.thisType;\n        if (thisType) {\n          if (!this.checkTypeSupported(thisType, reportNode)) {\n            return false;\n          }\n        }\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n          if (!this.checkTypeSupported(parameterTypes[i], reportNode)) {\n            return false;\n          }\n        }\n        let returnType = signatureReference.returnType;\n        if (!this.checkTypeSupported(returnType, reportNode)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Checks whether a particular function signature is supported. */\n  checkSignatureSupported(signature: Signature, reportNode: FunctionTypeNode): bool {\n    var supported = true;\n    var explicitThisType = reportNode.explicitThisType;\n    if (explicitThisType) {\n      if (!this.checkTypeSupported(assert(signature.thisType), explicitThisType)) {\n        supported = false;\n      }\n    }\n    var parameterTypes = signature.parameterTypes;\n    var parameterNodes = reportNode.parameters;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let parameterReportNode: Node;\n      if (parameterNodes.length > i) parameterReportNode = parameterNodes[i];\n      else parameterReportNode = reportNode;\n      if (!this.checkTypeSupported(parameterTypes[i], parameterReportNode)) {\n        supported = false;\n      }\n    }\n    if (!this.checkTypeSupported(signature.returnType, reportNode.returnType)) {\n      supported = false;\n    }\n    return supported;\n  }\n\n  /** Evaluates a boolean condition, determining whether it is TRUE, FALSE or UNKNOWN. */\n  evaluateCondition(expr: ExpressionRef): ConditionKind {\n    let type = getExpressionType(expr);\n    if (type == TypeRef.Unreachable)\n      return ConditionKind.UNKNOWN;\n\n    assert(type == TypeRef.I32);\n    var module = this.module;\n    var evaled = module.runExpression(expr, ExpressionRunnerFlags.Default);\n    if (evaled) {\n      return getConstValueI32(evaled)\n        ? ConditionKind.TRUE\n        : ConditionKind.FALSE;\n    }\n    return ConditionKind.UNKNOWN;\n  }\n\n  // === Specialized code generation ==============================================================\n\n  /** Makes a constant zero of the specified type. */\n  makeZero(type: Type, reportNode: Node): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.i32(0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(0);\n      case TypeKind.F32: return module.f32(0);\n      case TypeKind.F64: return module.f64(0);\n      case TypeKind.V128: return module.v128(v128_zero);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF:\n      case TypeKind.EQREF:\n      case TypeKind.DATAREF: return module.ref_null(type.toRef());\n      case TypeKind.I31REF: return module.i31_new(module.i32(0));\n    }\n  }\n\n  /** Makes a constant one of the specified type. */\n  makeOne(type: Type): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.i32(1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(1);\n      case TypeKind.F32: return module.f32(1);\n      case TypeKind.F64: return module.f64(1);\n      case TypeKind.I31REF: return module.i31_new(module.i32(1));\n    }\n  }\n\n  /** Makes a constant negative one of the specified type. */\n  makeNegOne(type: Type): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(-1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(-1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(-1, -1);\n      case TypeKind.F32: return module.f32(-1);\n      case TypeKind.F64: return module.f64(-1);\n    }\n  }\n\n  /** Creates a comparison whether an expression is 'true' in a broader sense. */\n  makeIsTrueish(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        expr = this.ensureSmallIntegerWrap(expr, type);\n        // fall-through\n      }\n      case TypeKind.BOOL: // not a mask, just != 0\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.NeI64, expr, module.i64(0));\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return type.size == 64\n          ? module.binary(BinaryOp.NeI64, expr, module.i64(0))\n          : expr;\n      }\n      case TypeKind.F32: {\n        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n        // (reinterpret<u32>(x) & 0x7FFFFFFF) - 1 <= 0x7F800000 - 1\n        //\n        // and finally:\n        // (reinterpret<u32>(x) << 1) - (1 << 1) <= ((0x7F800000 - 1) << 1)\n        return module.binary(BinaryOp.LeU32,\n          module.binary(BinaryOp.SubI32,\n            module.binary(BinaryOp.ShlI32,\n              module.unary(UnaryOp.ReinterpretF32ToI32, expr),\n              module.i32(1)\n            ),\n            module.i32(2) // 1 << 1\n          ),\n          module.i32(0xFEFFFFFE) // (0x7F800000 - 1) << 1\n        );\n      }\n      case TypeKind.F64: {\n        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n        // (reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF) - 1 <= 0x7FF0000000000000 - 1\n        //\n        // and finally:\n        // (reinterpret<u64>(x) << 1) - (1 << 1) <= ((0x7FF0000000000000 - 1) << 1)\n        return module.binary(BinaryOp.LeU64,\n          module.binary(BinaryOp.SubI64,\n            module.binary(BinaryOp.ShlI64,\n              module.unary(UnaryOp.ReinterpretF64ToI64, expr),\n              module.i64(1)\n            ),\n            module.i64(2) // 1 << 1\n          ),\n          module.i64(0xFFFFFFFE, 0xFFDFFFFF) // (0x7FF0000000000000 - 1) << 1\n        );\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueV128, expr);\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.ANYREF:\n      case TypeKind.EQREF:\n      case TypeKind.DATAREF:\n      case TypeKind.I31REF: {\n        // Needs to be true (i.e. not zero) when the ref is _not_ null,\n        // which means `ref.is_null` returns false (i.e. zero).\n        return module.unary(UnaryOp.EqzI32, module.ref_is(RefIsOp.RefIsNull, expr));\n\n      }\n      default: {\n        assert(false);\n        return module.i32(0);\n      }\n    }\n  }\n\n  /** Makes a string conversion of the given expression. */\n  makeToString(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    var stringType = this.program.stringInstance.type;\n    if (type == stringType) {\n      return expr;\n    }\n    var classType = type.getClassOrWrapper(this.program);\n    if (classType) {\n      let toStringInstance = classType.getMethod(\"toString\");\n      if (toStringInstance) {\n        let toStringSignature = toStringInstance.signature;\n        if (!this.checkCallSignature( // reports\n          toStringSignature,\n          0,\n          true,\n          reportNode\n        )) {\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        if (!type.isStrictlyAssignableTo(assert(toStringSignature.thisType))) {\n          this.errorRelated(\n            DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n            reportNode.range, toStringInstance.identifierAndSignatureRange\n          );\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        let toStringReturnType = toStringSignature.returnType;\n        if (!toStringReturnType.isStrictlyAssignableTo(stringType)) {\n          this.errorRelated(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            reportNode.range, toStringInstance.identifierAndSignatureRange, toStringReturnType.toString(), stringType.toString()\n          );\n          this.currentType = stringType;\n          return this.module.unreachable();\n        }\n        return this.makeCallDirect(toStringInstance, [ expr ], reportNode);\n      }\n    }\n    this.error(\n      DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n      reportNode.range, type.toString(), stringType.toString()\n    );\n    this.currentType = stringType;\n    return this.module.unreachable();\n  }\n\n  /** Makes an allocation suitable to hold the data of an instance of the given class. */\n  makeAllocation(\n    classInstance: Class\n  ): ExpressionRef {\n    var program = this.program;\n    assert(classInstance.program == program);\n    var module = this.module;\n    var options = this.options;\n    this.currentType = classInstance.type;\n    if (classInstance.hasDecorator(DecoratorFlags.UNMANAGED)) {\n      let allocInstance = program.allocInstance;\n      this.compileFunction(allocInstance);\n      return module.call(allocInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset)\n      ], options.sizeTypeRef);\n    } else {\n      let newInstance = program.newInstance;\n      this.compileFunction(newInstance);\n      return module.call(newInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset),\n        module.i32(classInstance.id)\n      ], options.sizeTypeRef);\n    }\n  }\n\n  /** Makes a conditional allocation where `this` might not have been initialized yet. */\n  makeConditionalAllocation(\n    classInstance: Class,\n    thisIndex: i32\n  ): ExpressionRef {\n    var module = this.module;\n    var classType = classInstance.type;\n    var classTypeRef = classType.toRef();\n    assert(classTypeRef == this.options.sizeTypeRef);\n    return module.if(\n      module.unary(classTypeRef == TypeRef.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\n        module.local_get(thisIndex, classTypeRef)\n      ),\n      module.local_set(thisIndex,\n        this.makeAllocation(classInstance),\n        classInstance.type.isManaged\n      )\n    );\n  }\n\n  /** Makes the initializers for a class's fields within the constructor. */\n  makeFieldInitializationInConstructor(\n    /** Class being initialized. */\n    classInstance: Class,\n    /** Statements to append to also being returned. Created if omitted. */\n    stmts: ExpressionRef[] = []\n  ): ExpressionRef[] {\n    var members = classInstance.members;\n    if (!members) return stmts;\n\n    var module = this.module;\n    var flow = this.currentFlow;\n    var isInline = flow.isInline;\n    var thisLocalIndex = isInline ? flow.lookupLocal(CommonNames.this_)!.index : 0;\n    var sizeTypeRef = this.options.sizeTypeRef;\n    var nonParameterFields: Field[] | null = null;\n\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      if (\n        member.kind != ElementKind.FIELD || // not a field\n        member.parent != classInstance      // inherited field\n      ) continue;\n      let field = <Field>member;\n      assert(!field.isAny(CommonFlags.CONST));\n      let fieldPrototype = field.prototype;\n      let parameterIndex = fieldPrototype.parameterIndex;\n\n      // Defer non-parameter fields until parameter fields are initialized\n      if (parameterIndex < 0) {\n        if (!nonParameterFields) nonParameterFields = new Array();\n        nonParameterFields.push(field);\n        continue;\n      }\n\n      // Initialize constructor parameter field\n      let fieldType = field.type;\n      let fieldTypeRef = fieldType.toRef();\n      assert(!fieldPrototype.initializerNode);\n      this.compileFieldSetter(field);\n      stmts.push(\n        module.call(field.internalSetterName, [\n          module.local_get(thisLocalIndex, sizeTypeRef),\n          module.local_get(\n            isInline\n              ? flow.lookupLocal(field.name)!.index\n              : 1 + parameterIndex, // `this` is local 0\n            fieldTypeRef\n          )\n        ], TypeRef.None)\n      );\n    }\n\n    // Initialize deferred non-parameter fields\n    if (nonParameterFields) {\n      for (let i = 0, k = nonParameterFields.length; i < k; ++i) {\n        let field = unchecked(nonParameterFields[i]);\n        let fieldType = field.type;\n        let fieldPrototype = field.prototype;\n        let initializerNode = fieldPrototype.initializerNode;\n        assert(fieldPrototype.parameterIndex < 0);\n        this.compileFieldSetter(field);\n        stmts.push(\n          module.call(field.internalSetterName, [\n            module.local_get(thisLocalIndex, sizeTypeRef),\n            initializerNode // use initializer if present, otherwise initialize with zero\n              ? this.compileExpression(initializerNode, fieldType, Constraints.CONV_IMPLICIT)\n              : this.makeZero(fieldType, fieldPrototype.declaration)\n          ], TypeRef.None)\n        );\n      }\n    }\n\n    this.currentType = Type.void;\n    return stmts;\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeAbort(\n    /** Message argument of type string, if any. */\n    message: Expression | null,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    var program = this.program;\n    var abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return this.module.unreachable();\n\n    var stringInstance = program.stringInstance;\n    var messageArg: ExpressionRef;\n    if (message !== null) {\n      messageArg = this.compileExpression(message, stringInstance.type, Constraints.CONV_IMPLICIT);\n    } else {\n      messageArg = this.makeZero(stringInstance.type, codeLocation);\n    }\n\n    return this.makeStaticAbort(messageArg, codeLocation);\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeStaticAbort(\n    /** Message argument of type string. May be zero. */\n    messageExpr: ExpressionRef,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    var program = this.program;\n    var module = this.module;\n    var abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return module.unreachable();\n\n    var filenameExpr = this.ensureStaticString(codeLocation.range.source.normalizedPath);\n    var range = codeLocation.range;\n    var source = range.source;\n    return module.block(null, [\n      module.call(\n        abortInstance.internalName, [\n          messageExpr,\n          filenameExpr,\n          module.i32(source.lineAt(range.start)),\n          module.i32(source.columnAt())\n        ],\n        TypeRef.None\n      ),\n      module.unreachable()\n    ]);\n  }\n\n  /** Makes a runtime non-null check, e.g. on `<Type>possiblyNull` or `possiblyNull!`. */\n  makeRuntimeNonNullCheck(\n    /** Expression being checked. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var temp = flow.getTempLocal(type);\n    if (!flow.canOverflow(expr, type)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n    flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n    expr = module.if(\n      module.local_tee(temp.index, expr, type.isManaged),\n      module.local_get(temp.index, type.toRef()),\n      this.makeStaticAbort(this.ensureStaticString(\"unexpected null\"), reportNode) // TODO: throw\n    );\n    flow.freeTempLocal(temp);\n    this.currentType = type.nonNullableType;\n    return expr;\n  }\n\n  /** Makes a runtime upcast check, e.g. on `<Child>parent`. */\n  makeRuntimeUpcastCheck(\n    /** Expression being upcast. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Type casting to. */\n    toType: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(toType.isReference && toType.nonNullableType.isAssignableTo(type));\n    var module = this.module;\n    var flow = this.currentFlow;\n    var temp = flow.getTempLocal(type);\n    var instanceofInstance = this.program.instanceofInstance;\n    assert(this.compileFunction(instanceofInstance));\n    if (!toType.isNullableReference || flow.isNonnull(expr, type)) {\n      // Simplify if the value cannot be `null`. If toType is non-nullable, a\n      // null-check would have been emitted separately so is not necessary here.\n      expr = module.if(\n        module.call(instanceofInstance.internalName, [\n          module.local_tee(temp.index, expr, type.isManaged),\n          module.i32(toType.classReference!.id)\n        ], TypeRef.I32),\n        module.local_get(temp.index, type.toRef()),\n        this.makeStaticAbort(this.ensureStaticString(\"unexpected upcast\"), reportNode) // TODO: throw\n      );\n    } else {\n      expr = module.if(\n        module.local_tee(temp.index, expr, type.isManaged),\n        module.if(\n          module.call(instanceofInstance.internalName, [\n            module.local_get(temp.index, type.toRef()),\n            module.i32(toType.classReference!.id)\n          ], TypeRef.I32),\n          module.local_get(temp.index, type.toRef()),\n          this.makeStaticAbort(this.ensureStaticString(\"unexpected upcast\"), reportNode) // TODO: throw\n        ),\n        module.usize(0)\n      );\n    }\n    flow.freeTempLocal(temp);\n    this.currentType = toType;\n    return expr;\n  }\n}\n\n// helpers\n\nfunction mangleImportName(\n  element: Element,\n  declaration: DeclarationStatement\n): void {\n  // by default, use the file name as the module name\n  mangleImportName_moduleName = declaration.range.source.simplePath;\n  // and the internal name of the element within that file as the element name\n  mangleImportName_elementName = mangleInternalName(\n    element.name, element.parent, element.is(CommonFlags.INSTANCE), true\n  );\n  if (!element.hasDecorator(DecoratorFlags.EXTERNAL)) return;\n\n  var program = element.program;\n  var decorator = assert(findDecorator(DecoratorKind.EXTERNAL, declaration.decorators));\n  var args = decorator.args;\n  if (args !== null && args.length > 0) {\n    let arg = args[0];\n    // if one argument is given, override just the element name\n    // if two arguments are given, override both module and element name\n    if (arg.isLiteralKind(LiteralKind.STRING)) {\n      mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n      if (args.length >= 2) {\n        arg = args[1];\n        if (arg.isLiteralKind(LiteralKind.STRING)) {\n          mangleImportName_moduleName = mangleImportName_elementName;\n          mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n          if (args.length > 2) {\n            program.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              decorator.range, \"2\", args.length.toString()\n            );\n          }\n        } else {\n          program.error(\n            DiagnosticCode.String_literal_expected,\n            arg.range\n          );\n        }\n      }\n    } else {\n      program.error(\n        DiagnosticCode.String_literal_expected,\n        arg.range\n      );\n    }\n  } else {\n    program.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      decorator.range, \"1\", \"0\"\n    );\n  }\n}\n\nvar mangleImportName_moduleName: string;\nvar mangleImportName_elementName: string;\n","/**\n * @fileoverview Builders for various definitions describing a module.\n *\n * - TSDBuilder: Creates a TypeScript definition file (.d.ts)\n * - IDLBuilder: Creates a WebIDL interface definition (.webidl)\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  Program,\n  Element,\n  ElementKind,\n  Global,\n  Enum,\n  EnumValue,\n  Field,\n  Function,\n  FunctionPrototype,\n  Class,\n  ClassPrototype,\n  Namespace,\n  ConstantValueKind,\n  Interface,\n  Property,\n  PropertyPrototype,\n  File\n} from \"./program\";\n\nimport {\n  Type,\n  TypeKind\n} from \"./types\";\n\nimport {\n  SourceKind\n} from \"./ast\";\n\nimport {\n  indent\n} from \"./util\";\n\n/** Walker base class. */\nexport abstract class ExportsWalker {\n\n  /** Program reference. */\n  program: Program;\n  /** Whether to include private members */\n  includePrivate: bool;\n  /** Already seen elements. */\n  seen: Map<Element,string> = new Map();\n\n  /** Constructs a new Element walker. */\n  constructor(program: Program, includePrivate: bool = false) {\n    this.program = program;\n    this.includePrivate = includePrivate;\n  }\n\n  /** Walks all elements and calls the respective handlers. */\n  walk(): void {\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.visitFile(file);\n    }\n  }\n\n  /** Visits all exported elements of a file. */\n  visitFile(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        this.visitElement(memberName, member);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.visitFile(exportStar);\n      }\n    }\n  }\n\n  /** Visits an element.*/\n  visitElement(name: string, element: Element): void {\n    if (element.is(CommonFlags.PRIVATE) && !this.includePrivate) return;\n    var seen = this.seen;\n    if (!element.is(CommonFlags.INSTANCE) && seen.has(element)) {\n      this.visitAlias(name, element, assert(seen.get(element)));\n      return;\n    }\n    seen.set(element, name);\n    switch (element.kind) {\n      case ElementKind.GLOBAL: {\n        if (element.is(CommonFlags.COMPILED)) this.visitGlobal(name, <Global>element);\n        break;\n      }\n      case ElementKind.ENUM: {\n        if (element.is(CommonFlags.COMPILED)) this.visitEnum(name, <Enum>element);\n        break;\n      }\n      case ElementKind.ENUMVALUE: break; // handled by visitEnum\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        this.visitFunctionInstances(name, <FunctionPrototype>element);\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        this.visitClassInstances(name, <ClassPrototype>element);\n        break;\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>element;\n        if (fieldInstance.is(CommonFlags.COMPILED)) this.visitField(name, fieldInstance);\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (!propertyInstance) break;\n        element = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.visitFunction(name, getterInstance);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.visitFunction(name, setterInstance);\n        break;\n      }\n      case ElementKind.NAMESPACE: {\n        if (hasCompiledMember(element)) this.visitNamespace(name, element);\n        break;\n      }\n      case ElementKind.TYPEDEFINITION: break;\n      default: assert(false);\n    }\n  }\n\n  private visitFunctionInstances(name: string, element: FunctionPrototype): void {\n    var instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.COMPILED)) this.visitFunction(name, instance);\n      }\n    }\n  }\n\n  private visitClassInstances(name: string, element: ClassPrototype): void {\n    var instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.COMPILED)) this.visitClass(name, instance);\n      }\n    }\n  }\n\n  abstract visitGlobal(name: string, element: Global): void;\n  abstract visitEnum(name: string, element: Enum): void;\n  abstract visitFunction(name: string, element: Function): void;\n  abstract visitClass(name: string, element: Class): void;\n  abstract visitInterface(name: string, element: Interface): void;\n  abstract visitField(name: string, element: Field): void;\n  abstract visitNamespace(name: string, element: Element): void;\n  abstract visitAlias(name: string, element: Element, originalName: string): void;\n}\n\n/** A WebIDL definitions builder. */\nexport class IDLBuilder extends ExportsWalker {\n\n  /** Builds WebIDL definitions for the specified program. */\n  static build(program: Program): string {\n    return new IDLBuilder(program).build();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  /** Constructs a new WebIDL builder. */\n  constructor(program: Program, includePrivate: bool = false) {\n    super(program, includePrivate);\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    var sb = this.sb;\n    var isConst = element.is(CommonFlags.INLINED);\n    indent(sb, this.indentLevel);\n    if (isConst) sb.push(\"const \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\" \");\n    sb.push(name);\n    if (isConst) {\n      switch (element.constantValueKind) {\n        case ConstantValueKind.INTEGER: {\n          sb.push(\" = \");\n          sb.push(i64_to_string(element.constantIntegerValue));\n          break;\n        }\n        case ConstantValueKind.FLOAT: {\n          sb.push(\" = \");\n          sb.push(element.constantFloatValue.toString());\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    sb.push(\";\\n\");\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    if (members) {\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind == ElementKind.ENUMVALUE) {\n          let enumValue = <EnumValue>member;\n          let isConst = enumValue.is(CommonFlags.INLINED);\n          indent(sb, this.indentLevel);\n          if (isConst) sb.push(\"const \");\n          else sb.push(\"readonly \");\n          sb.push(\"unsigned long \");\n          sb.push(memberName);\n          if (isConst) {\n            sb.push(\" = \");\n            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n            sb.push(i64_low(enumValue.constantIntegerValue).toString());\n          }\n          sb.push(\";\\n\");\n        }\n      }\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.ENUMVALUE) this.visitElement(member.name, member);\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    var sb = this.sb;\n    var signature = element.signature;\n    indent(sb, this.indentLevel);\n    sb.push(this.typeToString(signature.returnType));\n    sb.push(\" \");\n    sb.push(name);\n    sb.push(\"(\");\n    var parameters = signature.parameterTypes;\n    var numParameters = parameters.length;\n    // var requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      // if (i >= requiredParameters) sb.push(\"optional \");\n      sb.push(this.typeToString(parameters[i]));\n      sb.push(\" \");\n      sb.push(element.getParameterName(i));\n    }\n    sb.push(\");\\n\");\n    var members = element.members;\n    if (members !== null && members.size > 0) {\n      indent(sb, this.indentLevel);\n      sb.push(\"interface \");\n      sb.push(element.name);\n      sb.push(\" {\\n\");\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\\n\");\n    }\n  }\n\n  visitClass(name: string, element: Class): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    // TODO\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitField(name: string, element: Field): void {\n    // TODO\n  }\n\n  visitNamespace(name: string, element: Namespace): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // TODO\n  }\n\n  typeToString(type: Type): string {\n    switch (type.kind) {\n      case TypeKind.I8: return \"byte\";\n      case TypeKind.I16: return \"short\";\n      case TypeKind.I32: return \"long\";\n      case TypeKind.I64: return \"long long\";\n      case TypeKind.ISIZE: return this.program.options.isWasm64 ? \"long long\" : \"long\";\n      case TypeKind.U8: return \"octet\";\n      case TypeKind.U16: return \"unsigned short\";\n      case TypeKind.U32: return \"unsigned long\";\n        // ^ TODO: function types\n      case TypeKind.U64: return \"unsigned long long\";\n      case TypeKind.USIZE: return this.program.options.isWasm64 ? \"unsigned long long\" : \"unsigned long\";\n        // ^ TODO: class types\n      case TypeKind.BOOL: return \"boolean\";\n      case TypeKind.F32: return \"unrestricted float\";\n      case TypeKind.F64: return \"unrestricted double\";\n      case TypeKind.VOID: return \"void\";\n      default: {\n        assert(false);\n        return \"\";\n      }\n    }\n  }\n\n  build(): string {\n    var sb = this.sb;\n    sb.push(\"interface ASModule {\\n\");\n    ++this.indentLevel;\n    this.walk();\n    --this.indentLevel;\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n/** A TypeScript definitions builder. */\nexport class TSDBuilder extends ExportsWalker {\n\n  /** Builds TypeScript definitions for the specified program. */\n  static build(program: Program): string {\n    return new TSDBuilder(program).build();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  /** Constructs a new WebIDL builder. */\n  constructor(program: Program, includePrivate: bool = false) {\n    super(program, includePrivate);\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    var sb = this.sb;\n    var isConst = element.is(CommonFlags.INLINED);\n    indent(sb, this.indentLevel);\n    if (element.is(CommonFlags.STATIC)) {\n      if (isConst) sb.push(\"static readonly \");\n      else sb.push(\"static \");\n    } else {\n      if (isConst) sb.push(\"export const \");\n      else sb.push(\"export var \");\n    }\n    sb.push(name);\n    sb.push(\": \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\";\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"export \");\n    if (element.is(CommonFlags.CONST)) sb.push(\"const \");\n    sb.push(\"enum \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    var remainingMembers = 0;\n    if (members) {\n      remainingMembers = members.size;\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind == ElementKind.ENUMVALUE) {\n          let enumValue = <EnumValue>member;\n          indent(sb, this.indentLevel);\n          sb.push(memberName);\n          if (member.is(CommonFlags.INLINED)) {\n            sb.push(\" = \");\n            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n            sb.push(i64_low(enumValue.constantIntegerValue).toString());\n          }\n          sb.push(\",\\n\");\n          --remainingMembers;\n        }\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    if (remainingMembers) this.visitNamespace(name, element);\n  }\n\n  visitFunction(name: string, element: Function): void {\n    if (element.isAny(CommonFlags.PRIVATE)) return;\n    var sb = this.sb;\n    var signature = element.signature;\n    indent(sb, this.indentLevel);\n    if (!element.isAny(CommonFlags.STATIC | CommonFlags.INSTANCE)) {\n      sb.push(\"export function \");\n    } else {\n      if (element.is(CommonFlags.PROTECTED)) sb.push(\"protected \");\n      if (element.is(CommonFlags.STATIC)) sb.push(\"static \");\n      if (element.is(CommonFlags.GET)) sb.push(\"get \");\n      else if (element.is(CommonFlags.SET)) sb.push(\"set \");\n    }\n    sb.push(name);\n    sb.push(\"(\");\n    var parameters = signature.parameterTypes;\n    var numParameters = parameters.length;\n    var requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      sb.push(element.getParameterName(i));\n      if (i >= requiredParameters) sb.push(\"?\");\n      sb.push(\": \");\n      sb.push(this.typeToString(parameters[i]));\n    }\n    if (element.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)) {\n      sb.push(\")\");\n    } else {\n      sb.push(\"): \");\n      sb.push(this.typeToString(signature.returnType));\n    }\n    sb.push(\";\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  visitClass(name: string, element: Class): void {\n    var sb = this.sb;\n    var isInterface = element.kind == ElementKind.INTERFACE;\n    indent(sb, this.indentLevel++);\n    if (isInterface) {\n      sb.push(\"export interface \");\n    } else {\n      sb.push(\"export \");\n      if (element.is(CommonFlags.ABSTRACT)) sb.push(\"abstract \");\n      sb.push(\"class \");\n    }\n    sb.push(name);\n    var base = element.base;\n    if (base !== null && base.is(CommonFlags.COMPILED | CommonFlags.MODULE_EXPORT)) {\n      sb.push(\" extends \");\n      let extendsNode = assert(element.prototype.extendsNode);\n      sb.push(extendsNode.name.identifier.text); // TODO: fqn?\n    }\n    sb.push(\" {\\n\");\n    if (!isInterface) {\n      indent(sb, this.indentLevel);\n      sb.push(\"static wrap(ptr: usize): \");\n      sb.push(name);\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"valueOf(): usize;\\n\");\n    }\n    var staticMembers = element.prototype.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n    }\n    var instanceMembers = element.members;\n    if (instanceMembers) {\n      // TODO: for (let member of instanceMembers.values()) {\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.parent == element) { // own member\n          this.visitElement(member.name, member);\n        }\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitField(name: string, element: Field): void {\n    if (element.is(CommonFlags.PRIVATE)) return;\n    var sb = this.sb;\n    indent(sb, this.indentLevel);\n    if (element.is(CommonFlags.PROTECTED)) sb.push(\"protected \");\n    if (element.is(CommonFlags.STATIC)) sb.push(\"static \");\n    if (element.is(CommonFlags.READONLY)) sb.push(\"readonly \");\n    sb.push(name);\n    sb.push(\": \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\";\\n\");\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    var members = element.members;\n    if (members !== null && members.size > 0) {\n      let sb = this.sb;\n      indent(sb, this.indentLevel++);\n      sb.push(\"export namespace \");\n      sb.push(name);\n      sb.push(\" {\\n\");\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\\n\");\n    }\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel);\n    sb.push(\"export const \");\n    sb.push(name);\n    sb.push(\": typeof \");\n    sb.push(originalName);\n    sb.push(\";\\n\");\n  }\n\n  typeToString(type: Type): string {\n    switch (type.kind) {\n      case TypeKind.I8: return \"i8\";\n      case TypeKind.I16: return \"i16\";\n      case TypeKind.I32: return \"i32\";\n      case TypeKind.I64: return \"i64\";\n      case TypeKind.ISIZE: return \"isize\";\n      case TypeKind.U8: return \"u8\";\n      case TypeKind.U16: return \"u16\";\n      case TypeKind.U32: return \"u32\";\n        // ^ TODO: function types\n      case TypeKind.U64: return \"u64\";\n      case TypeKind.USIZE: return \"usize\";\n        // ^ TODO: class types\n      case TypeKind.BOOL: return \"bool\";\n      case TypeKind.F32: return \"f32\";\n      case TypeKind.F64: return \"f64\";\n      case TypeKind.V128: return \"v128\";\n      case TypeKind.VOID: return \"void\";\n      case TypeKind.FUNCREF: return \"funcref\";\n      case TypeKind.EXTERNREF: return \"externref\";\n      case TypeKind.ANYREF: return \"anyref\";\n      case TypeKind.EQREF: return \"eqref\";\n      case TypeKind.I31REF: return \"i31ref\";\n      case TypeKind.DATAREF: return \"dataref\";\n      default: {\n        assert(false);\n        return \"any\";\n      }\n    }\n  }\n\n  build(): string {\n    var sb = this.sb;\n    var options = this.program.options;\n    sb.push(\"type i8 = number;\\n\");\n    sb.push(\"type i16 = number;\\n\");\n    sb.push(\"type i32 = number;\\n\");\n    sb.push(\"type i64 = bigint;\\n\");\n    if (options.isWasm64) {\n      sb.push(\"type isize = bigint;\\n\");\n    } else {\n      sb.push(\"type isize = number;\\n\");\n    }\n    sb.push(\"type u8 = number;\\n\");\n    sb.push(\"type u16 = number;\\n\");\n    sb.push(\"type u32 = number;\\n\");\n    sb.push(\"type u64 = bigint;\\n\");\n    if (options.isWasm64) {\n      sb.push(\"type usize = bigint;\\n\");\n    } else {\n      sb.push(\"type usize = number;\\n\");\n    }\n    sb.push(\"type f32 = number;\\n\");\n    sb.push(\"type f64 = number;\\n\");\n    sb.push(\"type bool = boolean | number;\\n\");\n    this.walk();\n    if (options.exportMemory) {\n      sb.push(\"export const memory: WebAssembly.Memory;\\n\");\n    }\n    if (options.exportTable) {\n      sb.push(\"export const table: WebAssembly.Table;\\n\");\n    }\n    if (options.explicitStart) {\n      sb.push(\"export function _start(): void;\\n\");\n    }\n    if (options.exportRuntime) {\n      sb.push(\"export function __new(size: usize, id: u32): usize;\\n\");\n      sb.push(\"export function __pin(ptr: usize): usize;\\n\");\n      sb.push(\"export function __unpin(ptr: usize): void;\\n\");\n      sb.push(\"export function __collect(): void;\\n\");\n      sb.push(\"export const __rtti_base: usize;\\n\");\n    }\n    sb.push(\"export const __setArgumentsLength: ((n: i32) => void) | undefined;\\n\");\n    return this.sb.join(\"\");\n  }\n}\n\n// helpers\n\n/** Tests if a namespace-like element has at least one compiled member. */\nfunction hasCompiledMember(element: Element): bool {\n  var members = element.members;\n  if (members) {\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      switch (member.kind) {\n        case ElementKind.FUNCTION_PROTOTYPE: {\n          let instances = (<FunctionPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.COMPILED)) return true;\n            }\n          }\n          break;\n        }\n        case ElementKind.CLASS_PROTOTYPE: {\n          let instances = (<ClassPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.COMPILED)) return true;\n            }\n          }\n          break;\n        }\n        default: {\n          if (member.is(CommonFlags.COMPILED) || hasCompiledMember(member)) return true;\n          break;\n        }\n      }\n    }\n  }\n  return false;\n}\n","/**\n * @fileoverview Generated from diagnosticsMessages.json. Do not edit.\n * @license Apache-2.0\n */\n\n/** Enum of available diagnostic codes. */\nexport enum DiagnosticCode {\n  Not_implemented_0 = 100,\n  Operation_is_unsafe = 101,\n  User_defined_0 = 102,\n  Feature_0_is_not_enabled = 103,\n  Low_memory_limit_exceeded_by_static_data_0_1 = 104,\n  Module_requires_at_least_0_pages_of_initial_memory = 105,\n  Module_requires_at_least_0_pages_of_maximum_memory = 106,\n  Shared_memory_requires_maximum_memory_to_be_defined = 107,\n  Shared_memory_requires_feature_threads_to_be_enabled = 108,\n  Transform_0_1 = 109,\n  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,\n  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,\n  Type_0_cannot_be_changed_to_type_1 = 202,\n  Operation_0_cannot_be_applied_to_type_1 = 203,\n  Type_0_cannot_be_nullable = 204,\n  Cannot_export_a_mutable_global = 205,\n  Mutable_value_cannot_be_inlined = 206,\n  Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa = 207,\n  Unmanaged_classes_cannot_implement_interfaces = 208,\n  Invalid_regular_expression_flags = 209,\n  Expression_is_never_null = 210,\n  Class_0_is_final_and_cannot_be_extended = 211,\n  Decorator_0_is_not_valid_here = 212,\n  Duplicate_decorator = 213,\n  Type_0_is_illegal_in_this_context = 214,\n  Optional_parameter_must_have_an_initializer = 215,\n  Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal = 216,\n  Function_0_cannot_be_inlined_into_itself = 217,\n  Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set = 218,\n  Optional_properties_are_not_supported = 219,\n  Expression_must_be_a_compile_time_constant = 220,\n  Type_0_is_not_a_function_index_or_function_reference = 221,\n  _0_must_be_a_value_between_1_and_2_inclusive = 222,\n  _0_must_be_a_power_of_two = 223,\n  _0_is_not_a_valid_operator = 224,\n  Expression_cannot_be_represented_by_a_type = 225,\n  Expression_resolves_to_unusual_type_0 = 226,\n  Array_literal_expected = 227,\n  Function_0_is_virtual_and_will_not_be_inlined = 228,\n  Property_0_only_has_a_setter_and_is_missing_a_getter = 229,\n  _0_keyword_cannot_be_used_here = 230,\n  A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final = 231,\n  Property_0_is_always_assigned_before_being_used = 233,\n  Expression_does_not_compile_to_a_value_at_runtime = 234,\n  Importing_the_table_disables_some_indirect_call_optimizations = 901,\n  Exporting_the_table_disables_some_indirect_call_optimizations = 902,\n  Expression_compiles_to_a_dynamic_check_at_runtime = 903,\n  Indexed_access_may_involve_bounds_checking = 904,\n  Explicitly_returning_constructor_drops_this_allocation = 905,\n  Unnecessary_definite_assignment = 906,\n  Exported_generic_function_or_class_has_no_concrete_instances = 907,\n  Unterminated_string_literal = 1002,\n  Identifier_expected = 1003,\n  _0_expected = 1005,\n  A_file_cannot_have_a_reference_to_itself = 1006,\n  Trailing_comma_not_allowed = 1009,\n  Unexpected_token = 1012,\n  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,\n  Parameter_cannot_have_question_mark_and_initializer = 1015,\n  A_required_parameter_cannot_follow_an_optional_parameter = 1016,\n  _0_modifier_cannot_appear_on_class_elements_of_this_kind = 1031,\n  Statements_are_not_allowed_in_ambient_contexts = 1036,\n  Initializers_are_not_allowed_in_ambient_contexts = 1039,\n  _0_modifier_cannot_be_used_here = 1042,\n  A_rest_parameter_cannot_be_optional = 1047,\n  A_rest_parameter_cannot_have_an_initializer = 1048,\n  A_set_accessor_must_have_exactly_one_parameter = 1049,\n  A_set_accessor_parameter_cannot_have_an_initializer = 1052,\n  A_get_accessor_cannot_have_parameters = 1054,\n  Enum_member_must_have_initializer = 1061,\n  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,\n  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,\n  An_accessor_cannot_have_type_parameters = 1094,\n  A_set_accessor_cannot_have_a_return_type_annotation = 1095,\n  Type_parameter_list_cannot_be_empty = 1098,\n  Type_argument_list_cannot_be_empty = 1099,\n  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,\n  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,\n  A_return_statement_can_only_be_used_within_a_function_body = 1108,\n  Expression_expected = 1109,\n  Type_expected = 1110,\n  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,\n  Duplicate_label_0 = 1114,\n  An_export_assignment_cannot_have_modifiers = 1120,\n  Octal_literals_are_not_allowed_in_strict_mode = 1121,\n  Digit_expected = 1124,\n  Hexadecimal_digit_expected = 1125,\n  Unexpected_end_of_text = 1126,\n  Invalid_character = 1127,\n  _case_or_default_expected = 1130,\n  _super_must_be_followed_by_an_argument_list_or_member_access = 1034,\n  A_declare_modifier_cannot_be_used_in_an_already_ambient_context = 1038,\n  Type_argument_expected = 1140,\n  String_literal_expected = 1141,\n  Line_break_not_permitted_here = 1142,\n  Declaration_expected = 1146,\n  _const_declarations_must_be_initialized = 1155,\n  Unterminated_regular_expression_literal = 1161,\n  Interface_declaration_cannot_have_implements_clause = 1176,\n  Binary_digit_expected = 1177,\n  Octal_digit_expected = 1178,\n  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,\n  The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = 1190,\n  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,\n  Unterminated_Unicode_escape_sequence = 1199,\n  Decorators_are_not_valid_here = 1206,\n  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,\n  Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = 1245,\n  A_definite_assignment_assertion_is_not_permitted_in_this_context = 1255,\n  A_class_may_only_extend_another_class = 1311,\n  A_parameter_property_cannot_be_declared_using_a_rest_parameter = 1317,\n  An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal = 1351,\n  Duplicate_identifier_0 = 2300,\n  Cannot_find_name_0 = 2304,\n  Module_0_has_no_exported_member_1 = 2305,\n  An_interface_can_only_extend_an_interface = 2312,\n  Generic_type_0_requires_1_type_argument_s = 2314,\n  Type_0_is_not_generic = 2315,\n  Type_0_is_not_assignable_to_type_1 = 2322,\n  Property_0_is_private_in_type_1_but_not_in_type_2 = 2325,\n  Index_signature_is_missing_in_type_0 = 2329,\n  _this_cannot_be_referenced_in_current_location = 2332,\n  _this_cannot_be_referenced_in_constructor_arguments = 2333,\n  _super_can_only_be_referenced_in_a_derived_class = 2335,\n  _super_cannot_be_referenced_in_constructor_arguments = 2336,\n  Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = 2337,\n  Property_0_does_not_exist_on_type_1 = 2339,\n  Property_0_is_private_and_only_accessible_within_class_1 = 2341,\n  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,\n  This_expression_is_not_constructable = 2351,\n  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,\n  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,\n  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,\n  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,\n  A_super_call_must_be_the_first_statement_in_the_constructor = 2376,\n  Constructors_for_derived_classes_must_contain_a_super_call = 2377,\n  Getter_and_setter_accessors_do_not_agree_in_visibility = 2379,\n  _get_and_set_accessor_must_have_the_same_type = 2380,\n  Overload_signatures_must_all_be_public_private_or_protected = 2385,\n  Constructor_implementation_is_missing = 2390,\n  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,\n  Multiple_constructor_implementations_are_not_allowed = 2392,\n  Duplicate_function_implementation = 2393,\n  This_overload_signature_is_not_compatible_with_its_implementation_signature = 2394,\n  Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = 2395,\n  Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2 = 2416,\n  A_class_can_only_implement_an_interface = 2422,\n  A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = 2434,\n  Types_have_separate_declarations_of_a_private_property_0 = 2442,\n  Property_0_is_protected_in_type_1_but_public_in_type_2 = 2444,\n  Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = 2445,\n  Variable_0_used_before_its_declaration = 2448,\n  Cannot_redeclare_block_scoped_variable_0 = 2451,\n  The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = 2453,\n  Type_0_has_no_property_1 = 2460,\n  The_0_operator_cannot_be_applied_to_type_1 = 2469,\n  In_const_enum_declarations_member_initializer_must_be_constant_expression = 2474,\n  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,\n  _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = 2506,\n  Cannot_create_an_instance_of_an_abstract_class = 2511,\n  Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2 = 2515,\n  Object_is_possibly_null = 2531,\n  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,\n  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,\n  Index_signature_in_type_0_only_permits_reading = 2542,\n  Expected_0_arguments_but_got_1 = 2554,\n  Expected_at_least_0_arguments_but_got_1 = 2555,\n  Expected_0_type_arguments_but_got_1 = 2558,\n  Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned = 2564,\n  Property_0_is_used_before_being_assigned = 2565,\n  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,\n  Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = 2673,\n  Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = 2674,\n  The_this_types_of_each_signature_are_incompatible = 2685,\n  Namespace_0_has_no_exported_member_1 = 2694,\n  Required_type_parameters_may_not_follow_optional_type_parameters = 2706,\n  Duplicate_property_0 = 2718,\n  Property_0_is_missing_in_type_1_but_required_in_type_2 = 2741,\n  Type_0_has_no_call_signatures = 2757,\n  File_0_not_found = 6054,\n  Numeric_separators_are_not_allowed_here = 6188,\n  Multiple_consecutive_numeric_separators_are_not_permitted = 6189,\n  _super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = 17009,\n  _super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = 17011\n}\n\n/** Translates a diagnostic code to its respective string. */\nexport function diagnosticCodeToString(code: DiagnosticCode): string {\n  switch (code) {\n    case 100: return \"Not implemented: {0}\";\n    case 101: return \"Operation is unsafe.\";\n    case 102: return \"User-defined: {0}\";\n    case 103: return \"Feature '{0}' is not enabled.\";\n    case 104: return \"Low memory limit exceeded by static data: {0} > {1}\";\n    case 105: return \"Module requires at least '{0}' pages of initial memory.\";\n    case 106: return \"Module requires at least '{0}' pages of maximum memory.\";\n    case 107: return \"Shared memory requires maximum memory to be defined.\";\n    case 108: return \"Shared memory requires feature 'threads' to be enabled.\";\n    case 109: return \"Transform '{0}': {1}\";\n    case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\n    case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\n    case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\n    case 203: return \"Operation '{0}' cannot be applied to type '{1}'.\";\n    case 204: return \"Type '{0}' cannot be nullable.\";\n    case 205: return \"Cannot export a mutable global.\";\n    case 206: return \"Mutable value cannot be inlined.\";\n    case 207: return \"Unmanaged classes cannot extend managed classes and vice-versa.\";\n    case 208: return \"Unmanaged classes cannot implement interfaces.\";\n    case 209: return \"Invalid regular expression flags.\";\n    case 210: return \"Expression is never 'null'.\";\n    case 211: return \"Class '{0}' is final and cannot be extended.\";\n    case 212: return \"Decorator '{0}' is not valid here.\";\n    case 213: return \"Duplicate decorator.\";\n    case 214: return \"Type '{0}' is illegal in this context.\";\n    case 215: return \"Optional parameter must have an initializer.\";\n    case 216: return \"Class '{0}' cannot declare a constructor when instantiated from an object literal.\";\n    case 217: return \"Function '{0}' cannot be inlined into itself.\";\n    case 218: return \"Cannot access method '{0}' without calling it as it requires 'this' to be set.\";\n    case 219: return \"Optional properties are not supported.\";\n    case 220: return \"Expression must be a compile-time constant.\";\n    case 221: return \"Type '{0}' is not a function index or function reference.\";\n    case 222: return \"'{0}' must be a value between '{1}' and '{2}' inclusive.\";\n    case 223: return \"'{0}' must be a power of two.\";\n    case 224: return \"'{0}' is not a valid operator.\";\n    case 225: return \"Expression cannot be represented by a type.\";\n    case 226: return \"Expression resolves to unusual type '{0}'.\";\n    case 227: return \"Array literal expected.\";\n    case 228: return \"Function '{0}' is virtual and will not be inlined.\";\n    case 229: return \"Property '{0}' only has a setter and is missing a getter.\";\n    case 230: return \"'{0}' keyword cannot be used here.\";\n    case 231: return \"A class with a constructor explicitly returning something else than 'this' must be '@final'.\";\n    case 233: return \"Property '{0}' is always assigned before being used.\";\n    case 234: return \"Expression does not compile to a value at runtime.\";\n    case 901: return \"Importing the table disables some indirect call optimizations.\";\n    case 902: return \"Exporting the table disables some indirect call optimizations.\";\n    case 903: return \"Expression compiles to a dynamic check at runtime.\";\n    case 904: return \"Indexed access may involve bounds checking.\";\n    case 905: return \"Explicitly returning constructor drops 'this' allocation.\";\n    case 906: return \"Unnecessary definite assignment.\";\n    case 907: return \"Exported generic function or class has no concrete instances.\";\n    case 1002: return \"Unterminated string literal.\";\n    case 1003: return \"Identifier expected.\";\n    case 1005: return \"'{0}' expected.\";\n    case 1006: return \"A file cannot have a reference to itself.\";\n    case 1009: return \"Trailing comma not allowed.\";\n    case 1012: return \"Unexpected token.\";\n    case 1014: return \"A rest parameter must be last in a parameter list.\";\n    case 1015: return \"Parameter cannot have question mark and initializer.\";\n    case 1016: return \"A required parameter cannot follow an optional parameter.\";\n    case 1031: return \"'{0}' modifier cannot appear on class elements of this kind.\";\n    case 1036: return \"Statements are not allowed in ambient contexts.\";\n    case 1039: return \"Initializers are not allowed in ambient contexts.\";\n    case 1042: return \"'{0}' modifier cannot be used here.\";\n    case 1047: return \"A rest parameter cannot be optional.\";\n    case 1048: return \"A rest parameter cannot have an initializer.\";\n    case 1049: return \"A 'set' accessor must have exactly one parameter.\";\n    case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\n    case 1054: return \"A 'get' accessor cannot have parameters.\";\n    case 1061: return \"Enum member must have initializer.\";\n    case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\n    case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\n    case 1094: return \"An accessor cannot have type parameters.\";\n    case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\n    case 1098: return \"Type parameter list cannot be empty.\";\n    case 1099: return \"Type argument list cannot be empty.\";\n    case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\n    case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\n    case 1108: return \"A 'return' statement can only be used within a function body.\";\n    case 1109: return \"Expression expected.\";\n    case 1110: return \"Type expected.\";\n    case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\n    case 1114: return \"Duplicate label '{0}'.\";\n    case 1120: return \"An export assignment cannot have modifiers.\";\n    case 1121: return \"Octal literals are not allowed in strict mode.\";\n    case 1124: return \"Digit expected.\";\n    case 1125: return \"Hexadecimal digit expected.\";\n    case 1126: return \"Unexpected end of text.\";\n    case 1127: return \"Invalid character.\";\n    case 1130: return \"'case' or 'default' expected.\";\n    case 1034: return \"'super' must be followed by an argument list or member access.\";\n    case 1038: return \"A 'declare' modifier cannot be used in an already ambient context.\";\n    case 1140: return \"Type argument expected.\";\n    case 1141: return \"String literal expected.\";\n    case 1142: return \"Line break not permitted here.\";\n    case 1146: return \"Declaration expected.\";\n    case 1155: return \"'const' declarations must be initialized.\";\n    case 1161: return \"Unterminated regular expression literal.\";\n    case 1176: return \"Interface declaration cannot have 'implements' clause.\";\n    case 1177: return \"Binary digit expected.\";\n    case 1178: return \"Octal digit expected.\";\n    case 1183: return \"An implementation cannot be declared in ambient contexts.\";\n    case 1190: return \"The variable declaration of a 'for...of' statement cannot have an initializer.\";\n    case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\n    case 1199: return \"Unterminated Unicode escape sequence.\";\n    case 1206: return \"Decorators are not valid here.\";\n    case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\n    case 1245: return \"Method '{0}' cannot have an implementation because it is marked abstract.\";\n    case 1255: return \"A definite assignment assertion '!' is not permitted in this context.\";\n    case 1311: return \"A class may only extend another class.\";\n    case 1317: return \"A parameter property cannot be declared using a rest parameter.\";\n    case 1351: return \"An identifier or keyword cannot immediately follow a numeric literal.\";\n    case 2300: return \"Duplicate identifier '{0}'.\";\n    case 2304: return \"Cannot find name '{0}'.\";\n    case 2305: return \"Module '{0}' has no exported member '{1}'.\";\n    case 2312: return \"An interface can only extend an interface.\";\n    case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\n    case 2315: return \"Type '{0}' is not generic.\";\n    case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\n    case 2325: return \"Property '{0}' is private in type '{1}' but not in type '{2}'.\";\n    case 2329: return \"Index signature is missing in type '{0}'.\";\n    case 2332: return \"'this' cannot be referenced in current location.\";\n    case 2333: return \"'this' cannot be referenced in constructor arguments.\";\n    case 2335: return \"'super' can only be referenced in a derived class.\";\n    case 2336: return \"'super' cannot be referenced in constructor arguments.\";\n    case 2337: return \"Super calls are not permitted outside constructors or in nested functions inside constructors.\";\n    case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\n    case 2341: return \"Property '{0}' is private and only accessible within class '{1}'.\";\n    case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\n    case 2351: return \"This expression is not constructable.\";\n    case 2355: return \"A function whose declared type is not 'void' must return a value.\";\n    case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\n    case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\n    case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\n    case 2376: return \"A 'super' call must be the first statement in the constructor.\";\n    case 2377: return \"Constructors for derived classes must contain a 'super' call.\";\n    case 2379: return \"Getter and setter accessors do not agree in visibility.\";\n    case 2380: return \"'get' and 'set' accessor must have the same type.\";\n    case 2385: return \"Overload signatures must all be public, private or protected.\";\n    case 2390: return \"Constructor implementation is missing.\";\n    case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\n    case 2392: return \"Multiple constructor implementations are not allowed.\";\n    case 2393: return \"Duplicate function implementation.\";\n    case 2394: return \"This overload signature is not compatible with its implementation signature.\";\n    case 2395: return \"Individual declarations in merged declaration '{0}' must be all exported or all local.\";\n    case 2416: return \"Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'.\";\n    case 2422: return \"A class can only implement an interface.\";\n    case 2434: return \"A namespace declaration cannot be located prior to a class or function with which it is merged.\";\n    case 2442: return \"Types have separate declarations of a private property '{0}'.\";\n    case 2444: return \"Property '{0}' is protected in type '{1}' but public in type '{2}'.\";\n    case 2445: return \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\";\n    case 2448: return \"Variable '{0}' used before its declaration.\";\n    case 2451: return \"Cannot redeclare block-scoped variable '{0}'\";\n    case 2453: return \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\";\n    case 2460: return \"Type '{0}' has no property '{1}'.\";\n    case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\n    case 2474: return \"In 'const' enum declarations member initializer must be constant expression.\";\n    case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\n    case 2506: return \"'{0}' is referenced directly or indirectly in its own base expression.\";\n    case 2511: return \"Cannot create an instance of an abstract class.\";\n    case 2515: return \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.\";\n    case 2531: return \"Object is possibly 'null'.\";\n    case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\n    case 2541: return \"The target of an assignment must be a variable or a property access.\";\n    case 2542: return \"Index signature in type '{0}' only permits reading.\";\n    case 2554: return \"Expected {0} arguments, but got {1}.\";\n    case 2555: return \"Expected at least {0} arguments, but got {1}.\";\n    case 2558: return \"Expected {0} type arguments, but got {1}.\";\n    case 2564: return \"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.\";\n    case 2565: return \"Property '{0}' is used before being assigned.\";\n    case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\n    case 2673: return \"Constructor of class '{0}' is private and only accessible within the class declaration.\";\n    case 2674: return \"Constructor of class '{0}' is protected and only accessible within the class declaration.\";\n    case 2685: return \"The 'this' types of each signature are incompatible.\";\n    case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\n    case 2706: return \"Required type parameters may not follow optional type parameters.\";\n    case 2718: return \"Duplicate property '{0}'.\";\n    case 2741: return \"Property '{0}' is missing in type '{1}' but required in type '{2}'.\";\n    case 2757: return \"Type '{0}' has no call signatures.\";\n    case 6054: return \"File '{0}' not found.\";\n    case 6188: return \"Numeric separators are not allowed here.\";\n    case 6189: return \"Multiple consecutive numeric separators are not permitted.\";\n    case 17009: return \"'super' must be called before accessing 'this' in the constructor of a derived class.\";\n    case 17011: return \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\";\n    default: return \"\";\n  }\n}\n","/**\n * @fileoverview Shared diagnostic handling.\n * @license Apache-2.0\n */\n\nimport {\n  Range\n} from \"./tokenizer\";\n\nimport {\n  Source\n} from \"./ast\";\n\nimport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\nimport {\n  isLineBreak,\n  COLOR_CYAN,\n  COLOR_YELLOW,\n  COLOR_RED,\n  COLOR_MAGENTA,\n  COLOR_RESET,\n  isColorsEnabled,\n  setColorsEnabled\n} from \"./util\";\n\nexport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\n/** Indicates the category of a {@link DiagnosticMessage}. */\nexport enum DiagnosticCategory {\n  /** Overly pedantic message. */\n  PEDANTIC,\n  /** Informatory message. */\n  INFO,\n  /** Warning message. */\n  WARNING,\n  /** Error message. */\n  ERROR\n}\n\n/** Returns the string representation of the specified diagnostic category. */\nexport function diagnosticCategoryToString(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.PEDANTIC: return \"PEDANTIC\";\n    case DiagnosticCategory.INFO: return \"INFO\";\n    case DiagnosticCategory.WARNING: return \"WARNING\";\n    case DiagnosticCategory.ERROR: return \"ERROR\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Returns the ANSI escape sequence for the specified category. */\nexport function diagnosticCategoryToColor(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.PEDANTIC: return COLOR_MAGENTA;\n    case DiagnosticCategory.INFO: return COLOR_CYAN;\n    case DiagnosticCategory.WARNING: return COLOR_YELLOW;\n    case DiagnosticCategory.ERROR: return COLOR_RED;\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Represents a diagnostic message. */\nexport class DiagnosticMessage {\n\n  /** Message code. */\n  code: i32;\n  /** Message category. */\n  category: DiagnosticCategory;\n  /** Message text. */\n  message: string;\n  /** Respective source range, if any. */\n  range: Range | null = null;\n  /** Related range, if any. */\n  relatedRange: Range | null = null; // TODO: Make this a related message for chains?\n\n  /** Constructs a new diagnostic message. */\n  private constructor(code: i32, category: DiagnosticCategory, message: string) {\n    this.code = code;\n    this.category = category;\n    this.message = message;\n  }\n\n  /** Creates a new diagnostic message of the specified category. */\n  static create(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): DiagnosticMessage {\n    var message = diagnosticCodeToString(code);\n    if (arg0 !== null) message = message.replace(\"{0}\", arg0);\n    if (arg1 !== null) message = message.replace(\"{1}\", arg1);\n    if (arg2 !== null) message = message.replace(\"{2}\", arg2);\n    return new DiagnosticMessage(code, category, message);\n  }\n\n  /** Tests if this message equals the specified. */\n  equals(other: DiagnosticMessage): bool {\n    if (this.code != other.code) return false;\n    var thisRange = this.range;\n    var otherRange = other.range;\n    if (thisRange) {\n      if (!otherRange || !thisRange.equals(otherRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    var thisRelatedRange = this.relatedRange;\n    var otherRelatedRange = other.relatedRange;\n    if (thisRelatedRange) {\n      if (!otherRelatedRange || !thisRelatedRange.equals(otherRelatedRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    return this.message == other.message;\n  }\n\n  /** Adds a source range to this message. */\n  withRange(range: Range): this {\n    this.range = range;\n    return this;\n  }\n\n  /** Adds a related source range to this message. */\n  withRelatedRange(range: Range): this {\n    this.relatedRange = range;\n    return this;\n  }\n\n  /** Converts this message to a string. */\n  toString(): string {\n    var range = this.range;\n    if (range) {\n      let source = range.source;\n      return (\n        diagnosticCategoryToString(this.category) +\n        \" \" +\n        this.code.toString() +\n        \": \\\"\" +\n        this.message +\n        \"\\\" in \" +\n        source.normalizedPath +\n        \"(\" +\n        source.lineAt(range.start).toString() +\n        \",\" +\n        source.columnAt().toString() +\n        \"+\" +\n        (range.end - range.start).toString() +\n        \")\"\n      );\n    }\n    return (\n      diagnosticCategoryToString(this.category) +\n      \" \" +\n      this.code.toString() +\n      \": \" +\n      this.message\n    );\n  }\n}\n\n/** Formats a diagnostic message, optionally with terminal colors and source context. */\nexport function formatDiagnosticMessage(\n  message: DiagnosticMessage,\n  useColors: bool = false,\n  showContext: bool = false\n): string {\n  var wasColorsEnabled = setColorsEnabled(useColors);\n\n  // general information\n  var sb: string[] = [];\n  if (isColorsEnabled()) sb.push(diagnosticCategoryToColor(message.category));\n  sb.push(diagnosticCategoryToString(message.category));\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  sb.push(message.code < 1000 ? \" AS\" : \" TS\");\n  sb.push(message.code.toString());\n  sb.push(\": \");\n  sb.push(message.message);\n\n  // include range information if available\n  var range = message.range;\n  if (range) {\n    let source = range.source;\n\n    // include context information if requested\n    if (showContext) {\n      sb.push(\"\\n\");\n      sb.push(formatDiagnosticContext(range));\n    }\n    sb.push(\"\\n\");\n    sb.push(\" in \");\n    sb.push(source.normalizedPath);\n    sb.push(\"(\");\n    sb.push(source.lineAt(range.start).toString());\n    sb.push(\",\");\n    sb.push(source.columnAt().toString());\n    sb.push(\")\");\n\n    let relatedRange = message.relatedRange;\n    if (relatedRange) {\n      let relatedSource = relatedRange.source;\n      if (showContext) {\n        sb.push(\"\\n\");\n        sb.push(formatDiagnosticContext(relatedRange));\n      }\n      sb.push(\"\\n\");\n      sb.push(\" in \");\n      sb.push(relatedSource.normalizedPath);\n      sb.push(\"(\");\n      sb.push(relatedSource.lineAt(relatedRange.start).toString());\n      sb.push(\",\");\n      sb.push(relatedSource.columnAt().toString());\n      sb.push(\")\");\n    }\n  }\n  setColorsEnabled(wasColorsEnabled);\n  return sb.join(\"\");\n}\n\n/** Formats the diagnostic context for the specified range, optionally with terminal colors. */\nfunction formatDiagnosticContext(range: Range): string {\n  var text = range.source.text;\n  var len = text.length;\n  var start = range.start;\n  var end = range.end;\n  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) start--;\n  while (end < len && !isLineBreak(text.charCodeAt(end))) end++;\n  var sb: string[] = [\n    \"\\n \",\n    text.substring(start, end),\n    \"\\n \"\n  ];\n  while (start < range.start) {\n    sb.push(\" \");\n    start++;\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RED);\n  if (range.start == range.end) {\n    sb.push(\"^\");\n  } else {\n    while (start++ < range.end) {\n      if (isLineBreak(text.charCodeAt(start))) {\n        sb.push(start == range.start + 1 ? \"^\" : \"~\");\n        break;\n      }\n      sb.push(\"~\");\n    }\n  }\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\n  return sb.join(\"\");\n}\n\n/** Base class of all diagnostic emitters. */\nexport abstract class DiagnosticEmitter {\n\n  /** Diagnostic messages emitted so far. */\n  diagnostics: DiagnosticMessage[];\n  /** Diagnostic messages already seen, by range. */\n  private seen: Map<Source,Map<i32,DiagnosticMessage[]>> = new Map();\n\n  /** Initializes this diagnostic emitter. */\n  protected constructor(diagnostics: DiagnosticMessage[] | null = null) {\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n  }\n\n  /** Emits a diagnostic message of the specified category. */\n  emitDiagnostic(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    range: Range | null,\n    relatedRange: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    var message = DiagnosticMessage.create(code, category, arg0, arg1, arg2);\n    if (range) message = message.withRange(range);\n    if (relatedRange) message.relatedRange = relatedRange;\n    // It is possible that the same diagnostic is emitted twice, for example\n    // when compiling generics with different types or when recompiling a loop\n    // because our initial assumptions didn't hold. It is even possible to get\n    // multiple instances of the same range during parsing. Deduplicate these.\n    if (range) {\n      let seen = this.seen;\n      if (seen.has(range.source)) {\n        let seenInSource = assert(seen.get(range.source));\n        if (seenInSource.has(range.start)) {\n          let seenMessagesAtPos = assert(seenInSource.get(range.start));\n          for (let i = 0, k = seenMessagesAtPos.length; i < k; ++i) {\n            if (seenMessagesAtPos[i].equals(message)) return;\n          }\n          seenMessagesAtPos.push(message);\n        } else {\n          seenInSource.set(range.start, [ message ]);\n        }\n      } else {\n        let seenInSource = new Map<i32,DiagnosticMessage[]>();\n        seenInSource.set(range.start, [ message ]);\n        seen.set(range.source, seenInSource);\n      }\n    }\n    this.diagnostics.push(message);\n    // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\n    // console.log(<string>new Error(\"stack\").stack);\n  }\n\n  /** Emits an overly pedantic diagnostic message. */\n  pedantic(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an overly pedantic diagnostic message with a related range. */\n  pedanticRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message. */\n  info(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message with a related range. */\n  infoRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message. */\n  warning(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message with a related range. */\n  warningRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message. */\n  error(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message with a related range. */\n  errorRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, relatedRange, arg0, arg1, arg2);\n  }\n}\n","/**\n * @fileoverview Abstract Syntax Tree extras.\n *\n * Provides serialization of the AssemblyScript AST back to it source form.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  ArrowKind,\n\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  TypeName,\n  TypeParameterNode,\n\n  Expression,\n  IdentifierExpression,\n  LiteralExpression,\n  LiteralKind,\n  FloatLiteralExpression,\n  IntegerLiteralExpression,\n  StringLiteralExpression,\n  TemplateLiteralExpression,\n  RegexpLiteralExpression,\n  ArrayLiteralExpression,\n  AssertionExpression,\n  AssertionKind,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FunctionExpression,\n  NewExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  UnaryPostfixExpression,\n  UnaryExpression,\n  UnaryPrefixExpression,\n  ClassExpression,\n  ObjectLiteralExpression,\n\n  BlockStatement,\n  BreakStatement,\n  ContinueStatement,\n  DoStatement,\n  EmptyStatement,\n  ExportImportStatement,\n  ExportStatement,\n  ExportDefaultStatement,\n  ExpressionStatement,\n  ForStatement,\n  ForOfStatement,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  WhileStatement,\n\n  DeclarationStatement,\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  DecoratorNode,\n  ParameterNode,\n  ParameterKind,\n  ExportMember,\n  SwitchCase,\n  IndexSignatureNode,\n\n  isTypeOmitted\n} from \"../ast\";\n\nimport {\n  operatorTokenToString\n} from \"../tokenizer\";\n\nimport {\n  CharCode,\n  indent\n} from \"../util\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\n/** An AST builder. */\nexport class ASTBuilder {\n\n  /** Rebuilds the textual source from the specified AST, as far as possible. */\n  static build(node: Node): string {\n    var builder = new ASTBuilder();\n    builder.visitNode(node);\n    return builder.finish();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  visitNode(node: Node): void {\n    switch (node.kind) {\n      case NodeKind.SOURCE: {\n        this.visitSource(<Source>node);\n        break;\n      }\n\n      // types\n\n      case NodeKind.NAMEDTYPE: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      case NodeKind.TYPEPARAMETER: {\n        this.visitTypeParameter(<TypeParameterNode>node);\n        break;\n      }\n\n      // expressions\n\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.SUPER:\n      case NodeKind.THIS:\n      case NodeKind.TRUE:\n      case NodeKind.CONSTRUCTOR:\n      case NodeKind.IDENTIFIER: {\n        this.visitIdentifierExpression(<IdentifierExpression>node);\n        break;\n      }\n      case NodeKind.ASSERTION: {\n        this.visitAssertionExpression(<AssertionExpression>node);\n        break;\n      }\n      case NodeKind.BINARY: {\n        this.visitBinaryExpression(<BinaryExpression>node);\n        break;\n      }\n      case NodeKind.CALL: {\n        this.visitCallExpression(<CallExpression>node);\n        break;\n      }\n      case NodeKind.CLASS: {\n        this.visitClassExpression(<ClassExpression>node);\n        break;\n      }\n      case NodeKind.COMMA: {\n        this.visitCommaExpression(<CommaExpression>node);\n        break;\n      }\n      case NodeKind.ELEMENTACCESS: {\n        this.visitElementAccessExpression(<ElementAccessExpression>node);\n        break;\n      }\n      case NodeKind.FUNCTION: {\n        this.visitFunctionExpression(<FunctionExpression>node);\n        break;\n      }\n      case NodeKind.INSTANCEOF: {\n        this.visitInstanceOfExpression(<InstanceOfExpression>node);\n        break;\n      }\n      case NodeKind.LITERAL: {\n        this.visitLiteralExpression(<LiteralExpression>node);\n        break;\n      }\n      case NodeKind.NEW: {\n        this.visitNewExpression(<NewExpression>node);\n        break;\n      }\n      case NodeKind.PARENTHESIZED: {\n        this.visitParenthesizedExpression(<ParenthesizedExpression>node);\n        break;\n      }\n      case NodeKind.PROPERTYACCESS: {\n        this.visitPropertyAccessExpression(<PropertyAccessExpression>node);\n        break;\n      }\n      case NodeKind.TERNARY: {\n        this.visitTernaryExpression(<TernaryExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n\n      // statements\n\n      case NodeKind.BLOCK: {\n        this.visitBlockStatement(<BlockStatement>node);\n        break;\n      }\n      case NodeKind.BREAK: {\n        this.visitBreakStatement(<BreakStatement>node);\n        break;\n      }\n      case NodeKind.CONTINUE: {\n        this.visitContinueStatement(<ContinueStatement>node);\n        break;\n      }\n      case NodeKind.DO: {\n        this.visitDoStatement(<DoStatement>node);\n        break;\n      }\n      case NodeKind.EMPTY: {\n        this.visitEmptyStatement(<EmptyStatement>node);\n        break;\n      }\n      case NodeKind.EXPORT: {\n        this.visitExportStatement(<ExportStatement>node);\n        break;\n      }\n      case NodeKind.EXPORTDEFAULT: {\n        this.visitExportDefaultStatement(<ExportDefaultStatement>node);\n        break;\n      }\n      case NodeKind.EXPORTIMPORT: {\n        this.visitExportImportStatement(<ExportImportStatement>node);\n        break;\n      }\n      case NodeKind.EXPRESSION: {\n        this.visitExpressionStatement(<ExpressionStatement>node);\n        break;\n      }\n      case NodeKind.FOR: {\n        this.visitForStatement(<ForStatement>node);\n        break;\n      }\n      case NodeKind.FOROF: {\n        this.visitForOfStatement(<ForOfStatement>node);\n        break;\n      }\n      case NodeKind.IF: {\n        this.visitIfStatement(<IfStatement>node);\n        break;\n      }\n      case NodeKind.IMPORT: {\n        this.visitImportStatement(<ImportStatement>node);\n        break;\n      }\n      case NodeKind.RETURN: {\n        this.visitReturnStatement(<ReturnStatement>node);\n        break;\n      }\n      case NodeKind.SWITCH: {\n        this.visitSwitchStatement(<SwitchStatement>node);\n        break;\n      }\n      case NodeKind.THROW: {\n        this.visitThrowStatement(<ThrowStatement>node);\n        break;\n      }\n      case NodeKind.TRY: {\n        this.visitTryStatement(<TryStatement>node);\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        this.visitVariableStatement(<VariableStatement>node);\n        break;\n      }\n      case NodeKind.WHILE: {\n        this.visitWhileStatement(<WhileStatement>node);\n        break;\n      }\n\n      // declaration statements\n\n      case NodeKind.CLASSDECLARATION: {\n        this.visitClassDeclaration(<ClassDeclaration>node);\n        break;\n      }\n      case NodeKind.ENUMDECLARATION: {\n        this.visitEnumDeclaration(<EnumDeclaration>node);\n        break;\n      }\n      case NodeKind.ENUMVALUEDECLARATION: {\n        this.visitEnumValueDeclaration(<EnumValueDeclaration>node);\n        break;\n      }\n      case NodeKind.FIELDDECLARATION: {\n        this.visitFieldDeclaration(<FieldDeclaration>node);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>node);\n        break;\n      }\n      case NodeKind.IMPORTDECLARATION: {\n        this.visitImportDeclaration(<ImportDeclaration>node);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>node);\n        break;\n      }\n      case NodeKind.METHODDECLARATION: {\n        this.visitMethodDeclaration(<MethodDeclaration>node);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>node);\n        break;\n      }\n      case NodeKind.TYPEDECLARATION: {\n        this.visitTypeDeclaration(<TypeDeclaration>node);\n        break;\n      }\n      case NodeKind.VARIABLEDECLARATION: {\n        this.visitVariableDeclaration(<VariableDeclaration>node);\n        break;\n      }\n\n      // other\n\n      case NodeKind.DECORATOR: {\n        this.serializeDecorator(<DecoratorNode>node);\n        break;\n      }\n      case NodeKind.EXPORTMEMBER: {\n        this.visitExportMember(<ExportMember>node);\n        break;\n      }\n      case NodeKind.PARAMETER: {\n        this.serializeParameter(<ParameterNode>node);\n        break;\n      }\n      case NodeKind.SWITCHCASE: {\n        this.visitSwitchCase(<SwitchCase>node);\n        break;\n      }\n      case NodeKind.INDEXSIGNATURE: {\n        this.visitIndexSignature(<IndexSignatureNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitSource(source: Source): void {\n    var statements = source.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      this.visitNodeAndTerminate(statements[i]);\n    }\n  }\n\n  // types\n\n  visitTypeNode(node: TypeNode): void {\n    switch (node.kind) {\n      case NodeKind.NAMEDTYPE: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitTypeName(node: TypeName): void {\n    this.visitIdentifierExpression(node.identifier);\n    var sb = this.sb;\n    var current = node.next;\n    while (current) {\n      sb.push(\".\");\n      this.visitIdentifierExpression(current.identifier);\n      current = current.next;\n    }\n  }\n\n  visitNamedTypeNode(node: NamedTypeNode): void {\n    this.visitTypeName(node.name);\n    var typeArguments = node.typeArguments;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      let sb = this.sb;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">\");\n      }\n      if (node.isNullable) sb.push(\" | null\");\n    }\n  }\n\n  visitFunctionTypeNode(node: FunctionTypeNode): void {\n    var isNullable = node.isNullable;\n    var sb = this.sb;\n    sb.push(isNullable ? \"((\" : \"(\");\n    var explicitThisType = node.explicitThisType;\n    if (explicitThisType) {\n      sb.push(\"this: \");\n      this.visitTypeNode(explicitThisType);\n    }\n    var parameters = node.parameters;\n    var numParameters = parameters.length;\n    if (numParameters) {\n      if (explicitThisType) sb.push(\", \");\n      this.serializeParameter(parameters[0]);\n      for (let i = 1; i < numParameters; ++i) {\n        sb.push(\", \");\n        this.serializeParameter(parameters[i]);\n      }\n    }\n    var returnType = node.returnType;\n    if (returnType) {\n      sb.push(\") => \");\n      this.visitTypeNode(returnType);\n    } else {\n      sb.push(\") => void\");\n    }\n    if (isNullable) sb.push(\") | null\");\n  }\n\n  visitTypeParameter(node: TypeParameterNode): void {\n    this.visitIdentifierExpression(node.name);\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      this.sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    var defaultType = node.defaultType;\n    if (defaultType) {\n      this.sb.push(\"=\");\n      this.visitTypeNode(defaultType);\n    }\n  }\n\n  // expressions\n\n  visitIdentifierExpression(node: IdentifierExpression): void {\n    if (node.isQuoted) this.visitStringLiteral(node.text);\n    else this.sb.push(node.text);\n  }\n\n  visitArrayLiteralExpression(node: ArrayLiteralExpression): void {\n    var sb = this.sb;\n    sb.push(\"[\");\n    var elements = node.elementExpressions;\n    var numElements = elements.length;\n    if (numElements) {\n      let element = elements[0];\n      if (element) this.visitNode(element);\n      for (let i = 1; i < numElements; ++i) {\n        element = elements[i];\n        sb.push(\", \");\n        if (element) this.visitNode(element);\n      }\n    }\n    sb.push(\"]\");\n  }\n\n  visitObjectLiteralExpression(node: ObjectLiteralExpression): void {\n    var sb = this.sb;\n    var names = node.names;\n    var values = node.values;\n    var numElements = names.length;\n    assert(numElements == values.length);\n    if (numElements) {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      this.visitNode(names[0]);\n      sb.push(\": \");\n      this.visitNode(values[0]);\n      for (let i = 1; i < numElements; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        let name = names[i];\n        let value = values[i];\n        if (name === value) {\n          this.visitNode(name);\n        } else {\n          this.visitNode(name);\n          sb.push(\": \");\n          this.visitNode(value);\n        }\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitAssertionExpression(node: AssertionExpression): void {\n    var sb = this.sb;\n    switch (node.assertionKind) {\n      case AssertionKind.PREFIX: {\n        sb.push(\"<\");\n        this.visitTypeNode(assert(node.toType));\n        sb.push(\">\");\n        this.visitNode(node.expression);\n        break;\n      }\n      case AssertionKind.AS: {\n        this.visitNode(node.expression);\n        sb.push(\" as \");\n        this.visitTypeNode(assert(node.toType));\n        break;\n      }\n      case AssertionKind.NONNULL: {\n        this.visitNode(node.expression);\n        sb.push(\"!\");\n        break;\n      }\n      case AssertionKind.CONST: {\n        this.visitNode(node.expression);\n        sb.push(\" as const\");\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitBinaryExpression(node: BinaryExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.left);\n    sb.push(\" \");\n    sb.push(operatorTokenToString(node.operator));\n    sb.push(\" \");\n    this.visitNode(node.right);\n  }\n\n  visitCallExpression(node: CallExpression): void {\n    this.visitNode(node.expression);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  private visitArguments(typeArguments: TypeNode[] | null, args: Expression[]): void {\n    var sb = this.sb;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">(\");\n      }\n    } else {\n      sb.push(\"(\");\n    }\n    var numArgs = args.length;\n    if (numArgs) {\n      this.visitNode(args[0]);\n      for (let i = 1; i < numArgs; ++i) {\n        sb.push(\", \");\n        this.visitNode(args[i]);\n      }\n    }\n    sb.push(\")\");\n  }\n\n  visitClassExpression(node: ClassExpression): void {\n    var declaration = node.declaration;\n    this.visitClassDeclaration(declaration);\n  }\n\n  visitCommaExpression(node: CommaExpression): void {\n    var expressions = node.expressions;\n    var numExpressions = assert(expressions.length);\n    this.visitNode(expressions[0]);\n    var sb = this.sb;\n    for (let i = 1; i < numExpressions; ++i) {\n      sb.push(\",\");\n      this.visitNode(expressions[i]);\n    }\n  }\n\n  visitElementAccessExpression(node: ElementAccessExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.expression);\n    sb.push(\"[\");\n    this.visitNode(node.elementExpression);\n    sb.push(\"]\");\n  }\n\n  visitFunctionExpression(node: FunctionExpression): void {\n    var declaration = node.declaration;\n    if (!declaration.arrowKind) {\n      if (declaration.name.text.length) {\n        this.sb.push(\"function \");\n      } else {\n        this.sb.push(\"function\");\n      }\n    } else {\n      assert(declaration.name.text.length == 0);\n    }\n    this.visitFunctionCommon(declaration);\n  }\n\n  visitLiteralExpression(node: LiteralExpression): void {\n    switch (node.literalKind) {\n      case LiteralKind.FLOAT: {\n        this.visitFloatLiteralExpression(<FloatLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.INTEGER: {\n        this.visitIntegerLiteralExpression(<IntegerLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.STRING: {\n        this.visitStringLiteralExpression(<StringLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.TEMPLATE: {\n        this.visitTemplateLiteralExpression(<TemplateLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.REGEXP: {\n        this.visitRegexpLiteralExpression(<RegexpLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.ARRAY: {\n        this.visitArrayLiteralExpression(<ArrayLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.OBJECT: {\n        this.visitObjectLiteralExpression(<ObjectLiteralExpression>node);\n        break;\n      }\n      default: {\n        assert(false);\n        break;\n      }\n    }\n  }\n\n  visitFloatLiteralExpression(node: FloatLiteralExpression): void {\n    this.sb.push(node.value.toString());\n  }\n\n  visitInstanceOfExpression(node: InstanceOfExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\" instanceof \");\n    this.visitTypeNode(node.isType);\n  }\n\n  visitIntegerLiteralExpression(node: IntegerLiteralExpression): void {\n    this.sb.push(i64_to_string(node.value));\n  }\n\n  visitStringLiteral(str: string): void {\n    var sb = this.sb;\n    sb.push(\"\\\"\");\n    this.visitRawString(str, CharCode.DOUBLEQUOTE);\n    sb.push(\"\\\"\");\n  }\n\n  private visitRawString(str: string, quote: CharCode): void {\n    var sb = this.sb;\n    var off = 0;\n    var i = 0;\n    for (let k = str.length; i < k;) {\n      switch (str.charCodeAt(i)) {\n        case CharCode.NULL: {\n          if (i > off) sb.push(str.substring(off, off = i + 1));\n          sb.push(\"\\\\0\");\n          off = ++i;\n          break;\n        }\n        case CharCode.BACKSPACE: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\b\");\n          break;\n        }\n        case CharCode.TAB: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\t\");\n          break;\n        }\n        case CharCode.LINEFEED: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\n\");\n          break;\n        }\n        case CharCode.VERTICALTAB: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\v\");\n          break;\n        }\n        case CharCode.FORMFEED: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\f\");\n          break;\n        }\n        case CharCode.CARRIAGERETURN: {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\r\");\n          off = ++i;\n          break;\n        }\n        case CharCode.DOUBLEQUOTE: {\n          if (quote == CharCode.DOUBLEQUOTE) {\n            if (i > off) sb.push(str.substring(off, i));\n            sb.push(\"\\\\\\\"\");\n            off = ++i;\n          } else {\n            ++i;\n          }\n          break;\n        }\n        case CharCode.SINGLEQUOTE: {\n          if (quote == CharCode.SINGLEQUOTE) {\n            if (i > off) sb.push(str.substring(off, i));\n            sb.push(\"\\\\'\");\n            off = ++i;\n          } else {\n            ++i;\n          }\n          break;\n        }\n        case CharCode.BACKSLASH: {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\\\\\\");\n          off = ++i;\n          break;\n        }\n        case CharCode.BACKTICK: {\n          if (quote == CharCode.BACKTICK) {\n            if (i > off) sb.push(str.substring(off, i));\n            sb.push(\"\\\\`\");\n            off = ++i;\n          } else {\n            ++i;\n          }\n          break;\n        }\n        default: {\n          ++i;\n          break;\n        }\n      }\n    }\n    if (i > off) sb.push(str.substring(off, i));\n  }\n\n  visitStringLiteralExpression(node: StringLiteralExpression): void {\n    this.visitStringLiteral(node.value);\n  }\n\n  visitTemplateLiteralExpression(node: TemplateLiteralExpression): void {\n    var sb = this.sb;\n    var tag = node.tag;\n    var parts = node.parts;\n    var expressions = node.expressions;\n    if (tag) this.visitNode(tag);\n    sb.push(\"`\");\n    this.visitRawString(parts[0], CharCode.BACKTICK);\n    assert(parts.length == expressions.length + 1);\n    for (let i = 0, k = expressions.length; i < k; ++i) {\n      sb.push(\"${\");\n      this.visitNode(expressions[i]);\n      sb.push(\"}\");\n      this.visitRawString(parts[i + 1], CharCode.BACKTICK);\n    }\n    sb.push(\"`\");\n  }\n\n  visitRegexpLiteralExpression(node: RegexpLiteralExpression): void {\n    var sb = this.sb;\n    sb.push(\"/\");\n    sb.push(node.pattern);\n    sb.push(\"/\");\n    sb.push(node.patternFlags);\n  }\n\n  visitNewExpression(node: NewExpression): void {\n    this.sb.push(\"new \");\n    this.visitTypeName(node.typeName);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  visitParenthesizedExpression(node: ParenthesizedExpression): void {\n    var sb = this.sb;\n    sb.push(\"(\");\n    this.visitNode(node.expression);\n    sb.push(\")\");\n  }\n\n  visitPropertyAccessExpression(node: PropertyAccessExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\".\");\n    this.visitIdentifierExpression(node.property);\n  }\n\n  visitTernaryExpression(node: TernaryExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.condition);\n    sb.push(\" ? \");\n    this.visitNode(node.ifThen);\n    sb.push(\" : \");\n    this.visitNode(node.ifElse);\n  }\n\n  visitUnaryExpression(node: UnaryExpression): void {\n    switch (node.kind) {\n      case NodeKind.UNARYPOSTFIX: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitUnaryPostfixExpression(node: UnaryPostfixExpression): void {\n    this.visitNode(node.operand);\n    this.sb.push(operatorTokenToString(node.operator));\n  }\n\n  visitUnaryPrefixExpression(node: UnaryPrefixExpression): void {\n    this.sb.push(operatorTokenToString(node.operator));\n    this.visitNode(node.operand);\n  }\n\n  // statements\n\n  visitNodeAndTerminate(node: Node): void {\n    this.visitNode(node);\n    var sb = this.sb;\n    if (\n      !sb.length ||                     // leading EmptyStatement\n      node.kind == NodeKind.VARIABLE || // potentially assigns a FunctionExpression\n      node.kind == NodeKind.EXPRESSION  // potentially assigns a FunctionExpression\n    ) {\n      sb.push(\";\\n\");\n    } else {\n      let last = sb[sb.length - 1];\n      let lastCharPos = last.length - 1;\n      if (lastCharPos >= 0 && (\n        last.charCodeAt(lastCharPos) == CharCode.CLOSEBRACE ||\n        last.charCodeAt(lastCharPos) == CharCode.SEMICOLON)\n      ) {\n        sb.push(\"\\n\");\n      } else {\n        sb.push(\";\\n\");\n      }\n    }\n  }\n\n  visitBlockStatement(node: BlockStatement): void {\n    var sb = this.sb;\n    var statements = node.statements;\n    var numStatements = statements.length;\n    if (numStatements) {\n      sb.push(\"{\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitBreakStatement(node: BreakStatement): void {\n    var label = node.label;\n    if (label) {\n      this.sb.push(\"break \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"break\");\n    }\n  }\n\n  visitContinueStatement(node: ContinueStatement): void {\n    var label = node.label;\n    if (label) {\n      this.sb.push(\"continue \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"continue\");\n    }\n  }\n\n  visitClassDeclaration(node: ClassDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.ABSTRACT)) sb.push(\"abstract \");\n    if (node.name.text.length) {\n      sb.push(\"class \");\n      this.visitIdentifierExpression(node.name);\n    } else {\n      sb.push(\"class\");\n    }\n    var typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    var implementsTypes = node.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        sb.push(\" implements \");\n        this.visitTypeNode(implementsTypes[0]);\n        for (let i = 1; i < numImplementsTypes; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(implementsTypes[i]);\n        }\n      }\n    }\n    var indexSignature = node.indexSignature;\n    var members = node.members;\n    var numMembers = members.length;\n    if (indexSignature !== null || numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      if (indexSignature) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(indexSignature);\n      }\n      for (let i = 0, k = members.length; i < k; ++i) {\n        let member = members[i];\n        if (member.kind != NodeKind.FIELDDECLARATION || (<FieldDeclaration>member).parameterIndex < 0) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(member);\n        }\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitDoStatement(node: DoStatement): void {\n    var sb = this.sb;\n    sb.push(\"do \");\n    this.visitNode(node.statement);\n    if (node.statement.kind == NodeKind.BLOCK) {\n      sb.push(\" while (\");\n    } else {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"while (\");\n    }\n    this.visitNode(node.condition);\n    sb.push(\")\");\n  }\n\n  visitEmptyStatement(node: EmptyStatement): void {\n    /* nop */\n  }\n\n  visitEnumDeclaration(node: EnumDeclaration, isDefault: bool = false): void {\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.CONST)) sb.push(\"const \");\n    sb.push(\"enum \");\n    this.visitIdentifierExpression(node.name);\n    var values = node.values;\n    var numValues = values.length;\n    if (numValues) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitEnumValueDeclaration(node.values[0]);\n      for (let i = 1; i < numValues; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitEnumValueDeclaration(node.values[i]);\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitEnumValueDeclaration(node: EnumValueDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    var initializer = node.initializer;\n    if (initializer) {\n      this.sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitExportImportStatement(node: ExportImportStatement): void {\n    var sb = this.sb;\n    sb.push(\"export import \");\n    this.visitIdentifierExpression(node.externalName);\n    sb.push(\" = \");\n    this.visitIdentifierExpression(node.name);\n  }\n\n  visitExportMember(node: ExportMember): void {\n    this.visitIdentifierExpression(node.localName);\n    if (node.exportedName.text != node.localName.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(node.exportedName);\n    }\n  }\n\n  visitExportStatement(node: ExportStatement): void {\n    var sb = this.sb;\n    if (node.isDeclare) {\n      sb.push(\"declare \");\n    }\n    var members = node.members;\n    if (members == null) {\n      sb.push(\"export *\");\n    } else if (members.length > 0) {\n      let numMembers = members.length;\n      sb.push(\"export {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitExportMember(members[0]);\n      for (let i = 1; i < numMembers; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitExportMember(members[i]);\n      }\n      --this.indentLevel;\n      sb.push(\"\\n}\");\n    } else {\n      sb.push(\"export {}\");\n    }\n    var path = node.path;\n    if (path) {\n      sb.push(\" from \");\n      this.visitStringLiteralExpression(path);\n    }\n    sb.push(\";\");\n  }\n\n  visitExportDefaultStatement(node: ExportDefaultStatement): void {\n    var declaration = node.declaration;\n    switch (declaration.kind) {\n      case NodeKind.ENUMDECLARATION: {\n        this.visitEnumDeclaration(<EnumDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.CLASSDECLARATION: {\n        this.visitClassDeclaration(<ClassDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>declaration, true);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitExpressionStatement(node: ExpressionStatement): void {\n    this.visitNode(node.expression);\n  }\n\n  visitFieldDeclaration(node: FieldDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    this.visitIdentifierExpression(node.name);\n    var sb = this.sb;\n    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {\n      sb.push(\"!\");\n    }\n    var type = node.type;\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    var initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitForStatement(node: ForStatement): void {\n    var sb = this.sb;\n    sb.push(\"for (\");\n    var initializer = node.initializer;\n    if (initializer) {\n      this.visitNode(initializer);\n    }\n    var condition = node.condition;\n    if (condition) {\n      sb.push(\"; \");\n      this.visitNode(condition);\n    } else {\n      sb.push(\";\");\n    }\n    var incrementor = node.incrementor;\n    if (incrementor) {\n      sb.push(\"; \");\n      this.visitNode(incrementor);\n    } else {\n      sb.push(\";\");\n    }\n    sb.push(\") \");\n    this.visitNode(node.statement);\n  }\n\n  visitForOfStatement(node: ForOfStatement): void {\n    var sb = this.sb;\n    sb.push(\"for (\");\n    this.visitNode(node.variable);\n    sb.push(\" of \");\n    this.visitNode(node.iterable);\n    sb.push(\") \");\n    this.visitNode(node.statement);\n  }\n\n  visitFunctionDeclaration(node: FunctionDeclaration, isDefault: bool = false): void {\n    var sb = this.sb;\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n      this.serializeAccessModifiers(node);\n    }\n    if (node.name.text.length) {\n      sb.push(\"function \");\n    } else {\n      sb.push(\"function\");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitFunctionCommon(node: FunctionDeclaration): void {\n    var sb = this.sb;\n    this.visitIdentifierExpression(node.name);\n    var signature = node.signature;\n    var typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        this.visitTypeParameter(typeParameters[0]);\n        for (let i = 1; i < numTypeParameters; ++i) {\n          sb.push(\", \");\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    if (node.arrowKind == ArrowKind.ARROW_SINGLE) {\n      let parameters = signature.parameters;\n      assert(parameters.length == 1);\n      assert(!signature.explicitThisType);\n      this.serializeParameter(parameters[0]);\n    } else {\n      sb.push(\"(\");\n      let parameters = signature.parameters;\n      let numParameters = parameters.length;\n      let explicitThisType = signature.explicitThisType;\n      if (explicitThisType) {\n        sb.push(\"this: \");\n        this.visitTypeNode(explicitThisType);\n      }\n      if (numParameters) {\n        if (explicitThisType) sb.push(\", \");\n        this.serializeParameter(parameters[0]);\n        for (let i = 1; i < numParameters; ++i) {\n          sb.push(\", \");\n          this.serializeParameter(parameters[i]);\n        }\n      }\n    }\n    var body = node.body;\n    var returnType = signature.returnType;\n    if (node.arrowKind) {\n      if (body) {\n        if (node.arrowKind == ArrowKind.ARROW_SINGLE) {\n          assert(isTypeOmitted(returnType));\n        } else {\n          if (isTypeOmitted(returnType)) {\n            sb.push(\")\");\n          } else {\n            sb.push(\"): \");\n            this.visitTypeNode(returnType);\n          }\n        }\n        sb.push(\" => \");\n        this.visitNode(body);\n      } else {\n        assert(!isTypeOmitted(returnType));\n        sb.push(\" => \");\n        this.visitTypeNode(returnType);\n      }\n    } else {\n      if (\n        !isTypeOmitted(returnType) &&\n        !node.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)\n      ) {\n        sb.push(\"): \");\n        this.visitTypeNode(returnType);\n      } else {\n        sb.push(\")\");\n      }\n      if (body) {\n        sb.push(\" \");\n        this.visitNode(body);\n      }\n    }\n  }\n\n  visitIfStatement(node: IfStatement): void {\n    var sb = this.sb;\n    sb.push(\"if (\");\n    this.visitNode(node.condition);\n    sb.push(\") \");\n    var ifTrue = node.ifTrue;\n    this.visitNode(ifTrue);\n    if (ifTrue.kind != NodeKind.BLOCK) {\n      sb.push(\";\\n\");\n    }\n    var ifFalse = node.ifFalse;\n    if (ifFalse) {\n      if (ifTrue.kind == NodeKind.BLOCK) {\n        sb.push(\" else \");\n      } else {\n        sb.push(\"else \");\n      }\n      this.visitNode(ifFalse);\n    }\n  }\n\n  visitImportDeclaration(node: ImportDeclaration): void {\n    var externalName = node.foreignName;\n    var name = node.name;\n    this.visitIdentifierExpression(externalName);\n    if (externalName.text != name.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(name);\n    }\n  }\n\n  visitImportStatement(node: ImportStatement): void {\n    var sb = this.sb;\n    sb.push(\"import \");\n    var declarations = node.declarations;\n    var namespaceName = node.namespaceName;\n    if (declarations) {\n      let numDeclarations = declarations.length;\n      if (numDeclarations) {\n        sb.push(\"{\\n\");\n        let indentLevel = ++this.indentLevel;\n        indent(sb, indentLevel);\n        this.visitImportDeclaration(declarations[0]);\n        for (let i = 1; i < numDeclarations; ++i) {\n          sb.push(\",\\n\");\n          indent(sb, indentLevel);\n          this.visitImportDeclaration(declarations[i]);\n        }\n        --this.indentLevel;\n        sb.push(\"\\n} from \");\n      } else {\n        sb.push(\"{} from \");\n      }\n    } else if (namespaceName) {\n      sb.push(\"* as \");\n      this.visitIdentifierExpression(namespaceName);\n      sb.push(\" from \");\n    }\n    this.visitStringLiteralExpression(node.path);\n  }\n\n  visitIndexSignature(node: IndexSignatureNode): void {\n    var sb = this.sb;\n    sb.push(\"[key: \");\n    this.visitTypeNode(node.keyType);\n    sb.push(\"]: \");\n    this.visitTypeNode(node.valueType);\n  }\n\n  visitInterfaceDeclaration(node: InterfaceDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"interface \");\n    this.visitIdentifierExpression(node.name);\n    var typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    // must not have implementsTypes\n    sb.push(\" {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var members = node.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(members[i]);\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitMethodDeclaration(node: MethodDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    if (node.is(CommonFlags.GET)) {\n      this.sb.push(\"get \");\n    } else if (node.is(CommonFlags.SET)) {\n      this.sb.push(\"set \");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitNamespaceDeclaration(node: NamespaceDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"namespace \");\n    this.visitIdentifierExpression(node.name);\n    var members = node.members;\n    var numMembers = members.length;\n    if (numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0, k = members.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(members[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitReturnStatement(node: ReturnStatement): void {\n    var value = node.value;\n    if (value) {\n      this.sb.push(\"return \");\n      this.visitNode(value);\n    } else {\n      this.sb.push(\"return\");\n    }\n  }\n\n  visitSwitchCase(node: SwitchCase): void {\n    var sb = this.sb;\n    var label = node.label;\n    if (label) {\n      sb.push(\"case \");\n      this.visitNode(label);\n      sb.push(\":\\n\");\n    } else {\n      sb.push(\"default:\\n\");\n    }\n    var statements = node.statements;\n    var numStatements = statements.length;\n    if (numStatements) {\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[0]);\n      for (let i = 1; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      --this.indentLevel;\n    }\n  }\n\n  visitSwitchStatement(node: SwitchStatement): void {\n    var sb = this.sb;\n    sb.push(\"switch (\");\n    this.visitNode(node.condition);\n    sb.push(\") {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var cases = node.cases;\n    for (let i = 0, k = cases.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitSwitchCase(cases[i]);\n      sb.push(\"\\n\");\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitThrowStatement(node: ThrowStatement): void {\n    this.sb.push(\"throw \");\n    this.visitNode(node.value);\n  }\n\n  visitTryStatement(node: TryStatement): void {\n    var sb = this.sb;\n    sb.push(\"try {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var statements = node.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[i]);\n    }\n    var catchVariable = node.catchVariable;\n    if (catchVariable) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} catch (\");\n      this.visitIdentifierExpression(catchVariable);\n      sb.push(\") {\\n\");\n      let catchStatements = node.catchStatements;\n      if (catchStatements) {\n        for (let i = 0, k = catchStatements.length; i < k; ++i) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(catchStatements[i]);\n        }\n      }\n    }\n    var finallyStatements = node.finallyStatements;\n    if (finallyStatements) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} finally {\\n\");\n      for (let i = 0, k = finallyStatements.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(finallyStatements[i]);\n      }\n    }\n    indent(sb, indentLevel - 1);\n    sb.push(\"}\");\n  }\n\n  visitTypeDeclaration(node: TypeDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    this.serializeExternalModifiers(node);\n    sb.push(\"type \");\n    this.visitIdentifierExpression(node.name);\n    var typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        for (let i = 0; i < numTypeParameters; ++i) {\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    sb.push(\" = \");\n    this.visitTypeNode(node.type);\n  }\n\n  visitVariableDeclaration(node: VariableDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    var type = node.type;\n    var sb = this.sb;\n    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {\n      sb.push(\"!\");\n    }\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    var initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitVariableStatement(node: VariableStatement): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    var declarations = node.declarations;\n    var numDeclarations = assert(declarations.length);\n    var firstDeclaration = declarations[0];\n    this.serializeExternalModifiers(firstDeclaration);\n    sb.push(firstDeclaration.is(CommonFlags.CONST) ? \"const \" : firstDeclaration.is(CommonFlags.LET) ? \"let \" : \"var \");\n    this.visitVariableDeclaration(node.declarations[0]);\n    for (let i = 1; i < numDeclarations; ++i) {\n      sb.push(\", \");\n      this.visitVariableDeclaration(node.declarations[i]);\n    }\n  }\n\n  visitWhileStatement(node: WhileStatement): void {\n    var sb = this.sb;\n    sb.push(\"while (\");\n    this.visitNode(node.condition);\n    var statement = node.statement;\n    if (statement.kind == NodeKind.EMPTY) {\n      sb.push(\")\");\n    } else {\n      sb.push(\") \");\n      this.visitNode(node.statement);\n    }\n  }\n\n  // other\n\n  serializeDecorator(node: DecoratorNode): void {\n    var sb = this.sb;\n    sb.push(\"@\");\n    this.visitNode(node.name);\n    var args = node.args;\n    if (args) {\n      sb.push(\"(\");\n      let numArgs = args.length;\n      if (numArgs) {\n        this.visitNode(args[0]);\n        for (let i = 1; i < numArgs; ++i) {\n          sb.push(\", \");\n          this.visitNode(args[i]);\n        }\n      }\n      sb.push(\")\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, this.indentLevel);\n  }\n\n  serializeParameter(node: ParameterNode): void {\n    var sb = this.sb;\n    var kind = node.parameterKind;\n    var implicitFieldDeclaration = node.implicitFieldDeclaration;\n    if (implicitFieldDeclaration) {\n      this.serializeAccessModifiers(implicitFieldDeclaration);\n    }\n    if (kind == ParameterKind.REST) {\n      sb.push(\"...\");\n    }\n    this.visitIdentifierExpression(node.name);\n    var type = node.type;\n    var initializer = node.initializer;\n    if (type) {\n      if (kind == ParameterKind.OPTIONAL && !initializer) sb.push(\"?\");\n      if (!isTypeOmitted(type)) {\n        sb.push(\": \");\n        this.visitTypeNode(type);\n      }\n    }\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  serializeExternalModifiers(node: DeclarationStatement): void {\n    var sb = this.sb;\n    if (node.is(CommonFlags.EXPORT)) {\n      sb.push(\"export \");\n    } else if (node.is(CommonFlags.IMPORT)) {\n      sb.push(\"import \");\n    } else if (node.is(CommonFlags.DECLARE)) {\n      sb.push(\"declare \");\n    }\n  }\n\n  serializeAccessModifiers(node: DeclarationStatement): void {\n    var sb = this.sb;\n    if (node.is(CommonFlags.DECLARE)) {\n      sb.push(\"declare \");\n    }\n    if (node.is(CommonFlags.PUBLIC)) {\n      sb.push(\"public \");\n    } else if (node.is(CommonFlags.PRIVATE)) {\n      sb.push(\"private \");\n    } else if (node.is(CommonFlags.PROTECTED)) {\n      sb.push(\"protected \");\n    }\n    if (node.is(CommonFlags.STATIC)) {\n      sb.push(\"static \");\n    } else if (node.is(CommonFlags.ABSTRACT)) {\n      sb.push(\"abstract \");\n    }\n    if (node.is(CommonFlags.READONLY)) {\n      sb.push(\"readonly \");\n    }\n  }\n\n  finish(): string {\n    var ret = this.sb.join(\"\");\n    this.sb = [];\n    return ret;\n  }\n}\n","/**\n * @fileoverview A concurrent code flow analyzer.\n *\n * Flows keep track of compilation state and can be queried for various\n * conditions, like whether the current branch always terminates, whether\n * a local is known to be non-null or whether an expression has possibly\n * overflown its value range.\n *\n * To accomplish this, compilation of each function begins with a clean\n * flow populated with initial local states etc. While compilation\n * progresses, statements and expressions update flow state while control\n * constructs fork, potentially add scoped locals and later merge these\n * forked branches as necessary.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\n\nimport {\n  Local,\n  Function,\n  Element,\n  ElementKind,\n  Field,\n  Class,\n  TypedElement\n} from \"./program\";\n\nimport {\n  TypeRef,\n  ExpressionId,\n  ExpressionRef,\n  BinaryOp,\n  UnaryOp,\n\n  getExpressionId,\n  getLocalGetIndex,\n  isLocalTee,\n  getLocalSetValue,\n  getGlobalGetName,\n  getBinaryOp,\n  getBinaryLeft,\n  getConstValueI32,\n  getBinaryRight,\n  getUnaryOp,\n  getExpressionType,\n  getConstValueI64Low,\n  getConstValueF32,\n  getConstValueF64,\n  getLoadBytes,\n  isLoadSigned,\n  getBlockName,\n  getBlockChildCount,\n  getBlockChildAt,\n  getIfTrue,\n  getIfFalse,\n  getSelectThen,\n  getSelectElse,\n  getCallTarget,\n  getLocalSetIndex,\n  getIfCondition,\n  getConstValueI64High,\n  getUnaryValue\n} from \"./module\";\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Node\n} from \"./ast\";\n\nimport {\n  uniqueMap\n} from \"./util\";\n\n/** Control flow flags indicating specific conditions. */\nexport const enum FlowFlags {\n  /** No specific conditions. */\n  NONE = 0,\n\n  // categorical\n\n  /** This flow always returns. */\n  RETURNS = 1 << 0,\n  /** This flow always returns a wrapped value. */\n  RETURNS_WRAPPED = 1 << 1,\n  /** This flow always returns a non-null value. */\n  RETURNS_NONNULL = 1 << 2,\n  /** This flow always throws. */\n  THROWS = 1 << 3,\n  /** This flow always breaks. */\n  BREAKS = 1 << 4,\n  /** This flow always continues. */\n  CONTINUES = 1 << 5,\n  /** This flow always accesses `this`. Constructors only. */\n  ACCESSES_THIS = 1 << 6,\n  /** This flow always calls `super`. Constructors only. */\n  CALLS_SUPER = 1 << 7,\n  /** This flow always terminates (returns, throws or continues). */\n  TERMINATES = 1 << 8, // Note that this doesn't cover BREAKS, which is separate\n\n  // conditional\n\n  /** This flow conditionally returns in a child flow. */\n  CONDITIONALLY_RETURNS = 1 << 9,\n  /** This flow conditionally throws in a child flow. */\n  CONDITIONALLY_THROWS = 1 << 10,\n  /** This flow conditionally breaks in a child flow. */\n  CONDITIONALLY_BREAKS = 1 << 11,\n  /** This flow conditionally continues in a child flow. */\n  CONDITIONALLY_CONTINUES = 1 << 12,\n  /** This flow conditionally accesses `this` in a child flow. Constructors only. */\n  CONDITIONALLY_ACCESSES_THIS = 1 << 13,\n  /** This flow may return a non-this value. Constructors only. */\n  MAY_RETURN_NONTHIS = 1 << 14,\n\n  // other\n\n  /** This is a flow with explicitly disabled bounds checking. */\n  UNCHECKED_CONTEXT = 1 << 15,\n  /** This is a flow compiling a constructor parameter. */\n  CTORPARAM_CONTEXT = 1 << 16,\n\n  // masks\n\n  /** Any categorical flag. */\n  ANY_CATEGORICAL = FlowFlags.RETURNS\n                  | FlowFlags.RETURNS_WRAPPED\n                  | FlowFlags.RETURNS_NONNULL\n                  | FlowFlags.THROWS\n                  | FlowFlags.BREAKS\n                  | FlowFlags.CONTINUES\n                  | FlowFlags.ACCESSES_THIS\n                  | FlowFlags.CALLS_SUPER\n                  | FlowFlags.TERMINATES,\n\n  /** Any conditional flag. */\n  ANY_CONDITIONAL = FlowFlags.CONDITIONALLY_RETURNS\n                  | FlowFlags.CONDITIONALLY_THROWS\n                  | FlowFlags.CONDITIONALLY_BREAKS\n                  | FlowFlags.CONDITIONALLY_CONTINUES\n                  | FlowFlags.CONDITIONALLY_ACCESSES_THIS\n}\n\n/** Flags indicating the current state of a local. */\nexport enum LocalFlags {\n  /** No specific conditions. */\n  NONE = 0,\n\n  /** Local is constant. */\n  CONSTANT = 1 << 0,\n  /** Local is properly wrapped. Relevant for small integers. */\n  WRAPPED = 1 << 1,\n  /** Local is non-null. */\n  NONNULL = 1 << 2,\n  /** Local is initialized. */\n  INITIALIZED = 1 << 3\n}\n\n/** Flags indicating the current state of a field. */\nexport enum FieldFlags {\n  NONE = 0,\n  INITIALIZED = 1 << 0\n}\n\n/** Condition kinds. */\nexport const enum ConditionKind {\n  /** Outcome of the condition is unknown */\n  UNKNOWN,\n  /** Condition is always true. */\n  TRUE,\n  /** Condition is always false. */\n  FALSE\n}\n\n/** A control flow evaluator. */\nexport class Flow {\n\n  /** Creates the parent flow of the specified function. */\n  static createParent(parentFunction: Function): Flow {\n    var flow = new Flow(parentFunction);\n    if (parentFunction.is(CommonFlags.CONSTRUCTOR)) {\n      flow.initThisFieldFlags();\n    }\n    return flow;\n  }\n\n  /** Creates an inline flow within `parentFunction`. */\n  static createInline(parentFunction: Function, inlineFunction: Function): Flow {\n    var flow = new Flow(parentFunction);\n    flow.inlineFunction = inlineFunction;\n    flow.inlineReturnLabel = inlineFunction.internalName + \"|inlined.\" + (inlineFunction.nextInlineId++).toString();\n    if (inlineFunction.is(CommonFlags.CONSTRUCTOR)) {\n      flow.initThisFieldFlags();\n    }\n    return flow;\n  }\n\n  private constructor(\n    /** Function this flow belongs to. */\n    public parentFunction: Function\n  ) {\n    /* nop */\n  }\n\n  /** Parent flow. */\n  parent: Flow | null = null;\n  /** Outer flow. Only relevant for first-class functions. */\n  outer: Flow | null = null;\n  /** Flow flags indicating specific conditions. */\n  flags: FlowFlags = FlowFlags.NONE;\n  /** The label we break to when encountering a continue statement. */\n  continueLabel: string | null = null;\n  /** The label we break to when encountering a break statement. */\n  breakLabel: string | null = null;\n  /** Scoped local variables. */\n  scopedLocals: Map<string,Local> | null = null;\n  /** Local flags. */\n  localFlags: LocalFlags[] = [];\n  /** Field flags on `this`. Constructors only. */\n  thisFieldFlags: Map<Field,FieldFlags> | null = null;\n  /** Function being inlined, when inlining. */\n  inlineFunction: Function | null = null;\n  /** The label we break to when encountering a return statement, when inlining. */\n  inlineReturnLabel: string | null = null;\n\n  /** Tests if this is an inline flow. */\n  get isInline(): bool {\n    return this.inlineFunction !== null;\n  }\n\n  /** Gets the actual function being compiled, The inlined function when inlining, otherwise the parent function. */\n  get actualFunction(): Function {\n    var inlineFunction = this.inlineFunction;\n    if (inlineFunction) return inlineFunction;\n    return this.parentFunction;\n  }\n\n  /** Gets the current return type. */\n  get returnType(): Type {\n    return this.actualFunction.signature.returnType;\n  }\n\n  /** Gets the current contextual type arguments. */\n  get contextualTypeArguments(): Map<string,Type> | null {\n    return this.actualFunction.contextualTypeArguments;\n  }\n\n  /** Tests if this flow has the specified flag or flags. */\n  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this flow has one of the specified flags. */\n  isAny(flag: FlowFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets the specified flag or flags. */\n  set(flag: FlowFlags): void { this.flags |= flag; }\n  /** Unsets the specified flag or flags. */\n  unset(flag: FlowFlags): void { this.flags &= ~flag; }\n\n  deriveConditionalFlags(): FlowFlags {\n    let condiFlags = this.flags & FlowFlags.ANY_CONDITIONAL;\n    if (this.is(FlowFlags.RETURNS)) {\n      condiFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n    }\n    if (this.is(FlowFlags.THROWS)) {\n      condiFlags |= FlowFlags.CONDITIONALLY_THROWS;\n    }\n    if (this.is(FlowFlags.BREAKS)) {\n      condiFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n    }\n    if (this.is(FlowFlags.CONTINUES)) {\n      condiFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n    }\n    if (this.is(FlowFlags.ACCESSES_THIS)) {\n      condiFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    }\n    return condiFlags;\n  }\n\n  /** Forks this flow to a child flow. */\n  fork(resetBreakContext: bool = false): Flow {\n    var branch = new Flow(this.parentFunction);\n    branch.parent = this;\n    branch.outer = this.outer;\n    if (resetBreakContext) {\n      branch.flags = this.flags & ~(\n        FlowFlags.BREAKS |\n        FlowFlags.CONDITIONALLY_BREAKS |\n        FlowFlags.CONTINUES |\n        FlowFlags.CONDITIONALLY_CONTINUES\n      );\n    } else {\n      branch.flags = this.flags;\n      branch.continueLabel = this.continueLabel;\n      branch.breakLabel = this.breakLabel;\n    }\n    branch.localFlags = this.localFlags.slice();\n    if (this.actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n      let thisFieldFlags = assert(this.thisFieldFlags);\n      branch.thisFieldFlags = uniqueMap<Field,FieldFlags>(thisFieldFlags);\n    } else {\n      assert(!this.thisFieldFlags);\n    }\n    branch.inlineFunction = this.inlineFunction;\n    branch.inlineReturnLabel = this.inlineReturnLabel;\n    return branch;\n  }\n\n  /** Gets a free temporary local of the specified type. */\n  getTempLocal(type: Type, except: Set<i32> | null = null): Local {\n    var parentFunction = this.parentFunction;\n    var temps: Local[] | null;\n    switch (<u32>type.toRef()) {\n      case <u32>TypeRef.I32: { temps = parentFunction.tempI32s; break; }\n      case <u32>TypeRef.I64: { temps = parentFunction.tempI64s; break; }\n      case <u32>TypeRef.F32: { temps = parentFunction.tempF32s; break; }\n      case <u32>TypeRef.F64: { temps = parentFunction.tempF64s; break; }\n      case <u32>TypeRef.V128: { temps = parentFunction.tempV128s; break; }\n      case <u32>TypeRef.Funcref: { temps = parentFunction.tempFuncrefs; break; }\n      case <u32>TypeRef.Externref: { temps = parentFunction.tempExternrefs; break; }\n      case <u32>TypeRef.Anyref: { temps = parentFunction.tempAnyrefs; break; }\n      case <u32>TypeRef.Eqref: { temps = parentFunction.tempEqrefs; break; }\n      case <u32>TypeRef.I31ref: { temps = parentFunction.tempI31refs; break; }\n      case <u32>TypeRef.Dataref: { temps = parentFunction.tempDatarefs; break; }\n      default: throw new Error(\"concrete type expected\");\n    }\n    var local: Local;\n    if (except) {\n      if (temps !== null && temps.length > 0) {\n        for (let i = 0, k = temps.length; i < k; ++i) {\n          if (!except.has(temps[i].index)) {\n            local = temps[i];\n            let k = temps.length - 1;\n            while (i < k) unchecked(temps[i] = temps[i++ + 1]);\n            temps.length = k;\n            local.type = type;\n            local.flags = CommonFlags.NONE;\n            this.unsetLocalFlag(local.index, ~0);\n            return local;\n          }\n        }\n      }\n      local = parentFunction.addLocal(type);\n    } else {\n      if (temps !== null && temps.length > 0) {\n        local = assert(temps.pop());\n        local.type = type;\n        local.flags = CommonFlags.NONE;\n      } else {\n        local = parentFunction.addLocal(type);\n      }\n    }\n    this.unsetLocalFlag(local.index, ~0);\n    return local;\n  }\n\n  /** Frees the temporary local for reuse. */\n  freeTempLocal(local: Local): void {\n    if (local.is(CommonFlags.INLINED)) return;\n    assert(local.index >= 0);\n    var parentFunction = this.parentFunction;\n    var temps: Local[];\n    assert(local.type != null); // internal error\n    local.resetTemporaryName();\n    switch (<u32>local.type.toRef()) {\n      case <u32>TypeRef.I32: {\n        let tempI32s = parentFunction.tempI32s;\n        if (tempI32s) temps = tempI32s;\n        else parentFunction.tempI32s = temps = [];\n        break;\n      }\n      case <u32>TypeRef.I64: {\n        let tempI64s = parentFunction.tempI64s;\n        if (tempI64s) temps = tempI64s;\n        else parentFunction.tempI64s = temps = [];\n        break;\n      }\n      case <u32>TypeRef.F32: {\n        let tempF32s = parentFunction.tempF32s;\n        if (tempF32s) temps = tempF32s;\n        else parentFunction.tempF32s = temps = [];\n        break;\n      }\n      case <u32>TypeRef.F64: {\n        let tempF64s = parentFunction.tempF64s;\n        if (tempF64s) temps = tempF64s;\n        else parentFunction.tempF64s = temps = [];\n        break;\n      }\n      case <u32>TypeRef.V128: {\n        let tempV128s = parentFunction.tempV128s;\n        if (tempV128s) temps = tempV128s;\n        else parentFunction.tempV128s = temps = [];\n        break;\n      }\n      case <u32>TypeRef.Funcref: {\n        let tempFuncrefs = parentFunction.tempFuncrefs;\n        if (tempFuncrefs) temps = tempFuncrefs;\n        else parentFunction.tempFuncrefs = temps = [];\n        break;\n      }\n      case <u32>TypeRef.Externref: {\n        let tempExternrefs = parentFunction.tempExternrefs;\n        if (tempExternrefs) temps = tempExternrefs;\n        else parentFunction.tempExternrefs = temps = [];\n        break;\n      }\n      case <u32>TypeRef.Anyref: {\n        let tempAnyrefs = parentFunction.tempAnyrefs;\n        if (tempAnyrefs) temps = tempAnyrefs;\n        else parentFunction.tempAnyrefs = temps = [];\n        break;\n      }\n      case <u32>TypeRef.Eqref: {\n        let tempEqrefs = parentFunction.tempEqrefs;\n        if (tempEqrefs) temps = tempEqrefs;\n        else parentFunction.tempEqrefs = temps = [];\n        break;\n      }\n      case <u32>TypeRef.I31ref: {\n        let tempI31refs = parentFunction.tempI31refs;\n        if (tempI31refs) temps = tempI31refs;\n        else parentFunction.tempI31refs = temps = [];\n        break;\n      }\n      case <u32>TypeRef.Dataref: {\n        let tempDatarefs = parentFunction.tempDatarefs;\n        if (tempDatarefs) temps = tempDatarefs;\n        else parentFunction.tempDatarefs = temps = [];\n        break;\n      }\n      default: throw new Error(\"concrete type expected\");\n    }\n    assert(local.index >= 0);\n    temps.push(local);\n  }\n\n  /** Gets the scoped local of the specified name. */\n  getScopedLocal(name: string): Local | null {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals !== null && scopedLocals.has(name)) return assert(scopedLocals.get(name));\n    return null;\n  }\n\n  /** Adds a new scoped local of the specified name. */\n  addScopedLocal(name: string, type: Type, except: Set<i32> | null = null): Local {\n    var scopedLocal = this.getTempLocal(type, except);\n    scopedLocal.setTemporaryName(name);\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else assert(!scopedLocals.has(name));\n    scopedLocal.set(CommonFlags.SCOPED);\n    scopedLocals.set(name, scopedLocal);\n    return scopedLocal;\n  }\n\n  /** Adds a new scoped dummy local of the specified name. */\n  addScopedDummyLocal(name: string, type: Type, declarationNode: Node): Local {\n    var scopedDummy = new Local(name, -1, type, this.parentFunction);\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else if (scopedLocals.has(name)) {\n      this.parentFunction.program.error(\n        DiagnosticCode.Cannot_redeclare_block_scoped_variable_0,\n        declarationNode.range, name\n      );\n    }\n    scopedDummy.set(CommonFlags.SCOPED);\n    scopedLocals.set(name, scopedDummy);\n    return scopedDummy;\n  }\n\n  /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */\n  addScopedAlias(name: string, type: Type, index: i32, reportNode: Node | null = null): Local {\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) {\n      this.scopedLocals = scopedLocals = new Map();\n    } else if (scopedLocals.has(name)) {\n      let existingLocal = assert(scopedLocals.get(name));\n      if (reportNode) {\n        if (!existingLocal.declaration.range.source.isNative) {\n          this.parentFunction.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range,\n            existingLocal.declaration.name.range,\n            name\n          );\n        } else {\n          this.parentFunction.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            reportNode.range, name\n          );\n        }\n      }\n      return existingLocal;\n    }\n    assert(index < this.parentFunction.localsByIndex.length);\n    var scopedAlias = new Local(name, index, type, this.parentFunction);\n    // not flagged as SCOPED as it must not be free'd when the flow is finalized\n    scopedLocals.set(name, scopedAlias);\n    return scopedAlias;\n  }\n\n  /** Tests if this flow has any scoped locals that must be free'd. */\n  get hasScopedLocals(): bool {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals) {\n      // TODO: for (let local of scopedLocals.values()) {\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n        let local = unchecked(_values[i]);\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Frees a single scoped local by its name. */\n  freeScopedDummyLocal(name: string): void {\n    var scopedLocals = assert(this.scopedLocals);\n    assert(scopedLocals.has(name));\n    let local = assert(scopedLocals.get(name));\n    assert(local.index == -1);\n    scopedLocals.delete(name);\n  }\n\n  /** Frees this flow's scoped variables and returns its parent flow. */\n  freeScopedLocals(): void {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals) {\n      // TODO: for (let local of scopedLocals.values()) {\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n        let local = unchecked(_values[i]);\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\n          this.freeTempLocal(local);\n        }\n      }\n      this.scopedLocals = null;\n    }\n  }\n\n  /** Looks up the local of the specified name in the current scope. */\n  lookupLocal(name: string): Local | null {\n    var current: Flow | null = this;\n    do {\n      let scope = current.scopedLocals;\n      if (scope !== null && scope.has(name)) return assert(scope.get(name));\n      current = current.parent;\n    } while (current);\n    var localsByName = this.parentFunction.localsByName;\n    if (localsByName.has(name)) return assert(localsByName.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to the scope of this flow. */\n  lookup(name: string): Element | null {\n    var element = this.lookupLocal(name);\n    if (element) return element;\n    return this.actualFunction.lookup(name);\n  }\n\n  /** Tests if the local at the specified index has the specified flag or flags. */\n  isLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    var localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) == flag;\n  }\n\n  /** Tests if the local at the specified index has any of the specified flags. */\n  isAnyLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    var localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) != 0;\n  }\n\n  /** Sets the specified flag or flags on the local at the specified index. */\n  setLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    var localFlags = this.localFlags;\n    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags | flag;\n  }\n\n  /** Unsets the specified flag or flags on the local at the specified index. */\n  unsetLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    var localFlags = this.localFlags;\n    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags & ~flag;\n  }\n\n  /** Initializes `this` field flags. */\n  initThisFieldFlags(): void {\n    var actualFunction = this.actualFunction;\n    assert(actualFunction.is(CommonFlags.CONSTRUCTOR));\n    var actualParent = actualFunction.parent;\n    assert(actualParent.kind == ElementKind.CLASS);\n    var actualClass = <Class>actualParent;\n    this.thisFieldFlags = new Map();\n    var members = actualClass.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind == ElementKind.FIELD) {\n          let field = <Field>member;\n          if (\n            // guaranteed by super\n            field.parent != actualClass ||\n            // has field initializer\n            field.initializerNode !== null ||\n            // is initialized as a ctor parameter\n            field.prototype.parameterIndex != -1 ||\n            // is safe to initialize with zero\n            field.type.isAny(TypeFlags.VALUE | TypeFlags.NULLABLE)\n          ) {\n            this.setThisFieldFlag(field, FieldFlags.INITIALIZED);\n          }\n        }\n      }\n    }\n  }\n\n  /** Tests if the specified `this` field has the specified flag or flags. */\n  isThisFieldFlag(field: Field, flag: FieldFlags): bool {\n    var fieldFlags = this.thisFieldFlags;\n    if (fieldFlags != null && fieldFlags.has(field)) {\n      return (changetype<FieldFlags>(fieldFlags.get(field)) & flag) == flag;\n    }\n    return false;\n  }\n\n  /** Sets the specified flag or flags on the given `this` field. */\n  setThisFieldFlag(field: Field, flag: FieldFlags): void {\n    var fieldFlags = this.thisFieldFlags;\n    if (fieldFlags) {\n      assert(this.actualFunction.is(CommonFlags.CONSTRUCTOR));\n      if (fieldFlags.has(field)) {\n        let flags = changetype<FieldFlags>(fieldFlags.get(field));\n        fieldFlags.set(field, flags | flag);\n      } else {\n        fieldFlags.set(field, flag);\n      }\n    } else {\n      assert(!this.actualFunction.is(CommonFlags.CONSTRUCTOR));\n    }\n  }\n\n  /** Pushes a new break label to the stack, for example when entering a loop that one can `break` from. */\n  pushBreakLabel(): string {\n    var parentFunction = this.parentFunction;\n    var id = parentFunction.nextBreakId++;\n    var stack = parentFunction.breakStack;\n    if (!stack) parentFunction.breakStack = [ id ];\n    else stack.push(id);\n    var label = id.toString();\n    parentFunction.breakLabel = label;\n    return label;\n  }\n\n  /** Pops the most recent break label from the stack. */\n  popBreakLabel(): void {\n    var parentFunction = this.parentFunction;\n    var stack = assert(parentFunction.breakStack);\n    var length = assert(stack.length);\n    stack.pop();\n    if (length > 1) {\n      parentFunction.breakLabel = stack[length - 2].toString();\n    } else {\n      parentFunction.breakLabel = null;\n      parentFunction.breakStack = null;\n    }\n  }\n\n  /** Inherits flags of another flow into this one, i.e. a finished inner block. */\n  inherit(other: Flow): void {\n    assert(other.parentFunction == this.parentFunction);\n    assert(other.parent == this); // currently the case, but might change\n    var otherFlags = other.flags;\n\n    // respective inner flags are irrelevant if contexts differ\n    if (this.breakLabel != other.breakLabel) {\n      if (otherFlags & (FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        otherFlags &= ~FlowFlags.TERMINATES;\n      }\n      otherFlags &= ~(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS);\n    }\n    if (this.continueLabel != other.continueLabel) {\n      otherFlags &= ~(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES);\n    }\n\n    this.flags = this.flags | otherFlags; // what happens before is still true\n    this.localFlags = other.localFlags;\n    this.thisFieldFlags = other.thisFieldFlags;\n  }\n\n  /** Inherits flags of a conditional branch joining again with this one, i.e. then without else. */\n  inheritBranch(other: Flow, conditionKind: ConditionKind = ConditionKind.UNKNOWN): void {\n    assert(other.parentFunction == this.parentFunction);\n    switch (conditionKind) {\n      case ConditionKind.TRUE: this.inherit(other); // always executes\n      case ConditionKind.FALSE: return;             // never executes\n    }\n\n    // Note that flags in `this` flow have already happened. For instance,\n    // a return cannot be undone no matter what'd happen in subsequent branches,\n    // but an allocation, which doesn't terminate, can become conditional. Not\n    // all flags have a corresponding conditional flag that's tracked.\n\n    var thisFlags = this.flags;\n    var otherFlags = other.flags;\n    var newFlags = FlowFlags.NONE;\n\n    if (thisFlags & FlowFlags.RETURNS) { // nothing can change that\n      newFlags |= FlowFlags.RETURNS;\n    } else if (otherFlags & FlowFlags.RETURNS) {\n      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_RETURNS;\n    }\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_WRAPPED;\n    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_NONNULL;\n\n    if (thisFlags & FlowFlags.THROWS) { // nothing can change that\n      newFlags |= FlowFlags.THROWS;\n    } else if (otherFlags & FlowFlags.THROWS) {\n      newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_THROWS;\n    }\n\n    if (thisFlags & FlowFlags.BREAKS) { // nothing can change that\n      newFlags |= FlowFlags.BREAKS;\n    } else if (other.breakLabel == this.breakLabel) {\n      if (otherFlags & FlowFlags.BREAKS) {\n        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_BREAKS;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_BREAKS;\n    }\n\n    if (thisFlags & FlowFlags.CONTINUES) { // nothing can change that\n      newFlags |= FlowFlags.CONTINUES;\n    } else if (other.continueLabel === this.continueLabel) {\n      if (otherFlags & FlowFlags.CONTINUES) {\n        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_CONTINUES;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_CONTINUES;\n    }\n\n    if (thisFlags & FlowFlags.ACCESSES_THIS) { // can become conditional\n      if (otherFlags & FlowFlags.ACCESSES_THIS) {\n        newFlags |= FlowFlags.ACCESSES_THIS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n      }\n    } else if (otherFlags & FlowFlags.ACCESSES_THIS) {\n      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    }\n\n    // may be the case in any\n    newFlags |= (thisFlags | otherFlags) & FlowFlags.MAY_RETURN_NONTHIS;\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.CALLS_SUPER;\n\n    if (thisFlags & FlowFlags.TERMINATES) { // nothing can change that\n      newFlags |= FlowFlags.TERMINATES;\n    }\n\n    this.flags = newFlags | (thisFlags & (FlowFlags.UNCHECKED_CONTEXT | FlowFlags.CTORPARAM_CONTEXT));\n\n    // local flags\n    var thisLocalFlags = this.localFlags;\n    var numThisLocalFlags = thisLocalFlags.length;\n    var otherLocalFlags = other.localFlags;\n    var numOtherLocalFlags = otherLocalFlags.length;\n    var maxLocalFlags = max(numThisLocalFlags, numOtherLocalFlags);\n    for (let i = 0; i < maxLocalFlags; ++i) {\n      let thisFlags = i < numThisLocalFlags ? thisLocalFlags[i] : 0;\n      let otherFlags = i < numOtherLocalFlags ? otherLocalFlags[i] : 0;\n      thisLocalFlags[i] = thisFlags & otherFlags & (\n        LocalFlags.CONSTANT  |\n        LocalFlags.WRAPPED   |\n        LocalFlags.NONNULL   |\n        LocalFlags.INITIALIZED\n      );\n    }\n\n    // field flags do not matter here since there's only INITIALIZED, which can\n    // only be set if it has been observed prior to entering the branch.\n  }\n\n  /** Inherits mutual flags of two alternate branches becoming this one, i.e. then with else. */\n  inheritMutual(left: Flow, right: Flow): void {\n    assert(left.parentFunction == right.parentFunction);\n    assert(left.parentFunction == this.parentFunction);\n    // This differs from the previous method in that no flags are guaranteed\n    // to happen unless it is the case in both flows.\n\n    var leftFlags = left.flags;\n    var rightFlags = right.flags;\n    var newFlags = FlowFlags.NONE;\n\n    if (leftFlags & FlowFlags.RETURNS) {\n      if (rightFlags & FlowFlags.RETURNS) {\n        newFlags |= FlowFlags.RETURNS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n      }\n    } else if (rightFlags & FlowFlags.RETURNS) {\n      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_RETURNS;\n    }\n\n    if ((leftFlags & FlowFlags.RETURNS_WRAPPED) && (rightFlags & FlowFlags.RETURNS_WRAPPED)) {\n      newFlags |= FlowFlags.RETURNS_WRAPPED;\n    }\n\n    if ((leftFlags & FlowFlags.RETURNS_NONNULL) && (rightFlags & FlowFlags.RETURNS_NONNULL)) {\n      newFlags |= FlowFlags.RETURNS_NONNULL;\n    }\n\n    if (leftFlags & FlowFlags.THROWS) {\n      if (rightFlags & FlowFlags.THROWS) {\n        newFlags |= FlowFlags.THROWS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n      }\n    } else if (rightFlags & FlowFlags.THROWS) {\n      newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_THROWS;\n    }\n\n    if (leftFlags & FlowFlags.BREAKS) {\n      if (rightFlags & FlowFlags.BREAKS) {\n        newFlags |= FlowFlags.BREAKS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n      }\n    } else if (rightFlags & FlowFlags.BREAKS) {\n      newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_BREAKS;\n    }\n\n    if (leftFlags & FlowFlags.CONTINUES) {\n      if (rightFlags & FlowFlags.CONTINUES) {\n        newFlags |= FlowFlags.CONTINUES;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n      }\n    } else if (rightFlags & FlowFlags.CONTINUES) {\n      newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_CONTINUES;\n    }\n\n    if (leftFlags & FlowFlags.ACCESSES_THIS) {\n      if (rightFlags & FlowFlags.ACCESSES_THIS) {\n        newFlags |= FlowFlags.ACCESSES_THIS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n      }\n    } else if (rightFlags & FlowFlags.ACCESSES_THIS) {\n      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    }\n\n    newFlags |= (leftFlags | rightFlags) & FlowFlags.MAY_RETURN_NONTHIS;\n\n    if ((leftFlags & FlowFlags.CALLS_SUPER) && (rightFlags & FlowFlags.CALLS_SUPER)) {\n      newFlags |= FlowFlags.CALLS_SUPER;\n    }\n\n    if ((leftFlags & FlowFlags.TERMINATES) && (rightFlags & FlowFlags.TERMINATES)) {\n      newFlags |= FlowFlags.TERMINATES;\n    }\n\n    this.flags = newFlags | (this.flags & (FlowFlags.UNCHECKED_CONTEXT | FlowFlags.CTORPARAM_CONTEXT));\n\n    // local flags\n    var thisLocalFlags = this.localFlags;\n    if (leftFlags & FlowFlags.TERMINATES) {\n      if (!(rightFlags & FlowFlags.TERMINATES)) {\n        let rightLocalFlags = right.localFlags;\n        for (let i = 0, k = rightLocalFlags.length; i < k; ++i) {\n          thisLocalFlags[i] = rightLocalFlags[i];\n        }\n      }\n    } else if (rightFlags & FlowFlags.TERMINATES) {\n      let leftLocalFlags = left.localFlags;\n      for (let i = 0, k = leftLocalFlags.length; i < k; ++i) {\n        thisLocalFlags[i] = leftLocalFlags[i];\n      }\n    } else {\n      let leftLocalFlags = left.localFlags;\n      let numLeftLocalFlags = leftLocalFlags.length;\n      let rightLocalFlags = right.localFlags;\n      let numRightLocalFlags = rightLocalFlags.length;\n      let maxLocalFlags = max(numLeftLocalFlags, numRightLocalFlags);\n      for (let i = 0; i < maxLocalFlags; ++i) {\n        let leftFlags = i < numLeftLocalFlags ? leftLocalFlags[i] : 0;\n        let rightFlags = i < numRightLocalFlags ? rightLocalFlags[i] : 0;\n        thisLocalFlags[i] = leftFlags & rightFlags & (\n          LocalFlags.CONSTANT  |\n          LocalFlags.WRAPPED   |\n          LocalFlags.NONNULL   |\n          LocalFlags.INITIALIZED\n        );\n      }\n    }\n\n    // field flags (currently only INITIALIZED, so can simplify)\n    var leftFieldFlags = left.thisFieldFlags;\n    if (leftFieldFlags) {\n      let newFieldFlags = new Map<Field,FieldFlags>();\n      let rightFieldFlags = assert(right.thisFieldFlags);\n      for (let _keys = Map_keys(leftFieldFlags), i = 0, k = _keys.length; i < k; ++i) {\n        let key = _keys[i];\n        let leftFlags = changetype<FieldFlags>(leftFieldFlags.get(key));\n        if (\n          (leftFlags & FieldFlags.INITIALIZED) != 0 && rightFieldFlags.has(key) &&\n          (changetype<FieldFlags>(rightFieldFlags.get(key)) & FieldFlags.INITIALIZED)\n        ) {\n          newFieldFlags.set(key, FieldFlags.INITIALIZED);\n        }\n      }\n      this.thisFieldFlags = newFieldFlags;\n    } else {\n      assert(!right.thisFieldFlags);\n    }\n  }\n\n  /** Tests if the specified flows have differing local states. */\n  static hasIncompatibleLocalStates(before: Flow, after: Flow): bool {\n    var numThisLocalFlags = before.localFlags.length;\n    var numOtherLocalFlags = after.localFlags.length;\n    var parentFunction = before.parentFunction;\n    assert(parentFunction === after.parentFunction);\n    var localsByIndex = parentFunction.localsByIndex;\n    assert(localsByIndex === after.parentFunction.localsByIndex);\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      let local = localsByIndex[i];\n      let type = local.type;\n      if (type.isShortIntegerValue) {\n        if (before.isLocalFlag(i, LocalFlags.WRAPPED) && !after.isLocalFlag(i, LocalFlags.WRAPPED)) {\n          return true;\n        }\n      }\n      if (type.isNullableReference) {\n        if (before.isLocalFlag(i, LocalFlags.NONNULL) && !after.isLocalFlag(i, LocalFlags.NONNULL)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Unifies local flags between this and the other flow. */\n  unifyLocalFlags(other: Flow): void {\n    var numThisLocalFlags = this.localFlags.length;\n    var numOtherLocalFlags = other.localFlags.length;\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      if (this.isLocalFlag(i, LocalFlags.WRAPPED) != other.isLocalFlag(i, LocalFlags.WRAPPED)) {\n        this.unsetLocalFlag(i, LocalFlags.WRAPPED); // assume not wrapped\n      }\n      if (this.isLocalFlag(i, LocalFlags.NONNULL) != other.isLocalFlag(i, LocalFlags.NONNULL)) {\n        this.unsetLocalFlag(i, LocalFlags.NONNULL); // assume possibly null\n      }\n    }\n  }\n\n  /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */\n  isNonnull(expr: ExpressionRef, type: Type): bool {\n    if (!type.isNullableReference) return true;\n    // below, only teeLocal/getLocal are relevant because these are the only expressions that\n    // depend on a dynamic nullable state (flag = LocalFlags.NONNULL), while everything else\n    // has already been handled by the nullable type check above.\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);\n      }\n    }\n    return false;\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */\n  inheritNonnullIfTrue(\n    /** Expression being true. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is true-ish -> Q: how did that happen?\n\n    // The iff argument is useful in situations like\n    //\n    //  if (!ref) {\n    //    ref = new Ref();\n    //  }\n    //  // inheritNonnullIfFalse(`!ref`, thenFlow) -> ref != null\n    //\n\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {\n          this.setLocalFlag(local.index, LocalFlags.NONNULL);\n        }\n        this.inheritNonnullIfTrue(getLocalSetValue(expr), iff); // must have been true-ish as well\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {\n          this.setLocalFlag(local.index, LocalFlags.NONNULL);\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifFalse = getIfFalse(expr);\n        if (!ifFalse) break;\n        if (getExpressionId(ifFalse) == ExpressionId.Const) {\n          // Logical AND: (if (condition ifTrue 0))\n          // the only way this had become true is if condition and ifTrue are true\n          if (\n            (getExpressionType(ifFalse) == TypeRef.I32 && getConstValueI32(ifFalse) == 0) ||\n            (getExpressionType(ifFalse) == TypeRef.I64 && getConstValueI64Low(ifFalse) == 0 && getConstValueI64High(ifFalse) == 0)\n          ) {\n            this.inheritNonnullIfTrue(getIfCondition(expr), iff);\n            this.inheritNonnullIfTrue(getIfTrue(expr), iff);\n          }\n        }\n        break;\n      }\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfFalse(getUnaryValue(expr), iff); // !value -> value must have been false\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          case BinaryOp.EqI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 && getConstValueI64High(right) != 0)) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */\n  inheritNonnullIfFalse(\n    /** Expression being false. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is false-ish -> Q: how did that happen?\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfTrue(getUnaryValue(expr), iff); // !value -> value must have been true\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifTrue = getIfTrue(expr);\n        if (getExpressionId(ifTrue) == ExpressionId.Const) {\n          let ifFalse = getIfFalse(expr);\n          if (!ifFalse) break;\n          // Logical OR: (if (condition 1 ifFalse))\n          // the only way this had become false is if condition and ifFalse are false\n          let exprType = getExpressionType(ifTrue);\n          if (\n            (exprType == TypeRef.I32 && getConstValueI32(ifTrue) != 0) ||\n            (exprType == TypeRef.I64 && (getConstValueI64Low(ifTrue) != 0 || getConstValueI64High(ifTrue) != 0))\n          ) {\n            this.inheritNonnullIfFalse(getIfCondition(expr), iff);\n            this.inheritNonnullIfFalse(getIfFalse(expr), iff);\n          }\n\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          // remember: we want to know how the _entire_ expression became FALSE (!)\n          case BinaryOp.EqI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true for this to become false\n            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 || getConstValueI64High(right) != 0)) {\n              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true for this to become false\n            }\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * Tests if an expression can possibly overflow in the context of this flow. Assumes that the\n   * expression might already have overflown and returns `false` only if the operation neglects\n   * any possible combination of garbage bits being present.\n   */\n  canOverflow(expr: ExpressionRef, type: Type): bool {\n    // TODO: the following catches most common and a few uncommon cases, but there are additional\n    // opportunities here, obviously.\n\n    // types other than i8, u8, i16, u16 and bool do not overflow\n    if (!type.isShortIntegerValue) return false;\n\n    var operand: ExpressionRef;\n    switch (getExpressionId(expr)) {\n\n      // overflows if the local isn't wrapped or the conversion does\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !this.isLocalFlag(local.index, LocalFlags.WRAPPED, true)\n            || canConversionOverflow(local.type, type);\n      }\n\n      // overflows if the value does\n      case ExpressionId.LocalSet: { // tee\n        assert(isLocalTee(expr));\n        return this.canOverflow(getLocalSetValue(expr), type);\n      }\n\n      // overflows if the conversion does (globals are wrapped on set)\n      case ExpressionId.GlobalGet: {\n        // TODO: this is inefficient because it has to read a string\n        let global = assert(this.parentFunction.program.elementsByName.get(assert(getGlobalGetName(expr))));\n        assert(global.kind == ElementKind.GLOBAL || global.kind == ElementKind.ENUMVALUE);\n        return canConversionOverflow((<TypedElement>global).type, type);\n      }\n\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64:\n          case BinaryOp.EqF32:\n          case BinaryOp.EqF64:\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64:\n          case BinaryOp.NeF32:\n          case BinaryOp.NeF64:\n          case BinaryOp.LtI32:\n          case BinaryOp.LtU32:\n          case BinaryOp.LtI64:\n          case BinaryOp.LtU64:\n          case BinaryOp.LtF32:\n          case BinaryOp.LtF64:\n          case BinaryOp.LeI32:\n          case BinaryOp.LeU32:\n          case BinaryOp.LeI64:\n          case BinaryOp.LeU64:\n          case BinaryOp.LeF32:\n          case BinaryOp.LeF64:\n          case BinaryOp.GtI32:\n          case BinaryOp.GtU32:\n          case BinaryOp.GtI64:\n          case BinaryOp.GtU64:\n          case BinaryOp.GtF32:\n          case BinaryOp.GtF64:\n          case BinaryOp.GeI32:\n          case BinaryOp.GeU32:\n          case BinaryOp.GeI64:\n          case BinaryOp.GeU64:\n          case BinaryOp.GeF32:\n          case BinaryOp.GeF64: return false;\n\n          // result won't overflow if one side is 0 or if one side is 1 and the other wrapped\n          case BinaryOp.MulI32: {\n            return !(\n              (\n                getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryRight(expr), type)\n                  )\n                )\n              ) || (\n                getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryLeft(expr), type)\n                  )\n                )\n              )\n            );\n          }\n\n          // result won't overflow if one side is a constant less than this type's mask or one side\n          // is wrapped\n          case BinaryOp.AndI32: {\n            // note that computeSmallIntegerMask returns the mask minus the MSB for signed types\n            // because signed value garbage bits must be guaranteed to be equal to the MSB.\n            return !(\n              (\n                (\n                  getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              ) || (\n                (\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              )\n            );\n          }\n\n          // overflows if the shift doesn't clear potential garbage bits\n          case BinaryOp.ShlI32: {\n            let shift = 32 - type.size;\n            return getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const\n                || getConstValueI32(operand) < shift;\n          }\n\n          // overflows if the value does and the shift doesn't clear potential garbage bits\n          case BinaryOp.ShrI32: {\n            let shift = 32 - type.size;\n            return this.canOverflow(getBinaryLeft(expr), type) && (\n              getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const ||\n              getConstValueI32(operand) < shift\n            );\n          }\n\n          // overflows if the shift does not clear potential garbage bits. if an unsigned value is\n          // wrapped, it can't overflow.\n          case BinaryOp.ShrU32: {\n            let shift = 32 - type.size;\n            return type.isSignedIntegerValue\n              ? !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) > shift // must clear MSB\n                )\n              : this.canOverflow(getBinaryLeft(expr), type) &&\n                !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) >= shift // can leave MSB\n                );\n          }\n\n          // overflows if any side does\n          case BinaryOp.DivU32:\n          case BinaryOp.RemI32:\n          case BinaryOp.RemU32: {\n            return this.canOverflow(getBinaryLeft(expr), type)\n                || this.canOverflow(getBinaryRight(expr), type);\n          }\n        }\n        break;\n      }\n\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: return false;\n\n          // overflow if the maximum result (32) cannot be represented in the target type\n          case UnaryOp.ClzI32:\n          case UnaryOp.CtzI32:\n          case UnaryOp.PopcntI32: return type.size < 7;\n\n          // sign extensions overflow if result can have high garbage bits in the target type\n          case UnaryOp.Extend8I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 8);\n          case UnaryOp.Extend8I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 8);\n          case UnaryOp.Extend16I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 16);\n          case UnaryOp.Extend16I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 16);\n          case UnaryOp.Extend32I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 32);\n        }\n        break;\n      }\n\n      // overflows if the value cannot be represented in the target type\n      case ExpressionId.Const: {\n        let value: i32 = 0;\n        switch (<u32>getExpressionType(expr)) {\n          case <u32>TypeRef.I32: { value = getConstValueI32(expr); break; }\n          case <u32>TypeRef.I64: { value = getConstValueI64Low(expr); break; } // discards upper bits\n          case <u32>TypeRef.F32: { value = i32(getConstValueF32(expr)); break; }\n          case <u32>TypeRef.F64: { value = i32(getConstValueF64(expr)); break; }\n          case <u32>TypeRef.V128: return false;\n          default: assert(false);\n        }\n        switch (type.kind) {\n          case TypeKind.I8: return value < <i32>i8.MIN_VALUE || value > <i32>i8.MAX_VALUE;\n          case TypeKind.I16: return value < <i32>i16.MIN_VALUE || value > <i32>i16.MAX_VALUE;\n          case TypeKind.U8: return value < 0 || value > <i32>u8.MAX_VALUE;\n          case TypeKind.U16: return value < 0 || value > <i32>u16.MAX_VALUE;\n          case TypeKind.BOOL: return (value & ~1) != 0;\n        }\n        break;\n      }\n\n      // overflows if the conversion does\n      case ExpressionId.Load: {\n        let fromType: Type;\n        let signed = isLoadSigned(expr);\n        switch (getLoadBytes(expr)) {\n          case 1:  { fromType = signed ? Type.i8  : Type.u8;  break; }\n          case 2:  { fromType = signed ? Type.i16 : Type.u16; break; }\n          default: { fromType = signed ? Type.i32 : Type.u32; break; }\n        }\n        return canConversionOverflow(fromType, type);\n      }\n\n      // overflows if the result does, which is either\n      // - the last expression of the block, by contract, if the block doesn't have a label\n      // - the last expression or the value of an inner br if the block has a label (TODO)\n      case ExpressionId.Block: {\n        if (!getBlockName(expr)) {\n          let size = assert(getBlockChildCount(expr));\n          let last = getBlockChildAt(expr, size - 1);\n          return this.canOverflow(last, type);\n        }\n        break;\n      }\n\n      // overflows if either side does\n      case ExpressionId.If: {\n        return this.canOverflow(getIfTrue(expr), type)\n            || this.canOverflow(assert(getIfFalse(expr)), type);\n      }\n\n      // overflows if either side does\n      case ExpressionId.Select: {\n        return this.canOverflow(getSelectThen(expr), type)\n            || this.canOverflow(getSelectElse(expr), type);\n      }\n\n      // overflows if the call does not return a wrapped value or the conversion does\n      case ExpressionId.Call: {\n        let program = this.parentFunction.program;\n        let instancesByName = program.instancesByName;\n        let instanceName = assert(getCallTarget(expr));\n        if (instancesByName.has(instanceName)) {\n          let instance = assert(instancesByName.get(instanceName));\n          assert(instance.kind == ElementKind.FUNCTION);\n          let functionInstance = <Function>instance;\n          let returnType = functionInstance.signature.returnType;\n          return !functionInstance.flow.is(FlowFlags.RETURNS_WRAPPED)\n              || canConversionOverflow(returnType, type);\n        }\n        return false; // assume no overflow for builtins\n      }\n\n      // doesn't technically overflow\n      case ExpressionId.Unreachable: return false;\n    }\n    return true;\n  }\n\n  toString(): string {\n    var levels = 0;\n    var parent = this.parent;\n    while (parent) {\n      parent = parent.parent;\n      ++levels;\n    }\n    var sb = new Array<string>();\n    if (this.is(FlowFlags.RETURNS)) sb.push(\"RETURNS\");\n    if (this.is(FlowFlags.RETURNS_WRAPPED)) sb.push(\"RETURNS_WRAPPED\");\n    if (this.is(FlowFlags.RETURNS_NONNULL)) sb.push(\"RETURNS_NONNULL\");\n    if (this.is(FlowFlags.THROWS)) sb.push(\"THROWS\");\n    if (this.is(FlowFlags.BREAKS)) sb.push(\"BREAKS\");\n    if (this.is(FlowFlags.CONTINUES)) sb.push(\"CONTINUES\");\n    if (this.is(FlowFlags.ACCESSES_THIS)) sb.push(\"ACCESSES_THIS\");\n    if (this.is(FlowFlags.CALLS_SUPER)) sb.push(\"CALLS_SUPER\");\n    if (this.is(FlowFlags.TERMINATES)) sb.push(\"TERMINATES\");\n    if (this.is(FlowFlags.CONDITIONALLY_RETURNS)) sb.push(\"CONDITIONALLY_RETURNS\");\n    if (this.is(FlowFlags.CONDITIONALLY_THROWS)) sb.push(\"CONDITIONALLY_THROWS\");\n    if (this.is(FlowFlags.CONDITIONALLY_BREAKS)) sb.push(\"CONDITIONALLY_BREAKS\");\n    if (this.is(FlowFlags.CONDITIONALLY_CONTINUES)) sb.push(\"CONDITIONALLY_CONTINUES\");\n    if (this.is(FlowFlags.CONDITIONALLY_ACCESSES_THIS)) sb.push(\"CONDITIONALLY_ACCESSES_THIS\");\n    if (this.is(FlowFlags.MAY_RETURN_NONTHIS)) sb.push(\"MAY_RETURN_NONTHIS\");\n    return \"Flow(\" + this.actualFunction.toString() + \")[\" + levels.toString() + \"] \" + sb.join(\" \");\n  }\n}\n\n/** Tests if a conversion from one type to another can technically overflow. */\nfunction canConversionOverflow(fromType: Type, toType: Type): bool {\n  return toType.isShortIntegerValue && (\n    !fromType.isIntegerValue ||                                    // i.e. float to small int\n    fromType.size > toType.size ||                                 // larger int to small int\n    fromType.isSignedIntegerValue != toType.isSignedIntegerValue   // signedness mismatch\n  );\n}\n\nexport { findUsedLocals } from \"./passes/findusedlocals\";\n","/**\n * @fileoverview JavaScript glue code.\n * @license Apache-2.0\n */\n\nimport \"../../../std/portable/index\";\nimport \"../binaryen\";\nimport \"./float\";\nimport \"./i64\";\nimport \"./collections\";\n","/**\n * @license\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The C-like and re-exported public compiler interface.\n *\n * The intended way to consume the compiler sources is to import this\n * file, which again exports all relevant functions, classes and constants\n * as a flat namespace.\n *\n * Note though that the compiler sources are written in \"portable\n * AssemblyScript\" that can be compiled to both JavaScript with tsc and\n * to WebAssembly with asc, and as such require additional glue code\n * depending on the target.\n *\n * When compiling to JavaScript `glue/js/index.js` must be included.\n * When compiling to WebAssembly `glue/wasm/index.ts` must be included.\n */\n\nimport { Target, Runtime, Feature } from \"./common\";\nimport { Compiler, Options } from \"./compiler\";\nimport { IDLBuilder, TSDBuilder } from \"./definitions\";\nimport { DiagnosticMessage, DiagnosticCategory, formatDiagnosticMessage } from \"./diagnostics\";\nimport { Module } from \"./module\";\nimport { Program } from \"./program\";\n\n// Options\n\n/** Creates a new set of compiler options. */\nexport function newOptions(): Options {\n  return new Options();\n}\n\n/** Sets the `target` option. */\nexport function setTarget(options: Options, target: Target): void {\n  options.target = target;\n}\n\nexport function setRuntime(options: Options, runtime: Runtime): void {\n  options.runtime = runtime;\n}\n\n/** Sets the `noAssert` option. */\nexport function setNoAssert(options: Options, noAssert: bool): void {\n  options.noAssert = noAssert;\n}\n\n/** Sets the `exportMemory` option. */\nexport function setExportMemory(options: Options, exportMemory: bool): void {\n  options.exportMemory = exportMemory;\n}\n\n/** Sets the `importMemory` option. */\nexport function setImportMemory(options: Options, importMemory: bool): void {\n  options.importMemory = importMemory;\n}\n\n/** Sets the `initialMemory` option. */\nexport function setInitialMemory(options: Options, initialMemory: u32): void {\n  options.initialMemory = initialMemory;\n}\n\n/** Sets the `maximumMemory` option. */\nexport function setMaximumMemory(options: Options, maximumMemory: u32): void {\n  options.maximumMemory = maximumMemory;\n}\n\n/** Sets the `sharedMemory` option. */\nexport function setSharedMemory(options: Options, sharedMemory: bool): void {\n  options.sharedMemory = sharedMemory;\n}\n\n/** Sets the `importTable` option. */\nexport function setImportTable(options: Options, importTable: bool): void {\n  options.importTable = importTable;\n}\n\n/** Sets the `exportTable` option. */\nexport function setExportTable(options: Options, exportTable: bool): void {\n  options.exportTable = exportTable;\n}\n\n/** Sets the `sourceMap` option. */\nexport function setSourceMap(options: Options, sourceMap: bool): void {\n  options.sourceMap = sourceMap;\n}\n\n/** Sets the `memoryBase` option. */\nexport function setMemoryBase(options: Options, memoryBase: u32): void {\n  options.memoryBase = memoryBase;\n}\n\n/** Sets the `tableBase` option. */\nexport function setTableBase(options: Options, tableBase: u32): void {\n  options.tableBase = tableBase;\n}\n\n/** Sets a 'globalAliases' value. */\nexport function setGlobalAlias(options: Options, alias: string, name: string): void {\n  var globalAliases = options.globalAliases;\n  if (!globalAliases) options.globalAliases = globalAliases = new Map();\n  globalAliases.set(alias, name);\n}\n\n/** Sets the `explicitStart` option. */\nexport function setExplicitStart(options: Options, explicitStart: bool): void {\n  options.explicitStart = explicitStart;\n}\n\n/** Sets the `noUnsafe` option. */\nexport function setNoUnsafe(options: Options, noUnsafe: bool): void {\n  options.noUnsafe = noUnsafe;\n}\n\n/** Sets the `lowMemoryLimit` option. */\nexport function setLowMemoryLimit(options: Options, lowMemoryLimit: i32): void {\n  options.lowMemoryLimit = lowMemoryLimit;\n}\n\n/** Sets the `exportRuntime` option. */\nexport function setExportRuntime(options: Options, exportRuntime: bool): void {\n  options.exportRuntime = exportRuntime;\n}\n\n/** Default stack size. */\nexport const DEFAULT_STACK_SIZE = 16384;\n\n/** Sets the `stackSize` option. */\nexport function setStackSize(options: Options, stackSize: i32): void {\n  options.stackSize = stackSize;\n}\n\n/** Sets the bundle semantic version. */\nexport function setBundleVersion(\n  options: Options,\n  bundleMajorVersion: i32,\n  bundleMinorVersion: i32,\n  bundlePatchVersion: i32,\n): void {\n  options.bundleMajorVersion = bundleMajorVersion;\n  options.bundleMinorVersion = bundleMinorVersion;\n  options.bundlePatchVersion = bundlePatchVersion;\n}\n\n/** Sign extension operations. */\nexport const FEATURE_SIGN_EXTENSION = Feature.SIGN_EXTENSION;\n/** Mutable global imports and exports. */\nexport const FEATURE_MUTABLE_GLOBALS = Feature.MUTABLE_GLOBALS;\n/** Non-trapping float to int conversion operations. */\nexport const FEATURE_NONTRAPPING_F2I = Feature.NONTRAPPING_F2I;\n/** Bulk memory operations. */\nexport const FEATURE_BULK_MEMORY = Feature.BULK_MEMORY;\n/** SIMD types and operations. */\nexport const FEATURE_SIMD = Feature.SIMD;\n/** Threading and atomic operations. */\nexport const FEATURE_THREADS = Feature.THREADS;\n/** Exception handling operations. */\nexport const FEATURE_EXCEPTION_HANDLING = Feature.EXCEPTION_HANDLING;\n/** Tail call operations. */\nexport const FEATURE_TAIL_CALLS = Feature.TAIL_CALLS;\n/** Reference types. */\nexport const FEATURE_REFERENCE_TYPES = Feature.REFERENCE_TYPES;\n/** Multi value types. */\nexport const FEATURE_MULTI_VALUE = Feature.MULTI_VALUE;\n/** Garbage collection. */\nexport const FEATURE_GC = Feature.GC;\n/** Memory64. */\nexport const FEATURE_MEMORY64 = Feature.MEMORY64;\n\n/** Enables a specific feature. */\nexport function enableFeature(options: Options, feature: Feature): void {\n  options.features |= feature;\n}\n\n/** Disables a specific feature. */\nexport function disableFeature(options: Options, feature: Feature): void {\n  options.features &= ~feature;\n}\n\n/** Gives the compiler a hint at the optimize levels that will be used later on. */\nexport function setOptimizeLevelHints(options: Options, optimizeLevel: i32, shrinkLevel: i32): void {\n  options.optimizeLevelHint = optimizeLevel;\n  options.shrinkLevelHint = shrinkLevel;\n}\n\n/** Sets the `pedantic` option. */\nexport function setPedantic(options: Options, pedantic: bool): void {\n  options.pedantic = pedantic;\n}\n\n// Program\n\n/** Creates a new Program. */\nexport function newProgram(options: Options): Program {\n  return new Program(options);\n}\n\n/** Obtains the next diagnostic message. Returns `null` once complete. */\nexport function nextDiagnostic(program: Program): DiagnosticMessage | null {\n  return program.diagnosticsOffset < program.diagnostics.length\n    ? program.diagnostics[program.diagnosticsOffset++]\n    : null;\n}\n\n/** Obtains the source of the given file. */\nexport function getSource(program: Program, internalPath: string): string | null {\n  return program.getSource(internalPath);\n}\n\n/** Formats a diagnostic message to a string. */\nexport { formatDiagnosticMessage as formatDiagnostic };\n\n/** Tests whether a diagnostic is informatory. */\nexport function isInfo(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.INFO;\n}\n\n/** Tests whether a diagnostic is a warning. */\nexport function isWarning(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.WARNING;\n}\n\n/** Tests whether a diagnostic is an error. */\nexport function isError(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.ERROR;\n}\n\n// Parser\n\n/** Parses a source file. If `parser` has been omitted a new one is created. */\nexport function parse(\n  /** Program reference. */\n  program: Program,\n  /** Source text of the file, or `null` to indicate not found. */\n  text: string | null,\n  /** Normalized path of the file. */\n  path: string,\n  /** Whether this is an entry file. */\n  isEntry: bool = false\n): void {\n  program.parser.parseFile(text, path, isEntry);\n}\n\n/** Obtains the next required file's path. Returns `null` once complete. */\nexport function nextFile(program: Program): string | null {\n  return program.parser.nextFile();\n}\n\n/** Obtains the path of the dependee of a given imported file. */\nexport function getDependee(program: Program, file: string): string | null {\n  return program.parser.getDependee(file);\n}\n\n// Compiler\n\n/** Initializes the program pre-emptively for transform hooks. */\nexport function initializeProgram(program: Program): void {\n  program.initialize();\n}\n\n/** Compiles the parsed sources to a module. */\nexport function compile(program: Program): Module {\n  program.parser.finish();\n  return new Compiler(program).compile();\n}\n\n/** Builds WebIDL definitions for the specified program. */\nexport function buildIDL(program: Program): string {\n  return IDLBuilder.build(program);\n}\n\n/** Builds TypeScript definitions for the specified program. */\nexport function buildTSD(program: Program): string {\n  return TSDBuilder.build(program);\n}\n\n// Full API\nexport * from \"./ast\";\nexport * from \"./common\";\nexport * from \"./compiler\";\nexport * from \"./definitions\";\nexport * from \"./diagnostics\";\nexport * from \"./flow\";\nexport * from \"./module\";\nexport * from \"./parser\";\nexport * from \"./program\";\nexport * from \"./resolver\";\nexport * from \"./tokenizer\";\nexport * from \"./types\";\nexport * from \"./extra/ast\";\nimport * as util from \"./util/index\";\nexport { util };\n","/**\n * @fileoverview A thin wrapper around Binaryen's C-API.\n *\n * The AssemblyScript compiler utilizes Binaryen's C-API directly. Even\n * though it currently imports binaryen.js, none of the JS APIs it\n * provides are used.\n *\n * @license Apache-2.0\n */\n\nimport { BuiltinNames } from \"./builtins\";\nimport { Target } from \"./common\";\nimport {\n  isHighSurrogate,\n  isLowSurrogate,\n  combineSurrogates,\n  SURROGATE_HIGH,\n  SURROGATE_LOW\n} from \"./util\";\nimport * as binaryen from \"./glue/binaryen\";\n\n/** A Binaryen-compatible index. */\nexport type Index = binaryen.Index;\n/** Reference to a Binaryen-compatible string. */\nexport type StringRef = binaryen.StringRef;\n/** Reference to a Binaryen module. */\nexport type ModuleRef = binaryen.ModuleRef;\n/** Reference to a Binaryen function. */\nexport type FunctionRef = binaryen.FunctionRef;\n/** Reference to a Binaryen expression. */\nexport type ExpressionRef = binaryen.ExpressionRef;\n/** Reference to a Binaryen global. */\nexport type GlobalRef = binaryen.GlobalRef;\n/** Reference to a Binaryen tag. */\nexport type TagRef = binaryen.TagRef;\n/** Reference to a Binaryen import. */\nexport type ImportRef = binaryen.ImportRef;\n/** Reference to a Binaryen export. */\nexport type ExportRef = binaryen.ExportRef;\n/** Reference to a Binaryen relooper. */\nexport type RelooperRef = binaryen.RelooperRef;\n/** Reference to a Binaryen relooper block. */\nexport type RelooperBlockRef = binaryen.RelooperBlockRef;\n\n// The following constants must be updated by running scripts/update-constants.\n// This is necessary because the functions are not yet callable with Binaryen\n// compiled to WebAssembly, requiring awaiting the ready promise first. Note\n// that this essentially fixes the compiler to specific versions of Binaryen\n// sometimes, because these constants can differ between Binaryen versions.\n\n/** Reference to a Binaryen type. */\nexport type TypeRef = binaryen.TypeRef;\nexport namespace TypeRef {\n  export const None: TypeRef = 0 /* _BinaryenTypeNone */;\n  export const Unreachable: TypeRef = 1 /* _BinaryenTypeUnreachable */;\n  export const I32: TypeRef = 2 /* _BinaryenTypeInt32 */;\n  export const I64: TypeRef = 3 /* _BinaryenTypeInt64 */;\n  export const F32: TypeRef = 4 /* _BinaryenTypeFloat32 */;\n  export const F64: TypeRef = 5 /* _BinaryenTypeFloat64 */;\n  export const V128: TypeRef = 6 /* _BinaryenTypeVec128 */;\n  export const Funcref: TypeRef = 7 /* _BinaryenTypeFuncref */;\n  export const Externref: TypeRef = 8 /* _BinaryenTypeExternref */;\n  export const Anyref: TypeRef = 9 /* _BinaryenTypeAnyref */;\n  export const Eqref: TypeRef = 10 /* _BinaryenTypeEqref */;\n  export const I31ref: TypeRef = 11 /* _BinaryenTypeI31ref */;\n  export const Dataref: TypeRef = 12 /* _BinaryenTypeDataref */;\n  export const Auto: TypeRef = -1 /* _BinaryenTypeAuto */;\n}\n\n/** Binaryen feature constants. */\nexport enum FeatureFlags {\n  MVP = 0 /* _BinaryenFeatureMVP */,\n  Atomics = 1 /* _BinaryenFeatureAtomics */,\n  MutableGloabls = 2 /* _BinaryenFeatureMutableGlobals */,\n  TruncSat = 4 /* _BinaryenFeatureNontrappingFPToInt */,\n  SIMD = 8 /* _BinaryenFeatureSIMD128 */,\n  BulkMemory = 16 /* _BinaryenFeatureBulkMemory */,\n  SignExt = 32 /* _BinaryenFeatureSignExt */,\n  ExceptionHandling = 64 /* _BinaryenFeatureExceptionHandling */,\n  TailCall = 128 /* _BinaryenFeatureTailCall */,\n  ReferenceTypes = 256 /* _BinaryenFeatureReferenceTypes */,\n  MultiValue = 512 /* _BinaryenFeatureMultivalue */,\n  GC = 1024 /* _BinaryenFeatureGC */,\n  Memory64 = 2048 /* _BinaryenFeatureMemory64 */,\n  TypedFunctionReferences = 4096 /* _BinaryenFeatureTypedFunctionReferences */,\n  RelaxedSIMD = 16384 /* _BinaryenFeatureRelaxedSIMD */,\n  All = 32767 /* _BinaryenFeatureAll */\n}\n\n/** Binaryen expression id constants. */\nexport enum ExpressionId {\n  Invalid = 0 /* _BinaryenInvalidId */,\n  Block = 1 /* _BinaryenBlockId */,\n  If = 2 /* _BinaryenIfId */,\n  Loop = 3 /* _BinaryenLoopId */,\n  Break = 4 /* _BinaryenBreakId */,\n  Switch = 5 /* _BinaryenSwitchId */,\n  Call = 6 /* _BinaryenCallId */,\n  CallIndirect = 7 /* _BinaryenCallIndirectId */,\n  LocalGet = 8 /* _BinaryenLocalGetId */,\n  LocalSet = 9 /* _BinaryenLocalSetId */,\n  GlobalGet = 10 /* _BinaryenGlobalGetId */,\n  GlobalSet = 11 /* _BinaryenGlobalSetId */,\n  Load = 12 /* _BinaryenLoadId */,\n  Store = 13 /* _BinaryenStoreId */,\n  Const = 14 /* _BinaryenConstId */,\n  Unary = 15 /* _BinaryenUnaryId */,\n  Binary = 16 /* _BinaryenBinaryId */,\n  Select = 17 /* _BinaryenSelectId */,\n  Drop = 18 /* _BinaryenDropId */,\n  Return = 19 /* _BinaryenReturnId */,\n  MemorySize = 20 /* _BinaryenMemorySizeId */,\n  MemoryGrow = 21 /* _BinaryenMemoryGrowId */,\n  Nop = 22 /* _BinaryenNopId */,\n  Unreachable = 23 /* _BinaryenUnreachableId */,\n  AtomicRMW = 24 /* _BinaryenAtomicRMWId */,\n  AtomicCmpxchg = 25 /* _BinaryenAtomicCmpxchgId */,\n  AtomicWait = 26 /* _BinaryenAtomicWaitId */,\n  AtomicNotify = 27 /* _BinaryenAtomicNotifyId */,\n  AtomicFence = 28 /* _BinaryenAtomicFenceId */,\n  SIMDExtract = 29 /* _BinaryenSIMDExtractId */,\n  SIMDReplace = 30 /* _BinaryenSIMDReplaceId */,\n  SIMDShuffle = 31 /* _BinaryenSIMDShuffleId */,\n  SIMDTernary = 32 /* _BinaryenSIMDTernaryId */,\n  SIMDShift = 33 /* _BinaryenSIMDShiftId */,\n  SIMDLoad = 34 /* _BinaryenSIMDLoadId */,\n  SIMDLoadStoreLane = 35 /* _BinaryenSIMDLoadStoreLaneId */,\n  MemoryInit = 36 /* _BinaryenMemoryInitId */,\n  DataDrop = 37 /* _BinaryenDataDropId */,\n  MemoryCopy = 38 /* _BinaryenMemoryCopyId */,\n  MemoryFill = 39 /* _BinaryenMemoryFillId */,\n  Pop = 40 /* _BinaryenPopId */,\n  RefNull = 41 /* _BinaryenRefNullId */,\n  RefIs = 42 /* _BinaryenRefIsId */,\n  RefFunc = 43 /* _BinaryenRefFuncId */,\n  RefEq = 44 /* _BinaryenRefEqId */,\n  TableGet = 45 /* _BinaryenTableGetId */,\n  TableSet = 46 /* _BinaryenTableSetId */,\n  TableSize = 47 /* _BinaryenTableSizeId */,\n  TableGrow = 48 /* _BinaryenTableGrowId */,\n  Try = 49 /* _BinaryenTryId */,\n  Throw = 50 /* _BinaryenThrowId */,\n  Rethrow = 51 /* _BinaryenRethrowId */,\n  TupleMake = 52 /* _BinaryenTupleMakeId */,\n  TupleExtract = 53 /* _BinaryenTupleExtractId */,\n  I31New = 54 /* _BinaryenI31NewId */,\n  I31Get = 55 /* _BinaryenI31GetId */,\n  CallRef = 56 /* _BinaryenCallRefId */,\n  RefTest = 57 /* _BinaryenRefTestId */,\n  RefCast = 58 /* _BinaryenRefCastId */,\n  BrOn = 59 /* _BinaryenBrOnId */,\n  RttCanon = 60 /* _BinaryenRttCanonId */,\n  RttSub = 61 /* _BinaryenRttSubId */,\n  StructNew = 62 /* _BinaryenStructNewId */,\n  StructGet = 63 /* _BinaryenStructGetId */,\n  StructSet = 64 /* _BinaryenStructSetId */,\n  ArrayNew = 65 /* _BinaryenArrayNewId */,\n  ArrayInit = 66 /* _BinaryenArrayInitId */,\n  ArrayGet = 67 /* _BinaryenArrayGetId */,\n  ArraySet = 68 /* _BinaryenArraySetId */,\n  ArrayLen = 69 /* _BinaryenArrayLenId */,\n  ArrayCopy = 70 /* _BinaryenArrayCopyId */,\n  RefAs = 71 /* _BinaryenRefAsId */\n}\n\n/** Binaryen external kind constants. */\nexport enum ExternalKind {\n  Function = 0 /* _BinaryenExternalFunction */,\n  Table = 1 /* _BinaryenExternalTable */,\n  Memory = 2 /* _BinaryenExternalMemory */,\n  Global = 3 /* _BinaryenExternalGlobal */,\n  Tag = 4 /* _BinaryenExternalTag */\n}\n\n/** Binaryen unary operation constants. */\nexport enum UnaryOp {\n  /** i32.clz */\n  ClzI32 = 0 /* _BinaryenClzInt32 */,\n  /** i64.clz */\n  ClzI64 = 1 /* _BinaryenClzInt64 */,\n  /** i32.ctz */\n  CtzI32 = 2 /* _BinaryenCtzInt32 */,\n  /** i64.ctz */\n  CtzI64 = 3 /* _BinaryenCtzInt64 */,\n  /** i32.popcnt */\n  PopcntI32 = 4 /* _BinaryenPopcntInt32 */,\n  /** i64.popcnt */\n  PopcntI64 = 5 /* _BinaryenPopcntInt64 */,\n  /** f32.neg */\n  NegF32 = 6 /* _BinaryenNegFloat32 */,\n  /** f64.neg */\n  NegF64 = 7 /* _BinaryenNegFloat64 */,\n  /** f32.abs */\n  AbsF32 = 8 /* _BinaryenAbsFloat32 */,\n  /** f64.abs */\n  AbsF64 = 9 /* _BinaryenAbsFloat64 */,\n  /** f32.ceil */\n  CeilF32 = 10 /* _BinaryenCeilFloat32 */,\n  /** f64.ceil */\n  CeilF64 = 11 /* _BinaryenCeilFloat64 */,\n  /** f32.floor */\n  FloorF32 = 12 /* _BinaryenFloorFloat32 */,\n  /** f64.floor */\n  FloorF64 = 13 /* _BinaryenFloorFloat64 */,\n  /** f32.trunc */\n  TruncF32 = 14 /* _BinaryenTruncFloat32 */,\n  /** f64.trunc */\n  TruncF64 = 15 /* _BinaryenTruncFloat64 */,\n  /** f32.nearest */\n  NearestF32 = 16 /* _BinaryenNearestFloat32 */,\n  /** f64.nearest */\n  NearestF64 = 17 /* _BinaryenNearestFloat64 */,\n  /** f32.sqrt */\n  SqrtF32 = 18 /* _BinaryenSqrtFloat32 */,\n  /** f64.sqrt */\n  SqrtF64 = 19 /* _BinaryenSqrtFloat64 */,\n  /** i32.eqz */\n  EqzI32 = 20 /* _BinaryenEqZInt32 */,\n  /** i64.eqz */\n  EqzI64 = 21 /* _BinaryenEqZInt64 */,\n  /** i64.extend_i32_s */\n  ExtendI32ToI64 = 22 /* _BinaryenExtendSInt32 */,\n  /** i64.extend_i32_u */\n  ExtendU32ToU64 = 23 /* _BinaryenExtendUInt32 */,\n  /** i32.wrap_i64 */\n  WrapI64ToI32 = 24 /* _BinaryenWrapInt64 */,\n  /** i32.trunc_f32_s */\n  TruncF32ToI32 = 25 /* _BinaryenTruncSFloat32ToInt32 */,\n  /** i64.trunc_f32_s */\n  TruncF32ToI64 = 26 /* _BinaryenTruncSFloat32ToInt64 */,\n  /** i32.trunc_f32_u */\n  TruncF32ToU32 = 27 /* _BinaryenTruncUFloat32ToInt32 */,\n  /** i64.trunc_f32_u */\n  TruncF32ToU64 = 28 /* _BinaryenTruncUFloat32ToInt64 */,\n  /** i32.trunc_f64_s */\n  TruncF64ToI32 = 29 /* _BinaryenTruncSFloat64ToInt32 */,\n  /** i64.trunc_f64_s */\n  TruncF64ToI64 = 30 /* _BinaryenTruncSFloat64ToInt64 */,\n  /** i32.trunc_f64_u */\n  TruncF64ToU32 = 31 /* _BinaryenTruncUFloat64ToInt32 */,\n  /** i64.trunc_f64_u */\n  TruncF64ToU64 = 32 /* _BinaryenTruncUFloat64ToInt64 */,\n  /** i32.reinterpret_f32 */\n  ReinterpretF32ToI32 = 33 /* _BinaryenReinterpretFloat32 */,\n  /** i64.reinterpret_f64 */\n  ReinterpretF64ToI64 = 34 /* _BinaryenReinterpretFloat64 */,\n  /** f32.convert_i32_s */\n  ConvertI32ToF32 = 35 /* _BinaryenConvertSInt32ToFloat32 */,\n  /** f64.convert_i32_s */\n  ConvertI32ToF64 = 36 /* _BinaryenConvertSInt32ToFloat64 */,\n  /** f32.convert_i32_u */\n  ConvertU32ToF32 = 37 /* _BinaryenConvertUInt32ToFloat32 */,\n  /** f64.convert_i32_u */\n  ConvertU32ToF64 = 38 /* _BinaryenConvertUInt32ToFloat64 */,\n  /** f32.convert_i64_s */\n  ConvertI64ToF32 = 39 /* _BinaryenConvertSInt64ToFloat32 */,\n  /** f64.convert_i64_s */\n  ConvertI64ToF64 = 40 /* _BinaryenConvertSInt64ToFloat64 */,\n  /** f32.convert_i64_u */\n  ConvertU64ToF32 = 41 /* _BinaryenConvertUInt64ToFloat32 */,\n  /** f64.convert_i64_u */\n  ConvertU64ToF64 = 42 /* _BinaryenConvertUInt64ToFloat64 */,\n  /** f64.promote.f32 */\n  PromoteF32ToF64 = 43 /* _BinaryenPromoteFloat32 */,\n  /** f32.demote_f64 */\n  DemoteF64ToF32 = 44 /* _BinaryenDemoteFloat64 */,\n  /** f32.reinterpret_i32 */\n  ReinterpretI32ToF32 = 45 /* _BinaryenReinterpretInt32 */,\n  /** f64.reinterpret_i64 */\n  ReinterpretI64ToF64 = 46 /* _BinaryenReinterpretInt64 */,\n\n  // see: https://github.com/WebAssembly/sign-extension-ops\n\n  /** i32.extend8_s */\n  Extend8I32 = 47 /* _BinaryenExtendS8Int32 */,\n  /** i32.extend16_s */\n  Extend16I32 = 48 /* _BinaryenExtendS16Int32 */,\n  /** i64.extend8_s */\n  Extend8I64 = 49 /* _BinaryenExtendS8Int64 */,\n  /** i64.extend16_s */\n  Extend16I64 = 50 /* _BinaryenExtendS16Int64 */,\n  /** i64.extend32_s (i64 in, i64 out) */\n  Extend32I64 = 51 /* _BinaryenExtendS32Int64 */,\n\n  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n\n  /** i32.trunc_sat_f32_s */\n  TruncSatF32ToI32 = 52 /* _BinaryenTruncSatSFloat32ToInt32 */,\n  /** i32.trunc_sat_f32_u */\n  TruncSatF32ToU32 = 53 /* _BinaryenTruncSatUFloat32ToInt32 */,\n  /** i32.trunc_sat_f64_s */\n  TruncSatF64ToI32 = 54 /* _BinaryenTruncSatSFloat64ToInt32 */,\n  /** i32.trunc_sat_f64_u */\n  TruncSatF64ToU32 = 55 /* _BinaryenTruncSatUFloat64ToInt32 */,\n  /** i64.trunc_sat_f32_s */\n  TruncSatF32ToI64 = 56 /* _BinaryenTruncSatSFloat32ToInt64 */,\n  /** i64.trunc_sat_f32_u */\n  TruncSatF32ToU64 = 57 /* _BinaryenTruncSatUFloat32ToInt64 */,\n  /** i64.trunc_sat_f64_s */\n  TruncSatF64ToI64 = 58 /* _BinaryenTruncSatSFloat64ToInt64 */,\n  /** i64.trunc_sat_f64_u */\n  TruncSatF64ToU64 = 59 /* _BinaryenTruncSatUFloat64ToInt64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.splat */\n  SplatI8x16 = 60 /* _BinaryenSplatVecI8x16 */,\n  /** i16x8.splat */\n  SplatI16x8 = 61 /* _BinaryenSplatVecI16x8 */,\n  /** i32x4.splat */\n  SplatI32x4 = 62 /* _BinaryenSplatVecI32x4 */,\n  /** i64x2.splat */\n  SplatI64x2 = 63 /* _BinaryenSplatVecI64x2 */,\n  /** f32x4.splat */\n  SplatF32x4 = 64 /* _BinaryenSplatVecF32x4 */,\n  /** f64x2.splat */\n  SplatF64x2 = 65 /* _BinaryenSplatVecF64x2 */,\n  /** v128.not */\n  NotV128 = 66 /* _BinaryenNotVec128 */,\n  /** v128.any_true */\n  AnyTrueV128 = 67 /* _BinaryenAnyTrueVec128 */,\n  /** i8x16.abs */\n  AbsI8x16 = 68 /* _BinaryenAbsVecI8x16 */,\n  /** i8x16.neg */\n  NegI8x16 = 69 /* _BinaryenNegVecI8x16 */,\n  /** i8x16.all_true */\n  AllTrueI8x16 = 70 /* _BinaryenAllTrueVecI8x16 */,\n  /** i8x16.bitmask */\n  BitmaskI8x16 = 71 /* _BinaryenBitmaskVecI8x16 */,\n  /** i8x16.popcnt */\n  PopcntI8x16 = 72 /* _BinaryenPopcntVecI8x16 */,\n  /** i16x8.abs */\n  AbsI16x8 = 73 /* _BinaryenAbsVecI16x8 */,\n  /** i16x8.neg */\n  NegI16x8 = 74 /* _BinaryenNegVecI16x8 */,\n  /** i16x8.all_true */\n  AllTrueI16x8 = 75 /* _BinaryenAllTrueVecI16x8 */,\n  /** i16x8.bitmask */\n  BitmaskI16x8 = 76 /* _BinaryenBitmaskVecI16x8 */,\n  /** i32x4.abs */\n  AbsI32x4 = 77 /* _BinaryenAbsVecI32x4 */,\n  /** i32x4.neg */\n  NegI32x4 = 78 /* _BinaryenNegVecI32x4 */,\n  /** i32x4.all_true */\n  AllTrueI32x4 = 79 /* _BinaryenAllTrueVecI32x4 */,\n  /** i32x4.bitmask */\n  BitmaskI32x4 = 80 /* _BinaryenBitmaskVecI32x4 */,\n  /** i64x2.abs */\n  AbsI64x2 = 81 /* _BinaryenAbsVecI64x2 */,\n  /** i64x2.neg */\n  NegI64x2 = 82 /* _BinaryenNegVecI64x2 */,\n  /** i64x2.all_true */\n  AllTrueI64x2 = 83 /* _BinaryenAllTrueVecI64x2 */,\n  /** i64x2.bitmask */\n  BitmaskI64x2 = 84 /* _BinaryenBitmaskVecI64x2 */,\n  /** f32x4.abs */\n  AbsF32x4 = 85 /* _BinaryenAbsVecF32x4 */,\n  /** f32x4.neg */\n  NegF32x4 = 86 /* _BinaryenNegVecF32x4 */,\n  /** f32x4.sqrt */\n  SqrtF32x4 = 87 /* _BinaryenSqrtVecF32x4 */,\n  /** f32x4.ceil */\n  CeilF32x4 = 88 /* _BinaryenCeilVecF32x4 */,\n  /** f32x4.floor */\n  FloorF32x4 = 89 /* _BinaryenFloorVecF32x4 */,\n  /** f32x4.trunc */\n  TruncF32x4 = 90 /* BinaryenTruncVecF32x4 */,\n  /** f32x4.nearest */\n  NearestF32x4 = 91 /* BinaryenNearestVecF32x4 */,\n  /** f64x2.abs */\n  AbsF64x2 = 92 /* _BinaryenAbsVecF64x2 */,\n  /** f64x2.neg */\n  NegF64x2 = 93 /* _BinaryenNegVecF64x2 */,\n  /** f64x2.sqrt */\n  SqrtF64x2 = 94 /* _BinaryenSqrtVecF64x2 */,\n  /** f64x2.ceil */\n  CeilF64x2 = 95 /* _BinaryenCeilVecF64x2 */,\n  /** f64x2.floor */\n  FloorF64x2 = 96 /* _BinaryenFloorVecF64x2 */,\n  /** f64x2.trunc */\n  TruncF64x2 = 97 /* _BinaryenTruncVecF64x2 */,\n  /** f64x2.nearest */\n  NearestF64x2 = 98 /* _BinaryenNearestVecF64x2 */,\n  /** i16x8.extadd_pairwise_i8x16_s */\n  ExtaddPairwiseI8x16ToI16x8 = 99 /* _BinaryenExtAddPairwiseSVecI8x16ToI16x8 */,\n  /** i16x8.extadd_pairwise.i8x16_u */\n  ExtaddPairwiseU8x16ToU16x8 = 100 /* _BinaryenExtAddPairwiseUVecI8x16ToI16x8 */,\n  /** i32x4.extadd_pairwise.i16x8_s */\n  ExtaddPairwiseI16x8ToI32x4 = 101 /* _BinaryenExtAddPairwiseSVecI16x8ToI32x4 */,\n  /** i32x4.extadd_pairwise.i64x8_u */\n  ExtaddPairwiseU16x8ToU32x4 = 102 /* _BinaryenExtAddPairwiseUVecI16x8ToI32x4 */,\n  /** i32x4.trunc_sat_f32x4_s */\n  TruncSatF32x4ToI32x4 = 103 /* _BinaryenTruncSatSVecF32x4ToVecI32x4 */,\n  /** i32x4.trunc_sat_f32x4_u */\n  TruncSatF32x4ToU32x4 = 104 /* _BinaryenTruncSatUVecF32x4ToVecI32x4 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertI32x4ToF32x4 = 105 /* _BinaryenConvertSVecI32x4ToVecF32x4 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertU32x4ToF32x4 = 106 /* _BinaryenConvertUVecI32x4ToVecF32x4 */,\n  /** i16x8.extend_low_i8x16_s */\n  ExtendLowI8x16ToI16x8 = 107 /* _BinaryenExtendLowSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_s */\n  ExtendHighI8x16ToI16x8 = 108 /* _BinaryenExtendHighSVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_low_i8x16_u */\n  ExtendLowU8x16ToU16x8 = 109 /* _BinaryenExtendLowUVecI8x16ToVecI16x8 */,\n  /** i16x8.extend_high_i8x16_u */\n  ExtendHighU8x16ToU16x8 = 110 /* _BinaryenExtendHighUVecI8x16ToVecI16x8 */,\n  /** i32x4.extend_low_i16x8_s */\n  ExtendLowI16x8ToI32x4 = 111 /* _BinaryenExtendLowSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_s */\n  ExtendHighI16x8ToI32x4 = 112 /* _BinaryenExtendHighSVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_low_i16x8_u */\n  ExtendLowU16x8ToU32x4 = 113 /* _BinaryenExtendLowUVecI16x8ToVecI32x4 */,\n  /** i32x4.extend_high_i16x8_u */\n  ExtendHighU16x8ToU32x4 = 114 /* _BinaryenExtendHighUVecI16x8ToVecI32x4 */,\n  /** i64x2.extend_low_i32x4_s */\n  ExtendLowI32x4ToI64x2 = 115 /* _BinaryenExtendLowSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_s */\n  ExtendHighI32x4ToI64x2 = 116 /* _BinaryenExtendHighSVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_low_i32x4_u */\n  ExtendLowU32x4ToU64x2 = 117 /* _BinaryenExtendLowUVecI32x4ToVecI64x2 */,\n  /** i64x2.extend_high_i32x4_u */\n  ExtendHighU32x4ToU64x2 = 118 /* _BinaryenExtendHighUVecI32x4ToVecI64x2 */,\n  /** f32x4.convert_i32x4_s */\n  ConvertLowI32x4ToF64x2 = 119 /* _BinaryenConvertLowSVecI32x4ToVecF64x2 */,\n  /** f32x4.convert_i32x4_u */\n  ConvertLowU32x4ToF64x2 = 120 /* _BinaryenConvertLowUVecI32x4ToVecF64x2 */,\n  /** i32x4.trunc_sat_f64x2_s_zero */\n  TruncSatF64x2ToI32x4Zero = 121 /* _BinaryenTruncSatZeroSVecF64x2ToVecI32x4 */,\n  /** i32x4.trunc_sat_f64x2_u_zero */\n  TruncSatF64x2ToU32x4Zero = 122 /* _BinaryenTruncSatZeroUVecF64x2ToVecI32x4 */,\n  /** f32x4.demote_f64x2_zero */\n  DemoteZeroF64x2ToF32x4 = 123 /* _BinaryenDemoteZeroVecF64x2ToVecF32x4 */,\n  /** f64x2.promote_low_f32x4 */\n  PromoteLowF32x4ToF64x2 = 124 /* _BinaryenPromoteLowVecF32x4ToVecF64x2 */,\n\n  _last = PromoteLowF32x4ToF64x2,\n\n  // Target dependent\n\n  /** i32.clz or i64.clz, depending on target word size */\n  ClzSize,\n  /** i32.ctz or i64.ctz, depending on target word size */\n  CtzSize,\n  /** i32.popcnt or i64.popcnt, depending on target word size */\n  PopcntSize,\n  /** i32.eqz or i64.eqz, depending on target word size */\n  EqzSize\n}\n\n/** Binaryen binary operation constants. */\nexport enum BinaryOp {\n  /** i32.add */\n  AddI32 = 0 /* _BinaryenAddInt32 */,\n  /** i32.sub */\n  SubI32 = 1 /* _BinaryenSubInt32 */,\n  /** i32.mul */\n  MulI32 = 2 /* _BinaryenMulInt32 */,\n  /** i32.div_s */\n  DivI32 = 3 /* _BinaryenDivSInt32 */,\n  /** i32.div_u */\n  DivU32 = 4 /* _BinaryenDivUInt32 */,\n  /** i32.rem_s */\n  RemI32 = 5 /* _BinaryenRemSInt32 */,\n  /** i32.rem_u */\n  RemU32 = 6 /* _BinaryenRemUInt32 */,\n  /** i32.and */\n  AndI32 = 7 /* _BinaryenAndInt32 */,\n  /** i32.or */\n  OrI32 = 8 /* _BinaryenOrInt32 */,\n  /** i32.xor */\n  XorI32 = 9 /* _BinaryenXorInt32 */,\n  /** i32.shl */\n  ShlI32 = 10 /* _BinaryenShlInt32 */,\n  /** i32.shr_s */\n  ShrI32 = 11 /* _BinaryenShrSInt32 */,\n  /** i32.shr_u */\n  ShrU32 = 12 /* _BinaryenShrUInt32 */,\n  /** i32.rotl */\n  RotlI32 = 13 /* _BinaryenRotLInt32 */,\n  /** i32.rotr */\n  RotrI32 = 14 /* _BinaryenRotRInt32 */,\n  /** i32.eq */\n  EqI32 = 15 /* _BinaryenEqInt32 */,\n  /** i32.ne */\n  NeI32 = 16 /* _BinaryenNeInt32 */,\n  /** i32.lt_s */\n  LtI32 = 17 /* _BinaryenLtSInt32 */,\n  /** i32.lt_u */\n  LtU32 = 18 /* _BinaryenLtUInt32 */,\n  /** i32.le_s */\n  LeI32 = 19 /* _BinaryenLeSInt32 */,\n  /** i32.le_u */\n  LeU32 = 20 /* _BinaryenLeUInt32 */,\n  /** i32.gt_s */\n  GtI32 = 21 /* _BinaryenGtSInt32 */,\n  /** i32.gt_u */\n  GtU32 = 22 /* _BinaryenGtUInt32 */,\n  /** i32.ge_s */\n  GeI32 = 23 /* _BinaryenGeSInt32 */,\n  /** i32.ge_u */\n  GeU32 = 24 /* _BinaryenGeUInt32 */,\n  /** i64.add */\n  AddI64 = 25 /* _BinaryenAddInt64 */,\n  /** i64.sub */\n  SubI64 = 26 /* _BinaryenSubInt64 */,\n  /** i64.mul */\n  MulI64 = 27 /* _BinaryenMulInt64 */,\n  /** i64.div_s */\n  DivI64 = 28 /* _BinaryenDivSInt64 */,\n  /** i64.div_u */\n  DivU64 = 29 /* _BinaryenDivUInt64 */,\n  /** i64.rem_s */\n  RemI64 = 30 /* _BinaryenRemSInt64 */,\n  /** i64.rem_u */\n  RemU64 = 31 /* _BinaryenRemUInt64 */,\n  /** i64.and */\n  AndI64 = 32 /* _BinaryenAndInt64 */,\n  /** i64.or */\n  OrI64 = 33 /* _BinaryenOrInt64 */,\n  /** i64.xor */\n  XorI64 = 34 /* _BinaryenXorInt64 */,\n  /** i64.shl */\n  ShlI64 = 35 /* _BinaryenShlInt64 */,\n  /** i64.shr_s */\n  ShrI64 = 36 /* _BinaryenShrSInt64 */,\n  /** i64.shr_u */\n  ShrU64 = 37 /* _BinaryenShrUInt64 */,\n  /** i64.rotl */\n  RotlI64 = 38 /* _BinaryenRotLInt64 */,\n  /** i64.rotr */\n  RotrI64 = 39 /* _BinaryenRotRInt64 */,\n  /** i64.eq */\n  EqI64 = 40 /* _BinaryenEqInt64 */,\n  /** i64.ne */\n  NeI64 = 41 /* _BinaryenNeInt64 */,\n  /** i64.lt_s */\n  LtI64 = 42 /* _BinaryenLtSInt64 */,\n  /** i64.lt_u */\n  LtU64 = 43 /* _BinaryenLtUInt64 */,\n  /** i64.le_s */\n  LeI64 = 44 /* _BinaryenLeSInt64 */,\n  /** i64.le_u */\n  LeU64 = 45 /* _BinaryenLeUInt64 */,\n  /** i64.gt_s */\n  GtI64 = 46 /* _BinaryenGtSInt64 */,\n  /** i64.gt_u */\n  GtU64 = 47 /* _BinaryenGtUInt64 */,\n  /** i64.ge_s */\n  GeI64 = 48 /* _BinaryenGeSInt64 */,\n  /** i64.ge_u */\n  GeU64 = 49 /* _BinaryenGeUInt64 */,\n  /** f32.add */\n  AddF32 = 50 /* _BinaryenAddFloat32 */,\n  /** f32.sub */\n  SubF32 = 51 /* _BinaryenSubFloat32 */,\n  /** f32.mul */\n  MulF32 = 52 /* _BinaryenMulFloat32 */,\n  /** f32.div */\n  DivF32 = 53 /* _BinaryenDivFloat32 */,\n  /** f32.copysign */\n  CopysignF32 = 54 /* _BinaryenCopySignFloat32 */,\n  /** f32.min */\n  MinF32 = 55 /* _BinaryenMinFloat32 */,\n  /** f32.max */\n  MaxF32 = 56 /* _BinaryenMaxFloat32 */,\n  /** f32.eq */\n  EqF32 = 57 /* _BinaryenEqFloat32 */,\n  /** f32.ne */\n  NeF32 = 58 /* _BinaryenNeFloat32 */,\n  /** f32.lt */\n  LtF32 = 59 /* _BinaryenLtFloat32 */,\n  /** f32.le */\n  LeF32 = 60 /* _BinaryenLeFloat32 */,\n  /** f32.gt */\n  GtF32 = 61 /* _BinaryenGtFloat32 */,\n  /** f32.ge */\n  GeF32 = 62 /* _BinaryenGeFloat32 */,\n  /** f64.add */\n  AddF64 = 63 /* _BinaryenAddFloat64 */,\n  /** f64.sub */\n  SubF64 = 64 /* _BinaryenSubFloat64 */,\n  /** f64.mul */\n  MulF64 = 65 /* _BinaryenMulFloat64 */,\n  /** f64.div */\n  DivF64 = 66 /* _BinaryenDivFloat64 */,\n  /** f64.copysign */\n  CopysignF64 = 67 /* _BinaryenCopySignFloat64 */,\n  /** f64.min */\n  MinF64 = 68 /* _BinaryenMinFloat64 */,\n  /** f64.max */\n  MaxF64 = 69 /* _BinaryenMaxFloat64 */,\n  /** f64.eq */\n  EqF64 = 70 /* _BinaryenEqFloat64 */,\n  /** f64.ne */\n  NeF64 = 71 /* _BinaryenNeFloat64 */,\n  /** f64.lt */\n  LtF64 = 72 /* _BinaryenLtFloat64 */,\n  /** f64.le */\n  LeF64 = 73 /* _BinaryenLeFloat64 */,\n  /** f64.gt */\n  GtF64 = 74 /* _BinaryenGtFloat64 */,\n  /** f64.ge */\n  GeF64 = 75 /* _BinaryenGeFloat64 */,\n\n  // see: https://github.com/WebAssembly/simd\n\n  /** i8x16.eq */\n  EqI8x16 = 76 /* _BinaryenEqVecI8x16 */,\n  /** i8x16.he */\n  NeI8x16 = 77 /* _BinaryenNeVecI8x16 */,\n  /** i8x16.lt_s */\n  LtI8x16 = 78 /* _BinaryenLtSVecI8x16 */,\n  /** i8x16.lt_u */\n  LtU8x16 = 79 /* _BinaryenLtUVecI8x16 */,\n  /** i8x16.gt_s */\n  GtI8x16 = 80 /* _BinaryenGtSVecI8x16 */,\n  /** i8x16.gt_u */\n  GtU8x16 = 81 /* _BinaryenGtUVecI8x16 */,\n  /** i8x16.le_s */\n  LeI8x16 = 82 /* _BinaryenLeSVecI8x16 */,\n  /** i8x16.le_u */\n  LeU8x16 = 83 /* _BinaryenLeUVecI8x16 */,\n  /** i8x16.ge_s */\n  GeI8x16 = 84 /* _BinaryenGeSVecI8x16 */,\n  /** i8x16.ge_u */\n  GeU8x16 = 85 /* _BinaryenGeUVecI8x16 */,\n  /** i16x8.eq */\n  EqI16x8 = 86 /* _BinaryenEqVecI16x8 */,\n  /** i16x8.ne */\n  NeI16x8 = 87 /* _BinaryenNeVecI16x8 */,\n  /** i16x8.lt_s */\n  LtI16x8 = 88 /* _BinaryenLtSVecI16x8 */,\n  /** i16x8.lt_u */\n  LtU16x8 = 89 /* _BinaryenLtUVecI16x8 */,\n  /** i16x8.gt_s */\n  GtI16x8 = 90 /* _BinaryenGtSVecI16x8 */,\n  /** i16x8.gt_u */\n  GtU16x8 = 91 /* _BinaryenGtUVecI16x8 */,\n  /** i16x8.le_s */\n  LeI16x8 = 92 /* _BinaryenLeSVecI16x8 */,\n  /** i16x8.le_u */\n  LeU16x8 = 93 /* _BinaryenLeUVecI16x8 */,\n  /** i16x8.ge_s */\n  GeI16x8 = 94 /* _BinaryenGeSVecI16x8 */,\n  /** i16x8.ge_u */\n  GeU16x8 = 95 /* _BinaryenGeUVecI16x8 */,\n  /** i32x4.eq */\n  EqI32x4 = 96 /* _BinaryenEqVecI32x4 */,\n  /** i32x4.ne */\n  NeI32x4 = 97 /* _BinaryenNeVecI32x4 */,\n  /** i32x4.lt_s */\n  LtI32x4 = 98 /* _BinaryenLtSVecI32x4 */,\n  /** i32x4.lt_u */\n  LtU32x4 = 99 /* _BinaryenLtUVecI32x4 */,\n  /** i32x4.gt_s */\n  GtI32x4 = 100 /* _BinaryenGtSVecI32x4 */,\n  /** i32x4.gt_u */\n  GtU32x4 = 101 /* _BinaryenGtUVecI32x4 */,\n  /** i32x4.le_s */\n  LeI32x4 = 102 /* _BinaryenLeSVecI32x4 */,\n  /** i32x4.le_u */\n  LeU32x4 = 103 /* _BinaryenLeUVecI32x4 */,\n  /** i32x4.ge_s */\n  GeI32x4 = 104 /* _BinaryenGeSVecI32x4 */,\n  /** i32x4.ge_u */\n  GeU32x4 = 105 /* _BinaryenGeUVecI32x4 */,\n  /** i64x2.eq */\n  EqI64x2 = 106 /* _BinaryenEqVecI64x2 */,\n  /** i64x2.ne */\n  NeI64x2 = 107 /* _BinaryenNeVecI64x2 */,\n  /** i64x2.lt_s */\n  LtI64x2 = 108 /* _BinaryenLtSVecI64x2 */,\n  /** i64x2.gt_s */\n  GtI64x2 = 109 /* _BinaryenGtSVecI64x2 */,\n  /** i64x2.le_s */\n  LeI64x2 = 110 /* _BinaryenLeSVecI64x2 */,\n  /** i64x2.ge_s */\n  GeI64x2 = 111 /* _BinaryenGeSVecI64x2 */,\n  /** f32x4.eq */\n  EqF32x4 = 112 /* _BinaryenEqVecF32x4 */,\n  /** f32x4.ne */\n  NeF32x4 = 113 /* _BinaryenNeVecF32x4 */,\n  /** f32x4.lt */\n  LtF32x4 = 114 /* _BinaryenLtVecF32x4 */,\n  /** f32x4.gt */\n  GtF32x4 = 115 /* _BinaryenGtVecF32x4 */,\n  /** f32x4.le */\n  LeF32x4 = 116 /* _BinaryenLeVecF32x4 */,\n  /** f32x4.ge */\n  GeF32x4 = 117 /* _BinaryenGeVecF32x4 */,\n  /** f64x2.eq */\n  EqF64x2 = 118 /* _BinaryenEqVecF64x2 */,\n  /** f64x2.ne */\n  NeF64x2 = 119 /* _BinaryenNeVecF64x2 */,\n  /** f64x2.lt */\n  LtF64x2 = 120 /* _BinaryenLtVecF64x2 */,\n  /** f64x2.gt */\n  GtF64x2 = 121 /* _BinaryenGtVecF64x2 */,\n  /** f64x2.le */\n  LeF64x2 = 122 /* _BinaryenLeVecF64x2 */,\n  /** f64x2.ge */\n  GeF64x2 = 123 /* _BinaryenGeVecF64x2 */,\n  /** v128.and */\n  AndV128 = 124 /* _BinaryenAndVec128 */,\n  /** v128.or */\n  OrV128 = 125 /* _BinaryenOrVec128 */,\n  /** v128.xor */\n  XorV128 = 126 /* _BinaryenXorVec128 */,\n  /** v128.andnot */\n  AndnotV128 = 127 /* _BinaryenAndNotVec128 */,\n  /** i8x16.add */\n  AddI8x16 = 128 /* _BinaryenAddVecI8x16 */,\n  /** i8x16.add_sat_s */\n  AddSatI8x16 = 129 /* _BinaryenAddSatSVecI8x16 */,\n  /** i8x16.add_sat_u */\n  AddSatU8x16 = 130 /* _BinaryenAddSatUVecI8x16 */,\n  /** i8x16.sub */\n  SubI8x16 = 131 /* _BinaryenSubVecI8x16 */,\n  /** i8x16.sub_sat_s */\n  SubSatI8x16 = 132 /* _BinaryenSubSatSVecI8x16 */,\n  /** i8x16.sub_sat_u */\n  SubSatU8x16 = 133 /* _BinaryenSubSatUVecI8x16 */,\n  /** i8x16.min_s */\n  MinI8x16 = 134 /* _BinaryenMinSVecI8x16 */,\n  /** i8x16.min_u */\n  MinU8x16 = 135 /* _BinaryenMinUVecI8x16 */,\n  /** i8x16.max_s */\n  MaxI8x16 = 136 /* _BinaryenMaxSVecI8x16 */,\n  /** i8x16.max_u */\n  MaxU8x16 = 137 /* _BinaryenMaxUVecI8x16 */,\n  /** i8x16.avgr_u */\n  AvgrU8x16 = 138 /* _BinaryenAvgrUVecI8x16 */,\n  /** i16x8.add */\n  AddI16x8 = 139 /* _BinaryenAddVecI16x8 */,\n  /** i16x8.add_sat_s */\n  AddSatI16x8 = 140 /* _BinaryenAddSatSVecI16x8 */,\n  /** i16x8.add_sat_u */\n  AddSatU16x8 = 141 /* _BinaryenAddSatUVecI16x8 */,\n  /** i16x8.sub */\n  SubI16x8 = 142 /* _BinaryenSubVecI16x8 */,\n  /** i16x8.sub_sat_s */\n  SubSatI16x8 = 143 /* _BinaryenSubSatSVecI16x8 */,\n  /** i16x8.sub_sat_u */\n  SubSatU16x8 = 144 /* _BinaryenSubSatUVecI16x8 */,\n  /** i16x8.mul */\n  MulI16x8 = 145 /* _BinaryenMulVecI16x8 */,\n  /** i16x8.min_s */\n  MinI16x8 = 146 /* _BinaryenMinSVecI16x8 */,\n  /** i16x8.min_u */\n  MinU16x8 = 147 /* _BinaryenMinUVecI16x8 */,\n  /** i16x8.max_s */\n  MaxI16x8 = 148 /* _BinaryenMaxSVecI16x8 */,\n  /** i16x8.max_u */\n  MaxU16x8 = 149 /* _BinaryenMaxUVecI16x8 */,\n  /** i16x8.avgr_u */\n  AvgrU16x8 = 150 /* _BinaryenAvgrUVecI16x8 */,\n  /** i16x8.q15mulr_sat_s */\n  Q15mulrSatI16x8 = 151 /* _BinaryenQ15MulrSatSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_s */\n  ExtmulLowI16x8 = 152 /* _BinaryenExtMulLowSVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_s */\n  ExtmulHighI16x8 = 153 /* _BinaryenExtMulHighSVecI16x8 */,\n  /** i16x8.extmul_low_i8x16_u */\n  ExtmulLowU16x8 = 154 /* _BinaryenExtMulLowUVecI16x8 */,\n  /** i16x8.extmul_high_i8x16_u */\n  ExtmulHighU16x8 = 155 /* _BinaryenExtMulHighUVecI16x8 */,\n  /** i32x4.add */\n  AddI32x4 = 156 /* _BinaryenAddVecI32x4 */,\n  /** i32x4.sub */\n  SubI32x4 = 157 /* _BinaryenSubVecI32x4 */,\n  /** i32x4.mul */\n  MulI32x4 = 158 /* _BinaryenMulVecI32x4 */,\n  /** i32x4.min_s */\n  MinI32x4 = 159 /* _BinaryenMinSVecI32x4 */,\n  /** i32x4.min_u */\n  MinU32x4 = 160 /* _BinaryenMinUVecI32x4 */,\n  /** i32x4.max_s */\n  MaxI32x4 = 161 /* _BinaryenMaxSVecI32x4 */,\n  /** i32x4.max_u */\n  MaxU32x4 = 162 /* _BinaryenMaxUVecI32x4 */,\n  /** i32x4.dot_i16x8_s */\n  DotI16x8 = 163 /* _BinaryenDotSVecI16x8ToVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_s */\n  ExtmulLowI32x4 = 164 /* _BinaryenExtMulLowSVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_s */\n  ExtmulHighI32x4 = 165 /* _BinaryenExtMulHighSVecI32x4 */,\n  /** i32x4.extmul_low_i16x8_u */\n  ExtmulLowU32x4 = 166 /* _BinaryenExtMulLowUVecI32x4 */,\n  /** i32x4.extmul_high_i16x8_u */\n  ExtmulHighU32x4 = 167 /* _BinaryenExtMulHighUVecI32x4 */,\n  /** i64x2.add */\n  AddI64x2 = 168 /* _BinaryenAddVecI64x2 */,\n  /** i64x2.sub */\n  SubI64x2 = 169 /* _BinaryenSubVecI64x2 */,\n  /** i64x2.mul */\n  MulI64x2 = 170 /* _BinaryenMulVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_s */\n  ExtmulLowI64x2 = 171 /* _BinaryenExtMulLowSVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_s */\n  ExtmulHighI64x2 = 172 /* _BinaryenExtMulHighSVecI64x2 */,\n  /** i64x2.extmul_low_i32x4_u */\n  ExtmulLowU64x2 = 173 /* _BinaryenExtMulLowUVecI64x2 */,\n  /** i64x2.extmul_high_i32x4_u */\n  ExtmulHighU64x2 = 174 /* _BinaryenExtMulHighUVecI64x2 */,\n  /** f32x4.add */\n  AddF32x4 = 175 /* _BinaryenAddVecF32x4 */,\n  /** f32x4.sub */\n  SubF32x4 = 176 /* _BinaryenSubVecF32x4 */,\n  /** f32x4.mul */\n  MulF32x4 = 177 /* _BinaryenMulVecF32x4 */,\n  /** f32x4.div */\n  DivF32x4 = 178 /* _BinaryenDivVecF32x4 */,\n  /** f32x4.min */\n  MinF32x4 = 179 /* _BinaryenMinVecF32x4 */,\n  /** f32x4.max */\n  MaxF32x4 = 180 /* _BinaryenMaxVecF32x4 */,\n  /** f32x4.pmin */\n  PminF32x4 = 181 /* _BinaryenPMinVecF32x4 */,\n  /** f32x4.pmax */\n  PmaxF32x4 = 182 /* _BinaryenPMaxVecF32x4 */,\n  /** f64x2.add */\n  AddF64x2 = 183 /* _BinaryenAddVecF64x2 */,\n  /** f64x2.sub */\n  SubF64x2 = 184 /* _BinaryenSubVecF64x2 */,\n  /** f64x2.mul */\n  MulF64x2 = 185 /* _BinaryenMulVecF64x2 */,\n  /** f64x2.div */\n  DivF64x2 = 186 /* _BinaryenDivVecF64x2 */,\n  /** f64x2.min */\n  MinF64x2 = 187 /* _BinaryenMinVecF64x2 */,\n  /** f64x2.max */\n  MaxF64x2 = 188 /* _BinaryenMaxVecF64x2 */,\n  /** f64x2.pmin */\n  PminF64x2 = 189 /* _BinaryenPMinVecF64x2 */,\n  /** f64x2.pmax */\n  PmaxF64x2 = 190 /* _BinaryenPMaxVecF64x2 */,\n  /** i8x16.narrow_i16x8_s */\n  NarrowI16x8ToI8x16 = 191 /* _BinaryenNarrowSVecI16x8ToVecI8x16 */,\n  /** i8x16.narrow_i16x8_u */\n  NarrowU16x8ToU8x16 = 192 /* _BinaryenNarrowUVecI16x8ToVecI8x16 */,\n  /** i16x8.narrow_i32x4_s */\n  NarrowI32x4ToI16x8 = 193 /* _BinaryenNarrowSVecI32x4ToVecI16x8 */,\n  /** i16x8.narrow_i32x4_u */\n  NarrowU32x4ToU16x8 = 194 /* _BinaryenNarrowUVecI32x4ToVecI16x8 */,\n  /** i8x16.swizzle */\n  SwizzleI8x16 = 195 /* _BinaryenSwizzleVec8x16 */,\n\n  _last = SwizzleI8x16,\n\n  // Target dependent\n\n  /** i32.add or i64.add, depending on target word size */\n  AddSize,\n  /** i32.sub or i64.sub, depending on target word size */\n  SubSize,\n  /** i32.mul or i64.mul, depending on target word size */\n  MulSize,\n  /** i32.div_s or i64.div_s, depending on target word size */\n  DivISize,\n  /** i32.div_u or i64.div_u, depending on target word size */\n  DivUSize,\n  /** i32.rem_s or i64.rem_s, depending on target word size */\n  RemISize,\n  /** i32.rem_u or i64.rem_u, depending on target word size */\n  RemUSize,\n  /** i32.and or i64.and, depending on target word size */\n  AndSize,\n  /** i32.or or i64.or, depending on target word size */\n  OrSize,\n  /** i32.xor or i64.xor, depending on target word size */\n  XorSize,\n  /** i32.shl or i64.shl, depending on target word size */\n  ShlSize,\n  /** i32.shr_s or i64.shr_s, depending on target word size */\n  ShrISize,\n  /** i32.shr_u or i64.shr_u, depending on target word size */\n  ShrUSize,\n  /** i32.rotl or i64.rotl, depending on target word size */\n  RotlSize,\n  /** i32.rotr or i64.rotr, depending on target word size */\n  RotrSize,\n  /** i32.eq or i64.eq, depending on target word size */\n  EqSize,\n  /** i32.ne or i64.ne, depending on target word size */\n  NeSize,\n  /** i32.lt_s or i64.lt_s, depending on target word size */\n  LtISize,\n  /** i32.lt_u or i64.lt_u, depending on target word size */\n  LtUSize,\n  /** i32.le_s or i64.le_s, depending on target word size */\n  LeISize,\n  /** i32.le_u or i64.le_u, depending on target word size */\n  LeUSize,\n  /** i32.gt_s or i64.gt_s, depending on target word size */\n  GtISize,\n  /** i32.gt_u or i64.gt_u, depending on target word size */\n  GtUSize,\n  /** i32.ge_s or i64.ge_s, depending on target word size */\n  GeISize,\n  /** i32.ge_u or i64.ge_u, depending on target word size */\n  GeUSize\n}\n\n/** Binaryen atomic read-modify-write operation constants. */\nexport enum AtomicRMWOp {\n  /** i32.atomic.rmw.add, i32.atomic.rmw8.add_u, i32.atomic.rmw16.add_u, i64.atomic.rmw.add, i64.atomic.rmw8.add_u, i64.atomic.rmw16.add_u, i64.atomic.rmw32.add_u */\n  Add = 0 /* _BinaryenAtomicRMWAdd */,\n  /** i32.atomic.rmw.sub, i32.atomic.rmw8.sub_u, i32.atomic.rmw16.sub_u, i64.atomic.rmw.sub, i64.atomic.rmw8.sub_u, i64.atomic.rmw16.sub_u, i64.atomic.rmw32.sub_u */\n  Sub = 1 /* _BinaryenAtomicRMWSub */,\n  /** i32.atomic.rmw.and, i32.atomic.rmw8.and_u, i32.atomic.rmw16.and_u, i64.atomic.rmw.and, i64.atomic.rmw8.and_u, i64.atomic.rmw16.and_u, i64.atomic.rmw32.and_u */\n  And = 2 /* _BinaryenAtomicRMWAnd */,\n  /** i32.atomic.rmw.or, i32.atomic.rmw8.or_u, i32.atomic.rmw16.or_u, i64.atomic.rmw.or, i64.atomic.rmw8.or_u, i64.atomic.rmw16.or_u, i64.atomic.rmw32.or_u */\n  Or = 3 /* _BinaryenAtomicRMWOr */,\n  /** i32.atomic.rmw.xor, i32.atomic.rmw8.xor_u, i32.atomic.rmw16.xor_u, i64.atomic.rmw.xor, i64.atomic.rmw8.xor_u, i64.atomic.rmw16.xor_u, i64.atomic.rmw32.xor_u */\n  Xor = 4 /* _BinaryenAtomicRMWXor */,\n  /** i32.atomic.rmw.xchg, i32.atomic.rmw8.xchg_u, i32.atomic.rmw16.xchg_u, i64.atomic.rmw.xchg, i64.atomic.rmw8.xchg_u, i64.atomic.rmw16.xchg_u, i64.atomic.rmw32.xchg_u */\n  Xchg = 5 /* _BinaryenAtomicRMWXchg */\n}\n\n/** Binaryen SIMD extract operation constants. */\nexport enum SIMDExtractOp {\n  /** i8x16.extract_lane_s */\n  ExtractLaneI8x16 = 0 /* _BinaryenExtractLaneSVecI8x16 */,\n  /** i8x16.extract_lane_u */\n  ExtractLaneU8x16 = 1 /* _BinaryenExtractLaneUVecI8x16 */,\n  /** i16x8.extract_lane_s */\n  ExtractLaneI16x8 = 2 /* _BinaryenExtractLaneSVecI16x8 */,\n  /** i16x8.extract_lane_u */\n  ExtractLaneU16x8 = 3 /* _BinaryenExtractLaneUVecI16x8 */,\n  /** i32x4.extract_lane_s */\n  ExtractLaneI32x4 = 4 /* _BinaryenExtractLaneVecI32x4 */,\n  /** i32x4.extract_lane_u */\n  ExtractLaneI64x2 = 5 /* _BinaryenExtractLaneVecI64x2 */,\n  /** i64x2.extract_lane_s */\n  ExtractLaneF32x4 = 6 /* _BinaryenExtractLaneVecF32x4 */,\n  /** i64x2.extract_lane_u */\n  ExtractLaneF64x2 = 7 /* _BinaryenExtractLaneVecF64x2 */,\n}\n\n/** Binaryen SIMD replace operation constants. */\nexport enum SIMDReplaceOp {\n  /** i8x16.replace_lane */\n  ReplaceLaneI8x16 = 0 /* _BinaryenReplaceLaneVecI8x16 */,\n  /** i16x8.replace_lane */\n  ReplaceLaneI16x8 = 1 /* _BinaryenReplaceLaneVecI16x8 */,\n  /** i32x4.replace_lane */\n  ReplaceLaneI32x4 = 2 /* _BinaryenReplaceLaneVecI32x4 */,\n  /** i64x2.replace_lane */\n  ReplaceLaneI64x2 = 3 /* _BinaryenReplaceLaneVecI64x2 */,\n  /** f32x4.replace_lane */\n  ReplaceLaneF32x4 = 4 /* _BinaryenReplaceLaneVecF32x4 */,\n  /** f64x2.replace_lane */\n  ReplaceLaneF64x2 = 5 /* _BinaryenReplaceLaneVecF64x2 */\n}\n\n/** Binaryen SIMD shift operation constants. */\nexport enum SIMDShiftOp {\n  /** i8x16.shl */\n  ShlI8x16 = 0 /* _BinaryenShlVecI8x16 */,\n  /** i8x16.shr_s */\n  ShrI8x16 = 1 /* _BinaryenShrSVecI8x16 */,\n  /** i8x16.shr_u */\n  ShrU8x16 = 2 /* _BinaryenShrUVecI8x16 */,\n  /** i16x8.shl */\n  ShlI16x8 = 3 /* _BinaryenShlVecI16x8 */,\n  /** i16x8.shr_s */\n  ShrI16x8 = 4 /* _BinaryenShrSVecI16x8 */,\n  /** i16x8.shr_u */\n  ShrU16x8 = 5 /* _BinaryenShrUVecI16x8 */,\n  /** i16x8.shl */\n  ShlI32x4 = 6 /* _BinaryenShlVecI32x4 */,\n  /** i32x4.shr_s */\n  ShrI32x4 = 7 /* _BinaryenShrSVecI32x4 */,\n  /** i32x4.shr_u */\n  ShrU32x4 = 8 /* _BinaryenShrUVecI32x4 */,\n  /** i64x2.shl */\n  ShlI64x2 = 9 /* _BinaryenShlVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrI64x2 = 10 /* _BinaryenShrSVecI64x2 */,\n  /** i64x2.shr_u */\n  ShrU64x2 = 11 /* _BinaryenShrUVecI64x2 */\n}\n\n/** Binaryen SIMD load operation constants. */\nexport enum SIMDLoadOp {\n  /** v128.load8_splat */\n  Load8Splat = 0 /* _BinaryenLoad8SplatVec128 */,\n  /** v128.load16_splat */\n  Load16Splat = 1 /* _BinaryenLoad16SplatVec128 */,\n  /** v128.load32_splat */\n  Load32Splat = 2 /* _BinaryenLoad32SplatVec128 */,\n  /** v128.load64_splat */\n  Load64Splat = 3 /* _BinaryenLoad64SplatVec128 */,\n  /** v128.load8x8_s */\n  Load8x8S = 4 /* _BinaryenLoad8x8SVec128 */,\n  /** v128.load8x8_u */\n  Load8x8U = 5 /* _BinaryenLoad8x8UVec128 */,\n  /** v128.load16x4_s */\n  Load16x4S = 6 /* _BinaryenLoad16x4SVec128 */,\n  /** v128.load16x4_u */\n  Load16x4U = 7 /* _BinaryenLoad16x4UVec128 */,\n  /** v128.load32x2_s */\n  Load32x2S = 8 /* _BinaryenLoad32x2SVec128 */,\n  /** v128.load32x2_u */\n  Load32x2U = 9 /* _BinaryenLoad32x2UVec128 */,\n  /** v128.load32_zero */\n  Load32Zero = 10 /* _BinaryenLoad32ZeroVec128 */,\n  /** v128.load64_zero */\n  Load64Zero = 11 /* _BinaryenLoad64ZeroVec128 */,\n}\n\n/** Binaryen SIMD load/store lane operation constants. */\nexport enum SIMDLoadStoreLaneOp {\n  /** v128.load8_lane */\n  Load8Lane = 0 /* _BinaryenLoad8LaneVec128 */,\n  /** v128.load16_lane */\n  Load16Lane = 1 /* _BinaryenLoad16LaneVec128 */,\n  /** v128.load32_lane */\n  Load32Lane = 2 /* _BinaryenLoad32LaneVec128 */,\n  /** v128.load64_lane */\n  Load64Lane = 3 /* _BinaryenLoad64LaneVec128 */,\n  /** v128.store8_lane */\n  Store8Lane = 4 /* _BinaryenStore8LaneVec128 */,\n  /** v128.store16_lane */\n  Store16Lane = 5 /* _BinaryenStore16LaneVec128 */,\n  /** v128.store32_lane */\n  Store32Lane = 6 /* _BinaryenStore32LaneVec128 */,\n  /** v128.store64_lane */\n  Store64Lane = 7 /* _BinaryenStore64LaneVec128 */,\n}\n\n/** Binaryen SIMD ternary operation constants. */\nexport enum SIMDTernaryOp {\n  /** v128.bitselect */\n  Bitselect = 0 /* _BinaryenBitselectVec128 */\n}\n\n/** Binaryen RefIs operation constants. */\nexport enum RefIsOp {\n  /** ref.is_null */\n  RefIsNull = 0 /* _BinaryenRefIsNull */,\n  /** ref.is_func */\n  RefIsFunc = 1 /* _BinaryenRefIsFunc */,\n  /** ref.is_data */\n  RefIsData = 2 /* _BinaryenRefIsData */,\n  /** ref.is_i31 */\n  RefIsI31 = 3 /* _BinaryenRefIsI31 */\n}\n\n/** Binaryen RefAs operation constants. */\nexport enum RefAsOp {\n  /** ref.as_non_null */\n  RefAsNonNull = 0 /* _BinaryenRefAsNonNull */,\n  /** ref.as_func */\n  RefAsFunc = 1 /* _BinaryenRefAsFunc */,\n  /** ref.as_data */\n  RefAsData = 2 /* _BinaryenRefAsData */,\n  /** ref.as_i31 */\n  RefAsI31 = 3 /* _BinaryenRefAsI31 */\n}\n\n/** Binaryen BrOn operation constants. */\nexport enum BrOnOp {\n  /** br_on_null */\n  BrOnNull = 0 /* TODO_BinaryenBrOnNull */,\n  /** br_on_cast */\n  BrOnCast = 1 /* TODO_BinaryenBrOnCast */,\n  /** br_on_func */\n  BrOnFunc = 2 /* TODO_BinaryenBrOnFunc */,\n  /** br_on_data */\n  BrOnData = 3 /* TODO_BinaryenBrOnData */,\n  /** br_on_i31 */\n  BrOnI31 = 4 /* TODO_BinaryenBrOnI31 */\n}\n\n/** Binaryen expression runner flags. */\nexport enum ExpressionRunnerFlags {\n  Default = 0 /* _ExpressionRunnerFlagsDefault */,\n  PreserveSideeffects = 1 /* _ExpressionRunnerFlagsPreserveSideeffects */,\n  TraverseCalls = 2 /* _ExpressionRunnerFlagsTraverseCalls */\n}\n\nexport class MemorySegment {\n  constructor(\n    /** Segment data. */\n    public buffer: Uint8Array,\n    /** Segment offset. */\n    public offset: i64\n  ) {}\n}\n\nexport class Module {\n  constructor(\n    /** Binaryen module reference. */\n    public ref: ModuleRef,\n    /** Whether a shadow stack is used. */\n    public useShadowStack: bool,\n    /** Architecture-dependent size type. */\n    public sizeType: TypeRef\n  ) {\n    assert(sizeType == TypeRef.I32 || sizeType == TypeRef.I64);\n    this.lit = binaryen._malloc(binaryen._BinaryenSizeofLiteral());\n  }\n\n  private lit: usize;\n\n  static create(useShadowStack: bool, sizeType: TypeRef): Module {\n    return new Module(binaryen._BinaryenModuleCreate(), useShadowStack, sizeType);\n  }\n\n  static createFrom(buffer: Uint8Array, useShadowStack: bool, sizeType: TypeRef): Module {\n    var cArr = allocU8Array(buffer);\n    var module = new Module(binaryen._BinaryenModuleRead(cArr, buffer.length), useShadowStack, sizeType);\n    binaryen._free(changetype<usize>(cArr));\n    return module;\n  }\n\n  // constants\n\n  i32(value: i32): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralInt32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  i64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralInt64(out, valueLow, valueHigh);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  // isize<T>(value: T): ExpressionRef {\n  //   if (i64_is(value)) {\n  //     if (this.sizeType == TypeRef.I64) {\n  //       return this.i64(i64_low(value), i64_high(value));\n  //     }\n  //     assert(i64_is_i32(value));\n  //     return this.i32(i64_low(value));\n  //   }\n  //   return this.sizeType == TypeRef.I64\n  //     ? this.i64(i32(value), i32(value) < 0 ? -1 : 0)\n  //     : this.i32(i32(value));\n  // }\n\n  usize<T>(value: T): ExpressionRef {\n    if (i64_is(value)) {\n      if (this.sizeType == TypeRef.I64) {\n        return this.i64(i64_low(value), i64_high(value));\n      }\n      assert(i64_is_u32(value));\n      return this.i32(i64_low(value));\n    }\n    return this.sizeType == TypeRef.I64\n      ? this.i64(i32(value))\n      : this.i32(i32(value));\n  }\n\n  f32(value: f32): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralFloat32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  f64(value: f64): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralFloat64(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  v128(bytes: Uint8Array): ExpressionRef {\n    assert(bytes.length == 16);\n    var out = this.lit;\n    for (let i = 0; i < 16; ++i) {\n      binaryen.__i32_store8(out + i, bytes[i]);\n    }\n    binaryen._BinaryenLiteralVec128(out, out);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  ref_null(type: TypeRef): ExpressionRef {\n    return binaryen._BinaryenRefNull(this.ref, type);\n  }\n\n  ref_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenRefEq(this.ref, left, right);\n  }\n\n  // expressions\n\n  unary(\n    op: UnaryOp,\n    value: ExpressionRef\n  ): ExpressionRef {\n    if (op > UnaryOp._last) {\n      let isWam64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case UnaryOp.ClzSize: return this.unary(isWam64 ? UnaryOp.ClzI64 : UnaryOp.ClzI32, value);\n        case UnaryOp.CtzSize: return this.unary(isWam64 ? UnaryOp.CtzI64 : UnaryOp.CtzI32, value);\n        case UnaryOp.PopcntSize: return this.unary(isWam64 ? UnaryOp.PopcntI64 : UnaryOp.PopcntI32, value);\n        case UnaryOp.EqzSize: return this.unary(isWam64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32, value);\n      }\n      assert(false);\n    }\n    return binaryen._BinaryenUnary(this.ref, op, value);\n  }\n\n  binary(\n    op: BinaryOp,\n    left: ExpressionRef,\n    right: ExpressionRef\n  ): ExpressionRef {\n    if (op > BinaryOp._last) {\n      let isWasm64 = this.sizeType == TypeRef.I64;\n      switch (op) {\n        case BinaryOp.AddSize: return this.binary(isWasm64 ? BinaryOp.AddI64 : BinaryOp.AddI32, left, right);\n        case BinaryOp.SubSize: return this.binary(isWasm64 ? BinaryOp.SubI64 : BinaryOp.SubI32, left, right);\n        case BinaryOp.MulSize: return this.binary(isWasm64 ? BinaryOp.MulI64 : BinaryOp.MulI32, left, right);\n        case BinaryOp.DivISize: return this.binary(isWasm64 ? BinaryOp.DivI64 : BinaryOp.DivI32, left, right);\n        case BinaryOp.DivUSize: return this.binary(isWasm64 ? BinaryOp.DivU64 : BinaryOp.DivU32, left, right);\n        case BinaryOp.RemISize: return this.binary(isWasm64 ? BinaryOp.RemI64 : BinaryOp.RemI32, left, right);\n        case BinaryOp.RemUSize: return this.binary(isWasm64 ? BinaryOp.RemU64 : BinaryOp.RemU32, left, right);\n        case BinaryOp.AndSize: return this.binary(isWasm64 ? BinaryOp.AndI64 : BinaryOp.AndI32, left, right);\n        case BinaryOp.OrSize: return this.binary(isWasm64 ? BinaryOp.OrI64 : BinaryOp.OrI32, left, right);\n        case BinaryOp.XorSize: return this.binary(isWasm64 ? BinaryOp.XorI64 : BinaryOp.XorI32, left, right);\n        case BinaryOp.ShlSize: return this.binary(isWasm64 ? BinaryOp.ShlI64 : BinaryOp.ShlI32, left, right);\n        case BinaryOp.ShrISize: return this.binary(isWasm64 ? BinaryOp.ShrI64 : BinaryOp.ShrI32, left, right);\n        case BinaryOp.ShrUSize: return this.binary(isWasm64 ? BinaryOp.ShrU64 : BinaryOp.ShrU32, left, right);\n        case BinaryOp.RotlSize: return this.binary(isWasm64 ? BinaryOp.RotlI64 : BinaryOp.RotlI32, left, right);\n        case BinaryOp.RotrSize: return this.binary(isWasm64 ? BinaryOp.RotrI64 : BinaryOp.RotrI32, left, right);\n        case BinaryOp.EqSize: return this.binary(isWasm64 ? BinaryOp.EqI64 : BinaryOp.EqI32, left, right);\n        case BinaryOp.NeSize: return this.binary(isWasm64 ? BinaryOp.NeI64 : BinaryOp.NeI32, left, right);\n        case BinaryOp.LtISize: return this.binary(isWasm64 ? BinaryOp.LtI64 : BinaryOp.LtI32, left, right);\n        case BinaryOp.LtUSize: return this.binary(isWasm64 ? BinaryOp.LtU64 : BinaryOp.LtU32, left, right);\n        case BinaryOp.LeISize: return this.binary(isWasm64 ? BinaryOp.LeI64 : BinaryOp.LeI32, left, right);\n        case BinaryOp.LeUSize: return this.binary(isWasm64 ? BinaryOp.LeU64 : BinaryOp.LeU32, left, right);\n        case BinaryOp.GtISize: return this.binary(isWasm64 ? BinaryOp.GtI64 : BinaryOp.GtI32, left, right);\n        case BinaryOp.GtUSize: return this.binary(isWasm64 ? BinaryOp.GtU64 : BinaryOp.GtU32, left, right);\n        case BinaryOp.GeISize: return this.binary(isWasm64 ? BinaryOp.GeI64 : BinaryOp.GeI32, left, right);\n        case BinaryOp.GeUSize: return this.binary(isWasm64 ? BinaryOp.GeU64 : BinaryOp.GeU32, left, right);\n      }\n      assert(false);\n    }\n    return binaryen._BinaryenBinary(this.ref, op, left, right);\n  }\n\n  memory_size(): ExpressionRef {\n    return binaryen._BinaryenMemorySize(this.ref);\n  }\n\n  memory_grow(delta: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenMemoryGrow(this.ref, delta);\n  }\n\n  table_size(name: string): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSize(this.ref, cStr);\n  }\n\n  table_grow(name: string, delta: ExpressionRef, value: ExpressionRef = 0): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGrow(this.ref, cStr, value, delta);\n  }\n\n  local_get(\n    index: i32,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenLocalGet(this.ref, index, type);\n  }\n\n  tostack(value: ExpressionRef): ExpressionRef {\n    if (this.useShadowStack) {\n      let type = binaryen._BinaryenExpressionGetType(value);\n      assert(type == TypeRef.I32 || type == TypeRef.Unreachable);\n      return this.call(BuiltinNames.tostack, [ value ], type);\n    }\n    return value;\n  }\n\n  local_tee(\n    index: i32,\n    value: ExpressionRef,\n    isManaged: bool,\n    type: TypeRef = TypeRef.Auto,\n  ): ExpressionRef {\n    if (type == TypeRef.Auto) type = binaryen._BinaryenExpressionGetType(value);\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalTee(this.ref, index, value, type);\n  }\n\n  global_get(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalGet(this.ref, cStr, type);\n  }\n\n  table_get(\n    name: string,\n    index: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableGet(this.ref, cStr, index, type);\n  }\n\n  load(\n    bytes: Index,\n    signed: bool,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes // naturally aligned by default\n  ): ExpressionRef {\n    return binaryen._BinaryenLoad(this.ref, bytes, signed, offset, align, type, ptr);\n  }\n\n  store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0,\n    align: Index = bytes // naturally aligned by default\n  ): ExpressionRef {\n    return binaryen._BinaryenStore(this.ref, bytes, offset, align, ptr, value, type);\n  }\n\n  atomic_load(\n    bytes: Index,\n    ptr: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr);\n  }\n\n  atomic_store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef,\n    offset: Index = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type);\n  }\n\n  atomic_rmw(\n    op: AtomicRMWOp,\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type);\n  }\n\n  atomic_cmpxchg(\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    replacement: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type);\n  }\n\n  atomic_wait(\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    timeout: ExpressionRef,\n    expectedType: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType);\n  }\n\n  atomic_notify(\n    ptr: ExpressionRef,\n    notifyCount: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicNotify(this.ref, ptr, notifyCount);\n  }\n\n  atomic_fence(): ExpressionRef {\n    return binaryen._BinaryenAtomicFence(this.ref);\n  }\n\n  // statements\n\n  local_set(\n    index: Index,\n    value: ExpressionRef,\n    isManaged: bool\n  ): ExpressionRef {\n    if (isManaged && this.useShadowStack) {\n      value = this.tostack(value);\n    }\n    return binaryen._BinaryenLocalSet(this.ref, index, value);\n  }\n\n  global_set(\n    name: string,\n    value: ExpressionRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalSet(this.ref, cStr, value);\n  }\n\n  table_set(\n    name: string,\n    index: ExpressionRef,\n    value: ExpressionRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenTableSet(this.ref, cStr, index, value);\n  }\n\n  block(\n    label: string | null,\n    children: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    var cArr = allocPtrArray(children);\n    var ret = binaryen._BinaryenBlock(this.ref, cStr, cArr, children.length, type);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  /** Attempts to trivially flatten a series of expressions instead of emitting a block. */\n  flatten(\n    stmts: ExpressionRef[],\n    type: TypeRef = TypeRef.None\n  ): ExpressionRef {\n    var length = stmts.length;\n    if (length == 0) return this.nop(); // usually filtered out again\n    if (length == 1) {\n      let single = stmts[0];\n      switch (getExpressionId(single)) {\n        case ExpressionId.Return:\n        case ExpressionId.Throw:\n        case ExpressionId.Unreachable: {\n          // type does no matter, terminates anyway\n          return single;\n        }\n      }\n      let singleType = getExpressionType(single);\n      assert(singleType == TypeRef.Unreachable || singleType == type);\n      return single;\n    }\n    return this.block(null, stmts, type);\n  }\n\n  br(\n    label: string | null,\n    condition: ExpressionRef = 0,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    return binaryen._BinaryenBreak(this.ref, cStr, condition, value);\n  }\n\n  drop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenDrop(this.ref, expression);\n  }\n\n  maybeDropCondition(condition: ExpressionRef, result: ExpressionRef): ExpressionRef {\n    // FIXME: This is necessary because Binaryen's ExpressionRunner bails early\n    // when encountering a local with an unknown value. This helper only drops\n    // the pre-evaluated condition if it has relevant side effects.\n    // see WebAssembly/binaryen#1237\n    if ((getSideEffects(condition, this.ref) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != 0) {\n      return this.block(null, [\n        this.drop(condition),\n        result\n      ], getExpressionType(result));\n    }\n    return result;\n  }\n\n  loop(\n    label: string | null,\n    body: ExpressionRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    return binaryen._BinaryenLoop(this.ref, cStr, body);\n  }\n\n  if(\n    condition: ExpressionRef,\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenIf(this.ref, condition, ifTrue, ifFalse);\n  }\n\n  nop(): ExpressionRef {\n    return binaryen._BinaryenNop(this.ref);\n  }\n\n  return(\n    expression: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenReturn(this.ref, expression);\n  }\n\n  select(\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef,\n    condition: ExpressionRef,\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSelect(this.ref, condition, ifTrue, ifFalse, type);\n  }\n\n  switch(\n    names: string[],\n    defaultName: string | null,\n    condition: ExpressionRef,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    var numNames = names.length;\n    var strs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      strs[i] = this.allocStringCached(names[i]);\n    }\n    var cArr = allocPtrArray(strs);\n    var cStr = this.allocStringCached(defaultName);\n    var ret = binaryen._BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(target);\n    var cArr = allocPtrArray(operands);\n    var ret = isReturn\n      ? binaryen._BinaryenReturnCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        )\n      : binaryen._BinaryenCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: TypeRef\n  ): ExpressionRef {\n    return this.call(target, operands, returnType, true);\n  }\n\n  call_indirect(\n    tableName: string | null,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef,\n    isReturn: bool = false\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(tableName !== null ? tableName : \"0\");\n    var cArr = allocPtrArray(operands);\n    var ret = isReturn\n      ? binaryen._BinaryenReturnCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        )\n      : binaryen._BinaryenCallIndirect(\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call_indirect(\n    tableName: string | null,\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: TypeRef,\n    results: TypeRef\n  ): ExpressionRef {\n    return this.call_indirect(tableName, index, operands, params, results, true);\n  }\n\n  unreachable(): ExpressionRef {\n    return binaryen._BinaryenUnreachable(this.ref);\n  }\n\n  // bulk memory\n\n  memory_copy(\n    dest: ExpressionRef,\n    source: ExpressionRef,\n    size: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenMemoryCopy(this.ref, dest, source, size);\n  }\n\n  memory_fill(\n    dest: ExpressionRef,\n    value: ExpressionRef,\n    size: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenMemoryFill(this.ref, dest, value, size);\n  }\n\n  // exception handling\n\n  try(\n    name: string | null,\n    body: ExpressionRef,\n    catchTags: string[],\n    catchBodies: ExpressionRef[],\n    delegateTarget: string | null = null\n  ): ExpressionRef {\n    var numCatchTags = catchTags.length;\n    var strs = new Array<TagRef>(numCatchTags);\n    for (let i = 0; i < numCatchTags; ++i) {\n      strs[i] = this.allocStringCached(catchTags[i]);\n    }\n    var cArr1 = allocPtrArray(strs);\n    var cArr2 = allocPtrArray(catchBodies);\n    var cStr1 = this.allocStringCached(name);\n    var cStr2 = this.allocStringCached(delegateTarget);\n    var ret = binaryen._BinaryenTry(\n      this.ref, cStr1, body, cArr1, numCatchTags, cArr2, catchBodies.length, cStr2\n    );\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    return ret;\n  }\n\n  throw(\n    tagName: string,\n    operands: ExpressionRef[]\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(tagName);\n    var cArr = allocPtrArray(operands);\n    var ret = binaryen._BinaryenThrow(this.ref, cStr, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  rethrow(\n    target: string\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(target);\n    return binaryen._BinaryenRethrow(this.ref, cStr);\n  }\n\n  // multi value (pseudo instructions)\n\n  pop(\n    type: TypeRef\n  ): ExpressionRef {\n    return binaryen._BinaryenPop(this.ref, type);\n  }\n\n  tuple_make(operands: ExpressionRef[]): ExpressionRef {\n    var cArr = allocPtrArray(operands);\n    var ret = binaryen._BinaryenTupleMake(this.ref, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  tuple_extract(tuple: ExpressionRef, index: Index): ExpressionRef {\n    return binaryen._BinaryenTupleExtract(this.ref, tuple, index);\n  }\n\n  // simd\n\n  simd_extract(\n    op: SIMDExtractOp,\n    vec: ExpressionRef,\n    idx: u8\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDExtract(this.ref, op, vec, idx);\n  }\n\n  simd_replace(\n    op: SIMDReplaceOp,\n    vec: ExpressionRef,\n    idx: u8,\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDReplace(this.ref, op, vec, idx, value);\n  }\n\n  simd_shuffle(\n    vec1: ExpressionRef,\n    vec2: ExpressionRef,\n    mask: Uint8Array\n  ): ExpressionRef {\n    assert(mask.length == 16);\n    var cArr = allocU8Array(mask);\n    var ret = binaryen._BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  simd_ternary(\n    op: SIMDTernaryOp,\n    a: ExpressionRef,\n    b: ExpressionRef,\n    c: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDTernary(this.ref, op, a, b, c);\n  }\n\n  simd_shift(\n    op: SIMDShiftOp,\n    vec: ExpressionRef,\n    shift: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDShift(this.ref, op, vec, shift);\n  }\n\n  simd_load(\n    op: SIMDLoadOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDLoad(this.ref, op, offset, align, ptr);\n  }\n\n  simd_loadstorelane(\n    op: SIMDLoadStoreLaneOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32,\n    index: u8,\n    vec: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDLoadStoreLane(this.ref, op, offset, align, index, ptr, vec);\n  }\n\n  // reference types / gc\n\n  ref_is(\n    op: RefIsOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefIs(this.ref, op, expr);\n  }\n\n  ref_as(\n    op: RefAsOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefAs(this.ref, op, expr);\n  }\n\n  ref_func(\n    name: string,\n    type: TypeRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenRefFunc(this.ref, cStr, type);\n  }\n\n  i31_new(\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenI31New(this.ref, value);\n  }\n\n  i31_get(\n    expr: ExpressionRef,\n    signed: bool\n  ): ExpressionRef {\n    return binaryen._BinaryenI31Get(this.ref, expr, signed);\n  }\n\n  // globals\n\n  addGlobal(\n    name: string,\n    type: TypeRef,\n    mutable: bool,\n    initializer: ExpressionRef\n  ): GlobalRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);\n  }\n\n  getGlobal(\n    name: string\n  ): GlobalRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetGlobal(this.ref, cStr);\n  }\n\n  removeGlobal(\n    name: string\n  ): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveGlobal(this.ref, cStr);\n  }\n\n  // tags\n\n  addTag(\n    name: string,\n    params: TypeRef,\n    results: TypeRef\n  ): TagRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddTag(this.ref, cStr, params, results);\n  }\n\n  getTag(\n    name: string\n  ): TagRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetTag(this.ref, cStr);\n  }\n\n  removeTag(\n    name: string\n  ): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveTag(this.ref, cStr);\n  }\n\n  // functions\n\n  addFunction(\n    name: string,\n    params: TypeRef,\n    results: TypeRef,\n    varTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    var cStr = this.allocStringCached(name);\n    var cArr = allocPtrArray(varTypes);\n    var ret = binaryen._BinaryenAddFunction(\n      this.ref,\n      cStr,\n      params,\n      results,\n      cArr,\n      varTypes ? varTypes.length : 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  getFunction(\n    name: string\n  ): FunctionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr);\n  }\n\n  removeFunction(name: string): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveFunction(this.ref, cStr);\n  }\n\n  hasFunction(name: string): bool {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr) != 0;\n  }\n\n  private hasTemporaryFunction: bool = false;\n\n  addTemporaryFunction(\n    result: TypeRef,\n    paramTypes: TypeRef[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);\n    var tempName = this.allocStringCached(\"\");\n    var cArr = allocPtrArray(paramTypes);\n    var ret = binaryen._BinaryenAddFunction(this.ref,\n      tempName,\n      createType(paramTypes),\n      result,\n      0, 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  removeTemporaryFunction(): void {\n    this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);\n    var tempName = this.allocStringCached(\"\");\n    binaryen._BinaryenRemoveFunction(this.ref, tempName);\n  }\n\n  setStart(func: FunctionRef): void {\n    binaryen._BinaryenSetStart(this.ref, func);\n  }\n\n  // exports\n\n  addFunctionExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\n  }\n\n  addTableExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTableExport(this.ref, cStr1, cStr2);\n  }\n\n  addMemoryExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\n  }\n\n  addGlobalExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\n  }\n\n  addTagExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTagExport(this.ref, cStr1, cStr2);\n  }\n\n  removeExport(externalName: string): void {\n    var cStr = this.allocStringCached(externalName);\n    binaryen._BinaryenRemoveExport(this.ref, cStr);\n  }\n\n  hasExport(externalName: string): bool {\n    var cStr = this.allocStringCached(externalName);\n    return binaryen._BinaryenGetExport(this.ref, cStr) != 0;\n  }\n\n  // imports\n\n  addFunctionImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, params, results);\n  }\n\n  addTableImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\n  }\n\n  addMemoryImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    shared: bool = false,\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);\n  }\n\n  addGlobalImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    globalType: TypeRef,\n    mutable: bool = false\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);\n  }\n\n  addTagImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: TypeRef,\n    results: TypeRef\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTagImport(\n      this.ref, cStr1, cStr2, cStr3, params, results\n    );\n  }\n\n  // memory\n\n  /** Unlimited memory constant. */\n  static readonly UNLIMITED_MEMORY: Index = <Index>-1;\n\n  setMemory(\n    initial: Index,\n    maximum: Index,\n    segments: MemorySegment[],\n    target: Target,\n    exportName: string | null = null,\n    shared: bool = false\n  ): void {\n    var cStr = this.allocStringCached(exportName);\n    var k = segments.length;\n    var segs = new Array<usize>(k);\n    var psvs = new Uint8Array(k);\n    var offs = new Array<ExpressionRef>(k);\n    var sizs = new Array<Index>(k);\n    for (let i = 0; i < k; ++i) {\n      let segment = segments[i];\n      let buffer = segment.buffer;\n      let offset = segment.offset;\n      segs[i] = allocU8Array(buffer);\n      psvs[i] = 0; // no passive segments currently\n      offs[i] = target == Target.WASM64\n        ? this.i64(i64_low(offset), i64_high(offset))\n        : this.i32(i64_low(offset));\n      sizs[i] = buffer.length;\n    }\n    var cArr1 = allocPtrArray(segs);\n    var cArr2 = allocU8Array(psvs);\n    var cArr3 = allocPtrArray(offs);\n    var cArr4 = allocU32Array(sizs);\n    binaryen._BinaryenSetMemory(\n      this.ref, initial, maximum, cStr, cArr1, cArr2, cArr3, cArr4, k, shared\n    );\n    binaryen._free(cArr4);\n    binaryen._free(cArr3);\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    for (let i = k - 1; i >= 0; --i) {\n      binaryen._free(segs[i]);\n    }\n  }\n\n  // table\n\n  /** Unlimited table constant. */\n  static readonly UNLIMITED_TABLE: Index = <Index>-1;\n\n  addFunctionTable(\n    name: string,\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    var cStr = this.allocStringCached(name);\n    var numNames = funcs.length;\n    var names = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = this.allocStringCached(funcs[i]);\n    }\n    var cArr = allocPtrArray(names);\n    var tableRef = binaryen._BinaryenGetTable(this.ref, cStr);\n    if (!tableRef) {\n      tableRef = binaryen._BinaryenAddTable(this.ref, cStr, initial, maximum, TypeRef.Funcref);\n    } else {\n      binaryen._BinaryenTableSetInitial(tableRef, initial);\n      binaryen._BinaryenTableSetMax(tableRef, maximum);\n    }\n    binaryen._BinaryenAddActiveElementSegment(this.ref, cStr, cStr, cArr, numNames, offset);\n    binaryen._free(cArr);\n  }\n\n  /* setFunctionTable(\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    var numNames = funcs.length;\n    var names = new Array<CString>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = this.allocStringCached(funcs[i]);\n    }\n    var cArr = allocPtrArray(names);\n    binaryen._BinaryenSetFunctionTable(\n      this.ref, initial, maximum, cArr, numNames, offset\n    );\n    binaryen._free(cArr);\n  } */\n\n  // sections\n\n  addCustomSection(name: string, contents: Uint8Array): void {\n    var cStr = this.allocStringCached(name);\n    var cArr = allocU8Array(contents);\n    binaryen._BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);\n    binaryen._free(cArr);\n  }\n\n  // meta (global)\n\n  getOptimizeLevel(): i32 {\n    return binaryen._BinaryenGetOptimizeLevel();\n  }\n\n  setOptimizeLevel(level: i32): void {\n    binaryen._BinaryenSetOptimizeLevel(level);\n  }\n\n  getShrinkLevel(): i32 {\n    return binaryen._BinaryenGetShrinkLevel();\n  }\n\n  setShrinkLevel(level: i32): void {\n    binaryen._BinaryenSetShrinkLevel(level);\n  }\n\n  getDebugInfo(): boolean {\n    return binaryen._BinaryenGetDebugInfo();\n  }\n\n  setDebugInfo(on: bool): void {\n    binaryen._BinaryenSetDebugInfo(on);\n  }\n\n  getLowMemoryUnused(): bool {\n    return binaryen._BinaryenGetLowMemoryUnused();\n  }\n\n  setLowMemoryUnused(on: bool): void {\n    binaryen._BinaryenSetLowMemoryUnused(on);\n  }\n\n  getZeroFilledMemory(): bool {\n    return binaryen._BinaryenGetZeroFilledMemory();\n  }\n\n  setZeroFilledMemory(on: bool): void {\n    binaryen._BinaryenSetZeroFilledMemory(on);\n  }\n\n  getFastMath(): bool {\n    return binaryen._BinaryenGetFastMath();\n  }\n\n  setFastMath(on: bool): void {\n    binaryen._BinaryenSetFastMath(on);\n  }\n\n  getPassArgument(key: string): string | null {\n    var cStr = this.allocStringCached(key);\n    var ptr = binaryen._BinaryenGetPassArgument(cStr);\n    return ptr ? readString(ptr) : null;\n  }\n\n  setPassArgument(key: string, value: string | null): void {\n    var cStr1 = this.allocStringCached(key);\n    var cStr2 = this.allocStringCached(value);\n    binaryen._BinaryenSetPassArgument(cStr1, cStr2);\n  }\n\n  clearPassArguments(): void {\n    binaryen._BinaryenClearPassArguments();\n  }\n\n  getAlwaysInlineMaxSize(): Index {\n    return binaryen._BinaryenGetAlwaysInlineMaxSize();\n  }\n\n  setAlwaysInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetAlwaysInlineMaxSize(size);\n  }\n\n  getFlexibleInlineMaxSize(): Index {\n    return binaryen._BinaryenGetFlexibleInlineMaxSize();\n  }\n\n  setFlexibleInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetFlexibleInlineMaxSize(size);\n  }\n\n  getOneCallerInlineMaxSize(): Index {\n    return binaryen._BinaryenGetOneCallerInlineMaxSize();\n  }\n\n  setOneCallerInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetOneCallerInlineMaxSize(size);\n  }\n\n  getAllowInliningFunctionsWithLoops(): bool {\n    return binaryen._BinaryenGetAllowInliningFunctionsWithLoops();\n  }\n\n  setAllowInliningFunctionsWithLoops(enabled: bool): void {\n    binaryen._BinaryenSetAllowInliningFunctionsWithLoops(enabled);\n  }\n\n  // meta (module)\n\n  getFeatures(): FeatureFlags {\n    return binaryen._BinaryenModuleGetFeatures(this.ref);\n  }\n\n  setFeatures(featureFlags: FeatureFlags): void {\n    binaryen._BinaryenModuleSetFeatures(this.ref, featureFlags);\n  }\n\n  runPasses(passes: string[], func: FunctionRef = 0): void {\n    var numNames = passes.length;\n    var cStrs = new Array<StringRef>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      cStrs[i] = allocString(passes[i]);\n    }\n    var cArr = allocPtrArray(cStrs);\n    if (func) {\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);\n    } else {\n      binaryen._BinaryenModuleRunPasses(this.ref, cArr, numNames);\n    }\n    binaryen._free(cArr);\n    for (let i = numNames - 1; i >= 0; --i) binaryen._free(cStrs[i]);\n  }\n\n  optimize(\n    optimizeLevel: i32,\n    shrinkLevel: i32,\n    debugInfo: bool = false,\n    zeroFilledMemory: bool = false\n  ): void {\n    // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\n    if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\n\n    this.setOptimizeLevel(optimizeLevel);\n    this.setShrinkLevel(shrinkLevel);\n    this.setDebugInfo(debugInfo);\n    this.setZeroFilledMemory(zeroFilledMemory);\n    this.setFastMath(true);\n    this.clearPassArguments();\n\n    // Tweak inlining limits based on optimization levels\n    if (optimizeLevel >= 2 && shrinkLevel == 0) {\n      this.setAlwaysInlineMaxSize(12);\n      this.setFlexibleInlineMaxSize(70);\n      this.setOneCallerInlineMaxSize(200);\n      this.setAllowInliningFunctionsWithLoops(optimizeLevel >= 3);\n    } else {\n      this.setAlwaysInlineMaxSize(\n        optimizeLevel <= 1 || shrinkLevel >= 2\n          ? 2\n          : 6\n      );\n      this.setFlexibleInlineMaxSize(65);\n      this.setOneCallerInlineMaxSize(80);\n      this.setAllowInliningFunctionsWithLoops(false);\n    }\n\n    // Pass order here differs substantially from Binaryen's defaults\n    // see: Binaryen/src/pass.cpp\n    if (optimizeLevel > 0 || shrinkLevel > 0) {\n      let passes = new Array<string>();\n\n      // --- PassRunner::addDefaultGlobalOptimizationPrePasses ---\n\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"remove-unused-module-elements\"); // +\n\n      // --- PassRunner::addDefaultFunctionOptimizationPasses ---\n      if (optimizeLevel >= 2) {\n        passes.push(\"once-reduction\");\n        passes.push(\"inlining\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n        passes.push(\"code-folding\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"local-cse\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      if (optimizeLevel >= 3) {\n        passes.push(\"simplify-locals-nostructure\");\n        passes.push(\"flatten\");\n        passes.push(\"vacuum\");\n        passes.push(\"simplify-locals-notee-nostructure\");\n        passes.push(\"vacuum\");\n        passes.push(\"licm\");\n        passes.push(\"merge-locals\");\n        passes.push(\"reorder-locals\");\n        passes.push(\"dae-optimizing\");\n      }\n      passes.push(\"optimize-instructions\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"dce\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        passes.push(\"inlining\");\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"pick-load-signs\");\n      }\n      passes.push(\"simplify-locals-notee-nostructure\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"local-cse\");\n      }\n      passes.push(\"reorder-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"simplify-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"reorder-locals\");\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"merge-locals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      passes.push(\"merge-blocks\");\n      if (optimizeLevel >= 3) {\n        passes.push(\"optimize-instructions\");\n      }\n\n      // --- PassRunner::addDefaultGlobalOptimizationPostPasses ---\n\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"inlining-optimizing\");\n      }\n      if (this.getLowMemoryUnused()) {\n        if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n          passes.push(\"optimize-added-constants-propagate\");\n        } else {\n          passes.push(\"optimize-added-constants\");\n        }\n      }\n      passes.push(\"duplicate-import-elimination\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"simplify-globals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 2 && (this.getFeatures() & FeatureFlags.GC) != 0) {\n        passes.push(\"heap2local\");\n        passes.push(\"merge-locals\");\n        passes.push(\"local-subtyping\");\n      }\n      // precompute works best after global optimizations\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"precompute-propagate\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      passes.push(\"directize\"); // replace indirect with direct calls\n      passes.push(\"dae-optimizing\"); // reduce arity\n      passes.push(\"inlining-optimizing\"); // and inline if possible\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"code-folding\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"rse\");\n        // move code on early return (after CFG cleanup)\n        passes.push(\"code-pushing\");\n        if (optimizeLevel >= 3) {\n          // very expensive, so O3 only\n          passes.push(\"simplify-globals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"precompute-propagate\");\n\n          // replace indirect with direct calls again and inline\n          passes.push(\"inlining-optimizing\");\n          passes.push(\"directize\");\n          passes.push(\"dae-optimizing\");\n          passes.push(\"local-cse\");\n\n          passes.push(\"merge-locals\");\n          passes.push(\"coalesce-locals\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"inlining\");\n          passes.push(\"precompute-propagate\");\n          passes.push(\"rse\");\n          passes.push(\"vacuum\");\n          passes.push(\"ssa-nomerge\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"coalesce-locals\");\n        }\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"vacuum\");\n\n        passes.push(\"optimize-instructions\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      // clean up\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"memory-packing\");\n      passes.push(\"remove-unused-module-elements\");\n\n      this.runPasses(passes);\n    }\n  }\n\n  validate(): bool {\n    return binaryen._BinaryenModuleValidate(this.ref) == 1;\n  }\n\n  interpret(): void {\n    binaryen._BinaryenModuleInterpret(this.ref);\n  }\n\n  toBinary(sourceMapUrl: string | null = null): BinaryModule {\n    var out = this.lit; // safe to reuse as long as..\n    assert(binaryen._BinaryenSizeofLiteral() >= 12);\n    var cStr = allocString(sourceMapUrl);\n    var binaryPtr: usize = 0;\n    var sourceMapPtr: usize = 0;\n    binaryen._BinaryenModuleAllocateAndWrite(out, this.ref, cStr);\n    binaryPtr = assert(binaryen.__i32_load(out));\n    var binaryLen = binaryen.__i32_load(out + 4);\n    sourceMapPtr = binaryen.__i32_load(out + 8); // may be NULL\n    var binary = new BinaryModule(readBuffer(binaryPtr, binaryLen), readString(sourceMapPtr));\n    if (cStr) binaryen._free(cStr);\n    binaryen._free(binaryPtr);\n    if (sourceMapPtr) binaryen._free(sourceMapPtr);\n    return binary;\n  }\n\n  toText(watFormat: bool = true): string {\n    throw new Error(\"not implemented\"); // JS glue overrides this\n  }\n\n  toAsmjs(): string {\n    throw new Error(\"not implemented\"); // JS glue overrides this\n  }\n\n  private cachedStringsToPointers: Map<string,usize> = new Map();\n  private cachedPointersToStrings: Map<usize,string | null> = new Map();\n\n  allocStringCached(str: string | null): usize {\n    if (str === null) return 0;\n    var cached = this.cachedStringsToPointers;\n    if (cached.has(str)) return changetype<usize>(cached.get(str));\n    var ptr = allocString(str);\n    cached.set(str, ptr);\n    return ptr;\n  }\n\n  readStringCached(ptr: usize): string | null {\n    // Binaryen internalizes names, so using this method where it's safe can\n    // avoid quite a bit of unnecessary garbage.\n    if (ptr == 0) return null;\n    var cached = this.cachedPointersToStrings;\n    if (cached.has(ptr)) return changetype<string>(cached.get(ptr));\n    var str = readString(ptr);\n    cached.set(ptr, str);\n    return str;\n  }\n\n  dispose(): void {\n    assert(this.ref);\n    // TODO: for (let ptr of this.cachedStrings.values()) {\n    for (let _values = Map_values(this.cachedStringsToPointers), i = 0, k = _values.length; i < k; ++i) {\n      let ptr = unchecked(_values[i]);\n      binaryen._free(ptr);\n    }\n    this.cachedStringsToPointers.clear();\n    this.cachedPointersToStrings.clear();\n    binaryen._free(this.lit);\n    binaryen._BinaryenModuleDispose(this.ref);\n    this.ref = 0;\n  }\n\n  createRelooper(): Relooper {\n    return Relooper.create(this);\n  }\n\n  /** Makes a copy of a trivial expression (doesn't contain subexpressions). Returns `0` if non-trivial. */\n  tryCopyTrivialExpression(expr: ExpressionRef): ExpressionRef {\n    switch (binaryen._BinaryenExpressionGetId(expr)) {\n      case ExpressionId.LocalGet:\n      case ExpressionId.GlobalGet:\n      case ExpressionId.Const:\n      case ExpressionId.MemorySize:\n      case ExpressionId.Nop:\n      case ExpressionId.Unreachable:\n      case ExpressionId.DataDrop:\n      case ExpressionId.RefNull:\n      case ExpressionId.RttCanon: return this.copyExpression(expr);\n    }\n    return 0;\n  }\n\n  /** Makes a copy of any expression including all subexpressions. */\n  copyExpression(expr: ExpressionRef): ExpressionRef {\n    // TODO: Copy debug location as well (needs Binaryen support)\n    return binaryen._BinaryenExpressionCopy(expr, this.ref);\n  }\n\n  runExpression(\n    expr: ExpressionRef,\n    flags: ExpressionRunnerFlags,\n    maxDepth: i32 = 50,\n    maxLoopIterations: i32 = 1\n  ): ExpressionRef {\n    var runner = binaryen._ExpressionRunnerCreate(this.ref, flags, maxDepth, maxLoopIterations);\n    var precomp =  binaryen._ExpressionRunnerRunAndDispose(runner, expr);\n    if (precomp) {\n      assert(getExpressionId(precomp) == ExpressionId.Const);\n      assert(getExpressionType(precomp) == getExpressionType(expr));\n    }\n    return precomp;\n  }\n\n  // source map generation\n\n  addDebugInfoFile(name: string): Index {\n    var cStr = allocString(name);\n    var ret = binaryen._BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\n    binaryen._free(cStr);\n    return ret;\n  }\n\n  getDebugInfoFile(index: Index): string | null {\n    return readString(binaryen._BinaryenModuleGetDebugInfoFileName(this.ref, index));\n  }\n\n  setDebugLocation(\n    func: FunctionRef,\n    expr: ExpressionRef,\n    fileIndex: Index,\n    lineNumber: Index,\n    columnNumber: Index\n  ): void {\n    binaryen._BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\n  }\n}\n\n// types\n\nexport function createType(types: TypeRef[] | null): TypeRef {\n  if (!types) return TypeRef.None;\n  switch (types.length) {\n    case 0: return TypeRef.None;\n    case 1: return types[0];\n  }\n  var cArr = allocPtrArray(types);\n  var ret = binaryen._BinaryenTypeCreate(cArr, types.length);\n  binaryen._free(cArr);\n  return ret;\n}\n\nexport function expandType(type: TypeRef): TypeRef[] {\n  var arity = binaryen._BinaryenTypeArity(type);\n  var cArr = binaryen._malloc(<usize>arity << 2);\n  binaryen._BinaryenTypeExpand(type, cArr);\n  var types = new Array<TypeRef>(arity);\n  if (!ASC_TARGET) {\n    let ptr = cArr >>> 2;\n    for (let i: u32 = 0; i < arity; ++i) {\n      types[i] = binaryen.HEAPU32[ptr + i];\n    }\n  } else {\n    for (let i: u32 = 0; i < arity; ++i) {\n      types[i] = binaryen.__i32_load(cArr + (<usize>i << 2));\n    }\n  }\n  binaryen._free(cArr);\n  return types;\n}\n\n// expressions\n\nexport function getExpressionId(expr: ExpressionRef): ExpressionId {\n  return binaryen._BinaryenExpressionGetId(expr);\n}\n\nexport function getExpressionType(expr: ExpressionRef): TypeRef {\n  return binaryen._BinaryenExpressionGetType(expr);\n}\n\nexport function getConstValueI32(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI32(expr);\n}\n\nexport function getConstValueI64Low(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64Low(expr);\n}\n\nexport function getConstValueI64High(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64High(expr);\n}\n\nexport function getConstValueF32(expr: ExpressionRef): f32 {\n  return binaryen._BinaryenConstGetValueF32(expr);\n}\n\nexport function getConstValueF64(expr: ExpressionRef): f64 {\n  return binaryen._BinaryenConstGetValueF64(expr);\n}\n\nexport function isConstZero(expr: ExpressionRef): bool {\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\n  var type = getExpressionType(expr);\n  if (type == TypeRef.I32) return getConstValueI32(expr) == 0;\n  if (type == TypeRef.I64) return getConstValueI64Low(expr) == 0 && getConstValueI64High(expr) == 0;\n  if (type == TypeRef.F32) return getConstValueF32(expr) == 0;\n  if (type == TypeRef.F64) return getConstValueF64(expr) == 0;\n  return false;\n}\n\nexport function getLocalGetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalGetGetIndex(expr);\n}\n\nexport function getLocalSetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalSetGetIndex(expr);\n}\n\nexport function getLocalSetValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLocalSetGetValue(expr);\n}\n\nexport function isLocalTee(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLocalSetIsTee(expr);\n}\n\nexport function getGlobalGetName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetGetName(expr));\n}\n\nexport function getBinaryOp(expr: ExpressionRef): BinaryOp {\n  return binaryen._BinaryenBinaryGetOp(expr);\n}\n\nexport function getBinaryLeft(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetLeft(expr);\n}\n\nexport function getBinaryRight(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetRight(expr);\n}\n\nexport function getUnaryOp(expr: ExpressionRef): UnaryOp {\n  return binaryen._BinaryenUnaryGetOp(expr);\n}\n\nexport function getUnaryValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenUnaryGetValue(expr);\n}\n\nexport function getLoadBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetBytes(expr);\n}\n\nexport function getLoadOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetOffset(expr);\n}\n\nexport function getLoadPtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoadGetPtr(expr);\n}\n\nexport function isLoadSigned(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLoadIsSigned(expr);\n}\n\nexport function getStoreBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetBytes(expr);\n}\n\nexport function getStoreOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetOffset(expr);\n}\n\nexport function getStorePtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetPtr(expr);\n}\n\nexport function getStoreValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetValue(expr);\n}\n\nexport function getBlockName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBlockGetName(expr));\n}\n\nexport function getBlockChildCount(expr: ExpressionRef): Index {\n  return binaryen._BinaryenBlockGetNumChildren(expr);\n}\n\nexport function getBlockChildAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenBlockGetChildAt(expr, index);\n}\n\nexport function getIfCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetCondition(expr);\n}\n\nexport function getIfTrue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfTrue(expr);\n}\n\nexport function getIfFalse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfFalse(expr);\n}\n\nexport function getLoopName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenLoopGetName(expr));\n}\n\nexport function getLoopBody(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoopGetBody(expr);\n}\n\nexport function getBreakName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBreakGetName(expr));\n}\n\nexport function getBreakCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBreakGetCondition(expr);\n}\n\nexport function getSelectThen(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfTrue(expr);\n}\n\nexport function getSelectElse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfFalse(expr);\n}\n\nexport function getSelectCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetCondition(expr);\n}\n\nexport function getDropValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenDropGetValue(expr);\n}\n\nexport function getReturnValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenReturnGetValue(expr);\n}\n\nexport function getCallTarget(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenCallGetTarget(expr));\n}\n\nexport function getCallOperandCount(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenCallGetNumOperands(expr);\n}\n\nexport function getCallOperandAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenCallGetOperandAt(expr, index);\n}\n\nexport function getMemoryGrowDelta(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenMemoryGrowGetDelta(expr);\n}\n\n// functions\n\nexport function getFunctionBody(func: FunctionRef): ExpressionRef {\n  return binaryen._BinaryenFunctionGetBody(func);\n}\n\nexport function getFunctionName(func: FunctionRef): string | null {\n  return readString(binaryen._BinaryenFunctionGetName(func));\n}\n\nexport function getFunctionParams(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetParams(func);\n}\n\nexport function getFunctionResults(func: FunctionRef): TypeRef {\n  return binaryen._BinaryenFunctionGetResults(func);\n}\n\nexport function getFunctionVars(func: FunctionRef): TypeRef[] {\n  var count = binaryen._BinaryenFunctionGetNumVars(func);\n  var types = new Array<TypeRef>(count);\n  for (let i: Index = 0; i < count; ++i) {\n    types[i] = binaryen._BinaryenFunctionGetVar(func, i);\n  }\n  return types;\n}\n\n// globals\n\nexport function getGlobalName(global: GlobalRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetName(global));\n}\n\nexport function getGlobalType(global: GlobalRef): TypeRef {\n  return binaryen._BinaryenGlobalGetType(global);\n}\n\nexport function isGlobalMutable(global: GlobalRef): bool {\n  return binaryen._BinaryenGlobalIsMutable(global);\n}\n\nexport function getGlobalInit(global: GlobalRef): ExpressionRef {\n  return binaryen._BinaryenGlobalGetInitExpr(global);\n}\n\n// tags\n\nexport function getTagName(tag: TagRef): string | null {\n  return readString(binaryen._BinaryenTagGetName(tag));\n}\n\nexport function getTagParams(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetParams(tag);\n}\n\nexport function getTagResults(tag: TagRef): TypeRef {\n  return binaryen._BinaryenTagGetResults(tag);\n}\n\nexport class Relooper {\n  constructor(\n    /** Module this relooper belongs to. */\n    public module: Module,\n    /** Binaryen relooper reference. */\n    public ref: RelooperRef\n  ) {}\n\n  static create(module: Module): Relooper {\n    return new Relooper(module, binaryen._RelooperCreate(module.ref));\n  }\n\n  addBlock(code: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlock(this.ref, code);\n  }\n\n  addBranch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    condition: ExpressionRef = 0,\n    code: ExpressionRef = 0\n  ): void {\n    binaryen._RelooperAddBranch(from, to, condition, code);\n  }\n\n  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlockWithSwitch(this.ref, code, condition);\n  }\n\n  addBranchForSwitch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    indexes: i32[],\n    code: ExpressionRef = 0\n  ): void {\n    var cArr = allocI32Array(indexes);\n    binaryen._RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\n    binaryen._free(cArr);\n  }\n\n  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {\n    return binaryen._RelooperRenderAndDispose(this.ref, entry, labelHelper);\n  }\n}\n\n/** Builds a switch using a sequence of `br_if`s. */\nexport class SwitchBuilder {\n  // This is useful because Binaryen understands sequences of `br_if`s and\n  // knows how to make a `br_table` from such a sequence if switched over\n  // values are considered dense enough, respectively a size-efficient sequence\n  // of `if`s if not, depending on optimization levels.\n\n  private module: Module;\n  private condition: ExpressionRef;\n  private values: i32[] = new Array();\n  private indexes: i32[] = new Array();\n  private cases: ExpressionRef[][] = new Array();\n  private defaultIndex: i32 = -1;\n\n  /** Creates a new builder using the specified i32 condition. */\n  constructor(module: Module, condition: ExpressionRef) {\n    this.module = module;\n    this.condition = condition;\n  }\n\n  /** Links a case to the specified branch. */\n  addCase(value: i32, code: ExpressionRef[]): void {\n    var cases = this.cases;\n    var index = cases.indexOf(code);\n    if (index < 0) {\n      index = cases.length;\n      cases.push(code);\n    }\n    this.values.push(value);\n    this.indexes.push(index);\n  }\n\n  /** Links the default branch. */\n  addDefault(code: ExpressionRef[]): void {\n    assert(this.defaultIndex == -1);\n    var cases = this.cases;\n    this.defaultIndex = cases.length;\n    cases.push(code);\n  }\n\n  /** Renders the switch to a block. */\n  render(localIndex: i32, labelPostfix: string = \"\"): ExpressionRef {\n    var module = this.module;\n    var cases = this.cases;\n    var numCases = cases.length;\n    if (!numCases) {\n      return module.drop(this.condition);\n    }\n    var values = this.values;\n    var numValues = values.length;\n    var indexes = this.indexes;\n    var entry = new Array<ExpressionRef>(1 + numValues + 1);\n    var labels = new Array<string>(numCases);\n    for (let i = 0; i < numCases; ++i) {\n      labels[i] = \"case\" + i.toString() + labelPostfix;\n    }\n    entry[0] = module.local_set(localIndex, this.condition, false); // u32\n    for (let i = 0; i < numValues; ++i) {\n      let index = indexes[i];\n      entry[1 + i] = module.br(labels[index],\n        module.binary(BinaryOp.EqI32,\n          module.local_get(localIndex, TypeRef.I32),\n          module.i32(values[i])\n        )\n      );\n    }\n    var defaultIndex = this.defaultIndex;\n    var defaultLabel = \"default\" + labelPostfix;\n    entry[1 + numValues] = module.br(\n      ~defaultIndex\n        ? labels[defaultIndex]\n        : defaultLabel\n    );\n    var current = module.block(labels[0], entry);\n    for (let i = 1; i < numCases; ++i) {\n      let block = cases[i - 1];\n      block.unshift(current);\n      current = module.block(labels[i], block);\n    }\n    var lastCase = cases[numCases - 1];\n    lastCase.unshift(current);\n    return module.block(\n      ~defaultIndex\n        ? null\n        : defaultLabel,\n      lastCase\n    );\n  }\n}\n\nexport enum SideEffects {\n  None = 0 /* _BinaryenSideEffectNone */,\n  Branches = 1 /* _BinaryenSideEffectBranches */,\n  Calls = 2 /* _BinaryenSideEffectCalls */,\n  ReadsLocal = 4 /* _BinaryenSideEffectReadsLocal */,\n  WritesLocal = 8 /* _BinaryenSideEffectWritesLocal */,\n  ReadsGlobal = 16 /* _BinaryenSideEffectReadsGlobal */,\n  WritesGlobal = 32 /* _BinaryenSideEffectWritesGlobal */,\n  ReadsMemory = 64 /* _BinaryenSideEffectReadsMemory */,\n  WritesMemory = 128 /* _BinaryenSideEffectWritesMemory */,\n  ReadsTable = 256 /* _BinaryenSideEffectReadsTable */,\n  WritesTable = 512 /* _BinaryenSideEffectWritesTable */,\n  ImplicitTrap = 1024 /* _BinaryenSideEffectImplicitTrap */,\n  IsAtomic = 2048 /* _BinaryenSideEffectIsAtomic */,\n  Throws = 4096 /* _BinaryenSideEffectThrows */,\n  DanglingPop = 8192 /* _BinaryenSideEffectDanglingPop */,\n  TrapsNeverHappen = 16384 /* _BinaryenSideEffectTrapsNeverHappen */,\n  Any = 32767 /* _BinaryenSideEffectAny */\n}\n\nexport function getSideEffects(expr: ExpressionRef, module: ModuleRef): SideEffects {\n  return binaryen._BinaryenExpressionGetSideEffects(expr, module);\n}\n\nexport function hasSideEffects(expr: ExpressionRef, module: ModuleRef): bool {\n  return getSideEffects(expr, module) != SideEffects.None;\n}\n\n// helpers\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\n\nfunction allocU8Array(u8s: Uint8Array | null): usize {\n  if (!u8s) return 0;\n  var len = u8s.length;\n  var ptr = binaryen._malloc(len);\n  if (!ASC_TARGET) {\n    binaryen.HEAPU8.set(u8s, ptr);\n  } else {\n    for (let i = 0; i < len; ++i) {\n      binaryen.__i32_store8(ptr + i, u8s[i]);\n    }\n  }\n  return ptr;\n}\n\nfunction allocI32Array(i32s: i32[] | null): usize {\n  if (!i32s) return 0;\n  var len = i32s.length;\n  var ptr = binaryen._malloc(len << 2);\n  if (!ASC_TARGET) {\n    binaryen.HEAP32.set(i32s, ptr >>> 2);\n  } else {\n    var idx = ptr;\n    for (let i = 0; i < len; ++i) {\n      let val = i32s[i];\n      binaryen.__i32_store(idx, val);\n      idx += 4;\n    }\n  }\n  return ptr;\n}\n\nfunction allocU32Array(u32s: u32[] | null): usize {\n  if (!u32s) return 0;\n  var len = u32s.length;\n  var ptr = binaryen._malloc(len << 2);\n  if (!ASC_TARGET) {\n    binaryen.HEAPU32.set(u32s, ptr >>> 2);\n  } else {\n    var idx = ptr;\n    for (let i = 0; i < len; ++i) {\n      let val = u32s[i];\n      binaryen.__i32_store(idx, val);\n      idx += 4;\n    }\n  }\n  return ptr;\n}\n\nexport function allocPtrArray(ptrs: usize[] | null): usize {\n  if (!ptrs) return 0;\n  // TODO: WASM64\n  assert(ASC_TARGET != Target.WASM64);\n  var len = ptrs.length;\n  var ptr = binaryen._malloc(len << 2);\n  if (!ASC_TARGET) {\n    binaryen.HEAPU32.set(ptrs, ptr >>> 2);\n  } else {\n    var idx = ptr;\n    for (let i = 0, k = len; i < k; ++i) {\n      let val = ptrs[i];\n      binaryen.__i32_store(idx, <i32>val);\n      idx += 4;\n    }\n  }\n  return ptr;\n}\n\nfunction stringLengthUTF8(str: string): usize {\n  var len = 0;\n  for (let i = 0, k = str.length; i < k; ++i) {\n    let c1 = str.charCodeAt(i) >>> 0;\n    if (c1 <= 0x7F) {\n      len += 1;\n    } else if (c1 <= 0x7FF) {\n      len += 2;\n    } else if (\n      isHighSurrogate(c1) && i + 1 < k &&\n      isLowSurrogate(str.charCodeAt(i + 1))\n    ) {\n      i++;\n      len += 4;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n}\n\nfunction allocString(str: string | null): usize {\n  if (str === null) return 0;\n  var len = stringLengthUTF8(str);\n  var ptr = binaryen._malloc(len + 1) >>> 0;\n  var idx = ptr;\n  if (len === str.length) {\n    // fast path when all chars are ascii\n    if (!ASC_TARGET) {\n      for (let i = 0, k = str.length; i < k; ++i) {\n        binaryen.HEAPU8[idx++] = str.charCodeAt(i);\n      }\n    } else {\n      for (let i = 0, k = str.length; i < k; ++i) {\n        let u = str.charCodeAt(i) >>> 0;\n        binaryen.__i32_store8(idx++, u as u8);\n      }\n    }\n  } else {\n    for (let i = 0, k = str.length; i < k; ++i) {\n      let c1 = str.charCodeAt(i) >>> 0, c2: i32;\n      if (c1 <= 0x7F) {\n        binaryen.__i32_store8(idx++, c1 as u8);\n      } else if (c1 <= 0x7FF) {\n        binaryen.__i32_store8(idx++, (0xC0 |  (c1 >>> 6)       ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else if (\n        isHighSurrogate(c1) && i + 1 < k &&\n        isLowSurrogate(c2 = str.charCodeAt(i + 1))\n      ) {\n        c1 = combineSurrogates(c1, c2);\n        ++i;\n        binaryen.__i32_store8(idx++, (0xF0 |  (c1 >>> 18)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>> 12) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      } else {\n        binaryen.__i32_store8(idx++, (0xE0 |  (c1 >>> 12)      ) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ((c1 >>>  6) & 63)) as u8);\n        binaryen.__i32_store8(idx++, (0x80 | ( c1         & 63)) as u8);\n      }\n    }\n  }\n  binaryen.__i32_store8(idx, 0); // \\0\n  return ptr;\n}\n\nfunction readBuffer(ptr: usize, len: i32): Uint8Array {\n  if (!ASC_TARGET) {\n    return binaryen.HEAPU8.slice(ptr, ptr + len);\n  } else {\n    var ret = new Uint8Array(len);\n    for (let i = 0; i < len; ++i) {\n      ret[i] = binaryen.__i32_load8_u(ptr + <usize>i);\n    }\n    return ret;\n  }\n}\n\nexport function readString(ptr: usize): string | null {\n  if (!ptr) return null;\n  var arr = new Array<i32>();\n  // the following is based on Emscripten's UTF8ArrayToString\n  var cp: u32;\n  var u1: u32, u2: u32, u3: u32;\n  while (cp = binaryen.__i32_load8_u(ptr++)) {\n    if (!(cp & 0x80)) {\n      arr.push(cp);\n      continue;\n    }\n    u1 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xE0) == 0xC0) {\n      arr.push(((cp & 31) << 6) | u1);\n      continue;\n    }\n    u2 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xF0) == 0xE0) {\n      cp = ((cp & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u3 = binaryen.__i32_load8_u(ptr++) & 63;\n      if ((cp & 0xF8) == 0xF0) {\n        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n      } else {\n        assert(false, \"Invalid UTF8 sequence during readString\");\n      }\n    }\n    if (cp < 0x10000) {\n      arr.push(cp);\n    } else {\n      let ch = cp - 0x10000;\n      arr.push(SURROGATE_HIGH | (ch >>> 10));\n      arr.push(SURROGATE_LOW | (ch & 0x3FF));\n    }\n  }\n  // TODO: implement and use String.fromCodePoints\n  return String.fromCharCodes(arr);\n}\n\n/** Result structure of {@link Module#toBinary}. */\nexport class BinaryModule {\n  constructor(\n    /** WebAssembly binary. */\n    public output: Uint8Array,\n    /** Source map, if generated. */\n    public sourceMap: string | null\n  ) {}\n}\n\n/** Tests if an expression needs an explicit 'unreachable' when it is the terminating statement. */\nexport function needsExplicitUnreachable(expr: ExpressionRef): bool {\n  // not applicable if pushing a value to the stack\n  if (binaryen._BinaryenExpressionGetType(expr) != TypeRef.Unreachable) {\n    return false;\n  }\n\n  switch (binaryen._BinaryenExpressionGetId(expr)) {\n    case ExpressionId.Unreachable:\n    case ExpressionId.Return: return false;\n    case ExpressionId.Break: {\n      return binaryen._BinaryenBreakGetCondition(expr) != 0;\n    }\n    case ExpressionId.Block: {\n      if (!binaryen._BinaryenBlockGetName(expr)) { // can't break out of it\n        let numChildren = binaryen._BinaryenBlockGetNumChildren(expr); // last child needs unreachable\n        return (\n          numChildren > 0 &&\n          needsExplicitUnreachable(binaryen._BinaryenBlockGetChildAt(expr, numChildren - 1))\n        );\n      }\n    }\n  }\n  return true;\n}\n","/**\n * @fileoverview A TypeScript parser for the AssemblyScript subset.\n *\n * Takes the tokens produced by the `Tokenizer` and builds an abstract\n * syntax tree composed of `Node`s wrapped in a `Source` out of it.\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags,\n  LIBRARY_PREFIX,\n  PATH_DELIMITER\n} from \"./common\";\n\nimport {\n  Tokenizer,\n  Token,\n  Range,\n  CommentHandler,\n  IdentifierHandling,\n  isIllegalVariableIdentifier\n} from \"./tokenizer\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticEmitter,\n  DiagnosticMessage\n} from \"./diagnostics\";\n\nimport {\n  CharCode,\n  normalizePath\n} from \"./util\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  TypeNode,\n  TypeName,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  AssertionKind,\n  CallExpression,\n  ClassExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  StringLiteralExpression,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DecoratorNode,\n  DoStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportImportStatement,\n  ExportMember,\n  ExportStatement,\n  ExpressionStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportDeclaration,\n  ImportStatement,\n  IndexSignatureNode,\n  NamespaceDeclaration,\n  ParameterNode,\n  ParameterKind,\n  ReturnStatement,\n  SwitchCase,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  TypeDeclaration,\n  TypeParameterNode,\n  VariableStatement,\n  VariableDeclaration,\n  VoidStatement,\n  WhileStatement,\n\n  mangleInternalPath\n} from \"./ast\";\n\n/** Represents a dependee. */\nclass Dependee {\n  constructor(\n    public source: Source,\n    public reportNode: Node\n  ) {}\n}\n\n/** Parser interface. */\nexport class Parser extends DiagnosticEmitter {\n\n  /** Source file names to be requested next. */\n  backlog: string[] = new Array();\n  /** Source file names already seen, that is processed or backlogged. */\n  seenlog: Set<string> = new Set();\n  /** Source file names already completely processed. */\n  donelog: Set<string> = new Set();\n  /** Optional handler to intercept comments while tokenizing. */\n  onComment: CommentHandler | null = null;\n  /** Current file being parsed. */\n  currentSource: Source | null = null;\n  /** Map of dependees being depended upon by a source, by path. */\n  dependees: Map<string, Dependee> = new Map();\n  /** An array of parsed sources. */\n  sources: Source[];\n\n  /** Constructs a new parser. */\n  constructor(\n    diagnostics: DiagnosticMessage[] | null = null,\n    sources: Source[] | null = null\n  ) {\n    super(diagnostics);\n    this.sources = sources ? sources : new Array<Source>();\n  }\n\n  /** Parses a file and adds its definitions to the program. */\n  parseFile(\n    /** Source text of the file, or `null` to indicate not found. */\n    text: string | null,\n    /** Normalized path of the file. */\n    path: string,\n    /** Whether this is an entry file. */\n    isEntry: bool\n  ): void {\n    // the frontend gives us paths with file extensions\n    var normalizedPath = normalizePath(path);\n    var internalPath = mangleInternalPath(normalizedPath);\n\n    // check if already processed\n    if (this.donelog.has(internalPath)) return;\n    this.donelog.add(internalPath); // do not parse again\n    this.seenlog.add(internalPath); // do not request again\n\n    // check if this is an error\n    if (text === null) {\n      let dependees = this.dependees;\n      let dependee: Dependee | null = null;\n      if (dependees.has(internalPath)) dependee = assert(dependees.get(internalPath));\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        dependee\n          ? dependee.reportNode.range\n          : null,\n        path\n      );\n      return;\n    }\n\n    // create the source element\n    var source = new Source(\n      isEntry\n        ? SourceKind.USER_ENTRY\n        : path.startsWith(LIBRARY_PREFIX)\n          ? path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0\n            ? SourceKind.LIBRARY_ENTRY\n            : SourceKind.LIBRARY\n          : SourceKind.USER,\n      normalizedPath,\n      text\n    );\n\n    this.sources.push(source);\n    this.currentSource = source;\n\n    // tokenize and parse\n    var tn = new Tokenizer(source, this.diagnostics);\n    tn.onComment = this.onComment;\n    var statements = source.statements;\n    while (!tn.skip(Token.ENDOFFILE)) {\n      let statement = this.parseTopLevelStatement(tn, null);\n      if (statement) {\n        statements.push(statement);\n      } else {\n        this.skipStatement(tn);\n      }\n    }\n  }\n\n  /** Parses a top-level statement. */\n  parseTopLevelStatement(\n    tn: Tokenizer,\n    namespace: NamespaceDeclaration | null = null\n  ): Statement | null {\n    var flags = CommonFlags.NONE;\n    var startPos = -1;\n\n    // check decorators\n    var decorators: DecoratorNode[] | null = null;\n    while (tn.skip(Token.AT)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      let decorator = this.parseDecorator(tn);\n      if (!decorator) {\n        this.skipStatement(tn);\n        continue;\n      }\n      if (!decorators) decorators = [decorator];\n      else decorators.push(decorator);\n    }\n\n    // check modifiers\n    var exportStart = 0;\n    var exportEnd = 0;\n    var defaultStart = 0;\n    var defaultEnd = 0;\n    if (tn.skip(Token.EXPORT)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      flags |= CommonFlags.EXPORT;\n      exportStart = tn.tokenPos;\n      exportEnd = tn.pos;\n      if (tn.skip(Token.DEFAULT)) {\n        defaultStart = tn.tokenPos;\n        defaultEnd = tn.pos;\n      }\n    }\n\n    var declareStart = 0;\n    var declareEnd = 0;\n    var contextIsAmbient = namespace != null && namespace.is(CommonFlags.AMBIENT);\n    if (tn.skip(Token.DECLARE)) {\n      if (contextIsAmbient) {\n        this.error(\n          DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n          tn.range()\n        ); // recoverable\n      } else {\n        if (startPos < 0) startPos = tn.tokenPos;\n        declareStart = startPos;\n        declareEnd = tn.pos;\n        flags |= CommonFlags.DECLARE | CommonFlags.AMBIENT;\n      }\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.AMBIENT;\n    }\n\n    // parse the statement\n    var statement: Statement | null = null;\n\n    // handle declarations\n    var first = tn.peek();\n    if (startPos < 0) startPos = tn.nextTokenPos;\n    switch (first) {\n      case Token.CONST: {\n        tn.next();\n        flags |= CommonFlags.CONST;\n        if (tn.skip(Token.ENUM)) {\n          statement = this.parseEnum(tn, flags, decorators, startPos);\n        } else {\n          statement = this.parseVariable(tn, flags, decorators, startPos);\n        }\n        decorators = null;\n        break;\n      }\n      case Token.LET: flags |= CommonFlags.LET;\n      case Token.VAR: {\n        tn.next();\n        statement = this.parseVariable(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.ENUM: {\n        tn.next();\n        statement = this.parseEnum(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.FUNCTION: {\n        tn.next();\n        statement = this.parseFunction(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.ABSTRACT: {\n        let state = tn.mark();\n        tn.next();\n        let abstractStart = tn.tokenPos;\n        let abstractEnd = tn.pos;\n        let next = tn.peek(true);\n        if (tn.nextTokenOnNewLine) {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        }\n        if (next != Token.CLASS) {\n          if (next == Token.INTERFACE) {\n            this.error(\n              DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,\n              tn.range(abstractStart, abstractEnd)\n            );\n          }\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        } else {\n          tn.discard(state);\n        }\n        flags |= CommonFlags.ABSTRACT;\n        // fall through\n      }\n      case Token.CLASS:\n      case Token.INTERFACE: {\n        tn.next();\n        statement = this.parseClassOrInterface(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.NAMESPACE: {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          tn.discard(state);\n          statement = this.parseNamespace(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.IMPORT: {\n        tn.next();\n        flags |= CommonFlags.IMPORT;\n        if (flags & CommonFlags.EXPORT) {\n          statement = this.parseExportImport(tn, startPos);\n        } else {\n          statement = this.parseImport(tn);\n        }\n        break;\n      }\n      case Token.TYPE: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          tn.discard(state);\n          statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      default: {\n\n        // handle plain exports\n        if (flags & CommonFlags.EXPORT) {\n          if (defaultEnd && tn.skipIdentifier(IdentifierHandling.PREFER)) {\n            if (declareEnd) {\n              this.error(\n                DiagnosticCode.An_export_assignment_cannot_have_modifiers,\n                tn.range(declareStart, declareEnd)\n              );\n            }\n            statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);\n            defaultStart = defaultEnd = 0; // consume\n          } else {\n            statement = this.parseExport(tn, startPos, (flags & CommonFlags.DECLARE) != 0);\n          }\n\n        // handle non-declaration statements\n        } else {\n          if (exportEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(exportStart, exportEnd), \"export\"\n            ); // recoverable\n          }\n          if (declareEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(declareStart, declareEnd), \"declare\"\n            ); // recoverable\n          }\n          if (!namespace) {\n            statement = this.parseStatement(tn, true);\n          } // TODO: else?\n        }\n        break;\n      }\n    }\n\n    // check for decorators that weren't consumed\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          decorators[i].range\n        );\n      }\n    }\n\n    // check if this an `export default` declaration\n    if (defaultEnd && statement !== null) {\n      switch (statement.kind) {\n        case NodeKind.ENUMDECLARATION:\n        case NodeKind.FUNCTIONDECLARATION:\n        case NodeKind.CLASSDECLARATION:\n        case NodeKind.INTERFACEDECLARATION:\n        case NodeKind.NAMESPACEDECLARATION: {\n          return Node.createExportDefaultStatement(<DeclarationStatement>statement, tn.range(startPos, tn.pos));\n        }\n        default: {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(defaultStart, defaultEnd), \"default\"\n          );\n        }\n      }\n    }\n    return statement;\n  }\n\n  /** Obtains the next file to parse. */\n  nextFile(): string | null {\n    var backlog = this.backlog;\n    return backlog.length ? assert(backlog.shift()) : null;\n  }\n\n  /** Obtains the path of the dependee of the given imported file. */\n  getDependee(dependent: string): string | null {\n    var dependees = this.dependees;\n    if (dependees.has(dependent)) {\n      let dependee = assert(dependees.get(dependent));\n      return dependee.source.internalPath;\n    }\n    return null;\n  }\n\n  /** Finishes parsing. */\n  finish(): void {\n    if (this.backlog.length) throw new Error(\"backlog is not empty\");\n    this.backlog = [];\n    this.seenlog.clear();\n    this.donelog.clear();\n    this.dependees.clear();\n  }\n\n  // types\n\n  /** Parses a type name. */\n  parseTypeName(\n    tn: Tokenizer\n  ): TypeName | null {\n\n    // at: Identifier ('.' Identifier)*\n\n    var first = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n    var current = first;\n    while (tn.skip(Token.DOT)) {\n      if (tn.skip(Token.IDENTIFIER)) {\n        let next = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n        current.next = next;\n        current = next;\n      } else {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range(tn.pos)\n        );\n        return null;\n      }\n    }\n    return first;\n  }\n\n  /** Parses a type. */\n  parseType(\n    tn: Tokenizer,\n    acceptParenthesized: bool = true,\n    suppressErrors: bool = false\n  ): TypeNode | null {\n\n    // before: Type\n\n    // NOTE: this parses our limited subset\n    var token = tn.next();\n    var startPos = tn.tokenPos;\n\n    var type: TypeNode;\n\n    // '(' ...\n    if (token == Token.OPENPAREN) {\n\n      // '(' FunctionSignature ')' '|' 'null'?\n      let isNullableSignature = tn.skip(Token.OPENPAREN);\n      // FunctionSignature?\n      let signature = this.tryParseFunctionType(tn);\n      if (signature) {\n        if (isNullableSignature) {\n          if (!tn.skip(Token.CLOSEPAREN)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \")\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.BAR)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"|\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.NULL)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          signature.isNullable = true;\n        }\n        return signature;\n      } else if (isNullableSignature || this.tryParseSignatureIsSignature) {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n      // Type (',' Type)* ')'\n      if (acceptParenthesized) {\n        let innerType = this.parseType(tn, false, suppressErrors);\n        if (!innerType) return null;\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \")\"\n            );\n          }\n          return null;\n        }\n        type = innerType;\n        type.range.start = startPos;\n        type.range.end = tn.pos;\n      } else {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n    // 'void'\n    } else if (token == Token.VOID) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'this'\n    } else if (token == Token.THIS) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"this\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'true'\n    } else if (token == Token.TRUE || token == Token.FALSE) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'null'\n    } else if (token == Token.NULL) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"null\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // StringLiteral\n    } else if (token == Token.STRINGLITERAL) {\n      tn.readString();\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // Identifier\n    } else if (token == Token.IDENTIFIER) {\n      let name = this.parseTypeName(tn);\n      if (!name) return null;\n      let parameters: TypeNode[] | null = null;\n\n      // Name<T>\n      if (tn.skip(Token.LESSTHAN)) {\n        do {\n          let parameter = this.parseType(tn, true, suppressErrors);\n          if (!parameter) return null;\n          if (!parameters) parameters = [ parameter ];\n          else parameters.push(parameter);\n        } while (tn.skip(Token.COMMA));\n        if (!tn.skip(Token.GREATERTHAN)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \">\"\n            );\n          }\n          return null;\n        }\n      }\n      if (!parameters) parameters = [];\n      type = Node.createNamedType(name, parameters, false, tn.range(startPos, tn.pos));\n    } else {\n      if (!suppressErrors) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        );\n      }\n      return null;\n    }\n    // ... | null\n    while (tn.skip(Token.BAR)) {\n      if (tn.skip(Token.NULL)) {\n        type.isNullable = true;\n      } else {\n        let notNullStart = tn.pos;\n        let notNull = this.parseType(tn, false, true);\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            notNull ? notNull.range : tn.range(notNullStart), \"null\"\n          );\n        }\n        return null;\n      }\n    }\n    // ... [][]\n    while (tn.skip(Token.OPENBRACKET)) {\n      let bracketStart = tn.tokenPos;\n      if (!tn.skip(Token.CLOSEBRACKET)) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"]\"\n          );\n        }\n        return null;\n      }\n      let bracketRange = tn.range(bracketStart, tn.pos);\n\n      // ...[] | null\n      let nullable = false;\n      if (tn.skip(Token.BAR)) {\n        if (tn.skip(Token.NULL)) {\n          nullable = true;\n        } else {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          return null;\n        }\n      }\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"Array\", bracketRange),\n        [ type ],\n        nullable,\n        tn.range(startPos, tn.pos)\n      );\n      if (nullable) break;\n    }\n\n    return type;\n  }\n\n  // Indicates whether tryParseSignature determined that it is handling a Signature\n  private tryParseSignatureIsSignature: bool = false;\n\n  /** Parses a function type, as used in type declarations. */\n  tryParseFunctionType(\n    tn: Tokenizer\n  ): FunctionTypeNode | null {\n\n    // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type\n\n    var state = tn.mark();\n    var startPos = tn.tokenPos;\n    var parameters: ParameterNode[] | null = null;\n    var thisType: NamedTypeNode | null = null;\n    var isSignature: bool = false;\n    var firstParamNameNoType: IdentifierExpression | null = null;\n    var firstParamKind: ParameterKind = ParameterKind.DEFAULT;\n\n    if (tn.skip(Token.CLOSEPAREN)) {\n      isSignature = true;\n      tn.discard(state);\n      parameters = [];\n\n    } else {\n      isSignature = false; // not yet known\n      do {\n        let paramStart = -1;\n        let kind = ParameterKind.DEFAULT;\n        if (tn.skip(Token.DOT_DOT_DOT)) {\n          paramStart = tn.tokenPos;\n          isSignature = true;\n          tn.discard(state);\n          kind = ParameterKind.REST;\n        }\n        if (tn.skip(Token.THIS)) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          if (tn.skip(Token.COLON)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn, false);\n            if (!type) return null;\n            if (type.kind != NodeKind.NAMEDTYPE) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                type.range\n              );\n              this.tryParseSignatureIsSignature = true;\n              return null;\n            }\n            thisType = <NamedTypeNode>type;\n          } else {\n            tn.reset(state);\n            this.tryParseSignatureIsSignature = false;\n            return null;\n          }\n        } else if (tn.skipIdentifier()) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));\n          if (tn.skip(Token.QUESTION)) {\n            isSignature = true;\n            tn.discard(state);\n            if (kind == ParameterKind.REST) {\n              this.error(\n                DiagnosticCode.A_rest_parameter_cannot_be_optional,\n                tn.range()\n              ); // recoverable\n            } else {\n              kind = ParameterKind.OPTIONAL;\n            }\n          }\n          if (tn.skip(Token.COLON)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn); // not suppressing errors because known\n            if (!type) {\n              this.tryParseSignatureIsSignature = isSignature;\n              return null;\n            }\n            let param = Node.createParameter(kind, name, type, null, tn.range(paramStart, tn.pos));\n            if (!parameters) parameters = [ param ];\n            else parameters.push(param);\n          } else {\n            if (!isSignature) {\n              if (tn.peek() == Token.COMMA) {\n                isSignature = true;\n                tn.discard(state);\n              }\n            }\n            if (isSignature) {\n              let param = Node.createParameter(kind, name, Node.createOmittedType(tn.range(tn.pos)), null, tn.range(paramStart, tn.pos));\n              if (!parameters) parameters = [ param ];\n              else parameters.push(param);\n              this.error(\n                DiagnosticCode.Type_expected,\n                param.type.range\n              ); // recoverable\n            } else if (!parameters) {\n              // on '(' Identifier ^',' we don't yet know whether this is a\n              // parenthesized or a function type, hence we have to delay the\n              // respective diagnostic until we know for sure.\n              firstParamNameNoType = name;\n              firstParamKind = kind;\n            }\n          }\n        } else {\n          if (isSignature) {\n            this.error(\n              DiagnosticCode.Identifier_expected,\n              tn.range()\n            );\n          } else {\n            tn.reset(state);\n          }\n          this.tryParseSignatureIsSignature = isSignature;\n          return null;\n        }\n      } while (tn.skip(Token.COMMA));\n      if (!tn.skip(Token.CLOSEPAREN)) {\n        if (isSignature) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        } else {\n          tn.reset(state);\n        }\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    }\n\n    var returnType: TypeNode | null;\n    if (tn.skip(Token.EQUALS_GREATERTHAN)) {\n      if (!isSignature) {\n        isSignature = true;\n        tn.discard(state);\n        if (firstParamNameNoType) { // now we know\n          let param = Node.createParameter(\n            firstParamKind,\n            firstParamNameNoType,\n            Node.createOmittedType(firstParamNameNoType.range.atEnd),\n            null,\n            firstParamNameNoType.range\n          );\n          if (!parameters) parameters = [ param ];\n          else parameters.push(param);\n          this.error(\n            DiagnosticCode.Type_expected,\n            param.type.range\n          ); // recoverable\n        }\n      }\n      returnType = this.parseType(tn);\n      if (!returnType) {\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    } else {\n      if (isSignature) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=>\"\n        );\n      } else {\n        tn.reset(state);\n      }\n      this.tryParseSignatureIsSignature = isSignature;\n      return null;\n    }\n    this.tryParseSignatureIsSignature = true;\n\n    if (!parameters) parameters = [];\n\n    return Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  // statements\n\n  parseDecorator(\n    tn: Tokenizer\n  ): DecoratorNode | null {\n\n    // at '@': Identifier ('.' Identifier)* '(' Arguments\n\n    var startPos = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let name = tn.readIdentifier();\n      let expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\n      while (tn.skip(Token.DOT)) {\n        if (tn.skipIdentifier(IdentifierHandling.PREFER)) {\n          name = tn.readIdentifier();\n          expression = Node.createPropertyAccessExpression(\n            expression,\n            Node.createIdentifierExpression(name, tn.range()),\n            tn.range(startPos, tn.pos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let args: Expression[] | null;\n      if (tn.skip(Token.OPENPAREN)) {\n        args = this.parseArguments(tn);\n        if (args) {\n          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\n        }\n      } else {\n        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVariable(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32,\n    isFor: bool = false\n  ): VariableStatement | null {\n\n    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\n\n    var declarations = new Array<VariableDeclaration>();\n    do {\n      let declaration = this.parseVariableDeclaration(tn, flags, decorators, isFor);\n      if (!declaration) return null;\n      declarations.push(declaration);\n    } while (tn.skip(Token.COMMA));\n\n    var ret = Node.createVariableStatement(decorators, declarations, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseVariableDeclaration(\n    tn: Tokenizer,\n    parentFlags: CommonFlags,\n    parentDecorators: DecoratorNode[] | null,\n    isFor: bool = false\n  ): VariableDeclaration | null {\n\n    // before: Identifier (':' Type)? ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (isIllegalVariableIdentifier(identifier.text)) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        identifier.range\n      );\n    }\n    var flags = parentFlags;\n    if (tn.skip(Token.EXCLAMATION)) {\n      flags |= CommonFlags.DEFINITELY_ASSIGNED;\n    }\n\n    var type: TypeNode | null = null;\n    if (tn.skip(Token.COLON)) {\n      type = this.parseType(tn, true);\n    }\n\n    var initializer: Expression | null = null;\n    if (tn.skip(Token.EQUALS)) {\n      if (flags & CommonFlags.AMBIENT) {\n        this.error(\n          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n      initializer = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!initializer) return null;\n    } else if (!isFor) {\n      if (flags & CommonFlags.CONST) {\n        if (!(flags & CommonFlags.AMBIENT)) {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            identifier.range\n          ); // recoverable\n        }\n      } else if (!type) { // neither type nor initializer\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range(tn.pos)\n        ); // recoverable\n      }\n    }\n    var range = Range.join(identifier.range, tn.range());\n    if (initializer !== null && (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0) {\n      this.error(\n        DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n        range\n      );\n    }\n    return Node.createVariableDeclaration(\n      identifier,\n      parentDecorators,\n      flags,\n      type,\n      initializer,\n      range\n    );\n  }\n\n  parseEnum(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): EnumDeclaration | null {\n\n    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\n\n    if (tn.next() != Token.IDENTIFIER) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (tn.next() != Token.OPENBRACE) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n    var members = new Array<EnumValueDeclaration>();\n    while (!tn.skip(Token.CLOSEBRACE)) {\n      let member = this.parseEnumValue(tn, CommonFlags.NONE);\n      if (!member) return null;\n      members.push(member);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEBRACE)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          return null;\n        }\n      }\n    }\n    var ret = Node.createEnumDeclaration(\n      identifier,\n      decorators,\n      flags,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseEnumValue(\n    tn: Tokenizer,\n    parentFlags: CommonFlags\n  ): EnumValueDeclaration | null {\n\n    // before: Identifier ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    var value: Expression | null = null;\n    if (tn.skip(Token.EQUALS)) {\n      value = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!value) return null;\n    }\n    return Node.createEnumValueDeclaration(\n      identifier,\n      parentFlags,\n      value,\n      Range.join(identifier.range, tn.range())\n    );\n  }\n\n  parseReturn(\n    tn: Tokenizer\n  ): ReturnStatement | null {\n\n    // at 'return': Expression | (';' | '}' | ...'\\n')\n\n    var startPos = tn.tokenPos;\n    var expr: Expression | null = null;\n    if (\n      tn.peek(true) != Token.SEMICOLON &&\n      tn.nextToken != Token.CLOSEBRACE &&\n      !tn.nextTokenOnNewLine\n    ) {\n      if (!(expr = this.parseExpression(tn))) return null;\n    }\n\n    var ret = Node.createReturnStatement(expr, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseTypeParameters(\n    tn: Tokenizer\n  ): TypeParameterNode[] | null {\n\n    // at '<': TypeParameter (',' TypeParameter)* '>'\n\n    var typeParameters = new Array<TypeParameterNode>();\n    var seenOptional = false;\n    var start = tn.tokenPos;\n    while (!tn.skip(Token.GREATERTHAN)) {\n      let typeParameter = this.parseTypeParameter(tn);\n      if (!typeParameter) return null;\n      if (typeParameter.defaultType !== null) {\n        seenOptional = true;\n      } else if (seenOptional) {\n        this.error(\n          DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,\n          typeParameter.range\n        );\n        typeParameter.defaultType = null;\n      }\n      typeParameters.push(typeParameter);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.GREATERTHAN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n      }\n    }\n    if (!typeParameters.length) {\n      this.error(\n        DiagnosticCode.Type_parameter_list_cannot_be_empty,\n        tn.range(start, tn.pos)\n      ); // recoverable\n    }\n    return typeParameters;\n  }\n\n  parseTypeParameter(\n    tn: Tokenizer\n  ): TypeParameterNode | null {\n\n    // before: Identifier ('extends' Type)? ('=' Type)?\n\n    if (tn.next() == Token.IDENTIFIER) {\n      let identifier = Node.createIdentifierExpression(\n        tn.readIdentifier(),\n        tn.range()\n      );\n      let extendsType: NamedTypeNode | null = null;\n      if (tn.skip(Token.EXTENDS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        extendsType = <NamedTypeNode>type;\n      }\n      let defaultType: NamedTypeNode | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        defaultType = <NamedTypeNode>type;\n      }\n      return Node.createTypeParameter(\n        identifier,\n        extendsType,\n        defaultType,\n        Range.join(identifier.range, tn.range())\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  private parseParametersThis: NamedTypeNode | null = null;\n\n  parseParameters(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode[] | null {\n\n    // at '(': (Parameter (',' Parameter)*)? ')'\n\n    var parameters = new Array<ParameterNode>();\n    var seenRest: ParameterNode | null = null;\n    var seenOptional = false;\n    var reportedRest = false;\n    var thisType: TypeNode | null = null;\n\n    // check if there is a leading `this` parameter\n    this.parseParametersThis = null;\n    if (tn.skip(Token.THIS)) {\n      if (tn.skip(Token.COLON)) {\n        thisType = this.parseType(tn); // reports\n        if (!thisType) return null;\n        if (thisType.kind == NodeKind.NAMEDTYPE) {\n          this.parseParametersThis = <NamedTypeNode>thisType;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            thisType.range\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n        return null;\n      }\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          return parameters;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n\n    while (!tn.skip(Token.CLOSEPAREN)) {\n      let param = this.parseParameter(tn, isConstructor); // reports\n      if (!param) return null;\n      if (seenRest !== null && !reportedRest) {\n        this.error(\n          DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,\n          seenRest.name.range\n        );\n        reportedRest = true;\n      }\n      switch (param.parameterKind) {\n        default: {\n          if (seenOptional) {\n            this.error(\n              DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,\n              param.name.range\n            );\n          }\n          break;\n        }\n        case ParameterKind.OPTIONAL: {\n          seenOptional = true;\n          break;\n        }\n        case ParameterKind.REST: {\n          seenRest = param;\n          break;\n        }\n      }\n      parameters.push(param);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return parameters;\n  }\n\n  parseParameter(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode | null {\n\n    // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?\n\n    var isRest = false;\n    var isOptional = false;\n    var startRange: Range | null = null;\n    var accessFlags: CommonFlags = CommonFlags.NONE;\n    if (isConstructor) {\n      if (tn.skip(Token.PUBLIC)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PUBLIC;\n      } else if (tn.skip(Token.PROTECTED)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PROTECTED;\n      } else if (tn.skip(Token.PRIVATE)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PRIVATE;\n      }\n      if (tn.peek() == Token.READONLY) {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek() != Token.COLON) { // modifier\n          tn.discard(state);\n          if (!startRange) startRange = tn.range();\n          accessFlags |= CommonFlags.READONLY;\n        } else { // identifier\n          tn.reset(state);\n        }\n      }\n    }\n    if (tn.skip(Token.DOT_DOT_DOT)) {\n      if (accessFlags) {\n        this.error(\n          DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,\n          tn.range()\n        );\n      } else {\n        startRange = tn.range();\n      }\n      isRest = true;\n    }\n    if (tn.skipIdentifier()) {\n      if (!isRest) startRange = tn.range();\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let type: TypeNode | null = null;\n      if (isOptional = tn.skip(Token.QUESTION)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_be_optional,\n            identifier.range\n          );\n        }\n      }\n      if (tn.skip(Token.COLON)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        type = Node.createOmittedType(tn.range(tn.pos));\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,\n            identifier.range\n          );\n        }\n        if (isOptional) {\n          this.error(\n            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,\n            identifier.range\n          );\n        } else {\n          isOptional = true;\n        }\n        initializer = this.parseExpression(tn, Precedence.COMMA + 1);\n        if (!initializer) return null;\n      }\n      let param = Node.createParameter(\n        isRest\n          ? ParameterKind.REST\n          : isOptional\n            ? ParameterKind.OPTIONAL\n            : ParameterKind.DEFAULT,\n        identifier,\n        type,\n        initializer,\n        Range.join(assert(startRange), tn.range())\n      );\n      param.flags |= accessFlags;\n      return param;\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseFunction(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): FunctionDeclaration | null {\n\n    // at 'function':\n    //  Identifier\n    //  ('<' TypeParameters)?\n    //  '(' Parameters (':' Type)?\n    //  '{' Statement* '}'\n    //  ';'?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range(tn.pos)\n      );\n      return null;\n    }\n\n    var name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    var signatureStart = -1;\n\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      signatureStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.GENERIC;\n    }\n\n    if (!tn.skip(Token.OPENPAREN)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"(\"\n      );\n      return null;\n    }\n\n    if (signatureStart < 0) {\n      signatureStart = tn.tokenPos;\n    }\n\n    var parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n    var thisType = this.parseParametersThis;\n\n    var isSetter = (flags & CommonFlags.SET) != 0;\n    if (isSetter) {\n      if (parameters.length != 1) {\n        this.error(\n          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n          name.range\n        ); // recoverable\n      }\n      if (parameters.length > 0 && parameters[0].initializer !== null) {\n        this.error(\n          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    if (flags & CommonFlags.GET) {\n      if (parameters.length) {\n        this.error(\n          DiagnosticCode.A_get_accessor_cannot_have_parameters,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    var returnType: TypeNode | null = null;\n    if (tn.skip(Token.COLON)) {\n      returnType = this.parseType(tn, true, isSetter);\n      if (!returnType) return null;\n    }\n\n    if (!returnType) {\n      returnType = Node.createOmittedType(\n        tn.range(tn.pos)\n      );\n      if (!isSetter) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnType.range\n        ); // recoverable\n      }\n    }\n\n    var signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    var body: Statement | null = null;\n    if (tn.skip(Token.OPENBRACE)) {\n      if (flags & CommonFlags.AMBIENT) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n\n      body = this.parseBlockStatement(tn, false);\n      if (!body) return null;\n    } else if (!(flags & CommonFlags.AMBIENT)) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        tn.range(tn.pos)\n      );\n    }\n\n    var ret = Node.createFunctionDeclaration(\n      name,\n      decorators,\n      flags,\n      typeParameters,\n      signature,\n      body,\n      ArrowKind.NONE,\n      tn.range(startPos, tn.pos)\n    );\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {\n    var startPos = tn.tokenPos;\n    var name: IdentifierExpression;\n    var arrowKind = ArrowKind.NONE;\n\n    // either at 'function':\n    //  Identifier?\n    //  '(' Parameters (':' Type)?\n    //  Statement\n\n    if (tn.token == Token.FUNCTION) {\n      if (tn.skipIdentifier()) {\n        name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      } else { // empty name\n        name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n      }\n      if (!tn.skip(Token.OPENPAREN)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"(\"\n        );\n        return null;\n      }\n\n      // or at '(' of arrow function:\n      //  Parameters (':' Type)?\n      //  Statement\n\n    } else {\n      arrowKind = ArrowKind.ARROW_PARENTHESIZED;\n      assert(tn.token == Token.OPENPAREN);\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));\n    }\n\n    // TODO: type parameters? doesn't seem worth it.\n\n    var signatureStart = tn.pos;\n    var parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n\n    return this.parseFunctionExpressionCommon(tn, name, parameters, this.parseParametersThis, arrowKind, startPos, signatureStart);\n  }\n\n  private parseFunctionExpressionCommon(\n    tn: Tokenizer,\n    name: IdentifierExpression,\n    parameters: ParameterNode[],\n    explicitThis: NamedTypeNode | null,\n    arrowKind: ArrowKind,\n    startPos: i32 = -1,\n    signatureStart: i32 = -1\n  ): FunctionExpression | null {\n    if (startPos < 0) startPos = name.range.start;\n    if (signatureStart < 0) signatureStart = startPos;\n\n    var returnType: TypeNode | null = null;\n    if (arrowKind != ArrowKind.ARROW_SINGLE && tn.skip(Token.COLON)) {\n      returnType = this.parseType(tn);\n      if (!returnType) return null;\n    } else {\n      returnType = Node.createOmittedType(tn.range(tn.pos));\n    }\n\n    if (arrowKind) {\n      if (!tn.skip(Token.EQUALS_GREATERTHAN)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"=>\"\n        );\n        return null;\n      }\n    }\n\n    var signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      explicitThis,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    var body: Statement | null = null;\n    if (arrowKind) {\n      if (tn.skip(Token.OPENBRACE)) {\n        body = this.parseBlockStatement(tn, false);\n      } else {\n        let bodyExpression = this.parseExpression(tn, Precedence.COMMA + 1);\n        if (bodyExpression) body = Node.createExpressionStatement(bodyExpression);\n      }\n    } else {\n      if (!tn.skip(Token.OPENBRACE)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"{\"\n        );\n        return null;\n      }\n      body = this.parseBlockStatement(tn, false);\n    }\n    if (!body) return null;\n\n    var declaration = Node.createFunctionDeclaration(\n      name,\n      null,\n      CommonFlags.NONE,\n      null,\n      signature,\n      body,\n      arrowKind,\n      tn.range(startPos, tn.pos)\n    );\n    return Node.createFunctionExpression(declaration);\n  }\n\n  parseClassOrInterface(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): ClassDeclaration | null {\n\n    // at ('class' | 'interface'):\n    //   Identifier\n    //   ('<' TypeParameters)?\n    //   ('extends' Type)?\n    //   ('implements' Type (',' Type)*)?\n    //   '{' ClassMember* '}'\n\n    var isInterface = tn.token == Token.INTERFACE;\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n\n    var identifier = Node.createIdentifierExpression(\n      tn.readIdentifier(),\n      tn.range()\n    );\n\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.GENERIC;\n    }\n\n    var extendsType: NamedTypeNode | null = null;\n    if (tn.skip(Token.EXTENDS)) {\n      let type = this.parseType(tn);\n      if (!type) return null;\n      if (type.kind != NodeKind.NAMEDTYPE) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          type.range\n        );\n        return null;\n      }\n      extendsType = <NamedTypeNode>type;\n    }\n\n    var implementsTypes: NamedTypeNode[] | null = null;\n    if (tn.skip(Token.IMPLEMENTS)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode.Interface_declaration_cannot_have_implements_clause,\n          tn.range()\n        ); // recoverable\n      }\n      do {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        if (!isInterface) {\n          if (!implementsTypes) implementsTypes = [];\n          implementsTypes.push(<NamedTypeNode>type);\n        }\n      } while (tn.skip(Token.COMMA));\n    }\n\n    if (!tn.skip(Token.OPENBRACE)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n\n    var members = new Array<DeclarationStatement>();\n    var declaration: ClassDeclaration;\n    if (isInterface) {\n      assert(!implementsTypes);\n      declaration = Node.createInterfaceDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        null,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    } else {\n      declaration = Node.createClassDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        implementsTypes,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    }\n    if (!tn.skip(Token.CLOSEBRACE)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.INDEXSIGNATURE) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(member instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.ENDOFFILE)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CLOSEBRACE));\n    }\n    declaration.range.end = tn.pos;\n    return declaration;\n  }\n\n  parseClassExpression(tn: Tokenizer): ClassExpression | null {\n\n    // at 'class': Identifier? '{' ... '}'\n\n    var startPos = tn.tokenPos;\n    var name: IdentifierExpression;\n\n    if (tn.skipIdentifier()) {\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    } else {\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n    }\n\n    if (!tn.skip(Token.OPENBRACE)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"{\"\n      );\n      return null;\n    }\n\n    var members = new Array<DeclarationStatement>();\n    var declaration = Node.createClassDeclaration(\n      name,\n      null,\n      CommonFlags.NONE,\n      null,\n      null,\n      null,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    if (!tn.skip(Token.CLOSEBRACE)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.INDEXSIGNATURE) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(declaration instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.ENDOFFILE)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CLOSEBRACE));\n    }\n    declaration.range.end = tn.pos;\n    return Node.createClassExpression(declaration);\n  }\n\n  parseClassMember(\n    tn: Tokenizer,\n    parent: ClassDeclaration\n  ): Node | null {\n\n    // before:\n    //   'declare'?\n    //   ('public' | 'private' | 'protected')?\n    //   ('static' | 'abstract')?\n    //   'readonly'?\n    //   ('get' | 'set')?\n    //   Identifier ...\n\n    var isInterface = parent.kind == NodeKind.INTERFACEDECLARATION;\n    var startPos = 0;\n    var decorators: DecoratorNode[] | null = null;\n    if (tn.skip(Token.AT)) {\n      startPos = tn.tokenPos;\n      do {\n        let decorator = this.parseDecorator(tn);\n        if (!decorator) break;\n        if (!decorators) decorators = new Array();\n        decorators.push(decorator);\n      } while (tn.skip(Token.AT));\n      if (isInterface && decorators !== null) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n        );\n      }\n    }\n\n    // inherit ambient status\n    var flags = parent.flags & CommonFlags.AMBIENT;\n\n    // implemented methods are virtual\n    if (isInterface) flags |= CommonFlags.VIRTUAL;\n\n    var declareStart = 0;\n    var declareEnd = 0;\n    var contextIsAmbient = parent.is(CommonFlags.AMBIENT);\n    if (tn.skip(Token.DECLARE)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"declare\"\n        );\n      } else {\n        if (contextIsAmbient) {\n          this.error(\n            DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n            tn.range()\n          ); // recoverable\n        } else {\n          flags |= CommonFlags.DECLARE | CommonFlags.AMBIENT;\n          declareStart = tn.tokenPos;\n          declareEnd = tn.pos;\n        }\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.AMBIENT;\n    }\n\n    var accessStart = 0;\n    var accessEnd = 0;\n    if (tn.skip(Token.PUBLIC)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"public\"\n        );\n      } else {\n        flags |= CommonFlags.PUBLIC;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.PRIVATE)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"private\"\n        );\n      } else {\n        flags |= CommonFlags.PRIVATE;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.PROTECTED)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"protected\"\n        );\n      } else {\n        flags |= CommonFlags.PROTECTED;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    var staticStart = 0;\n    var staticEnd = 0;\n    var abstractStart = 0;\n    var abstractEnd = 0;\n    if (tn.skip(Token.STATIC)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"static\"\n        );\n      } else {\n        flags |= CommonFlags.STATIC;\n        staticStart = tn.tokenPos;\n        staticEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else {\n      flags |= CommonFlags.INSTANCE;\n      if (tn.skip(Token.ABSTRACT)) {\n        if (isInterface || !parent.is(CommonFlags.ABSTRACT)) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(), \"abstract\"\n          );\n        } else {\n          flags |= CommonFlags.ABSTRACT;\n          abstractStart = tn.tokenPos;\n          abstractEnd = tn.pos;\n        }\n        if (!startPos) startPos = tn.tokenPos;\n      }\n      if (parent.flags & CommonFlags.GENERIC) flags |= CommonFlags.GENERIC_CONTEXT;\n    }\n\n    var readonlyStart = 0;\n    var readonlyEnd = 0;\n    if (tn.peek() == Token.READONLY) {\n      let state = tn.mark();\n      tn.next();\n      if (tn.peek() != Token.COLON) { // modifier\n        tn.discard(state);\n        flags |= CommonFlags.READONLY;\n        readonlyStart = tn.tokenPos;\n        readonlyEnd = tn.pos;\n        if (!startPos) startPos = readonlyStart;\n      } else { // identifier\n        tn.reset(state);\n      }\n    }\n\n    // check if accessor: ('get' | 'set') ^\\n Identifier\n    var state = tn.mark();\n    var isConstructor = false;\n    var isGetter = false;\n    var getStart = 0;\n    var getEnd = 0;\n    var isSetter = false;\n    var setStart = 0;\n    var setEnd = 0;\n    if (!isInterface) {\n      if (tn.skip(Token.GET)) {\n        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.GET;\n          isGetter = true;\n          getStart = tn.tokenPos;\n          getEnd = tn.pos;\n          if (!startPos) startPos = getStart;\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.SET)) {\n        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.SET;\n          isSetter = true;\n          setStart = tn.tokenPos;\n          setEnd = tn.pos;\n          if (!startPos) startPos = setStart;\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.CONSTRUCTOR)) {\n        flags |= CommonFlags.CONSTRUCTOR;\n        isConstructor = true;\n        if (!startPos) startPos = tn.tokenPos;\n        if (flags & CommonFlags.STATIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.READONLY) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(readonlyStart, readonlyEnd), \"readonly\"\n          ); // recoverable\n        }\n      }\n    }\n\n    var isGetterOrSetter = isGetter || isSetter;\n    var name: IdentifierExpression;\n    if (isConstructor) {\n      name = Node.createConstructorExpression(tn.range());\n    } else {\n      if (!isGetterOrSetter && tn.skip(Token.OPENBRACKET)) {\n        if (!startPos) startPos = tn.tokenPos;\n        // TODO: also handle symbols, which might have some of these modifiers\n        if (flags & CommonFlags.PUBLIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"public\"\n          ); // recoverable\n        } else if (flags & CommonFlags.PROTECTED) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        } else if (flags & CommonFlags.PRIVATE) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.STATIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        let retIndex = this.parseIndexSignature(tn, flags, decorators);\n        if (!retIndex) {\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n          return null;\n        }\n        tn.skip(Token.SEMICOLON);\n        return retIndex;\n      }\n      if (!tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range()\n        );\n        return null;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      let typeParametersStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      if (isConstructor) {\n        this.error(\n          DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else if (isGetterOrSetter) {\n        this.error(\n          DiagnosticCode.An_accessor_cannot_have_type_parameters,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else {\n        flags |= CommonFlags.GENERIC;\n      }\n    }\n\n    // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\n    if (tn.skip(Token.OPENPAREN)) {\n      if (flags & CommonFlags.DECLARE) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_appear_on_class_elements_of_this_kind,\n          tn.range(declareStart, declareEnd), \"declare\"\n        ); // recoverable\n      }\n\n      let signatureStart = tn.tokenPos;\n      let parameters = this.parseParameters(tn, isConstructor);\n      if (!parameters) return null;\n      let thisType = this.parseParametersThis;\n      if (isConstructor) {\n        for (let i = 0, k = parameters.length; i < k; ++i) {\n          let parameter = parameters[i];\n          if (parameter.isAny(\n            CommonFlags.PUBLIC |\n            CommonFlags.PROTECTED |\n            CommonFlags.PRIVATE |\n            CommonFlags.READONLY\n          )) {\n            let implicitFieldDeclaration = Node.createFieldDeclaration(\n              parameter.name,\n              null,\n              parameter.flags | CommonFlags.INSTANCE,\n              parameter.type,\n              null, // initialized via parameter\n              parameter.range\n            );\n            implicitFieldDeclaration.parameterIndex = i;\n            parameter.implicitFieldDeclaration = implicitFieldDeclaration;\n            parent.members.push(implicitFieldDeclaration);\n          }\n        }\n      } else if (isGetter) {\n        if (parameters.length) {\n          this.error(\n            DiagnosticCode.A_get_accessor_cannot_have_parameters,\n            name.range\n          );\n        }\n      } else if (isSetter) {\n        if (parameters.length != 1) {\n          this.error(\n            DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n            name.range\n          );\n        }\n        if (parameters.length > 0 && parameters[0].initializer !== null) {\n          this.error(\n            DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n            name.range\n          );\n        }\n      } else if (name.text == \"constructor\") {\n        this.error(\n          DiagnosticCode._0_keyword_cannot_be_used_here,\n          name.range, \"constructor\"\n        );\n      }\n\n      let returnType: TypeNode | null = null;\n      if (tn.skip(Token.COLON)) {\n        if (name.kind == NodeKind.CONSTRUCTOR) {\n          this.error(\n            DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,\n            tn.range()\n          );\n        } else if (isSetter) {\n          this.error(\n            DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,\n            tn.range()\n          );\n        }\n        returnType = this.parseType(tn, isSetter || name.kind == NodeKind.CONSTRUCTOR);\n        if (!returnType) return null;\n      } else {\n        returnType = Node.createOmittedType(tn.range(tn.pos));\n        if (!isSetter && name.kind != NodeKind.CONSTRUCTOR) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            returnType.range\n          ); // recoverable\n        }\n      }\n\n      let signature = Node.createFunctionType(\n        parameters,\n        returnType,\n        thisType,\n        false,\n        tn.range(signatureStart, tn.pos)\n      );\n\n      let body: Statement | null = null;\n      if (tn.skip(Token.OPENBRACE)) {\n        if (flags & CommonFlags.AMBIENT) {\n          this.error(\n            DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        } else if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,\n            tn.range(), name.text\n          ); // recoverable\n        } else if (isInterface) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          ); // recoverable\n        }\n        body = this.parseBlockStatement(tn, false);\n        if (!body) return null;\n      } else if (!isInterface && !(flags & (CommonFlags.AMBIENT | CommonFlags.ABSTRACT))) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          tn.range()\n        ); // recoverable\n      }\n\n      let retMethod = Node.createMethodDeclaration(\n        name,\n        decorators,\n        flags,\n        typeParameters,\n        signature,\n        body,\n        tn.range(startPos, tn.pos)\n      );\n      if (!(isInterface && tn.skip(Token.COMMA))) {\n        tn.skip(Token.SEMICOLON);\n      }\n      return retMethod;\n\n    } else if (isConstructor) {\n      this.error(\n        DiagnosticCode.Constructor_implementation_is_missing,\n        name.range\n      );\n\n    } else if (isGetterOrSetter) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        name.range\n      );\n\n    // field: (':' Type)? ('=' Expression)? ';'?\n    } else {\n      if (flags & CommonFlags.DECLARE) {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(declareStart, declareEnd), \"Ambient fields\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.ABSTRACT) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(abstractStart, abstractEnd), \"abstract\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.GET) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(getStart, getEnd), \"get\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.SET) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(setStart, setEnd), \"set\"\n        ); // recoverable\n      }\n\n      let type: TypeNode | null = null;\n      if (tn.skip(Token.QUESTION)) {\n        this.error(\n          DiagnosticCode.Optional_properties_are_not_supported,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      if (tn.skip(Token.EXCLAMATION)) {\n        flags |= CommonFlags.DEFINITELY_ASSIGNED;\n      }\n      if (tn.skip(Token.COLON)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        ); // recoverable\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        if (flags & CommonFlags.AMBIENT) {\n          this.error(\n            DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        }\n        initializer = this.parseExpression(tn);\n        if (!initializer) return null;\n      }\n      let range = tn.range(startPos, tn.pos);\n      if (\n        (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0 &&\n        (isInterface || initializer !== null || (flags & CommonFlags.STATIC) != 0)\n      ) {\n        this.error(\n          DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n          range\n        );\n      }\n      let retField = Node.createFieldDeclaration(\n        name,\n        decorators,\n        flags,\n        type,\n        initializer,\n        range\n      );\n      if (!(isInterface && tn.skip(Token.COMMA))) {\n        tn.skip(Token.SEMICOLON);\n      }\n      return retField;\n    }\n    return null;\n  }\n\n  parseIndexSignature(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n  ): IndexSignatureNode | null {\n\n    // at: '[': 'key' ':' Type ']' ':' Type\n\n    if (decorators !== null && decorators.length > 0) {\n      this.error(\n        DiagnosticCode.Decorators_are_not_valid_here,\n        Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n      ); // recoverable\n    }\n\n    var start = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let id = tn.readIdentifier();\n      if (id == \"key\") {\n        if (tn.skip(Token.COLON)) {\n          let keyType = this.parseType(tn);\n          if (!keyType) return null;\n          if (keyType.kind != NodeKind.NAMEDTYPE) {\n            this.error(\n              DiagnosticCode.Type_expected,\n              tn.range()\n            );\n            return null;\n          }\n          if (tn.skip(Token.CLOSEBRACKET)) {\n            if (tn.skip(Token.COLON)) {\n              let valueType = this.parseType(tn);\n              if (!valueType) return null;\n              if (valueType.kind != NodeKind.NAMEDTYPE) {\n                this.error(\n                  DiagnosticCode.Identifier_expected,\n                  valueType.range\n                );\n                return null;\n              }\n              return Node.createIndexSignature(<NamedTypeNode>keyType, valueType, flags, tn.range(start, tn.pos));\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \":\"\n              );\n            }\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \":\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"key\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseNamespace(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): NamespaceDeclaration | null {\n\n    // at 'namespace': Identifier '{' (Variable | Function)* '}'\n\n    if (tn.skipIdentifier()) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.OPENBRACE)) {\n        let members = new Array<Statement>();\n        let declaration = Node.createNamespaceDeclaration(\n          identifier,\n          decorators,\n          flags,\n          members,\n          tn.range(startPos, tn.pos)\n        );\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          let member = this.parseTopLevelStatement(tn, declaration);\n          if (member) members.push(member);\n          else {\n            this.skipStatement(tn);\n            if (tn.skip(Token.ENDOFFILE)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        declaration.range.end = tn.pos;\n        tn.skip(Token.SEMICOLON);\n        return declaration;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"{\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExport(\n    tn: Tokenizer,\n    startPos: i32,\n    isDeclare: bool\n  ): ExportStatement | null {\n\n    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\n\n    var path: StringLiteralExpression | null = null;\n    var currentSource = assert(this.currentSource);\n    if (tn.skip(Token.OPENBRACE)) {\n      let members = new Array<ExportMember>();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        let member = this.parseExportMember(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.COMMA)) {\n          if (tn.skip(Token.CLOSEBRACE)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n      if (tn.skip(Token.FROM)) {\n        if (tn.skip(Token.STRINGLITERAL)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let ret = Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));\n      if (path !== null) {\n        let internalPath = assert(ret.internalPath);\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(currentSource, path));\n          this.backlog.push(internalPath);\n          this.seenlog.add(internalPath);\n        }\n      }\n      tn.skip(Token.SEMICOLON);\n      return ret;\n    } else if (tn.skip(Token.ASTERISK)) {\n      if (tn.skip(Token.FROM)) {\n        if (tn.skip(Token.STRINGLITERAL)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n          let ret = Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));\n          let internalPath = assert(ret.internalPath);\n          let source = tn.source;\n          let exportPaths = source.exportPaths;\n          if (!exportPaths) source.exportPaths = [ internalPath ];\n          else if (!exportPaths.includes(internalPath)) exportPaths.push(internalPath);\n          if (!this.seenlog.has(internalPath)) {\n            this.dependees.set(internalPath, new Dependee(currentSource, path));\n            this.backlog.push(internalPath);\n          }\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"from\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseExportMember(\n    tn: Tokenizer\n  ): ExportMember | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createExportMember(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createExportMember(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportDefaultAlias(\n    tn: Tokenizer,\n    startPos: i32,\n    defaultStart: i32,\n    defaultEnd: i32\n  ): ExportStatement {\n\n    // at 'export' 'default': [Known-To-Be-]Identifier\n\n    var name = tn.readIdentifier();\n    var range = tn.range();\n    var ret = Node.createExportStatement([\n      Node.createExportMember(\n        Node.createIdentifierExpression(name, range),\n        Node.createIdentifierExpression(\"default\", tn.range(defaultStart, defaultEnd)),\n        range\n      )\n    ], null, false, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseImport(\n    tn: Tokenizer\n  ): ImportStatement | null {\n\n    // at 'import':\n    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\n    //  'from' StringLiteral ';'?\n\n    var startPos = tn.tokenPos;\n    var members: ImportDeclaration[] | null = null;\n    var namespaceName: IdentifierExpression | null = null;\n    var skipFrom = false;\n    if (tn.skip(Token.OPENBRACE)) { // import { ... } from \"file\"\n      members = new Array();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        let member = this.parseImportDeclaration(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.COMMA)) {\n          if (tn.skip(Token.CLOSEBRACE)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n    } else if (tn.skip(Token.ASTERISK)) { // import * from \"file\"\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier()) {\n          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"as\"\n        );\n        return null;\n      }\n    } else if (tn.skip(Token.IDENTIFIER, IdentifierHandling.PREFER)) { // import Name from \"file\"\n      let name = tn.readIdentifier();\n      let range = tn.range();\n      members = [\n        Node.createImportDeclaration(\n          Node.createIdentifierExpression(\"default\", range),\n          Node.createIdentifierExpression(name, range),\n          range\n        )\n      ];\n      if (tn.skip(Token.COMMA)) {\n        // TODO: default + star, default + members\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(),\n          \"Mixed default and named imports\"\n        );\n        return null;\n      }\n    } else { // import \"file\"\n      skipFrom = true;\n    }\n\n    if (skipFrom || tn.skip(Token.FROM)) {\n      if (tn.skip(Token.STRINGLITERAL)) {\n        let path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        let ret: ImportStatement;\n        if (namespaceName) {\n          assert(!members);\n          ret = Node.createWildcardImportStatement(namespaceName, path, tn.range(startPos, tn.pos));\n        } else {\n          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\n        }\n        let internalPath = ret.internalPath;\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(assert(this.currentSource), path));\n          this.backlog.push(internalPath);\n        }\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode.String_literal_expected,\n          tn.range()\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"from\"\n      );\n    }\n    return null;\n  }\n\n  parseImportDeclaration(\n    tn: Tokenizer\n  ): ImportDeclaration | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier()) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createImportDeclaration(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createImportDeclaration(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportImport(\n    tn: Tokenizer,\n    startPos: i32\n  ): ExportImportStatement | null {\n\n    // at 'export' 'import': Identifier ('=' Identifier)? ';'?\n\n    if (tn.skipIdentifier()) {\n      let asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.EQUALS)) {\n        if (tn.skipIdentifier()) {\n          let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          let ret = Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseStatement(\n    tn: Tokenizer,\n    topLevel: bool = false\n  ): Statement | null {\n\n    // at previous token\n\n    var state = tn.mark();\n    var token = tn.next();\n    var statement: Statement | null = null;\n    switch (token) {\n      case Token.BREAK: {\n        statement = this.parseBreak(tn);\n        break;\n      }\n      case Token.CONST: {\n        statement = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos);\n        break;\n      }\n      case Token.CONTINUE: {\n        statement = this.parseContinue(tn);\n        break;\n      }\n      case Token.DO: {\n        statement = this.parseDoStatement(tn);\n        break;\n      }\n      case Token.FOR: {\n        statement = this.parseForStatement(tn);\n        break;\n      }\n      case Token.IF: {\n        statement = this.parseIfStatement(tn);\n        break;\n      }\n      case Token.LET: {\n        statement = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos);\n        break;\n      }\n      case Token.VAR: {\n        statement = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos);\n        break;\n      }\n      case Token.OPENBRACE: {\n        statement = this.parseBlockStatement(tn, topLevel);\n        break;\n      }\n      case Token.RETURN: {\n        if (topLevel) {\n          this.error(\n            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,\n            tn.range()\n          ); // recoverable\n        }\n        statement = this.parseReturn(tn);\n        break;\n      }\n      case Token.SEMICOLON: {\n        return Node.createEmptyStatement(tn.range(tn.tokenPos));\n      }\n      case Token.SWITCH: {\n        statement = this.parseSwitchStatement(tn);\n        break;\n      }\n      case Token.THROW: {\n        statement = this.parseThrowStatement(tn);\n        break;\n      }\n      case Token.TRY: {\n        statement = this.parseTryStatement(tn);\n        break;\n      }\n      case Token.VOID: {\n        statement = this.parseVoidStatement(tn);\n        break;\n      }\n      case Token.WHILE: {\n        statement = this.parseWhileStatement(tn);\n        break;\n      }\n      case Token.TYPE: { // also identifier\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          statement = this.parseTypeDeclaration(tn, CommonFlags.NONE, null, tn.tokenPos);\n          break;\n        }\n        // fall-through\n      }\n      default: {\n        tn.reset(state);\n        statement = this.parseExpressionStatement(tn);\n        break;\n      }\n    }\n    if (!statement) { // has been reported\n      tn.reset(state);\n      this.skipStatement(tn);\n    } else {\n      tn.discard(state);\n    }\n    return statement;\n  }\n\n  parseBlockStatement(\n    tn: Tokenizer,\n    topLevel: bool\n  ): BlockStatement | null {\n\n    // at '{': Statement* '}' ';'?\n\n    var startPos = tn.tokenPos;\n    var statements = new Array<Statement>();\n    while (!tn.skip(Token.CLOSEBRACE)) {\n      let state = tn.mark();\n      let statement = this.parseStatement(tn, topLevel);\n      if (!statement) {\n        if (tn.token == Token.ENDOFFILE) return null;\n        tn.reset(state);\n        this.skipStatement(tn);\n      } else {\n        tn.discard(state);\n        statements.push(statement);\n      }\n    }\n    var ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseBreak(\n    tn: Tokenizer\n  ): BreakStatement | null {\n\n    // at 'break': Identifier? ';'?\n\n    var identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.PREFER);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var ret = Node.createBreakStatement(identifier, tn.range());\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseContinue(\n    tn: Tokenizer\n  ): ContinueStatement | null {\n\n    // at 'continue': Identifier? ';'?\n\n    var identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.PREFER);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var ret = Node.createContinueStatement(identifier, tn.range());\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseDoStatement(\n    tn: Tokenizer\n  ): DoStatement | null {\n\n    // at 'do': Statement 'while' '(' Expression ')' ';'?\n\n    var startPos = tn.tokenPos;\n    var statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    if (tn.skip(Token.WHILE)) {\n\n      if (tn.skip(Token.OPENPAREN)) {\n        let condition = this.parseExpression(tn);\n        if (!condition) return null;\n\n        if (tn.skip(Token.CLOSEPAREN)) {\n          let ret = Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"(\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"while\"\n      );\n    }\n    return null;\n  }\n\n  parseExpressionStatement(\n    tn: Tokenizer\n  ): ExpressionStatement | null {\n\n    // at previous token\n\n    var expr = this.parseExpression(tn);\n    if (!expr) return null;\n\n    var ret = Node.createExpressionStatement(expr);\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseForStatement(\n    tn: Tokenizer\n  ): Statement | null {\n\n    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\n\n    var startPos = tn.tokenPos;\n\n    if (tn.skip(Token.OPENPAREN)) {\n      let initializer: Statement | null = null;\n\n      if (tn.skip(Token.CONST)) {\n        initializer = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.LET)) {\n        initializer = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.VAR)) {\n        initializer = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos, true);\n\n      } else if (!tn.skip(Token.SEMICOLON)) {\n        initializer = this.parseExpressionStatement(tn);\n        if (!initializer) return null;\n      }\n\n      if (initializer) {\n        if (tn.skip(Token.OF)) {\n          // TODO: for (let [key, val] of ...)\n          if (initializer.kind == NodeKind.EXPRESSION) {\n            if ((<ExpressionStatement>initializer).expression.kind != NodeKind.IDENTIFIER) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                initializer.range\n              );\n              return null;\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          if (initializer.kind == NodeKind.VARIABLE) {\n            let declarations = (<VariableStatement>initializer).declarations;\n            for (let i = 0, k = declarations.length; i < k; ++i) {\n              let declaration = declarations[i];\n              let initializer = declaration.initializer;\n              if (initializer) {\n                this.error(\n                  DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,\n                  initializer.range\n                ); // recoverable\n              }\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            initializer.range\n          );\n          return null;\n        }\n        // non-for..of needs type or initializer\n        if (initializer.kind == NodeKind.VARIABLE) {\n          let declarations = (<VariableStatement>initializer).declarations;\n          for (let i = 0, k = declarations.length; i < k; ++i) {\n            let declaration = declarations[i];\n            if (!declaration.initializer) {\n              if (declaration.flags & CommonFlags.CONST) {\n                this.error(\n                  DiagnosticCode._const_declarations_must_be_initialized,\n                  declaration.name.range\n                );\n              } else if (!declaration.type) {\n                this.error(\n                  DiagnosticCode.Type_expected,\n                  declaration.name.range.atEnd\n                );\n              }\n            }\n          }\n        }\n      }\n\n      if (tn.token == Token.SEMICOLON) {\n        let condition: ExpressionStatement | null = null;\n        if (!tn.skip(Token.SEMICOLON)) {\n          condition = this.parseExpressionStatement(tn);\n          if (!condition) return null;\n        }\n\n        if (tn.token == Token.SEMICOLON) {\n          let incrementor: Expression | null = null;\n          if (!tn.skip(Token.CLOSEPAREN)) {\n            incrementor = this.parseExpression(tn);\n            if (!incrementor) return null;\n\n            if (!tn.skip(Token.CLOSEPAREN)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \")\"\n              );\n              return null;\n            }\n          }\n\n          let statement = this.parseStatement(tn);\n          if (!statement) return null;\n\n          return Node.createForStatement(\n            initializer,\n            condition\n              ? condition.expression\n              : null,\n            incrementor,\n            statement,\n            tn.range(startPos, tn.pos)\n          );\n\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \";\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseForOfStatement(\n    tn: Tokenizer,\n    startPos: i32,\n    variable: Statement,\n  ): ForOfStatement | null {\n\n    // at 'of': Expression ')' Statement\n\n    var iterable = this.parseExpression(tn);\n    if (!iterable) return null;\n\n    if (!tn.skip(Token.CLOSEPAREN)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \")\"\n      );\n      return null;\n    }\n\n    var statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    return Node.createForOfStatement(\n      variable,\n      iterable,\n      statement,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  parseIfStatement(\n    tn: Tokenizer\n  ): IfStatement | null {\n\n    // at 'if': '(' Expression ')' Statement ('else' Statement)?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let elseStatement: Statement | null = null;\n        if (tn.skip(Token.ELSE)) {\n          elseStatement = this.parseStatement(tn);\n          if (!elseStatement) return null;\n        }\n        return Node.createIfStatement(\n          condition,\n          statement,\n          elseStatement,\n          tn.range(startPos, tn.pos)\n        );\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchStatement(\n    tn: Tokenizer\n  ): SwitchStatement | null {\n\n    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        if (tn.skip(Token.OPENBRACE)) {\n          let switchCases = new Array<SwitchCase>();\n          while (!tn.skip(Token.CLOSEBRACE)) {\n            let switchCase = this.parseSwitchCase(tn);\n            if (!switchCase) return null;\n            switchCases.push(switchCase);\n          }\n          let ret = Node.createSwitchStatement(condition, switchCases, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchCase(\n    tn: Tokenizer\n  ): SwitchCase | null {\n\n    var startPos = tn.tokenPos;\n    var statements: Statement[],\n        statement: Statement | null;\n\n    // 'case' Expression ':' Statement*\n\n    if (tn.skip(Token.CASE)) {\n      let label = this.parseExpression(tn);\n      if (!label) return null;\n      if (tn.skip(Token.COLON)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.CASE &&\n          tn.nextToken != Token.DEFAULT &&\n          tn.nextToken != Token.CLOSEBRACE\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n\n      // 'default' ':' Statement*\n\n    } else if (tn.skip(Token.DEFAULT)) {\n      if (tn.skip(Token.COLON)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.CASE &&\n          tn.nextToken != Token.DEFAULT &&\n          tn.nextToken != Token.CLOSEBRACE\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._case_or_default_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseThrowStatement(\n    tn: Tokenizer\n  ): ThrowStatement | null {\n\n    // at 'throw': Expression ';'?\n\n    var startPos = tn.tokenPos;\n    var expression = this.parseExpression(tn);\n    if (!expression) return null;\n    var ret = Node.createThrowStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseTryStatement(\n    tn: Tokenizer\n  ): TryStatement | null {\n\n    // at 'try':\n    //   '{' Statement* '}'\n    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\n    //   ('finally' '{' Statement* '}'? ';'?\n\n    var startPos = tn.tokenPos;\n    var stmt: Statement | null;\n    if (tn.skip(Token.OPENBRACE)) {\n      let statements = new Array<Statement>();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        stmt = this.parseStatement(tn);\n        if (!stmt) return null;\n        statements.push(stmt);\n      }\n      let catchVariable: IdentifierExpression | null = null;\n      let catchStatements: Statement[] | null = null;\n      let finallyStatements: Statement[] | null = null;\n      if (tn.skip(Token.CATCH)) {\n        if (!tn.skip(Token.OPENPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"(\"\n          );\n          return null;\n        }\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        if (!tn.skip(Token.OPENBRACE)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        catchStatements = [];\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          catchStatements.push(stmt);\n        }\n      }\n      if (tn.skip(Token.FINALLY)) {\n        if (!tn.skip(Token.OPENBRACE)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        finallyStatements = [];\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          finallyStatements.push(stmt);\n        }\n      }\n      if (!(catchStatements || finallyStatements)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"catch\"\n        );\n        return null;\n      }\n      let ret = Node.createTryStatement(\n        statements,\n        catchVariable,\n        catchStatements,\n        finallyStatements,\n        tn.range(startPos, tn.pos)\n      );\n      tn.skip(Token.SEMICOLON);\n      return ret;\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseTypeDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): TypeDeclaration | null {\n\n    // at 'type': Identifier ('<' TypeParameters '>')? '=' '|'? Type ';'?\n\n    if (tn.skipIdentifier()) {\n      let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let typeParameters: TypeParameterNode[] | null = null;\n      if (tn.skip(Token.LESSTHAN)) {\n        typeParameters = this.parseTypeParameters(tn);\n        if (!typeParameters) return null;\n        flags |= CommonFlags.GENERIC;\n      }\n      if (tn.skip(Token.EQUALS)) {\n        tn.skip(Token.BAR);\n        let type = this.parseType(tn);\n        if (!type) return null;\n        let ret = Node.createTypeDeclaration(\n          name,\n          decorators,\n          flags,\n          typeParameters,\n          type,\n          tn.range(startPos, tn.pos)\n        );\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVoidStatement(\n    tn: Tokenizer\n  ): VoidStatement | null {\n\n    // at 'void': Expression ';'?\n\n    var startPos = tn.tokenPos;\n    var expression = this.parseExpression(tn, Precedence.GROUPING);\n    if (!expression) return null;\n    var ret = Node.createVoidStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseWhileStatement(\n    tn: Tokenizer\n  ): WhileStatement | null {\n\n    // at 'while': '(' Expression ')' Statement ';'?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let expression = this.parseExpression(tn);\n      if (!expression) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let ret = Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  // expressions\n\n  parseExpressionStart(\n    tn: Tokenizer\n  ): Expression | null {\n    var token = tn.next(IdentifierHandling.PREFER);\n    var startPos = tn.tokenPos;\n    switch (token) {\n\n      // TODO: SpreadExpression, YieldExpression\n      case Token.DOT_DOT_DOT:\n      case Token.YIELD: // fallthrough to unsupported UnaryPrefixExpression\n\n      // UnaryPrefixExpression\n      case Token.EXCLAMATION:\n      case Token.TILDE:\n      case Token.PLUS:\n      case Token.MINUS:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.DELETE: {\n        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);\n        if (!operand) return null;\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);\n        if (!operand) return null;\n        switch (operand.kind) {\n          case NodeKind.IDENTIFIER:\n          case NodeKind.ELEMENTACCESS:\n          case NodeKind.PROPERTYACCESS: break;\n          default: {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              operand.range\n            );\n          }\n        }\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n\n      // NewExpression\n      case Token.NEW: {\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        let typeName = this.parseTypeName(tn);\n        if (!typeName) return null;\n        let typeArguments: TypeNode[] | null = null;\n        let arguments_: Expression[] | null = null;\n        if (\n          tn.skip(Token.OPENPAREN) ||\n          (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null\n        ) {\n          arguments_ = this.parseArguments(tn);\n          if (!arguments_) return null;\n        } else {\n          arguments_ = []; // new Type;\n        }\n        return Node.createNewExpression(\n          typeName,\n          typeArguments,\n          arguments_,\n          tn.range(startPos, tn.pos)\n        );\n      }\n\n      // Special IdentifierExpression\n      case Token.NULL: return Node.createNullExpression(tn.range());\n      case Token.TRUE: return Node.createTrueExpression(tn.range());\n      case Token.FALSE: return Node.createFalseExpression(tn.range());\n      case Token.THIS: return Node.createThisExpression(tn.range());\n      case Token.CONSTRUCTOR: return Node.createConstructorExpression(tn.range());\n\n      // ParenthesizedExpression or FunctionExpression\n      case Token.OPENPAREN: {\n\n        // determine whether this is a function expression\n        if (tn.skip(Token.CLOSEPAREN)) { // must be a function expression (fast route)\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [],\n            null,\n            ArrowKind.ARROW_PARENTHESIZED\n          );\n        }\n        let state = tn.mark();\n        let again = true;\n        do {\n          switch (tn.next(IdentifierHandling.PREFER)) {\n\n            // function expression\n            case Token.DOT_DOT_DOT: {\n              tn.reset(state);\n              return this.parseFunctionExpression(tn);\n            }\n            // can be both\n            case Token.IDENTIFIER: {\n              tn.readIdentifier();\n              switch (tn.next()) {\n\n                // if we got here, check for arrow\n                case Token.CLOSEPAREN: {\n                  if (\n                    !tn.skip(Token.COLON) &&\n                    !tn.skip(Token.EQUALS_GREATERTHAN)\n                  ) {\n                    again = false;\n                    break;\n                  }\n                  // fall-through\n                }\n                // function expression\n                case Token.COLON: {    // type annotation\n                  tn.reset(state);\n                  return this.parseFunctionExpression(tn);\n                }\n                // optional parameter or parenthesized\n                case Token.QUESTION: {\n                  if (\n                    tn.skip(Token.COLON) ||   // optional parameter with type\n                    tn.skip(Token.COMMA) ||   // optional parameter without type\n                    tn.skip(Token.CLOSEPAREN) // last optional parameter without type\n                  ) {\n                    tn.reset(state);\n                    return this.parseFunctionExpression(tn);\n                  }\n                  again = false; // parenthesized\n                  break;\n                }\n                case Token.COMMA: {\n                  break; // continue\n                }\n                // parenthesized expression\n                // case Token.EQUALS:  // missing type annotation for simplicity\n                default: {\n                  again = false;\n                  break;\n                }\n              }\n              break;\n            }\n            // parenthesized expression\n            default: {\n              again = false;\n              break;\n            }\n          }\n        } while (again);\n        tn.reset(state);\n\n        // parse parenthesized\n        let inner = this.parseExpression(tn);\n        if (!inner) return null;\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        inner = Node.createParenthesizedExpression(inner, tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, inner);\n      }\n      // ArrayLiteralExpression\n      case Token.OPENBRACKET: {\n        let elementExpressions = new Array<Expression>();\n        while (!tn.skip(Token.CLOSEBRACKET)) {\n          let expr: Expression | null;\n          if (tn.peek() == Token.COMMA) {\n            expr = Node.createOmittedExpression(tn.range(tn.pos));\n          } else {\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!expr) return null;\n          }\n          elementExpressions.push(expr);\n          if (!tn.skip(Token.COMMA)) {\n            if (tn.skip(Token.CLOSEBRACKET)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"]\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\n      }\n      // ObjectLiteralExpression\n      case Token.OPENBRACE: {\n        let startPos = tn.tokenPos;\n        let names = new Array<IdentifierExpression>();\n        let values = new Array<Expression>();\n        let name: IdentifierExpression;\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          if (!tn.skipIdentifier()) {\n            if (!tn.skip(Token.STRINGLITERAL)) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                tn.range(),\n              );\n              return null;\n            }\n            name = Node.createIdentifierExpression(tn.readString(), tn.range());\n            name.isQuoted = true;\n          } else {\n            name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          }\n          names.push(name);\n          if (tn.skip(Token.COLON)) {\n            let value = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!value) return null;\n            values.push(value);\n          } else if (!name.isQuoted) {\n            values.push(name);\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.COMMA)) {\n            if (tn.skip(Token.CLOSEBRACE)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));\n      }\n      // AssertionExpression (unary prefix)\n      case Token.LESSTHAN: {\n        let toType = this.parseType(tn);\n        if (!toType) return null;\n        if (!tn.skip(Token.GREATERTHAN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n        let expr = this.parseExpression(tn, Precedence.CALL);\n        if (!expr) return null;\n        return Node.createAssertionExpression(\n          AssertionKind.PREFIX,\n          expr,\n          toType,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.IDENTIFIER: {\n        let identifierText = tn.readIdentifier();\n        if (identifierText == \"null\") return Node.createNullExpression(tn.range()); // special\n        let identifier = Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));\n        if (tn.skip(Token.TEMPLATELITERAL)) {\n          return this.parseTemplateLiteral(tn, identifier);\n        }\n        if (tn.peek(true) == Token.EQUALS_GREATERTHAN && !tn.nextTokenOnNewLine) {\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [\n              Node.createParameter(\n                ParameterKind.DEFAULT,\n                identifier,\n                Node.createOmittedType(identifier.range.atEnd),\n                null,\n                identifier.range\n              )\n            ],\n            null,\n            ArrowKind.ARROW_SINGLE,\n            startPos\n          );\n        }\n        return this.maybeParseCallExpression(tn, identifier, true);\n      }\n      case Token.SUPER: {\n        if (tn.peek() != Token.DOT && tn.nextToken != Token.OPENPAREN) {\n          this.error(\n            DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,\n            tn.range()\n          );\n        }\n        let expr = Node.createSuperExpression(tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.STRINGLITERAL: {\n        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\n      }\n      case Token.TEMPLATELITERAL: {\n        return this.parseTemplateLiteral(tn);\n      }\n      case Token.INTEGERLITERAL: {\n        let value = tn.readInteger();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createIntegerLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      case Token.FLOATLITERAL: {\n        let value = tn.readFloat();\n        tn.checkForIdentifierStartAfterNumericLiteral();\n        return Node.createFloatLiteralExpression(value, tn.range(startPos, tn.pos));\n      }\n      // RegexpLiteralExpression\n      // note that this also continues on invalid ones so the surrounding AST remains intact\n      case Token.SLASH: {\n        let regexpPattern = tn.readRegexpPattern(); // also reports\n        if (!tn.skip(Token.SLASH)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"/\"\n          );\n          return null;\n        }\n        return Node.createRegexpLiteralExpression(\n          regexpPattern,\n          tn.readRegexpFlags(), // also reports\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.FUNCTION: {\n        let expr = this.parseFunctionExpression(tn);\n        if (!expr) return null;\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.CLASS: {\n        return this.parseClassExpression(tn);\n      }\n      default: {\n        if (token == Token.ENDOFFILE) {\n          this.error(\n            DiagnosticCode.Unexpected_end_of_text,\n            tn.range(startPos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_expected,\n            tn.range()\n          );\n        }\n        return null;\n      }\n    }\n  }\n\n  tryParseTypeArgumentsBeforeArguments(\n    tn: Tokenizer\n  ): TypeNode[] | null {\n\n    // at '<': Type (',' Type)* '>' '('\n\n    var state = tn.mark();\n    if (!tn.skip(Token.LESSTHAN)) return null;\n    var start = tn.tokenPos;\n    var typeArguments: TypeNode[] | null = null;\n    do {\n      if (tn.peek() === Token.GREATERTHAN) {\n        break;\n      }\n      let type = this.parseType(tn, true, true);\n      if (!type) {\n        tn.reset(state);\n        return null;\n      }\n      if (!typeArguments) typeArguments = [ type ];\n      else typeArguments.push(type);\n    } while (tn.skip(Token.COMMA));\n    if (tn.skip(Token.GREATERTHAN)) {\n      let end = tn.pos;\n      if (tn.skip(Token.OPENPAREN)) {\n        if (!typeArguments) {\n          this.error(\n            DiagnosticCode.Type_argument_list_cannot_be_empty,\n            tn.range(start, end)\n          );\n        }\n        return typeArguments;\n      }\n    }\n    tn.reset(state);\n    return null;\n  }\n\n  parseArguments(\n    tn: Tokenizer\n  ): Expression[] | null {\n\n    // at '(': (Expression (',' Expression)*)? ')'\n\n    var args = new Array<Expression>();\n    while (!tn.skip(Token.CLOSEPAREN)) {\n      let expr = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!expr) return null;\n      args.push(expr);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return args;\n  }\n\n  parseExpression(\n    tn: Tokenizer,\n    precedence: Precedence = Precedence.COMMA\n  ): Expression | null {\n    assert(precedence != Precedence.NONE);\n    var expr = this.parseExpressionStart(tn);\n    if (!expr) return null;\n    var startPos = expr.range.start;\n\n    // precedence climbing\n    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\n    var nextPrecedence: Precedence;\n    while (\n      (nextPrecedence = determinePrecedence(tn.peek())) >= precedence\n    ) {\n      let token = tn.next();\n      switch (token) {\n\n        // AssertionExpression\n        case Token.AS: {\n          if (tn.skip(Token.CONST)) {\n            expr = Node.createAssertionExpression(\n              AssertionKind.CONST,\n              expr,\n              null,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let toType = this.parseType(tn); // reports\n            if (!toType) return null;\n            expr = Node.createAssertionExpression(\n              AssertionKind.AS,\n              expr,\n              toType,\n              tn.range(startPos, tn.pos)\n            );\n          }\n          break;\n        }\n        case Token.EXCLAMATION: {\n          expr = Node.createAssertionExpression(\n            AssertionKind.NONNULL,\n            expr,\n            null,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // InstanceOfExpression\n        case Token.INSTANCEOF: {\n          let isType = this.parseType(tn); // reports\n          if (!isType) return null;\n          expr = Node.createInstanceOfExpression(\n            expr,\n            isType,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // ElementAccessExpression\n        case Token.OPENBRACKET: {\n          let next = this.parseExpression(tn); // reports\n          if (!next) return null;\n          if (!tn.skip(Token.CLOSEBRACKET)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n            return null;\n          }\n          expr = Node.createElementAccessExpression(\n            expr,\n            next,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // UnaryPostfixExpression\n        case Token.PLUS_PLUS:\n        case Token.MINUS_MINUS: {\n          if (\n            expr.kind != NodeKind.IDENTIFIER &&\n            expr.kind != NodeKind.ELEMENTACCESS &&\n            expr.kind != NodeKind.PROPERTYACCESS\n          ) {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              expr.range\n            );\n          }\n          expr = Node.createUnaryPostfixExpression(\n            token,\n            expr,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // TernaryExpression\n        case Token.QUESTION: {\n          let ifThen = this.parseExpression(tn);\n          if (!ifThen) return null;\n          if (!tn.skip(Token.COLON)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          let ifElse = this.parseExpression(tn, precedence > Precedence.COMMA\n            ? Precedence.COMMA + 1\n            : Precedence.COMMA\n          );\n          if (!ifElse) return null;\n          expr = Node.createTernaryExpression(\n            expr,\n            ifThen,\n            ifElse,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // CommaExpression\n        case Token.COMMA: {\n          let commaExprs: Expression[] = [ expr ];\n          do {\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!expr) return null;\n            commaExprs.push(expr);\n          } while (tn.skip(Token.COMMA));\n          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\n          break;\n        }\n        // PropertyAccessExpression\n        case Token.DOT: {\n          if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) { // expr '.' Identifier\n            let next = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n            expr = Node.createPropertyAccessExpression(\n              expr,\n              next,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let next = this.parseExpression(tn, nextPrecedence + 1);\n            if (!next) return null;\n            if (next.kind == NodeKind.CALL) { // expr '.' CallExpression\n              expr = this.joinPropertyCall(tn, startPos, expr, <CallExpression>next);\n              if (!expr) return null;\n            } else {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                next.range\n              );\n              return null;\n            }\n          }\n          if (tn.skip(Token.TEMPLATELITERAL)) {\n            expr = this.parseTemplateLiteral(tn, expr);\n            if (!expr) return null;\n          } else {\n            expr = this.maybeParseCallExpression(tn, expr, true);\n          }\n          break;\n        }\n        // BinaryExpression (right associative)\n        case Token.EQUALS:\n        case Token.PLUS_EQUALS:\n        case Token.MINUS_EQUALS:\n        case Token.ASTERISK_ASTERISK_EQUALS:\n        case Token.ASTERISK_EQUALS:\n        case Token.SLASH_EQUALS:\n        case Token.PERCENT_EQUALS:\n        case Token.LESSTHAN_LESSTHAN_EQUALS:\n        case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n        case Token.AMPERSAND_EQUALS:\n        case Token.CARET_EQUALS:\n        case Token.BAR_EQUALS:\n        case Token.ASTERISK_ASTERISK: {\n          let next = this.parseExpression(tn, nextPrecedence);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        // BinaryExpression\n        case Token.LESSTHAN:\n        case Token.GREATERTHAN:\n        case Token.LESSTHAN_EQUALS:\n        case Token.GREATERTHAN_EQUALS:\n        case Token.EQUALS_EQUALS:\n        case Token.EQUALS_EQUALS_EQUALS:\n        case Token.EXCLAMATION_EQUALS_EQUALS:\n        case Token.EXCLAMATION_EQUALS:\n        case Token.PLUS:\n        case Token.MINUS:\n        case Token.ASTERISK:\n        case Token.SLASH:\n        case Token.PERCENT:\n        case Token.LESSTHAN_LESSTHAN:\n        case Token.GREATERTHAN_GREATERTHAN:\n        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\n        case Token.AMPERSAND:\n        case Token.BAR:\n        case Token.CARET:\n        case Token.AMPERSAND_AMPERSAND:\n        case Token.BAR_BAR: {\n          let next = this.parseExpression(tn, nextPrecedence + 1);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        default: assert(false); // filtered by determinePrecedence\n      }\n    }\n    return expr;\n  }\n\n  private parseTemplateLiteral(tn: Tokenizer, tag: Expression | null = null): Expression | null {\n    // at '`': ... '`'\n    var startPos = tag ? tag.range.start : tn.tokenPos;\n    var parts = new Array<string>();\n    var rawParts = new Array<string>();\n    var exprs = new Array<Expression>();\n    parts.push(tn.readString(0, tag != null));\n    rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    while (tn.readingTemplateString) {\n      let expr = this.parseExpression(tn);\n      if (!expr) return null;\n      exprs.push(expr);\n      if (!tn.skip(Token.CLOSEBRACE)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"}\"\n        );\n        return null;\n      }\n      parts.push(tn.readString(CharCode.BACKTICK, tag != null));\n      rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\n    }\n    return Node.createTemplateLiteralExpression(tag, parts, rawParts, exprs, tn.range(startPos, tn.pos));\n  }\n\n  private joinPropertyCall(\n    tn: Tokenizer,\n    startPos: i32,\n    expr: Expression,\n    call: CallExpression\n  ): Expression | null {\n    var callee = call.expression;\n    switch (callee.kind) {\n      case NodeKind.IDENTIFIER: { // join property access and use as call target\n        call.expression = Node.createPropertyAccessExpression(\n          expr,\n          <IdentifierExpression>callee,\n          tn.range(startPos, tn.pos)\n        );\n        break;\n      }\n      case NodeKind.CALL: { // join call target und wrap the original call around it\n        let inner = this.joinPropertyCall(tn, startPos, expr, <CallExpression>callee);\n        if (!inner) return null;\n        call.expression = inner;\n        call.range = tn.range(startPos, tn.pos);\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          call.range\n        );\n        return null;\n      }\n    }\n    return call;\n  }\n\n  private maybeParseCallExpression(\n    tn: Tokenizer,\n    expr: Expression,\n    potentiallyGeneric: bool = false\n  ): Expression {\n    var typeArguments: TypeNode[] | null = null;\n    while (\n      tn.skip(Token.OPENPAREN) ||\n      potentiallyGeneric &&\n      (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null\n    ) {\n      let args = this.parseArguments(tn);\n      if (!args) break;\n      expr = Node.createCallExpression( // is again callable\n        expr,\n        typeArguments,\n        args,\n        tn.range(expr.range.start, tn.pos)\n      );\n      potentiallyGeneric = false;\n    }\n    return expr;\n  }\n\n  /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipStatement(tn: Tokenizer): void {\n    tn.peek(true);\n    if (tn.nextTokenOnNewLine) tn.next(); // if reset() to the previous line\n    do {\n      let nextToken = tn.peek(true);\n      if (\n        nextToken == Token.ENDOFFILE ||   // next step should handle this\n        nextToken == Token.SEMICOLON      // end of the statement for sure\n      ) {\n        tn.next();\n        break;\n      }\n      if (tn.nextTokenOnNewLine) break;   // end of the statement maybe\n      switch (tn.next()) {\n        case Token.IDENTIFIER: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.STRINGLITERAL:\n        case Token.TEMPLATELITERAL: {\n          tn.readString();\n          break;\n        }\n        case Token.INTEGERLITERAL: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FLOATLITERAL: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.OPENBRACE: {\n          this.skipBlock(tn);\n          break;\n        }\n      }\n    } while (true);\n    tn.readingTemplateString = false;\n  }\n\n  /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipBlock(tn: Tokenizer): void {\n    // at '{': ... '}'\n    var depth = 1;\n    var again = true;\n    do {\n      switch (tn.next()) {\n        case Token.ENDOFFILE: {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          again = false;\n          break;\n        }\n        case Token.OPENBRACE: {\n          ++depth;\n          break;\n        }\n        case Token.CLOSEBRACE: {\n          --depth;\n          if (!depth) again = false;\n          break;\n        }\n        case Token.IDENTIFIER: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.STRINGLITERAL:{\n          tn.readString();\n          break;\n        }\n        case Token.TEMPLATELITERAL: {\n          tn.readString();\n          while(tn.readingTemplateString){\n            this.skipBlock(tn);\n            tn.readString(CharCode.BACKTICK);\n          }\n          break;\n        }\n        case Token.INTEGERLITERAL: {\n          tn.readInteger();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n        case Token.FLOATLITERAL: {\n          tn.readFloat();\n          tn.checkForIdentifierStartAfterNumericLiteral();\n          break;\n        }\n      }\n    } while (again);\n  }\n}\n\n/** Operator precedence from least to largest. */\nexport const enum Precedence {\n  NONE,\n  COMMA,\n  SPREAD,\n  YIELD,\n  ASSIGNMENT,\n  CONDITIONAL,\n  LOGICAL_OR,\n  LOGICAL_AND,\n  BITWISE_OR,\n  BITWISE_XOR,\n  BITWISE_AND,\n  EQUALITY,\n  RELATIONAL,\n  SHIFT,\n  ADDITIVE,\n  MULTIPLICATIVE,\n  EXPONENTIATED,\n  UNARY_PREFIX,\n  UNARY_POSTFIX,\n  CALL,\n  MEMBERACCESS,\n  GROUPING\n}\n\n/** Determines the precende of a non-starting token. */\nfunction determinePrecedence(kind: Token): Precedence {\n  switch (kind) {\n    case Token.COMMA: return Precedence.COMMA;\n    case Token.EQUALS:\n    case Token.PLUS_EQUALS:\n    case Token.MINUS_EQUALS:\n    case Token.ASTERISK_ASTERISK_EQUALS:\n    case Token.ASTERISK_EQUALS:\n    case Token.SLASH_EQUALS:\n    case Token.PERCENT_EQUALS:\n    case Token.LESSTHAN_LESSTHAN_EQUALS:\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n    case Token.AMPERSAND_EQUALS:\n    case Token.CARET_EQUALS:\n    case Token.BAR_EQUALS: return Precedence.ASSIGNMENT;\n    case Token.QUESTION: return Precedence.CONDITIONAL;\n    case Token.BAR_BAR: return Precedence.LOGICAL_OR;\n    case Token.AMPERSAND_AMPERSAND: return Precedence.LOGICAL_AND;\n    case Token.BAR: return Precedence.BITWISE_OR;\n    case Token.CARET: return Precedence.BITWISE_XOR;\n    case Token.AMPERSAND: return Precedence.BITWISE_AND;\n    case Token.EQUALS_EQUALS:\n    case Token.EXCLAMATION_EQUALS:\n    case Token.EQUALS_EQUALS_EQUALS:\n    case Token.EXCLAMATION_EQUALS_EQUALS: return Precedence.EQUALITY;\n    case Token.AS:\n    case Token.IN:\n    case Token.INSTANCEOF:\n    case Token.LESSTHAN:\n    case Token.GREATERTHAN:\n    case Token.LESSTHAN_EQUALS:\n    case Token.GREATERTHAN_EQUALS: return Precedence.RELATIONAL;\n    case Token.LESSTHAN_LESSTHAN:\n    case Token.GREATERTHAN_GREATERTHAN:\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return Precedence.SHIFT;\n    case Token.PLUS:\n    case Token.MINUS: return Precedence.ADDITIVE;\n    case Token.ASTERISK:\n    case Token.SLASH:\n    case Token.PERCENT: return Precedence.MULTIPLICATIVE;\n    case Token.ASTERISK_ASTERISK: return Precedence.EXPONENTIATED;\n    case Token.PLUS_PLUS:\n    case Token.MINUS_MINUS: return Precedence.UNARY_POSTFIX;\n    case Token.DOT:\n    case Token.OPENBRACKET:\n    case Token.EXCLAMATION: return Precedence.MEMBERACCESS;\n  }\n  return Precedence.NONE;\n}\n","/**\n * @fileoverview Utility to find all locals used in an expression.\n * @license Apache-2.0\n */\n\nimport {\n  Visitor\n} from \"./pass\";\n\nimport {\n  ExpressionRef\n} from \"../module\";\n\nimport {\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalSetGetIndex\n} from \"../glue/binaryen\";\n\nclass FindUsedLocalsVisitor extends Visitor {\n  used: Set<i32>;\n\n  constructor(used: Set<i32> = new Set()) {\n    super();\n    this.used = used;\n  }\n  \n  /** @override */\n  visitLocalGet(localGet: ExpressionRef): void {\n    this.used.add(<i32>_BinaryenLocalGetGetIndex(localGet));\n  }\n\n  /** @override */\n  visitLocalSet(localSet: ExpressionRef): void {\n    this.used.add(<i32>_BinaryenLocalSetGetIndex(localSet));\n  }\n}\n\nvar singleton: FindUsedLocalsVisitor | null = null;\n\n/** Finds the indexes of all locals used in the specified expression. */\nexport function findUsedLocals(\n  expr: ExpressionRef,\n  used: Set<i32> = new Set()\n): Set<i32> {\n  var visitor = singleton;\n  if (!visitor) singleton = visitor = new FindUsedLocalsVisitor(used);\n  else visitor.used = used;\n  visitor.visit(expr);\n  return used;\n}\n","/**\n * @fileoverview Infrastructure for custom Binaryen passes.\n * @license Apache-2.0\n */\n\nimport {\n  Module,\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  GlobalRef,\n  Index,\n  StringRef\n} from \"../module\";\n\nimport {\n  _BinaryenExpressionGetId,\n  _BinaryenBlockGetNumChildren,\n  _BinaryenBlockGetChildAt,\n  _BinaryenIfGetCondition,\n  _BinaryenIfGetIfTrue,\n  _BinaryenIfGetIfFalse,\n  _BinaryenLoopGetBody,\n  _BinaryenBreakGetCondition,\n  _BinaryenBreakGetValue,\n  _BinaryenGetNumFunctions,\n  _BinaryenGetFunctionByIndex,\n  _BinaryenGetNumGlobals,\n  _BinaryenGetGlobalByIndex,\n  _BinaryenFunctionGetBody,\n  _BinaryenSwitchGetCondition,\n  _BinaryenSwitchGetValue,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenLocalSetGetValue,\n  _BinaryenGlobalSetGetValue,\n  _BinaryenGlobalGetInitExpr,\n  _BinaryenLoadGetPtr,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreGetValue,\n  _BinaryenUnaryGetValue,\n  _BinaryenBinaryGetLeft,\n  _BinaryenBinaryGetRight,\n  _BinaryenSelectGetIfTrue,\n  _BinaryenSelectGetIfFalse,\n  _BinaryenSelectGetCondition,\n  _BinaryenDropGetValue,\n  _BinaryenBlockSetChildAt,\n  _BinaryenCallIndirectGetTarget,\n  _BinaryenReturnGetValue,\n  _BinaryenMemoryGrowGetDelta,\n  _BinaryenAtomicRMWGetPtr,\n  _BinaryenAtomicRMWGetValue,\n  _BinaryenAtomicCmpxchgGetPtr,\n  _BinaryenAtomicCmpxchgGetExpected,\n  _BinaryenAtomicCmpxchgGetReplacement,\n  _BinaryenAtomicWaitGetPtr,\n  _BinaryenAtomicWaitGetExpected,\n  _BinaryenAtomicWaitGetTimeout,\n  _BinaryenAtomicNotifyGetPtr,\n  _BinaryenSIMDExtractGetVec,\n  _BinaryenSIMDReplaceGetVec,\n  _BinaryenSIMDReplaceGetValue,\n  _BinaryenSIMDShuffleGetLeft,\n  _BinaryenSIMDShuffleGetRight,\n  _BinaryenSIMDTernaryGetA,\n  _BinaryenSIMDTernaryGetB,\n  _BinaryenSIMDTernaryGetC,\n  _BinaryenSIMDShiftGetVec,\n  _BinaryenSIMDShiftGetShift,\n  _BinaryenSIMDLoadGetPtr,\n  _BinaryenMemoryInitGetDest,\n  _BinaryenMemoryInitGetOffset,\n  _BinaryenMemoryInitGetSize,\n  _BinaryenMemoryCopyGetDest,\n  _BinaryenMemoryCopyGetSource,\n  _BinaryenMemoryCopyGetSize,\n  _BinaryenMemoryFillGetDest,\n  _BinaryenMemoryFillGetValue,\n  _BinaryenMemoryFillGetSize,\n  _BinaryenRefIsGetValue,\n  _BinaryenTryGetBody,\n  _BinaryenTryGetNumCatchBodies,\n  _BinaryenTryGetCatchBodyAt,\n  _BinaryenThrowGetNumOperands,\n  _BinaryenThrowGetOperandAt,\n  _BinaryenTupleMakeGetOperandAt,\n  _BinaryenTupleMakeGetNumOperands,\n  _BinaryenIfSetCondition,\n  _BinaryenIfSetIfTrue,\n  _BinaryenIfSetIfFalse,\n  _BinaryenLoopSetBody,\n  _BinaryenBreakSetCondition,\n  _BinaryenBreakSetValue,\n  _BinaryenSwitchSetCondition,\n  _BinaryenSwitchSetValue,\n  _BinaryenCallSetOperandAt,\n  _BinaryenCallIndirectSetTarget,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenLocalSetSetValue,\n  _BinaryenGlobalSetSetValue,\n  _BinaryenLoadSetPtr,\n  _BinaryenStoreSetPtr,\n  _BinaryenStoreSetValue,\n  _BinaryenUnarySetValue,\n  _BinaryenExpressionFinalize,\n  _BinaryenBinarySetLeft,\n  _BinaryenBinarySetRight,\n  _BinaryenSelectSetIfTrue,\n  _BinaryenSelectSetIfFalse,\n  _BinaryenSelectSetCondition,\n  _BinaryenDropSetValue,\n  _BinaryenReturnSetValue,\n  _BinaryenMemoryGrowSetDelta,\n  _BinaryenAtomicRMWSetPtr,\n  _BinaryenAtomicRMWSetValue,\n  _BinaryenAtomicCmpxchgSetPtr,\n  _BinaryenAtomicCmpxchgSetExpected,\n  _BinaryenAtomicCmpxchgSetReplacement,\n  _BinaryenAtomicWaitSetPtr,\n  _BinaryenAtomicWaitSetExpected,\n  _BinaryenAtomicWaitSetTimeout,\n  _BinaryenAtomicNotifySetPtr,\n  _BinaryenSIMDExtractSetVec,\n  _BinaryenSIMDReplaceSetVec,\n  _BinaryenSIMDReplaceSetValue,\n  _BinaryenSIMDShuffleSetLeft,\n  _BinaryenSIMDShuffleSetRight,\n  _BinaryenSIMDTernarySetA,\n  _BinaryenSIMDTernarySetB,\n  _BinaryenSIMDTernarySetC,\n  _BinaryenSIMDShiftSetVec,\n  _BinaryenSIMDShiftSetShift,\n  _BinaryenSIMDLoadSetPtr,\n  _BinaryenSIMDLoadStoreLaneGetPtr,\n  _BinaryenSIMDLoadStoreLaneGetVec,\n  _BinaryenSIMDLoadStoreLaneSetPtr,\n  _BinaryenSIMDLoadStoreLaneSetVec,\n  _BinaryenMemoryInitSetDest,\n  _BinaryenMemoryInitSetOffset,\n  _BinaryenMemoryInitSetSize,\n  _BinaryenMemoryCopySetDest,\n  _BinaryenMemoryCopySetSource,\n  _BinaryenMemoryCopySetSize,\n  _BinaryenMemoryFillSetDest,\n  _BinaryenMemoryFillSetValue,\n  _BinaryenMemoryFillSetSize,\n  _BinaryenRefIsSetValue,\n  _BinaryenTrySetBody,\n  _BinaryenTrySetCatchBodyAt,\n  _BinaryenThrowSetOperandAt,\n  _BinaryenTupleMakeSetOperandAt,\n  _BinaryenBlockGetName,\n  _BinaryenLoopGetName,\n  _BinaryenBreakGetName,\n  _BinaryenSwitchGetDefaultName,\n  _BinaryenSwitchGetNumNames,\n  _BinaryenSwitchGetNameAt,\n  _BinaryenCallGetTarget,\n  _BinaryenLocalGetGetIndex,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenGlobalGetGetName,\n  _BinaryenGlobalSetGetName,\n  _BinaryenAtomicNotifyGetNotifyCount,\n  _BinaryenAtomicNotifySetNotifyCount,\n  _BinaryenRefFuncGetFunc,\n  _BinaryenThrowGetTag,\n  _BinaryenTupleExtractGetTuple,\n  _BinaryenTupleExtractSetTuple,\n  _BinaryenRefEqGetLeft,\n  _BinaryenRefEqGetRight,\n  _BinaryenRefEqSetLeft,\n  _BinaryenRefEqSetRight,\n  _BinaryenFunctionSetBody,\n  _BinaryenI31NewGetValue,\n  _BinaryenI31GetGetI31,\n  _BinaryenI31NewSetValue,\n  _BinaryenI31GetSetI31\n} from \"../glue/binaryen\";\n\n/** Base class of custom Binaryen visitors. */\nexport abstract class Visitor {\n  /** Expression stack. */\n  private stack: ExpressionRef[] = new Array<ExpressionRef>();\n\n  /** Gets the current expression being walked. */\n  get currentExpression(): ExpressionRef {\n    var currentExpression = this._currentExpression;\n    if (!currentExpression) throw new Error(\"not walking expressions\");\n    return currentExpression;\n  }\n  _currentExpression: ExpressionRef = 0;\n\n  /** Gets the parent expression of the current expression being walked. Returns zero if already the top-most expression. */\n  get parentExpressionOrNull(): ExpressionRef {\n    var stack = this.stack;\n    var length = stack.length;\n    return length ? stack[length - 1] : 0;\n  }\n\n  // Expressions\n\n  visitBlock(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitIf(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBreak(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSwitch(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCall(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirectPre(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallIndirect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLocalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitGlobalSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStore(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitConst(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBinary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSelect(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitReturn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemorySize(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryGrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitNop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitUnreachable(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicRMW(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicCmpxchg(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicWait(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicNotify(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitAtomicFence(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDReplace(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShuffle(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDTernary(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDShift(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoad(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitSIMDLoadStoreLane(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryInit(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitDataDrop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryCopy(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitMemoryFill(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitPop(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefNull(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefIs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefFunc(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefEq(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTry(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitThrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRethrow(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleMake(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitTupleExtract(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31New(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitI31Get(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitCallRef(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefTest(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefCast(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitBrOn(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRttCanon(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRttSub(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitStructSet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayNew(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayGet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArraySet(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitArrayLen(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  visitRefAs(expr: ExpressionRef): void {\n    // unimp\n  }\n\n  // Immediates\n\n  visitName(name: StringRef): void {\n    // unimp\n  }\n\n  visitLabel(name: StringRef): void {\n    // unimp\n  }\n\n  visitIndex(index: Index): void {\n    // unimp\n  }\n\n  visitTag(name: StringRef): void {\n    // unimp\n  }\n\n  // Delegate\n\n  /** Visits any expression, delegating to the respective visitor methods. */\n  visit(expr: ExpressionRef): void {\n    let previousExpression = this._currentExpression;\n    this._currentExpression = assert(expr);\n    switch (_BinaryenExpressionGetId(expr)) {\n      case ExpressionId.Block: {\n        this.stack.push(expr);\n        let name = _BinaryenBlockGetName(expr);\n        if (name) this.visitLabel(name);\n        for (let i: Index = 0, n = _BinaryenBlockGetNumChildren(expr); i < n; ++i) {\n          this.visit(_BinaryenBlockGetChildAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitBlock(expr);\n        break;\n      }\n      case ExpressionId.If: {\n        this.stack.push(expr);\n        this.visit(_BinaryenIfGetCondition(expr));\n        this.visit(_BinaryenIfGetIfTrue(expr));\n        let ifFalse = _BinaryenIfGetIfFalse(expr);\n        if (ifFalse) this.visit(ifFalse);\n        assert(this.stack.pop() == expr);\n        this.visitIf(expr);\n        break;\n      }\n      case ExpressionId.Loop: {\n        this.stack.push(expr);\n        let name = _BinaryenLoopGetName(expr);\n        if (name) this.visitLabel(name);\n        this.visit(_BinaryenLoopGetBody(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoop(expr);\n        break;\n      }\n      case ExpressionId.Break: {\n        this.stack.push(expr);\n        this.visitLabel(_BinaryenBreakGetName(expr));\n        let condition = _BinaryenBreakGetCondition(expr);\n        if (condition) this.visit(condition);\n        let value = _BinaryenBreakGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitBreak(expr);\n        break;\n      }\n      case ExpressionId.Switch: {\n        this.stack.push(expr);\n        let defaultName = _BinaryenSwitchGetDefaultName(expr);\n        if (defaultName) this.visitLabel(defaultName);\n        let numNames = _BinaryenSwitchGetNumNames(expr);\n        for (let i: Index = 0; i < numNames; ++i) {\n          this.visitLabel(_BinaryenSwitchGetNameAt(expr, i));\n        }\n        this.visit(_BinaryenSwitchGetCondition(expr));\n        let value = _BinaryenSwitchGetValue(expr);\n        if (value) this.visit(value);\n        assert(this.stack.pop() == expr);\n        this.visitSwitch(expr);\n        break;\n      }\n      case ExpressionId.Call: {\n        this.visitCallPre(expr);\n        this.stack.push(expr);\n        this.visitName(_BinaryenCallGetTarget(expr));\n        let numOperands = _BinaryenCallGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenCallGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCall(expr);\n        break;\n      }\n      case ExpressionId.CallIndirect: {\n        this.visitCallIndirectPre(expr);\n        this.stack.push(expr);\n        this.visit(_BinaryenCallIndirectGetTarget(expr));\n        for (let i: Index = 0, k = _BinaryenCallIndirectGetNumOperands(expr); i < k; ++i) {\n          this.visit(_BinaryenCallIndirectGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitCallIndirect(expr);\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalGetGetIndex(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalGet(expr);\n        break;\n      }\n      case ExpressionId.LocalSet: {\n        this.stack.push(expr);\n        this.visitIndex(_BinaryenLocalSetGetIndex(expr));\n        this.visit(_BinaryenLocalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLocalSet(expr);\n        break;\n      }\n      case ExpressionId.GlobalGet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalGetGetName(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalGet(expr);\n        break;\n      }\n      case ExpressionId.GlobalSet: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenGlobalSetGetName(expr));\n        this.visit(_BinaryenGlobalSetGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitGlobalSet(expr);\n        break;\n      }\n      case ExpressionId.Load: {\n        this.stack.push(expr);\n        this.visit(_BinaryenLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitLoad(expr);\n        break;\n      }\n      case ExpressionId.Store: {\n        this.stack.push(expr);\n        this.visit(_BinaryenStoreGetPtr(expr));\n        this.visit(_BinaryenStoreGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitStore(expr);\n        break;\n      }\n      case ExpressionId.Const: {\n        this.visitConst(expr);\n        break;\n      }\n      case ExpressionId.Unary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenUnaryGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitUnary(expr);\n        break;\n      }\n      case ExpressionId.Binary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenBinaryGetLeft(expr));\n        this.visit(_BinaryenBinaryGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitBinary(expr);\n        break;\n      }\n      case ExpressionId.Select: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSelectGetIfTrue(expr));\n        this.visit(_BinaryenSelectGetIfFalse(expr));\n        this.visit(_BinaryenSelectGetCondition(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSelect(expr);\n        break;\n      }\n      case ExpressionId.Drop: {\n        this.stack.push(expr);\n        this.visit(_BinaryenDropGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitDrop(expr);\n        break;\n      }\n      case ExpressionId.Return: {\n        let value = _BinaryenReturnGetValue(expr);\n        if (value) {\n          this.stack.push(expr);\n          this.visit(value);\n          assert(this.stack.pop() == expr);\n        }\n        this.visitReturn(expr);\n        break;\n      }\n      case ExpressionId.MemorySize: {\n        this.visitMemorySize(expr);\n        break;\n      }\n      case ExpressionId.MemoryGrow: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryGrowGetDelta(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryGrow(expr);\n        break;\n      }\n      case ExpressionId.Nop: {\n        this.visitNop(expr);\n        break;\n      }\n      case ExpressionId.Unreachable: {\n        this.visitUnreachable(expr);\n        break;\n      }\n      case ExpressionId.AtomicRMW: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicRMWGetPtr(expr));\n        this.visit(_BinaryenAtomicRMWGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicRMW(expr);\n        break;\n      }\n      case ExpressionId.AtomicCmpxchg: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicCmpxchgGetPtr(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetExpected(expr));\n        this.visit(_BinaryenAtomicCmpxchgGetReplacement(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicCmpxchg(expr);\n        break;\n      }\n      case ExpressionId.AtomicWait: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicWaitGetPtr(expr));\n        this.visit(_BinaryenAtomicWaitGetExpected(expr));\n        this.visit(_BinaryenAtomicWaitGetTimeout(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicWait(expr);\n        break;\n      }\n      case ExpressionId.AtomicNotify: {\n        this.stack.push(expr);\n        this.visit(_BinaryenAtomicNotifyGetPtr(expr));\n        this.visit(_BinaryenAtomicNotifyGetNotifyCount(expr));\n        assert(this.stack.pop() == expr);\n        this.visitAtomicNotify(expr);\n        break;\n      }\n      case ExpressionId.AtomicFence: {\n        this.visitAtomicFence(expr);\n        break;\n      }\n      case ExpressionId.SIMDExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDExtractGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDExtract(expr);\n        break;\n      }\n      case ExpressionId.SIMDReplace: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDReplaceGetVec(expr));\n        this.visit(_BinaryenSIMDReplaceGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDReplace(expr);\n        break;\n      }\n      case ExpressionId.SIMDShuffle: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShuffleGetLeft(expr));\n        this.visit(_BinaryenSIMDShuffleGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShuffle(expr);\n        break;\n      }\n      case ExpressionId.SIMDTernary: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDTernaryGetA(expr));\n        this.visit(_BinaryenSIMDTernaryGetB(expr));\n        this.visit(_BinaryenSIMDTernaryGetC(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDTernary(expr);\n        break;\n      }\n      case ExpressionId.SIMDShift: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDShiftGetVec(expr));\n        this.visit(_BinaryenSIMDShiftGetShift(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDShift(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoad: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadGetPtr(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoad(expr);\n        break;\n      }\n      case ExpressionId.SIMDLoadStoreLane: {\n        this.stack.push(expr);\n        this.visit(_BinaryenSIMDLoadStoreLaneGetPtr(expr));\n        this.visit(_BinaryenSIMDLoadStoreLaneGetVec(expr));\n        assert(this.stack.pop() == expr);\n        this.visitSIMDLoadStoreLane(expr);\n        break;\n      }\n      case ExpressionId.MemoryInit: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryInitGetDest(expr));\n        this.visit(_BinaryenMemoryInitGetOffset(expr));\n        this.visit(_BinaryenMemoryInitGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryInit(expr);\n        break;\n      }\n      case ExpressionId.DataDrop: {\n        this.visitDataDrop(expr);\n        break;\n      }\n      case ExpressionId.MemoryCopy: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryCopyGetDest(expr));\n        this.visit(_BinaryenMemoryCopyGetSource(expr));\n        this.visit(_BinaryenMemoryCopyGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryCopy(expr);\n        break;\n      }\n      case ExpressionId.MemoryFill: {\n        this.stack.push(expr);\n        this.visit(_BinaryenMemoryFillGetDest(expr));\n        this.visit(_BinaryenMemoryFillGetValue(expr));\n        this.visit(_BinaryenMemoryFillGetSize(expr));\n        assert(this.stack.pop() == expr);\n        this.visitMemoryFill(expr);\n        break;\n      }\n      case ExpressionId.Pop: {\n        this.visitPop(expr);\n        break;\n      }\n      case ExpressionId.RefNull: {\n        this.visitRefNull(expr);\n        break;\n      }\n      case ExpressionId.RefIs: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefIsGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefIs(expr);\n        break;\n      }\n      case ExpressionId.RefFunc: {\n        this.stack.push(expr);\n        this.visitName(_BinaryenRefFuncGetFunc(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefFunc(expr);\n        break;\n      }\n      case ExpressionId.RefEq: {\n        this.stack.push(expr);\n        this.visit(_BinaryenRefEqGetLeft(expr));\n        this.visit(_BinaryenRefEqGetRight(expr));\n        assert(this.stack.pop() == expr);\n        this.visitRefEq(expr);\n        break;\n      }\n      case ExpressionId.Try: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTryGetBody(expr));\n        let numCatchBodies = _BinaryenTryGetNumCatchBodies(expr);\n        for (let i: Index = 0; i < numCatchBodies; ++i) {\n          this.visit(_BinaryenTryGetCatchBodyAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitTry(expr);\n        break;\n      }\n      case ExpressionId.Throw: {\n        this.stack.push(expr);\n        this.visitTag(_BinaryenThrowGetTag(expr));\n        let numOperands = _BinaryenThrowGetNumOperands(expr);\n        for (let i: Index = 0; i < numOperands; ++i) {\n          this.visit(_BinaryenThrowGetOperandAt(expr, i));\n        }\n        assert(this.stack.pop() == expr);\n        this.visitThrow(expr);\n        break;\n      }\n      case ExpressionId.Rethrow: {\n        this.visitRethrow(expr);\n        break;\n      }\n      case ExpressionId.TupleMake: {\n        let numOperands = _BinaryenTupleMakeGetNumOperands(expr);\n        if (numOperands) {\n          this.stack.push(expr);\n          for (let i: Index = 0; i < numOperands; ++i) {\n            this.visit(_BinaryenTupleMakeGetOperandAt(expr, i));\n          }\n          assert(this.stack.pop() == expr);\n        }\n        this.visitTupleMake(expr);\n        break;\n      }\n      case ExpressionId.TupleExtract: {\n        this.stack.push(expr);\n        this.visit(_BinaryenTupleExtractGetTuple(expr));\n        assert(this.stack.pop() == expr);\n        this.visitTupleExtract(expr);\n        break;\n      }\n      case ExpressionId.I31New: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31NewGetValue(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31New(expr);\n        break;\n      }\n      case ExpressionId.I31Get: {\n        this.stack.push(expr);\n        this.visit(_BinaryenI31GetGetI31(expr));\n        assert(this.stack.pop() == expr);\n        this.visitI31Get(expr);\n        break;\n      }\n      case ExpressionId.CallRef: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitCallRef(expr);\n        break;\n      }\n      case ExpressionId.RefTest: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitRefTest(expr);\n        break;\n      }\n      case ExpressionId.RefCast: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitRefCast(expr);\n        break;\n      }\n      case ExpressionId.BrOn: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitBrOn(expr);\n        break;\n      }\n      case ExpressionId.RttCanon: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitRttCanon(expr);\n        break;\n      }\n      case ExpressionId.RttSub: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitRttSub(expr);\n        break;\n      }\n      case ExpressionId.StructNew: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitStructNew(expr);\n        break;\n      }\n      case ExpressionId.StructGet: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitStructGet(expr);\n        break;\n      }\n      case ExpressionId.StructSet: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitStructSet(expr);\n        break;\n      }\n      case ExpressionId.ArrayNew: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitArrayNew(expr);\n        break;\n      }\n      case ExpressionId.ArrayGet: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitArrayGet(expr);\n        break;\n      }\n      case ExpressionId.ArraySet: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitArraySet(expr);\n        break;\n      }\n      case ExpressionId.ArrayLen: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitArrayLen(expr);\n        break;\n      }\n      case ExpressionId.RefAs: {\n        this.stack.push(expr);\n        assert(false); // TODO\n        assert(this.stack.pop() == expr);\n        this.visitRefAs(expr);\n        break;\n      }\n      default: throw new Error(\"unexpected expression kind\");\n    }\n    this._currentExpression = previousExpression;\n  }\n}\n\n/** Base class of custom Binaryen passes. */\nexport abstract class Pass extends Visitor {\n\n  /** Gets the current function being walked. */\n  get currentFunction(): FunctionRef {\n    var currentFunction = this._currentFunction;\n    if (!currentFunction) throw new Error(\"not walking a function\");\n    return currentFunction;\n  }\n  private _currentFunction: FunctionRef = 0;\n\n  /** Gets the current global being walked. */\n  get currentGlobal(): GlobalRef {\n    var currentGlobal = this._currentGlobal;\n    if (!currentGlobal) throw new Error(\"not walking a global\");\n    return currentGlobal;\n  }\n  private _currentGlobal: GlobalRef = 0;\n\n  /** Constructs a new Binaryen pass. */\n  constructor(readonly module: Module) {\n    super();\n  }\n\n  // Walking\n\n  /** Walks the entire module. */\n  walkModule(): void {\n    this.walkFunctions();\n    this.walkGlobals();\n  }\n\n  /** Walks all functions. */\n  walkFunctions(): void {\n    var moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumFunctions(moduleRef); i < k; ++i) {\n      this.walkFunction(_BinaryenGetFunctionByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific function. */\n  walkFunction(func: FunctionRef): void {\n    var body = _BinaryenFunctionGetBody(func);\n    if (body) {\n      this._currentFunction = func;\n      this.visit(body);\n      this._currentFunction = 0;\n    }\n  }\n\n  /** Walks all global variables. */\n  walkGlobals(): void {\n    var moduleRef = this.module.ref;\n    for (let i: Index = 0, k = _BinaryenGetNumGlobals(moduleRef); i < k; ++i) {\n      this.walkGlobal(_BinaryenGetGlobalByIndex(moduleRef, i));\n    }\n  }\n\n  /** Walks a specific global variable. */\n  walkGlobal(global: GlobalRef): void {\n    this._currentGlobal = global;\n    var init = _BinaryenGlobalGetInitExpr(global);\n    if (init) this.visit(init);\n    this._currentGlobal = 0;\n  }\n\n  // Utility\n\n  /** Replaces the current expression with the specified replacement. */\n  replaceCurrent(replacement: ExpressionRef): void {\n    var search = this.currentExpression;\n    var func = this.currentFunction;\n    var body = _BinaryenFunctionGetBody(func);\n    if (body == search) {\n      _BinaryenFunctionSetBody(func, replacement);\n    } else {\n      var parent = assert(this.parentExpressionOrNull);\n      var replaced = replaceChild(parent, search, replacement);\n      if (!replaced) throw Error(\"failed to replace expression\");\n      _BinaryenExpressionFinalize(parent);\n    }\n  }\n}\n\n/** Replaces an expression within a parent expression. Returns the replaced expression on success, otherwise `0`. */\nexport function replaceChild(\n  /** Parent expression containing `search`. */\n  parent: ExpressionRef,\n  /** Expression to replace. */\n  search: ExpressionRef,\n  /** Expression to replace `search` with. */\n  replacement: ExpressionRef\n): ExpressionRef {\n  switch (_BinaryenExpressionGetId(parent)) {\n    case ExpressionId.Block: {\n      let numChildren = _BinaryenBlockGetNumChildren(parent);\n      for (let i: Index = 0; i < numChildren; ++i) {\n        let child = _BinaryenBlockGetChildAt(parent, i);\n        if (child == search) {\n          _BinaryenBlockSetChildAt(parent, i, replacement);\n          return child;\n        }\n      }\n      break;\n    }\n    case ExpressionId.If: {\n      let condition = _BinaryenIfGetCondition(parent);\n      if (condition == search) {\n        _BinaryenIfSetCondition(parent, replacement);\n        return condition;\n      }\n      let ifTrue = _BinaryenIfGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenIfSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenIfGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenIfSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      break;\n    }\n    case ExpressionId.Loop: {\n      let body = _BinaryenLoopGetBody(parent);\n      if (body == search) {\n        _BinaryenLoopSetBody(parent, replacement);\n        return body;\n      }\n      break;\n    }\n    case ExpressionId.Break: {\n      let condition = _BinaryenBreakGetCondition(parent);\n      if (condition == search) {\n        _BinaryenBreakSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenBreakGetValue(parent);\n      if (value == search) {\n        _BinaryenBreakSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Switch: {\n      let condition = _BinaryenSwitchGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSwitchSetCondition(parent, replacement);\n        return condition;\n      }\n      let value = _BinaryenSwitchGetValue(parent);\n      if (value == search) {\n        _BinaryenSwitchSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Call: {\n      let numOperands = _BinaryenCallGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.CallIndirect: {\n      let target = _BinaryenCallIndirectGetTarget(parent);\n      if (target == search) {\n        _BinaryenCallIndirectSetTarget(parent, replacement);\n        return target;\n      }\n      let numOperands = _BinaryenCallIndirectGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenCallIndirectGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenCallIndirectSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.LocalGet: {\n      break;\n    }\n    case ExpressionId.LocalSet: {\n      let value = _BinaryenLocalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenLocalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.GlobalGet: {\n      break;\n    }\n    case ExpressionId.GlobalSet: {\n      let value = _BinaryenGlobalSetGetValue(parent);\n      if (value == search) {\n        _BinaryenGlobalSetSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Load: {\n      let ptr = _BinaryenLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.Store: {\n      let ptr = _BinaryenStoreGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenStoreSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenStoreGetValue(parent);\n      if (value == search) {\n        _BinaryenStoreSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Const: {\n      break;\n    }\n    case ExpressionId.Unary: {\n      let value = _BinaryenUnaryGetValue(parent);\n      if (value == search) {\n        _BinaryenUnarySetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Binary: {\n      let left = _BinaryenBinaryGetLeft(parent);\n      if (left == search) {\n        _BinaryenBinarySetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenBinaryGetRight(parent);\n      if (right == search) {\n        _BinaryenBinarySetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Select: {\n      let ifTrue = _BinaryenSelectGetIfTrue(parent);\n      if (ifTrue == search) {\n        _BinaryenSelectSetIfTrue(parent, replacement);\n        return ifTrue;\n      }\n      let ifFalse = _BinaryenSelectGetIfFalse(parent);\n      if (ifFalse == search) {\n        _BinaryenSelectSetIfFalse(parent, replacement);\n        return ifFalse;\n      }\n      let condition = _BinaryenSelectGetCondition(parent);\n      if (condition == search) {\n        _BinaryenSelectSetCondition(parent, replacement);\n        return condition;\n      }\n      break;\n    }\n    case ExpressionId.Drop: {\n      let value = _BinaryenDropGetValue(parent);\n      if (value == search) {\n        _BinaryenDropSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.Return: {\n      let value = _BinaryenReturnGetValue(parent);\n      if (value == search) {\n        _BinaryenReturnSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.MemorySize: {\n      break;\n    }\n    case ExpressionId.MemoryGrow: {\n      let delta = _BinaryenMemoryGrowGetDelta(parent);\n      if (delta == search) {\n        _BinaryenMemoryGrowSetDelta(parent, replacement);\n        return delta;\n      }\n      break;\n    }\n    case ExpressionId.Nop: {\n      break;\n    }\n    case ExpressionId.Unreachable: {\n      break;\n    }\n    case ExpressionId.AtomicRMW: {\n      let ptr = _BinaryenAtomicRMWGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicRMWSetPtr(parent, replacement);\n        return ptr;\n      }\n      let value = _BinaryenAtomicRMWGetValue(parent);\n      if (value == search) {\n        _BinaryenAtomicRMWSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.AtomicCmpxchg: {\n      let ptr = _BinaryenAtomicCmpxchgGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicCmpxchgSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicCmpxchgGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicCmpxchgSetExpected(parent, replacement);\n        return expected;\n      }\n      let repl = _BinaryenAtomicCmpxchgGetReplacement(parent);\n      if (repl == search) {\n        _BinaryenAtomicCmpxchgSetReplacement(parent, replacement);\n        return repl;\n      }\n      break;\n    }\n    case ExpressionId.AtomicWait: {\n      let ptr = _BinaryenAtomicWaitGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicWaitSetPtr(parent, replacement);\n        return ptr;\n      }\n      let expected = _BinaryenAtomicWaitGetExpected(parent);\n      if (expected == search) {\n        _BinaryenAtomicWaitSetExpected(parent, replacement);\n        return expected;\n      }\n      let timeout = _BinaryenAtomicWaitGetTimeout(parent);\n      if (timeout == search) {\n        _BinaryenAtomicWaitSetTimeout(parent, replacement);\n        return timeout;\n      }\n      break;\n    }\n    case ExpressionId.AtomicNotify: {\n      let ptr = _BinaryenAtomicNotifyGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenAtomicNotifySetPtr(parent, replacement);\n        return ptr;\n      }\n      let notifyCount = _BinaryenAtomicNotifyGetNotifyCount(parent);\n      if (notifyCount == search) {\n        _BinaryenAtomicNotifySetNotifyCount(parent, replacement);\n        return notifyCount;\n      }\n      break;\n    }\n    case ExpressionId.AtomicFence: {\n      break;\n    }\n    case ExpressionId.SIMDExtract: {\n      let vec = _BinaryenSIMDExtractGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDExtractSetVec(parent, replacement);\n        return vec;\n      }\n      break;\n    }\n    case ExpressionId.SIMDReplace: {\n      let vec = _BinaryenSIMDReplaceGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDReplaceSetVec(parent, replacement);\n        return vec;\n      }\n      let value = _BinaryenSIMDReplaceGetValue(parent);\n      if (value == search) {\n        _BinaryenSIMDReplaceSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShuffle: {\n      let left = _BinaryenSIMDShuffleGetLeft(parent);\n      if (left == search) {\n        _BinaryenSIMDShuffleSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenSIMDShuffleGetRight(parent);\n      if (right == search) {\n        _BinaryenSIMDShuffleSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.SIMDTernary: {\n      let a = _BinaryenSIMDTernaryGetA(parent);\n      if (a == search) {\n        _BinaryenSIMDTernarySetA(parent, replacement);\n        return a;\n      }\n      let b = _BinaryenSIMDTernaryGetB(parent);\n      if (b == search) {\n        _BinaryenSIMDTernarySetB(parent, replacement);\n        return b;\n      }\n      let c = _BinaryenSIMDTernaryGetC(parent);\n      if (c == search) {\n        _BinaryenSIMDTernarySetC(parent, replacement);\n        return c;\n      }\n      break;\n    }\n    case ExpressionId.SIMDShift: {\n      let vec = _BinaryenSIMDShiftGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDShiftSetVec(parent, replacement);\n        return vec;\n      }\n      let shift = _BinaryenSIMDShiftGetShift(parent);\n      if (shift == search) {\n        _BinaryenSIMDShiftSetShift(parent, replacement);\n        return shift;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoad: {\n      let ptr = _BinaryenSIMDLoadGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadSetPtr(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.SIMDLoadStoreLane: {\n      let ptr = _BinaryenSIMDLoadStoreLaneGetPtr(parent);\n      if (ptr == search) {\n        _BinaryenSIMDLoadStoreLaneSetPtr(parent, replacement);\n        return ptr;\n      }\n      let vec = _BinaryenSIMDLoadStoreLaneGetVec(parent);\n      if (vec == search) {\n        _BinaryenSIMDLoadStoreLaneSetVec(parent, replacement);\n        return ptr;\n      }\n      break;\n    }\n    case ExpressionId.MemoryInit: {\n      let dest = _BinaryenMemoryInitGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryInitSetDest(parent, replacement);\n        return dest;\n      }\n      let offset = _BinaryenMemoryInitGetOffset(parent);\n      if (offset == search) {\n        _BinaryenMemoryInitSetOffset(parent, replacement);\n        return offset;\n      }\n      let size = _BinaryenMemoryInitGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryInitSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.DataDrop: {\n      break;\n    }\n    case ExpressionId.MemoryCopy: {\n      let dest = _BinaryenMemoryCopyGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryCopySetDest(parent, replacement);\n        return dest;\n      }\n      let source = _BinaryenMemoryCopyGetSource(parent);\n      if (source == search) {\n        _BinaryenMemoryCopySetSource(parent, replacement);\n        return source;\n      }\n      let size = _BinaryenMemoryCopyGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryCopySetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.MemoryFill: {\n      let dest = _BinaryenMemoryFillGetDest(parent);\n      if (dest == search) {\n        _BinaryenMemoryFillSetDest(parent, replacement);\n        return dest;\n      }\n      let value = _BinaryenMemoryFillGetValue(parent);\n      if (value == search) {\n        _BinaryenMemoryFillSetValue(parent, replacement);\n        return value;\n      }\n      let size = _BinaryenMemoryFillGetSize(parent);\n      if (size == search) {\n        _BinaryenMemoryFillSetSize(parent, replacement);\n        return size;\n      }\n      break;\n    }\n    case ExpressionId.Pop: {\n      break;\n    }\n    case ExpressionId.RefNull: {\n      break;\n    }\n    case ExpressionId.RefIs: {\n      let value = _BinaryenRefIsGetValue(parent);\n      if (value == search) {\n        _BinaryenRefIsSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.RefFunc: {\n      break;\n    }\n    case ExpressionId.RefEq: {\n      let left = _BinaryenRefEqGetLeft(parent);\n      if (left == search) {\n        _BinaryenRefEqSetLeft(parent, replacement);\n        return left;\n      }\n      let right = _BinaryenRefEqGetRight(parent);\n      if (right == search) {\n        _BinaryenRefEqSetRight(parent, replacement);\n        return right;\n      }\n      break;\n    }\n    case ExpressionId.Try: {\n      let body = _BinaryenTryGetBody(parent);\n      if (body == search) {\n        _BinaryenTrySetBody(parent, replacement);\n        return body;\n      }\n      let numCatchBodies = _BinaryenTryGetNumCatchBodies(parent);\n      for (let i: Index = 0; i < numCatchBodies; ++i) {\n        let catchBody = _BinaryenTryGetCatchBodyAt(parent, i);\n        if (catchBody == search) {\n          _BinaryenTrySetCatchBodyAt(parent, i, replacement);\n          return catchBody;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Throw: {\n      let numOperands = _BinaryenThrowGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenThrowGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenThrowSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.Rethrow: {\n      break;\n    }\n    case ExpressionId.TupleMake: {\n      let numOperands = _BinaryenTupleMakeGetNumOperands(parent);\n      for (let i: Index = 0; i < numOperands; ++i) {\n        let operand = _BinaryenTupleMakeGetOperandAt(parent, i);\n        if (operand == search) {\n          _BinaryenTupleMakeSetOperandAt(parent, i, replacement);\n          return operand;\n        }\n      }\n      break;\n    }\n    case ExpressionId.TupleExtract: {\n      let tuple = _BinaryenTupleExtractGetTuple(parent);\n      if (tuple == search) {\n        _BinaryenTupleExtractSetTuple(parent, replacement);\n        return tuple;\n      }\n      break;\n    }\n    case ExpressionId.I31New: {\n      let value = _BinaryenI31NewGetValue(parent);\n      if (value == search) {\n        _BinaryenI31NewSetValue(parent, replacement);\n        return value;\n      }\n      break;\n    }\n    case ExpressionId.I31Get: {\n      let i31Expr = _BinaryenI31GetGetI31(parent);\n      if (i31Expr == search) {\n        _BinaryenI31GetSetI31(parent, replacement);\n        return i31Expr;\n      }\n      break;\n    }\n    case ExpressionId.CallRef: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.RefTest: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.RefCast: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.BrOn: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.RttCanon: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.RttSub: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.StructNew: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.StructGet: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.StructSet: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.ArrayNew: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.ArrayGet: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.ArraySet: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.ArrayLen: {\n      assert(false); // TODO\n      break;\n    }\n    case ExpressionId.RefAs: {\n      assert(false); // TODO\n      break;\n    }\n    default: throw new Error(\"unexpected expression id\");\n  }\n  return 0;\n}\n","/**\n * @fileoverview A lightweight store instrumentation pass.\n * \n * Can be used to find rogue stores to protected memory addresses like object\n * headers or similar, without going overboard with instrumentation. Also\n * passes a flag whether a store originates within the runtime or other code.\n * \n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  Compiler\n} from \"../compiler\";\n\nimport {\n  createType,\n  ExpressionRef,\n  TypeRef\n} from \"../module\";\n\nimport {\n  _BinaryenFunctionGetName,\n  _BinaryenStoreGetBytes,\n  _BinaryenStoreGetOffset,\n  _BinaryenStoreGetPtr,\n  _BinaryenStoreSetPtr\n} from \"../glue/binaryen\";\n\n/** Instruments stores to also call an import. */\nexport class RtraceMemory extends Pass {\n  /** Whether we've seen any stores. */\n  seenStores: bool = false;\n  /** Target pointer type. */\n  ptrType: TypeRef;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.ptrType = compiler.options.sizeTypeRef;\n  }\n\n  checkRT(): bool {\n    var functionName = this.module.readStringCached(_BinaryenFunctionGetName(this.currentFunction))!;\n    return functionName.startsWith(\"~lib/rt/\");\n  }\n\n  /** @override */\n  visitStore(store: ExpressionRef): void {\n    var module = this.module;\n    var ptr = _BinaryenStoreGetPtr(store);\n    var offset = _BinaryenStoreGetOffset(store);\n    var bytes = _BinaryenStoreGetBytes(store);\n    // onstore(ptr: usize, offset: i32, bytes: i32, isRT: bool) -> ptr\n    _BinaryenStoreSetPtr(store,\n      module.call(\"~onstore\", [\n        ptr,\n        module.i32(offset),\n        module.i32(bytes),\n        module.i32(i32(this.checkRT()))\n      ], this.ptrType)\n    );\n    this.seenStores = true;\n  }\n\n  // TODO: MemoryFill, Atomics\n\n  /** @override */\n  walkModule(): void {\n    super.walkModule();\n    if (this.seenStores) {\n      this.module.addFunctionImport(\"~onstore\", \"rtrace\", \"onstore\",\n        createType([ this.ptrType, TypeRef.I32, TypeRef.I32, TypeRef.I32 ]),\n        this.ptrType\n      );\n    }\n  }\n}\n","/**\n * @fileoverview Shadow stack instrumentation for a precise GC.\n *\n * Instruments function arguments and local assignments marked with a 'tostack'\n * call to also do stores to a shadow stack of managed values only.\n *\n * Consider a simple call to a function looking like the following, taking\n * managed arguments, plus assigning managed values to locals:\n *\n *   function foo(a: Obj, b: Obj): Obj {\n *     var c = __tostack(a) // slot 2\n *     __collect()\n *     return b\n *   }\n *\n *   foo(__tostack(a), __tostack(b)) // slot 0, 1\n *\n * At the call to `__collect()` the 32-bit stack frame of the function is:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed argument 'a'\n *      4   | Second managed argument 'b'\n *   -------|----------------------------\n *      8   | First managed local 'c'\n *\n * We are splitting the frame in two halves as annotated since both halves are\n * only known separately for indirect calls, with the first half becoming an\n * extension of the calling function's stack frame by means of treating the\n * arguments as if these were locals beyond the caller's `numLocals`. Function\n * arguments stay a bit longer on the stack than usually, but we also don't have\n * to modify the stack pointer pre-call at all this way. The caller's amended\n * stack frame when assuming one managed local may look like this:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local '?'\n *      4   | Extended with first managed argument 'a'\n *      8   | Extended with second managed argument 'b'\n *\n * with the callee's stack frame becoming just:\n *\n *   Offset | Value stored\n *   -------|----------------------------\n *      0   | First managed local 'c'\n *\n * Instrumentation added below looks about like the following, with the stack\n * growing downwards and 't' and 'r' being new temporary locals:\n *\n *   // callee frameSize = 1 * sizeof<usize>()\n *   function foo(a: usize, b: usize): usize {\n *     memory.fill(__stack_pointer -= frameSize, 0, frameSize)\n *     store<usize>(__stack_pointer, c = a, 0 * sizeof<usize>())\n *     __collect()\n *     var r = b\n *     __stack_pointer += frameSize\n *     return r\n *   }\n *\n *   // caller frameSize = (numLocalSlots + 2 [by extension]) * sizeof<usize>()\n *   (\n *     r = foo(\n *       ( t = a,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 0) * sizeof<usize>()),\n *         t ),\n *       ( t = b,\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 1) * sizeof<usize>()),\n *         t )\n *     ),\n *     r\n *   )\n *\n * Also note that we have to `memory.fill` the second half because the first\n * assignment to a local may happen at a later point within the function. The\n * invariant we need to maintain for a precise GC is that it only sees zeroes\n * or valid pointers, but never an invalid pointer left on the stack earlier.\n * Since most frames are small, we unroll a sequence of `store`s up to a frame\n * size of 16 bytes, and `memory.fill`, if available, beyond.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Pass\n} from \"./pass\";\n\nimport {\n  _BinaryenAddFunction,\n  _BinaryenAddFunctionExport,\n  _BinaryenCallGetNumOperands,\n  _BinaryenCallGetOperandAt,\n  _BinaryenCallGetTarget,\n  _BinaryenCallIndirectGetNumOperands,\n  _BinaryenCallIndirectGetOperandAt,\n  _BinaryenCallIndirectSetOperandAt,\n  _BinaryenCallSetOperandAt,\n  _BinaryenExportGetKind,\n  _BinaryenExportGetName,\n  _BinaryenExportGetValue,\n  _BinaryenExpressionGetId,\n  _BinaryenExpressionGetType,\n  _BinaryenFunctionGetBody,\n  _BinaryenFunctionGetName,\n  _BinaryenFunctionGetNumLocals,\n  _BinaryenFunctionGetNumVars,\n  _BinaryenFunctionGetParams,\n  _BinaryenFunctionGetResults,\n  _BinaryenFunctionGetVar,\n  _BinaryenFunctionSetBody,\n  _BinaryenGetExport,\n  _BinaryenGetFunction,\n  _BinaryenLocalSetGetIndex,\n  _BinaryenLocalSetGetValue,\n  _BinaryenLocalSetIsTee,\n  _BinaryenLocalSetSetValue,\n  _BinaryenRemoveExport,\n  _BinaryenRemoveFunction,\n  _BinaryenReturnGetValue,\n  _BinaryenReturnSetValue,\n  _free\n} from \"../glue/binaryen\";\n\nimport {\n  ExpressionId,\n  ExpressionRef,\n  FunctionRef,\n  Index,\n  BinaryOp,\n  TypeRef,\n  allocPtrArray,\n  Module,\n  ExternalKind,\n  ExportRef,\n  expandType,\n  isConstZero\n} from \"../module\";\n\nimport {\n  Compiler,\n  Options\n} from \"../compiler\";\n\nimport {\n  Feature\n} from \"../common\";\n\nimport {\n  BuiltinNames\n} from \"../builtins\";\n\ntype LocalIndex = Index;\ntype SlotIndex = Index;\ntype SlotMap = Map<LocalIndex,SlotIndex>;\ntype TempMap = Map<TypeRef,LocalIndex>;\n\n/** Attempts to match the `__tostack(value)` pattern. Returns `value` if a match, otherwise `0`.  */\nfunction matchPattern(module: Module, expr: ExpressionRef): ExpressionRef {\n  if (\n    _BinaryenExpressionGetId(expr) == ExpressionId.Call &&\n    module.readStringCached(_BinaryenCallGetTarget(expr)) == BuiltinNames.tostack\n  ) {\n    assert(_BinaryenCallGetNumOperands(expr) == 1);\n    return _BinaryenCallGetOperandAt(expr, 0);\n  }\n  return 0;\n}\n\n/** Tests whether a `value` matched by `matchTostack` needs a slot. */\nfunction needsSlot(module: Module, value: ExpressionRef): bool {\n  switch (_BinaryenExpressionGetId(value)) {\n    // no need to stack null pointers\n    case ExpressionId.Const: return !isConstZero(value);\n    // already kept in another slot\n    case ExpressionId.LocalGet:\n    case ExpressionId.LocalSet: return false; // tee\n  }\n  return true;\n}\n\n/** Instruments a module with a shadow stack for precise GC. */\nexport class ShadowStackPass extends Pass {\n  /** Stack frame slots, per function. */\n  slotMaps: Map<FunctionRef, SlotMap> = new Map();\n  /** Temporary locals, per function. */\n  tempMaps: Map<FunctionRef, TempMap> = new Map();\n  /** Exports (with managed operands) map. */\n  exportMap: Map<string,i32[]> = new Map();\n  /** Compiler reference. */\n  compiler: Compiler;\n\n  constructor(compiler: Compiler) {\n    super(compiler.module);\n    this.compiler = compiler;\n  }\n\n  /** Compiler options. */\n  get options(): Options { return this.compiler.options; }\n  /** Target pointer type. */\n  get ptrType(): TypeRef { return this.options.sizeTypeRef; }\n  /** Target pointer size. */\n  get ptrSize(): i32 { return this.ptrType == TypeRef.I64 ? 8 : 4; }\n  /** Target pointer addition operation. */\n  get ptrBinaryAdd(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.AddI64 : BinaryOp.AddI32; }\n  /** Target pointer subtraction operation. */\n  get ptrBinarySub(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.SubI64 : BinaryOp.SubI32; }\n\n  /** Gets a constant with the specified value of the target pointer type. */\n  ptrConst(value: i32): ExpressionRef {\n    return this.ptrType == TypeRef.I64\n      ? this.module.i64(value)\n      : this.module.i32(value);\n  }\n\n  /** Notes the presence of a slot for the specified (imaginary) local, returning the slot index. */\n  noteSlot(func: FunctionRef, localIndex: Index): i32 {\n    let slotMap: SlotMap;\n    if (this.slotMaps.has(func)) {\n      slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      if (slotMap.has(localIndex)) {\n        return changetype<i32>(slotMap.get(localIndex));\n      }\n    } else {\n      slotMap = new Map();\n      this.slotMaps.set(func, slotMap);\n    }\n    let slotIndex = slotMap.size;\n    slotMap.set(localIndex, slotIndex);\n    return slotIndex;\n  }\n\n  /** Notes the presence of an exported function taking managed operands. */\n  noteExport(name: string, managedOperandIndices: i32[]): void {\n    if (!managedOperandIndices.length) return;\n    this.exportMap.set(name, managedOperandIndices);\n  }\n\n  /** Gets a shared temporary local of the given type in the specified functions. */\n  getSharedTemp(func: FunctionRef, type: TypeRef): Index {\n    let tempMap: TempMap;\n    if (this.tempMaps.has(func)) {\n      tempMap = changetype<TempMap>(this.tempMaps.get(func));\n      if (tempMap.has(type)) {\n        return changetype<Index>(tempMap.get(type));\n      }\n    } else {\n      tempMap = new Map();\n      this.tempMaps.set(func, tempMap);\n    }\n    let numLocals = _BinaryenFunctionGetNumLocals(func);\n    let localIndex = numLocals + tempMap.size;\n    tempMap.set(type, localIndex);\n    return localIndex;\n  }\n\n  /** Makes an expression modifying the stack pointer by the given offset. */\n  makeStackOffset(offset: i32): ExpressionRef {\n    assert(offset != 0);\n    var module = this.module;\n    var expr = module.global_set(BuiltinNames.stack_pointer,\n      module.binary(offset >= 0 ? this.ptrBinaryAdd : this.ptrBinarySub,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        this.ptrConst(abs(offset))\n      )\n    );\n    if (offset > 0) return expr;\n    return module.block(null, [\n      expr,\n      this.makeStackCheck()\n    ], TypeRef.None);\n  }\n\n  /** Makes a sequence of expressions zeroing the stack frame. */\n  makeStackFill(frameSize: i32, stmts: ExpressionRef[]): void {\n    assert(frameSize > 0);\n    var module = this.module;\n    if (this.options.hasFeature(Feature.BULK_MEMORY) && frameSize > 16) {\n      stmts.push(\n        module.memory_fill(\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.i32(0), // TODO: Wasm64 also i32?\n          this.ptrConst(frameSize)\n        )\n      );\n    } else {\n      let remain = frameSize;\n      while (remain >= 8) {\n        // store<i64>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(8,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i64(0),\n            TypeRef.I64,\n            frameSize - remain\n          )\n        );\n        remain -= 8;\n      }\n      if (remain) {\n        assert(remain == 4);\n        // store<i32>(__stack_pointer, 0, frameSize - remain)\n        stmts.push(\n          module.store(4,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.i32(0),\n            TypeRef.I32,\n            frameSize - remain\n          )\n        );\n      }\n    }\n  }\n\n  private hasStackCheckFunction: bool = false;\n\n  /** Makes a check that the current stack pointer is valid. */\n  makeStackCheck(): ExpressionRef {\n    var module = this.module;\n    if (!this.hasStackCheckFunction) {\n      this.hasStackCheckFunction = true;\n      module.addFunction(\"~stack_check\", TypeRef.None, TypeRef.None, null,\n        module.if(\n          module.binary(BinaryOp.LtI32,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.global_get(BuiltinNames.data_end, this.ptrType)\n          ),\n          this.compiler.makeStaticAbort(\n            this.compiler.ensureStaticString(\"stack overflow\"),\n            this.compiler.program.nativeSource\n          )\n        )\n      );\n    }\n    return module.call(\"~stack_check\", null, TypeRef.None);\n  }\n\n  private updateCallOperands(operands: ExpressionRef[]): i32 {\n    var module = this.module;\n    var numSlots = 0;\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      let operand = operands[i];\n      let match = matchPattern(module, operand);\n      if (!match) continue;\n      if (!needsSlot(module, match)) {\n        operands[i] = match;\n        continue;\n      }\n      let currentFunction = this.currentFunction;\n      let numLocals = _BinaryenFunctionGetNumLocals(currentFunction);\n      let slotIndex = this.noteSlot(currentFunction, numLocals + this.callSlotOffset + i);\n      let temp = this.getSharedTemp(currentFunction, this.ptrType);\n      let stmts = new Array<ExpressionRef>();\n      // t = value\n      stmts.push(\n        module.local_set(temp, match, false)\n      );\n      // store<usize>(__stack_pointer, t, slotIndex * ptrSize)\n      stmts.push(\n        module.store(this.ptrSize,\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n          module.local_get(temp, this.ptrType),\n          this.ptrType, slotIndex * this.ptrSize\n        )\n      );\n      // -> t\n      stmts.push(\n        module.local_get(temp, this.ptrType)\n      );\n      operands[i] = module.block(null, stmts, this.ptrType);\n      ++numSlots;\n    }\n    return numSlots;\n  }\n\n  /** Slot offset accounting for nested calls. */\n  private callSlotOffset: i32 = 0;\n  /** Slot offset stack in nested calls. */\n  private callSlotStack: i32[] = new Array();\n\n  /** @override */\n  visitCallPre(call: ExpressionRef): void {\n    var numOperands = _BinaryenCallGetNumOperands(call);\n    var operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallGetOperandAt(call, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallSetOperandAt(call, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCall(call: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitCallIndirectPre(callIndirect: ExpressionRef): void {\n    let numOperands = _BinaryenCallIndirectGetNumOperands(callIndirect);\n    let operands = new Array<ExpressionRef>(numOperands);\n    for (let i: Index = 0; i < numOperands; ++i) {\n      operands[i] = _BinaryenCallIndirectGetOperandAt(callIndirect, i);\n    }\n    let numSlots = this.updateCallOperands(operands);\n    for (let i = 0, k = operands.length; i < k; ++i) {\n      _BinaryenCallIndirectSetOperandAt(callIndirect, i, operands[i]);\n    }\n    if (numSlots) {\n      // Reserve these slots for us so nested calls use their own\n      this.callSlotOffset += numSlots;\n    }\n    this.callSlotStack.push(numSlots);\n  }\n\n  /** @override */\n  visitCallIndirect(callIndirect: ExpressionRef): void {\n    let numSlots = this.callSlotStack.pop();\n    if (numSlots) this.callSlotOffset -= numSlots;\n  }\n\n  /** @override */\n  visitLocalSet(localSet: ExpressionRef): void {\n    let module = this.module;\n    let value = _BinaryenLocalSetGetValue(localSet);\n    let match = matchPattern(module, value);\n    if (!match) return;\n    if (!needsSlot(module, match)) {\n      _BinaryenLocalSetSetValue(localSet, match);\n      return;\n    }\n    let index = _BinaryenLocalSetGetIndex(localSet);\n    let slotIndex = this.noteSlot(this.currentFunction, index);\n    let stmts = new Array<ExpressionRef>();\n    // store<usize>(__stack_pointer, local = match, slotIndex * ptrSize)\n    stmts.push(\n      module.store(this.ptrSize,\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n        module.local_tee(index, match, false),\n        this.ptrType, slotIndex * this.ptrSize\n      )\n    );\n    if (_BinaryenLocalSetIsTee(localSet)) {\n      // -> local\n      stmts.push(\n        module.local_get(index, this.ptrType)\n      );\n      this.replaceCurrent(module.flatten(stmts, this.ptrType));\n    } else {\n      this.replaceCurrent(module.flatten(stmts, TypeRef.None));\n    }\n  }\n\n  /** Updates a function with additional locals etc. */\n  updateFunction(funcRef: FunctionRef): void {\n    let name = _BinaryenFunctionGetName(funcRef);\n    let params = _BinaryenFunctionGetParams(funcRef);\n    let results = _BinaryenFunctionGetResults(funcRef);\n    let body = assert(_BinaryenFunctionGetBody(funcRef));\n    let numVars = _BinaryenFunctionGetNumVars(funcRef);\n    let vars = new Array<TypeRef>();\n    for (let i: Index = 0; i < numVars; ++i) {\n      vars[i] = _BinaryenFunctionGetVar(funcRef, i);\n    }\n    let tempMaps = this.tempMaps;\n    if (tempMaps.has(funcRef)) {\n      let tempMap = changetype<TempMap>(tempMaps.get(funcRef));\n      for (let _keys = Map_keys(tempMap), i = 0, k = _keys.length; i < k; ++i) {\n        vars.push(_keys[i]);\n      }\n    }\n    let moduleRef = this.module.ref;\n    _BinaryenRemoveFunction(moduleRef, name);\n    let cArr = allocPtrArray(vars);\n    _BinaryenAddFunction(moduleRef, name, params, results, cArr, vars.length, body);\n    _free(cArr);\n  }\n\n  /** Updates a function export taking managed arguments. */\n  updateExport(exportRef: ExportRef, managedOperandIndices: i32[]): void {\n    var module = this.module;\n    var moduleRef = module.ref;\n    assert(_BinaryenExportGetKind(exportRef) == ExternalKind.Function);\n\n    var internalNameRef = _BinaryenExportGetValue(exportRef);\n    var internalName = module.readStringCached(internalNameRef)!;\n    var externalNameRef = _BinaryenExportGetName(exportRef);\n    var funcRef = _BinaryenGetFunction(moduleRef, internalNameRef);\n    var params = _BinaryenFunctionGetParams(funcRef);\n    var paramTypes = expandType(params);\n    var numParams = paramTypes.length;\n    var results = _BinaryenFunctionGetResults(funcRef);\n    var numLocals = numParams;\n    var vars = new Array<TypeRef>();\n    var numSlots = assert(managedOperandIndices.length);\n    var frameSize = numSlots * this.ptrSize;\n    var wrapperName = \"export:\" + internalName;\n    var wrapperNameRef = module.allocStringCached(wrapperName);\n\n    if (_BinaryenGetFunction(moduleRef, wrapperNameRef) == 0) {\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      for (let slotIndex = 0; slotIndex < numSlots; ++slotIndex) {\n        // store<usize>(__stack_pointer, $local, slotIndex * ptrSize)\n        stmts.push(\n          module.store(this.ptrSize,\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\n            module.local_get(managedOperandIndices[slotIndex], this.ptrType),\n            this.ptrType, slotIndex * this.ptrSize\n          )\n        );\n      }\n      let forwardedOperands = new Array<ExpressionRef>(numParams);\n      for (let i = 0; i < numParams; ++i) {\n        forwardedOperands[i] = module.local_get(i, paramTypes[i]);\n      }\n      if (results != TypeRef.None) {\n        let tempIndex = numLocals++;\n        vars.push(results);\n        // t = original(...)\n        stmts.push(\n          module.local_set(tempIndex,\n            module.call(internalName, forwardedOperands, results),\n            false // internal\n          )\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(tempIndex, results)\n        );\n      } else {\n        // original(...)\n        stmts.push(\n          module.call(internalName, forwardedOperands, results)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      }\n      let cArr = allocPtrArray(vars);\n      _BinaryenAddFunction(moduleRef, wrapperNameRef, params, results, cArr, vars.length,\n        module.block(null, stmts, results)\n      );\n      _free(cArr);\n    }\n    _BinaryenRemoveExport(moduleRef, externalNameRef);\n    _BinaryenAddFunctionExport(moduleRef, wrapperNameRef, externalNameRef);\n  }\n\n  /** @override */\n  walkModule(): void {\n    // Run the pass normally\n    super.walkModule();\n\n    // Instrument returns in functions utilizing stack slots\n    var module = this.module;\n    var instrumentReturns = new InstrumentReturns(this);\n    for (let _keys = Map_keys(this.slotMaps), i = 0, k = _keys.length; i < k; ++i) {\n      let func = _keys[i];\n      let slotMap = changetype<SlotMap>(this.slotMaps.get(func));\n      let frameSize = slotMap.size * this.ptrSize;\n\n      // Instrument function returns\n      instrumentReturns.frameSize = frameSize;\n      instrumentReturns.walkFunction(func);\n\n      // Instrument function entry\n      let stmts = new Array<ExpressionRef>();\n      // __stack_pointer -= frameSize\n      stmts.push(\n        this.makeStackOffset(-frameSize)\n      );\n      // memory.fill(__stack_pointer, 0, frameSize)\n      this.makeStackFill(frameSize, stmts);\n\n      // Handle implicit return\n      let body = _BinaryenFunctionGetBody(func);\n      let bodyType = _BinaryenExpressionGetType(body);\n      if (bodyType == TypeRef.Unreachable) {\n        // body\n        stmts.push(\n          body\n        );\n      } else if (bodyType == TypeRef.None) {\n        // body\n        stmts.push(\n          body\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n      } else {\n        let temp = this.getSharedTemp(func, bodyType);\n        // t = body\n        stmts.push(\n          module.local_set(temp, body, false)\n        );\n        // __stack_pointer += frameSize\n        stmts.push(\n          this.makeStackOffset(+frameSize)\n        );\n        // -> t\n        stmts.push(\n          module.local_get(temp, bodyType)\n        );\n      }\n      _BinaryenFunctionSetBody(func, module.flatten(stmts, bodyType));\n    }\n\n    // Update functions we added more locals to\n    // TODO: _BinaryenFunctionAddVar ?\n    for (let _keys = Map_keys(this.tempMaps), i = 0, k = _keys.length; i < k; ++i) {\n      this.updateFunction(_keys[i]);\n    }\n\n    // Update exports taking managed arguments\n    var exportMap = this.exportMap;\n    for (let _keys = Map_keys(exportMap), i = 0, k = _keys.length; i < k; ++i) {\n      let exportName = _keys[i];\n      let exportRef = _BinaryenGetExport(module.ref, module.allocStringCached(exportName));\n      let managedOperandIndices = changetype<i32[]>(exportMap.get(exportName));\n      this.updateExport(exportRef, managedOperandIndices);\n    }\n  }\n}\n\n/** Companion pass instrumenting `return` statements to restore the stack frame. */\nclass InstrumentReturns extends Pass {\n  /** Parent pass. */\n  parentPass: ShadowStackPass;\n  /** Frame size of the current function being processed. */\n  frameSize: i32 = 0;\n\n  constructor(shadowStack: ShadowStackPass) {\n    super(shadowStack.module);\n    this.parentPass = shadowStack;\n  }\n\n  /** @override */\n  visitReturn(ret: ExpressionRef): void {\n    assert(this.frameSize);\n    var module = this.module;\n    var value = _BinaryenReturnGetValue(ret);\n    var stmts = new Array<ExpressionRef>();\n    if (value) {\n      let returnType = _BinaryenExpressionGetType(value);\n      let temp = this.parentPass.getSharedTemp(this.currentFunction, returnType);\n      // t = value\n      stmts.push(\n        module.local_set(temp, value, false)\n      );\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return t\n      _BinaryenReturnSetValue(ret, module.local_get(temp, returnType));\n    } else {\n      // __stack_pointer += frameSize\n      stmts.push(\n        this.parentPass.makeStackOffset(+this.frameSize)\n      );\n      // return\n    }\n    stmts.push(\n      ret\n    );\n    this.replaceCurrent(module.flatten(stmts, TypeRef.Unreachable));\n  }\n}\n","/**\n * @fileoverview AssemblyScript's intermediate representation.\n *\n * The compiler uses Binaryen IR, which is fairly low level, as its\n * primary intermediate representation, with the following structures\n * holding any higher level information that cannot be represented by\n * Binaryen IR alone, for example higher level types.\n *\n * Similar to the AST being composed of `Node`s in `Source`s, the IR is\n * composed of `Element`s in a `Program`. Each class or function is\n * represented by a \"prototype\" holding all the relevant information,\n * including each's concrete instances. If a class or function is not\n * generic, there is exactly one instance, otherwise there is one for\n * each concrete set of type arguments.\n *\n * @license Apache-2.0\n */\n\n// Element                    Base class of all elements\n// ├─DeclaredElement          Base class of elements with a declaration\n// │ ├─TypedElement           Base class of elements resolving to a type\n// │ │ ├─TypeDefinition       Type alias declaration\n// │ │ ├─VariableLikeElement  Base class of all variable-like elements\n// │ │ │ ├─EnumValue          Enum value\n// │ │ │ ├─Global             File global\n// │ │ │ ├─Local              Function local\n// │ │ │ ├─Field              Class field (instance only)\n// │ │ │ └─Property           Class property\n// │ │ ├─IndexSignature       Class index signature\n// │ │ ├─Function             Concrete function instance\n// │ │ └─Class                Concrete class instance\n// │ ├─Namespace              Namespace with static members\n// │ ├─FunctionPrototype      Prototype of concrete function instances\n// │ ├─FieldPrototype         Prototype of concrete field instances\n// │ ├─PropertyPrototype      Prototype of concrete property instances\n// │ └─ClassPrototype         Prototype of concrete classe instances\n// └─File                     File, analogous to Source in the AST\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  STATIC_DELIMITER,\n  INSTANCE_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INNER_DELIMITER,\n  LIBRARY_SUBST,\n  INDEX_SUFFIX,\n  STUB_DELIMITER,\n  CommonNames,\n  Feature,\n  Target\n} from \"./common\";\n\nimport {\n  Options\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Type,\n  TypeKind,\n  Signature,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  Token,\n  Range\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  DecoratorNode,\n  DecoratorKind,\n  TypeParameterNode,\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  IdentifierExpression,\n  LiteralKind,\n  StringLiteralExpression,\n\n  Statement,\n  ClassDeclaration,\n  DeclarationStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportMember,\n  ExportDefaultStatement,\n  ExportStatement,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  ImportStatement,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n  VariableLikeDeclarationStatement,\n  VariableStatement,\n  ParameterKind\n} from \"./ast\";\n\nimport {\n  Module,\n  FunctionRef,\n  MemorySegment\n} from \"./module\";\n\nimport {\n  CharCode,\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  writeI64,\n  writeI32AsI64,\n  writeI64AsI32\n} from \"./util\";\n\nimport {\n  Resolver\n} from \"./resolver\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  Parser\n} from \"./parser\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n// Memory manager constants\nconst AL_SIZE = 16;\nconst AL_MASK = AL_SIZE - 1;\n\n/** Represents a yet unresolved `import`. */\nclass QueuedImport {\n  constructor(\n    /** File being imported into. */\n    public localFile: File,\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. Is an `import *` if not set. */\n    public foreignIdentifier: IdentifierExpression | null,\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string\n  ) {}\n}\n\n/** Represents a yet unresolved `export`. */\nclass QueuedExport {\n  constructor(\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. */\n    public foreignIdentifier: IdentifierExpression,\n    /** Path to the other file if a re-export. */\n    public foreignPath: string | null,\n    /** Alternative path to the other file if a re-export. */\n    public foreignPathAlt: string | null\n  ) {}\n}\n\n/** Represents a yet unresolved `export *`. */\nclass QueuedExportStar {\n  // stored in a map with localFile as the key\n  constructor(\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string,\n    /** Reference to the path literal for reporting. */\n    public pathLiteral: StringLiteralExpression\n  ) {}\n}\n\n/** Represents the kind of an operator overload. */\nexport enum OperatorKind {\n  INVALID,\n\n  // indexed access\n  INDEXED_GET,            // a[]\n  INDEXED_SET,            // a[]=b\n  UNCHECKED_INDEXED_GET,  // unchecked(a[])\n  UNCHECKED_INDEXED_SET,  // unchecked(a[]=b)\n\n  // binary\n  ADD,                    // a + b\n  SUB,                    // a - b\n  MUL,                    // a * b\n  DIV,                    // a / b\n  REM,                    // a % b\n  POW,                    // a ** b\n  BITWISE_AND,            // a & b\n  BITWISE_OR,             // a | b\n  BITWISE_XOR,            // a ^ b\n  BITWISE_SHL,            // a << b\n  BITWISE_SHR,            // a >> b\n  BITWISE_SHR_U,          // a >>> b\n  EQ,                     // a == b\n  NE,                     // a != b\n  GT,                     // a > b\n  GE,                     // a >= b\n  LT,                     // a < b\n  LE,                     // a <= b\n\n  // unary prefix\n  PLUS,                   // +a\n  MINUS,                  // -a\n  NOT,                    // !a\n  BITWISE_NOT,            // ~a\n  PREFIX_INC,             // ++a\n  PREFIX_DEC,             // --a\n\n  // unary postfix\n  POSTFIX_INC,            // a++\n  POSTFIX_DEC             // a--\n\n  // not overridable:\n  // IDENTITY             // a === b\n  // LOGICAL_AND          // a && b\n  // LOGICAL_OR           // a || b\n}\n\nexport namespace OperatorKind {\n\n  /** Returns the operator kind represented by the specified decorator and string argument. */\n  export function fromDecorator(decoratorKind: DecoratorKind, arg: string): OperatorKind {\n    assert(arg.length);\n    switch (decoratorKind) {\n      case DecoratorKind.OPERATOR:\n      case DecoratorKind.OPERATOR_BINARY: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.OPENBRACKET: {\n            if (arg == \"[]\") return OperatorKind.INDEXED_GET;\n            if (arg == \"[]=\") return OperatorKind.INDEXED_SET;\n            break;\n          }\n          case CharCode.OPENBRACE: {\n            if (arg == \"{}\") return OperatorKind.UNCHECKED_INDEXED_GET;\n            if (arg == \"{}=\") return OperatorKind.UNCHECKED_INDEXED_SET;\n            break;\n          }\n          case CharCode.PLUS: {\n            if (arg == \"+\") return OperatorKind.ADD;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"-\") return OperatorKind.SUB;\n            break;\n          }\n          case CharCode.ASTERISK: {\n            if (arg == \"*\") return OperatorKind.MUL;\n            if (arg == \"**\") return OperatorKind.POW;\n            break;\n          }\n          case CharCode.SLASH: {\n            if (arg == \"/\") return OperatorKind.DIV;\n            break;\n          }\n          case CharCode.PERCENT: {\n            if (arg == \"%\") return OperatorKind.REM;\n            break;\n          }\n          case CharCode.AMPERSAND: {\n            if (arg == \"&\") return OperatorKind.BITWISE_AND;\n            break;\n          }\n          case CharCode.BAR: {\n            if (arg == \"|\") return OperatorKind.BITWISE_OR;\n            break;\n          }\n          case CharCode.CARET: {\n            if (arg == \"^\") return OperatorKind.BITWISE_XOR;\n            break;\n          }\n          case CharCode.EQUALS: {\n            if (arg == \"==\") return OperatorKind.EQ;\n            break;\n          }\n          case CharCode.EXCLAMATION: {\n            if (arg == \"!=\") return OperatorKind.NE;\n            break;\n          }\n          case CharCode.GREATERTHAN: {\n            if (arg == \">\") return OperatorKind.GT;\n            if (arg == \">=\") return OperatorKind.GE;\n            if (arg == \">>\") return OperatorKind.BITWISE_SHR;\n            if (arg == \">>>\") return OperatorKind.BITWISE_SHR_U;\n            break;\n          }\n          case CharCode.LESSTHAN: {\n            if (arg == \"<\") return OperatorKind.LT;\n            if (arg == \"<=\") return OperatorKind.LE;\n            if (arg == \"<<\") return OperatorKind.BITWISE_SHL;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OPERATOR_PREFIX: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.PLUS: {\n            if (arg == \"+\") return OperatorKind.PLUS;\n            if (arg == \"++\") return OperatorKind.PREFIX_INC;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"-\") return OperatorKind.MINUS;\n            if (arg == \"--\") return OperatorKind.PREFIX_DEC;\n            break;\n          }\n          case CharCode.EXCLAMATION: {\n            if (arg == \"!\") return OperatorKind.NOT;\n            break;\n          }\n          case CharCode.TILDE: {\n            if (arg == \"~\") return OperatorKind.BITWISE_NOT;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OPERATOR_POSTFIX: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.PLUS: {\n            if (arg == \"++\") return OperatorKind.POSTFIX_INC;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"--\") return OperatorKind.POSTFIX_DEC;\n            break;\n          }\n        }\n        break;\n      }\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a binary operator token to the respective operator kind. */\n  export function fromBinaryToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS:\n      case Token.PLUS_EQUALS: return OperatorKind.ADD;\n      case Token.MINUS:\n      case Token.MINUS_EQUALS: return OperatorKind.SUB;\n      case Token.ASTERISK:\n      case Token.ASTERISK_EQUALS: return OperatorKind.MUL;\n      case Token.SLASH:\n      case Token.SLASH_EQUALS: return OperatorKind.DIV;\n      case Token.PERCENT:\n      case Token.PERCENT_EQUALS: return OperatorKind.REM;\n      case Token.ASTERISK_ASTERISK:\n      case Token.ASTERISK_ASTERISK_EQUALS: return OperatorKind.POW;\n      case Token.AMPERSAND:\n      case Token.AMPERSAND_EQUALS: return OperatorKind.BITWISE_AND;\n      case Token.BAR:\n      case Token.BAR_EQUALS: return OperatorKind.BITWISE_OR;\n      case Token.CARET:\n      case Token.CARET_EQUALS: return OperatorKind.BITWISE_XOR;\n      case Token.LESSTHAN_LESSTHAN:\n      case Token.LESSTHAN_LESSTHAN_EQUALS: return OperatorKind.BITWISE_SHL;\n      case Token.GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR;\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR_U;\n      case Token.EQUALS_EQUALS: return OperatorKind.EQ;\n      case Token.EXCLAMATION_EQUALS: return OperatorKind.NE;\n      case Token.GREATERTHAN: return OperatorKind.GT;\n      case Token.GREATERTHAN_EQUALS: return OperatorKind.GE;\n      case Token.LESSTHAN: return OperatorKind.LT;\n      case Token.LESSTHAN_EQUALS: return OperatorKind.LE;\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a unary prefix operator token to the respective operator kind. */\n  export function fromUnaryPrefixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS: return OperatorKind.PLUS;\n      case Token.MINUS: return OperatorKind.MINUS;\n      case Token.EXCLAMATION: return OperatorKind.NOT;\n      case Token.TILDE: return OperatorKind.BITWISE_NOT;\n      case Token.PLUS_PLUS: return OperatorKind.PREFIX_INC;\n      case Token.MINUS_MINUS: return OperatorKind.PREFIX_DEC;\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a unary postfix operator token to the respective operator kind. */\n  export function fromUnaryPostfixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS_PLUS: return OperatorKind.POSTFIX_INC;\n      case Token.MINUS_MINUS: return OperatorKind.POSTFIX_DEC;\n    }\n    return OperatorKind.INVALID;\n  }\n}\n\n/** Represents an AssemblyScript program. */\nexport class Program extends DiagnosticEmitter {\n\n  /** Constructs a new program, optionally inheriting parser diagnostics. */\n  constructor(\n    /** Compiler options. */\n    public options: Options,\n    /** Shared array of diagnostic messages (emitted so far). */\n    diagnostics: DiagnosticMessage[] | null = null\n  ) {\n    super(diagnostics);\n    var nativeSource = new Source(SourceKind.LIBRARY_ENTRY, LIBRARY_SUBST + \".wasm\", \"[native code]\");\n    this.nativeSource = nativeSource;\n    this.parser = new Parser(this.diagnostics, this.sources);\n    this.resolver = new Resolver(this);\n    var nativeFile = new File(this, nativeSource);\n    this.nativeFile = nativeFile;\n    this.filesByName.set(nativeFile.internalName, nativeFile);\n  }\n\n  /** Parser instance. */\n  parser: Parser;\n  /** Resolver instance. */\n  resolver!: Resolver;\n  /** Array of sources. */\n  sources: Source[] = [];\n  /** Diagnostic offset used where successively obtaining the next diagnostic. */\n  diagnosticsOffset: i32 = 0;\n  /** Special native code source. */\n  nativeSource: Source;\n  /** Special native code range. */\n  get nativeRange(): Range { return this.nativeSource.range; }\n  /** Special native code file. */\n  nativeFile!: File;\n  /** Next class id. */\n  nextClassId: u32 = 0;\n  /** Next signature id. */\n  nextSignatureId: i32 = 0;\n  /** An indicator if the program has been initialized. */\n  initialized: bool = false;\n\n  // Lookup maps\n\n  /** Files by unique internal name. */\n  filesByName: Map<string,File> = new Map();\n  /** Elements by unique internal name in element space. */\n  elementsByName: Map<string,Element> = new Map();\n  /** Elements by declaration. */\n  elementsByDeclaration: Map<DeclarationStatement,DeclaredElement> = new Map();\n  /** Element instances by unique internal name. */\n  instancesByName: Map<string,Element> = new Map();\n  /** Classes wrapping basic types like `i32`. */\n  wrapperClasses: Map<Type,Class> = new Map();\n  /** Managed classes contained in the program, by id. */\n  managedClasses: Map<i32,Class> = new Map();\n  /** A set of unique function signatures contained in the program, by id. */\n  uniqueSignatures: Signature[] = new Array<Signature>(0);\n\n  // Standard library\n\n  /** Gets the standard `ArrayBufferView` instance. */\n  get arrayBufferViewInstance(): Class {\n    var cached = this._arrayBufferViewInstance;\n    if (!cached) this._arrayBufferViewInstance = cached = this.requireClass(CommonNames.ArrayBufferView);\n    return cached;\n  }\n  private _arrayBufferViewInstance: Class | null = null;\n\n  /** Gets the standard `ArrayBuffer` instance. */\n  get arrayBufferInstance(): Class {\n    var cached = this._arrayBufferInstance;\n    if (!cached) this._arrayBufferInstance = cached = this.requireClass(CommonNames.ArrayBuffer);\n    return cached;\n  }\n  private _arrayBufferInstance: Class | null = null;\n\n  /** Gets the standard `Array` prototype. */\n  get arrayPrototype(): ClassPrototype {\n    var cached = this._arrayPrototype;\n    if (!cached) this._arrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _arrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `StaticArray` prototype. */\n  get staticArrayPrototype(): ClassPrototype {\n    var cached = this._staticArrayPrototype;\n    if (!cached) this._staticArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.StaticArray, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _staticArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Set` prototype. */\n  get setPrototype(): ClassPrototype {\n    var cached = this._setPrototype;\n    if (!cached) this._setPrototype = cached = <ClassPrototype>this.require(CommonNames.Set, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _setPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Map` prototype. */\n  get mapPrototype(): ClassPrototype {\n    var cached = this._mapPrototype;\n    if (!cached) this._mapPrototype = cached = <ClassPrototype>this.require(CommonNames.Map, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _mapPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Function` prototype. */\n  get functionPrototype(): ClassPrototype {\n    var cached = this._functionPrototype;\n    if (!cached) this._functionPrototype = cached = <ClassPrototype>this.require(CommonNames.Function, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _functionPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int8Array` prototype. */\n  get int8ArrayPrototype(): ClassPrototype {\n    var cached = this._int8ArrayPrototype;\n    if (!cached) this._int8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int8Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int16Array` prototype. */\n  get int16ArrayPrototype(): ClassPrototype {\n    var cached = this._int16ArrayPrototype;\n    if (!cached) this._int16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int16Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int32Array` prototype. */\n  get int32ArrayPrototype(): ClassPrototype {\n    var cached = this._int32ArrayPrototype;\n    if (!cached) this._int32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int64Array` prototype. */\n  get int64ArrayPrototype(): ClassPrototype {\n    var cached = this._int64ArrayPrototype;\n    if (!cached) this._int64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8Array` prototype. */\n  get uint8ArrayPrototype(): ClassPrototype {\n    var cached = this._uint8ArrayPrototype;\n    if (!cached) this._uint8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8ClampedArray` prototype. */\n  get uint8ClampedArrayPrototype(): ClassPrototype {\n    var cached = this._uint8ClampedArrayPrototype;\n    if (!cached) this._uint8ClampedArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8ClampedArray, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint8ClampedArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint16Array` prototype. */\n  get uint16ArrayPrototype(): ClassPrototype {\n    var cached = this._uint16ArrayPrototype;\n    if (!cached) this._uint16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint16Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint32Array` prototype. */\n  get uint32ArrayPrototype(): ClassPrototype {\n    var cached = this._uint32ArrayPrototype;\n    if (!cached) this._uint32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint64Array` prototype. */\n  get uint64ArrayPrototype(): ClassPrototype {\n    var cached = this._uint64ArrayPrototype;\n    if (!cached) this._uint64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float32Array` prototype. */\n  get float32ArrayPrototype(): ClassPrototype {\n    var cached = this._float32ArrayPrototype;\n    if (!cached) this._float32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _float32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float64Array` prototype. */\n  get float64ArrayPrototype(): ClassPrototype {\n    var cached = this._float64ArrayPrototype;\n    if (!cached) this._float64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _float64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `String` instance. */\n  get stringInstance(): Class {\n    var cached = this._stringInstance;\n    if (!cached) this._stringInstance = cached = this.requireClass(CommonNames.String);\n    return cached;\n  }\n  private _stringInstance: Class | null = null;\n\n  /** Gets the standard `Object` instance. */\n  get objectInstance(): Class {\n    var cached = this._objectInstance;\n    if (!cached) this._objectInstance = cached = this.requireClass(CommonNames.Object);\n    return cached;\n  }\n  private _objectInstance: Class | null = null;\n\n  /** Gets the standard `TemplateStringsArray` instance. */\n  get templateStringsArrayInstance(): Class {\n    var cached = this._templateStringsArrayInstance;\n    if (!cached) this._templateStringsArrayInstance = cached = this.requireClass(CommonNames.TemplateStringsArray);\n    return cached;\n  }\n  private _templateStringsArrayInstance: Class | null = null;\n\n  /** Gets the standard `abort` instance, if not explicitly disabled. */\n  get abortInstance(): Function | null {\n    var prototype = this.lookup(CommonNames.abort);\n    if (!prototype || prototype.kind != ElementKind.FUNCTION_PROTOTYPE) return null;\n    return this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n  }\n\n  // Runtime interface\n\n  /** Gets the runtime `__alloc(size: usize): usize` instance. */\n  get allocInstance(): Function {\n    var cached = this._allocInstance;\n    if (!cached) this._allocInstance = cached = this.requireFunction(CommonNames.alloc);\n    return cached;\n  }\n  private _allocInstance: Function | null = null;\n\n  /** Gets the runtime `__realloc(ptr: usize, newSize: usize): usize` instance. */\n  get reallocInstance(): Function {\n    var cached = this._reallocInstance;\n    if (!cached) this._reallocInstance = cached = this.requireFunction(CommonNames.realloc);\n    return cached;\n  }\n  private _reallocInstance: Function | null = null;\n\n  /** Gets the runtime `__free(ptr: usize): void` instance. */\n  get freeInstance(): Function {\n    var cached = this._freeInstance;\n    if (!cached) this._freeInstance = cached = this.requireFunction(CommonNames.free);\n    return cached;\n  }\n  private _freeInstance: Function | null = null;\n\n  /** Gets the runtime `__new(size: usize, id: u32): usize` instance. */\n  get newInstance(): Function {\n    var cached = this._newInstance;\n    if (!cached) this._newInstance = cached = this.requireFunction(CommonNames.new_);\n    return cached;\n  }\n  private _newInstance: Function | null = null;\n\n  /** Gets the runtime `__renew(ptr: usize, size: usize): usize` instance. */\n  get renewInstance(): Function {\n    var cached = this._renewInstance;\n    if (!cached) this._renewInstance = cached = this.requireFunction(CommonNames.renew);\n    return cached;\n  }\n  private _renewInstance: Function | null = null;\n\n  /** Gets the runtime `__link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void` instance. */\n  get linkInstance(): Function {\n    var cached = this._linkInstance;\n    if (!cached) this._linkInstance = cached = this.requireFunction(CommonNames.link);\n    return cached;\n  }\n  private _linkInstance: Function | null = null;\n\n  /** Gets the runtime `__collect(): void` instance. */\n  get collectInstance(): Function {\n    var cached = this._collectInstance;\n    if (!cached) this._collectInstance = cached = this.requireFunction(CommonNames.collect);\n    return cached;\n  }\n  private _collectInstance: Function | null = null;\n\n  /** Gets the runtime `__visit(ptr: usize, cookie: u32): void` instance. */\n  get visitInstance(): Function {\n    var cached = this._visitInstance;\n    if (!cached) this._visitInstance = cached = this.requireFunction(CommonNames.visit);\n    return cached;\n  }\n  private _visitInstance: Function | null = null;\n\n  /** Gets the runtime `__typeinfo(id: u32): RTTIFlags` instance. */\n  get typeinfoInstance(): Function {\n    var cached = this._typeinfoInstance;\n    if (!cached) this._typeinfoInstance = cached = this.requireFunction(CommonNames.typeinfo);\n    return cached;\n  }\n  private _typeinfoInstance: Function | null = null;\n\n  /** Gets the runtime `__instanceof(ptr: usize, superId: u32): bool` instance. */\n  get instanceofInstance(): Function {\n    var cached = this._instanceofInstance;\n    if (!cached) this._instanceofInstance = cached = this.requireFunction(CommonNames.instanceof_);\n    return cached;\n  }\n  private _instanceofInstance: Function | null = null;\n\n  /** Gets the runtime `__newBuffer(size: usize, id: u32, data: usize = 0): usize` instance. */\n  get newBufferInstance(): Function {\n    var cached = this._newBufferInstance;\n    if (!cached) this._newBufferInstance = cached = this.requireFunction(CommonNames.newBuffer);\n    return cached;\n  }\n  private _newBufferInstance: Function | null = null;\n\n  /** Gets the runtime `__newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize` instance. */\n  get newArrayInstance(): Function {\n    var cached = this._newArrayInstance;\n    if (!cached) this._newArrayInstance = cached = this.requireFunction(CommonNames.newArray);\n    return cached;\n  }\n  private _newArrayInstance: Function | null = null;\n\n  /** Gets the runtime's internal `BLOCK` instance. */\n  get BLOCKInstance(): Class {\n    var cached = this._BLOCKInstance;\n    if (!cached) this._BLOCKInstance = cached = this.requireClass(CommonNames.BLOCK);\n    return cached;\n  }\n  private _BLOCKInstance: Class | null = null;\n\n  /** Gets the runtime's internal `OBJECT` instance. */\n  get OBJECTInstance(): Class {\n    var cached = this._OBJECTInstance;\n    if (!cached) this._OBJECTInstance = cached = this.requireClass(CommonNames.OBJECT);\n    return cached;\n  }\n  private _OBJECTInstance: Class | null = null;\n\n  // Utility\n\n  /** Tests whether this is a WASI program. */\n  get isWasi(): bool {\n    return this.elementsByName.has(CommonNames.ASC_WASI);\n  }\n\n  /** Obtains the source matching the specified internal path. */\n  getSource(internalPath: string): string | null {\n    var sources = this.sources;\n    for (let i = 0; i < sources.length; ++i) {\n      let source = sources[i];\n      if (source.internalPath == internalPath) return source.text;\n    }\n    return null;\n  }\n\n  /** Gets the overhead of a memory manager block. */\n  get blockOverhead(): i32 {\n    // BLOCK | data...\n    //       ^ 16b alignment\n    return this.BLOCKInstance.nextMemoryOffset;\n  }\n\n  /** Gets the overhead of a managed object, excl. block overhead, incl. alignment. */\n  get objectOverhead(): i32 {\n    // OBJECT+align | data...\n    //        └ 0 ┘ ^ 16b alignment\n    return (this.OBJECTInstance.nextMemoryOffset - this.blockOverhead + AL_MASK) & ~AL_MASK;\n  }\n\n  /** Gets the total overhead of a managed object, incl. block overhead. */\n  get totalOverhead(): i32 {\n    // BLOCK | OBJECT+align | data...\n    // └     = TOTAL      ┘ ^ 16b alignment\n    return this.blockOverhead + this.objectOverhead;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart(currentOffset: i32): i32 {\n    var blockOverhead = this.blockOverhead;\n    return ((currentOffset + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n  }\n\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\n  computeBlockStart64(currentOffset: i64): i64 {\n    var blockOverhead = i64_new(this.blockOverhead);\n    return i64_sub(i64_align(i64_add(currentOffset, blockOverhead), AL_SIZE), blockOverhead);\n  }\n\n  /** Computes the size of a memory manager block, excl. block overhead. */\n  computeBlockSize(payloadSize: i32, isManaged: bool): i32 {\n    // see: std/rt/tlsf.ts, computeSize; becomes mmInfo\n    if (isManaged) payloadSize += this.objectOverhead;\n    // we know that payload must be aligned, and that block sizes must be chosen\n    // so that blocks are adjacent with the next payload aligned. hence, block\n    // size is payloadSize rounded up to where the next block would start:\n    var blockSize = this.computeBlockStart(payloadSize);\n    // make sure that block size is valid according to TLSF requirements\n    var blockOverhead = this.blockOverhead;\n    var blockMinsize = ((3 * this.options.usizeType.byteSize + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\n    if (blockSize < blockMinsize) blockSize = blockMinsize;\n    const blockMaxsize = 1 << 30; // 1 << (FL_BITS + SB_BITS - 1), exclusive\n    const tagsMask = 3;\n    if (blockSize >= blockMaxsize || (blockSize & tagsMask) != 0) {\n      throw new Error(\"invalid block size\");\n    }\n    return blockSize;\n  }\n\n  /** Creates a native variable declaration. */\n  makeNativeVariableDeclaration(\n    /** The simple name of the variable */\n    name: string,\n    /** Flags indicating specific traits, e.g. `CONST`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): VariableDeclaration {\n    var range = this.nativeSource.range;\n    return Node.createVariableDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, null, range\n    );\n  }\n\n  /** Creates a native type declaration. */\n  makeNativeTypeDeclaration(\n    /** The simple name of the type. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): TypeDeclaration {\n    var range = this.nativeSource.range;\n    var identifier = Node.createIdentifierExpression(name, range);\n    return Node.createTypeDeclaration(\n      identifier,\n      null, flags, null,\n      Node.createOmittedType(range),\n      range\n    );\n  }\n\n  // a dummy signature for programmatically generated native functions\n  private nativeDummySignature: FunctionTypeNode | null = null;\n\n  /** Creates a native function declaration. */\n  makeNativeFunctionDeclaration(\n    /** The simple name of the function. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `DECLARE`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): FunctionDeclaration {\n    var range = this.nativeSource.range;\n    var signature = this.nativeDummySignature;\n    if (!signature) {\n      this.nativeDummySignature = signature = Node.createFunctionType([],\n        Node.createNamedType( // ^ AST signature doesn't really matter, is overridden anyway\n          Node.createSimpleTypeName(CommonNames.void_, range),\n          null, false, range\n        ),\n        null, false, range\n      );\n    }\n    return Node.createFunctionDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, signature, null, ArrowKind.NONE, range\n    );\n  }\n\n  /** Creates a native namespace declaration. */\n  makeNativeNamespaceDeclaration(\n    /** The simple name of the namespace. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `EXPORT`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): NamespaceDeclaration {\n    var range = this.nativeSource.range;\n    return Node.createNamespaceDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, [], range\n    );\n  }\n\n  /** Creates a native function. */\n  makeNativeFunction(\n    /** The simple name of the function. */\n    name: string,\n    /** Concrete function signature. */\n    signature: Signature,\n    /** Parent element, usually a file, class or namespace. */\n    parent: Element = this.nativeFile,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.NONE,\n    /** Decorator flags representing built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ): Function {\n    return new Function(\n      name,\n      new FunctionPrototype(\n        name,\n        parent,\n        this.makeNativeFunctionDeclaration(name, flags),\n        decoratorFlags\n      ),\n      null,\n      signature\n    );\n  }\n\n  /** Gets the (possibly merged) program element linked to the specified declaration. */\n  getElementByDeclaration(declaration: DeclarationStatement): DeclaredElement | null {\n    var elementsByDeclaration = this.elementsByDeclaration;\n    return elementsByDeclaration.has(declaration)\n      ? assert(elementsByDeclaration.get(declaration))\n      : null;\n  }\n\n  /** Initializes the program and its elements prior to compilation. */\n  initialize(): void {\n    if (this.initialized) return;\n    this.initialized = true;\n\n    var options = this.options;\n\n    // register native types\n    this.registerNativeType(CommonNames.i8, Type.i8);\n    this.registerNativeType(CommonNames.i16, Type.i16);\n    this.registerNativeType(CommonNames.i32, Type.i32);\n    this.registerNativeType(CommonNames.i64, Type.i64);\n    this.registerNativeType(CommonNames.isize, options.isizeType);\n    this.registerNativeType(CommonNames.u8, Type.u8);\n    this.registerNativeType(CommonNames.u16, Type.u16);\n    this.registerNativeType(CommonNames.u32, Type.u32);\n    this.registerNativeType(CommonNames.u64, Type.u64);\n    this.registerNativeType(CommonNames.usize, options.usizeType);\n    this.registerNativeType(CommonNames.bool, Type.bool);\n    this.registerNativeType(CommonNames.f32, Type.f32);\n    this.registerNativeType(CommonNames.f64, Type.f64);\n    this.registerNativeType(CommonNames.void_, Type.void);\n    this.registerNativeType(CommonNames.number, Type.f64); // alias\n    this.registerNativeType(CommonNames.boolean, Type.bool); // alias\n    this.nativeFile.add(CommonNames.native, new TypeDefinition(\n      CommonNames.native,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.native, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.indexof, new TypeDefinition(\n      CommonNames.indexof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.indexof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.valueof, new TypeDefinition(\n      CommonNames.valueof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.valueof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.returnof, new TypeDefinition(\n      CommonNames.returnof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.returnof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.nonnull, new TypeDefinition(\n      CommonNames.nonnull,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.nonnull, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n\n    // The following types might not be enabled by compiler options, so the\n    // compiler needs to check this condition whenever such a value is created\n    // respectively stored or loaded.\n    this.registerNativeType(CommonNames.v128, Type.v128);\n    this.registerNativeType(CommonNames.funcref, Type.funcref);\n    this.registerNativeType(CommonNames.externref, Type.externref);\n    this.registerNativeType(CommonNames.anyref, Type.anyref);\n    this.registerNativeType(CommonNames.eqref, Type.eqref);\n    this.registerNativeType(CommonNames.i31ref, Type.i31ref);\n    this.registerNativeType(CommonNames.dataref, Type.dataref);\n\n    // register compiler hints\n    this.registerConstantInteger(CommonNames.ASC_TARGET, Type.i32,\n      i64_new(options.isWasm64 ? Target.WASM64 : Target.WASM32));\n    this.registerConstantInteger(CommonNames.ASC_RUNTIME, Type.i32,\n      i64_new(options.runtime));\n    this.registerConstantInteger(CommonNames.ASC_NO_ASSERT, Type.bool,\n      i64_new(options.noAssert ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_MEMORY_BASE, Type.i32,\n      i64_new(options.memoryBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_TABLE_BASE, Type.i32,\n      i64_new(options.tableBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_OPTIMIZE_LEVEL, Type.i32,\n      i64_new(options.optimizeLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_SHRINK_LEVEL, Type.i32,\n      i64_new(options.shrinkLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_LOW_MEMORY_LIMIT, Type.i32,\n      i64_new(options.lowMemoryLimit, 0));\n    this.registerConstantInteger(CommonNames.ASC_EXPORT_RUNTIME, Type.bool,\n      i64_new(options.exportRuntime ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MAJOR, Type.i32,\n      i64_new(options.bundleMajorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MINOR, Type.i32,\n      i64_new(options.bundleMinorVersion));\n    this.registerConstantInteger(CommonNames.ASC_VERSION_PATCH, Type.i32,\n      i64_new(options.bundlePatchVersion));\n\n    // register feature hints\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIGN_EXTENSION, Type.bool,\n      i64_new(options.hasFeature(Feature.SIGN_EXTENSION) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MUTABLE_GLOBALS, Type.bool,\n      i64_new(options.hasFeature(Feature.MUTABLE_GLOBALS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_NONTRAPPING_F2I, Type.bool,\n      i64_new(options.hasFeature(Feature.NONTRAPPING_F2I) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_BULK_MEMORY, Type.bool,\n      i64_new(options.hasFeature(Feature.BULK_MEMORY) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.SIMD) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_THREADS, Type.bool,\n      i64_new(options.hasFeature(Feature.THREADS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXCEPTION_HANDLING, Type.bool,\n      i64_new(options.hasFeature(Feature.EXCEPTION_HANDLING) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_TAIL_CALLS, Type.bool,\n      i64_new(options.hasFeature(Feature.TAIL_CALLS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_REFERENCE_TYPES, Type.bool,\n      i64_new(options.hasFeature(Feature.REFERENCE_TYPES) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MULTI_VALUE, Type.bool,\n      i64_new(options.hasFeature(Feature.MULTI_VALUE) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_GC, Type.bool,\n      i64_new(options.hasFeature(Feature.GC) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MEMORY64, Type.bool,\n      i64_new(options.hasFeature(Feature.MEMORY64) ? 1 : 0, 0));\n\n    // remember deferred elements\n    var queuedImports = new Array<QueuedImport>();\n    var queuedExports = new Map<File,Map<string,QueuedExport>>();\n    var queuedExportsStar = new Map<File,QueuedExportStar[]>();\n    var queuedExtends = new Array<ClassPrototype>();\n    var queuedImplements = new Array<ClassPrototype>();\n\n    // initialize relevant declaration-like statements of the entire program\n    for (let i = 0, k = this.sources.length; i < k; ++i) {\n      let source = this.sources[i];\n      let file = new File(this, source);\n      this.filesByName.set(file.internalName, file);\n      let statements = source.statements;\n      for (let j = 0, l = statements.length; j < l; ++j) {\n        let statement = statements[j];\n        switch (statement.kind) {\n          case NodeKind.EXPORT: {\n            this.initializeExports(<ExportStatement>statement, file, queuedExports, queuedExportsStar);\n            break;\n          }\n          case NodeKind.EXPORTDEFAULT: {\n            this.initializeExportDefault(<ExportDefaultStatement>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.IMPORT: {\n            this.initializeImports(<ImportStatement>statement, file, queuedImports, queuedExports);\n            break;\n          }\n          case NodeKind.VARIABLE: {\n            this.initializeVariables(<VariableStatement>statement, file);\n            break;\n          }\n          case NodeKind.CLASSDECLARATION: {\n            this.initializeClass(<ClassDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.ENUMDECLARATION: {\n            this.initializeEnum(<EnumDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.FUNCTIONDECLARATION: {\n            this.initializeFunction(<FunctionDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.INTERFACEDECLARATION: {\n            this.initializeInterface(<InterfaceDeclaration>statement, file, queuedExtends);\n            break;\n          }\n          case NodeKind.NAMESPACEDECLARATION: {\n            this.initializeNamespace(<NamespaceDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.TYPEDECLARATION: {\n            this.initializeTypeDefinition(<TypeDeclaration>statement, file);\n            break;\n          }\n        }\n      }\n    }\n\n    // queued exports * should be linkable now that all files have been processed\n    // TODO: for (let [file, starExports] of queuedExportsStar) {\n    for (let _keys = Map_keys(queuedExportsStar), i = 0, k = _keys.length; i < k; ++i) {\n      let file = _keys[i];\n      let starExports = assert(queuedExportsStar.get(file));\n      for (let j = 0, l = starExports.length; j < l; ++j) {\n        let exportStar = unchecked(starExports[j]);\n        let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);\n        if (!foreignFile) {\n          this.error(\n            DiagnosticCode.File_0_not_found,\n            exportStar.pathLiteral.range, exportStar.pathLiteral.value\n          );\n          continue;\n        }\n        file.ensureExportStar(foreignFile);\n      }\n    }\n\n    // queued imports should be resolvable now through traversing exports and queued exports.\n    // note that imports may depend upon imports, so repeat until there's no more progress.\n    do {\n      let i = 0, madeProgress = false;\n      while (i < queuedImports.length) {\n        let queuedImport = queuedImports[i];\n        let localIdentifier = queuedImport.localIdentifier;\n        let foreignIdentifier = queuedImport.foreignIdentifier;\n        // File must be found here, as it would otherwise already have been reported by the parser\n        let foreignFile = assert(this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt));\n        if (foreignIdentifier) { // i.e. import { foo [as bar] } from \"./baz\"\n          let element = this.lookupForeign(\n            foreignIdentifier.text,\n            foreignFile,\n            queuedExports\n          );\n          if (element) {\n            queuedImport.localFile.add(\n              localIdentifier.text,\n              element,\n              localIdentifier // isImport\n            );\n            queuedImports.splice(i, 1);\n            madeProgress = true;\n          } else {\n            ++i;\n          }\n        } else { // i.e. import * as bar from \"./bar\"\n          let localFile = queuedImport.localFile;\n          let localName = localIdentifier.text;\n          localFile.add(\n            localName,\n            foreignFile.asAliasNamespace(\n              localName,\n              localFile,\n              localIdentifier\n            ),\n            localIdentifier // isImport\n          );\n          queuedImports.splice(i, 1);\n          madeProgress = true;\n        }\n      }\n      if (!madeProgress) {\n        // report queued imports we were unable to resolve\n        for (let j = 0, l = queuedImports.length; j < l; ++j) {\n          let queuedImport = queuedImports[j];\n          let foreignIdentifier = queuedImport.foreignIdentifier;\n          if (foreignIdentifier) {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text\n            );\n          }\n        }\n        break;\n      }\n    } while (true);\n\n    // queued exports should be resolvable now that imports are finalized\n    // TODO: for (let [file, exports] of queuedExports) {\n    for (let _keys = Map_keys(queuedExports), i = 0, k = _keys.length; i < k; ++i) {\n      let file = unchecked(_keys[i]);\n      let exports = assert(queuedExports.get(file));\n      // TODO: for (let [exportName, queuedExport] of exports) {\n      for (let exportNames = Map_keys(exports), j = 0, l = exportNames.length; j < l; ++j) {\n        let exportName = unchecked(exportNames[j]);\n        let queuedExport = assert(exports.get(exportName));\n        let localName = queuedExport.localIdentifier.text;\n        let foreignPath = queuedExport.foreignPath;\n        if (foreignPath) { // i.e. export { foo [as bar] } from \"./baz\"\n          // File must be found here, as it would otherwise already have been reported by the parser\n          let foreignFile = assert(this.lookupForeignFile(foreignPath, assert(queuedExport.foreignPathAlt)));\n          let element = this.lookupForeign(localName, foreignFile, queuedExports);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              queuedExport.localIdentifier.range,\n              foreignPath, localName\n            );\n          }\n        } else { // i.e. export { foo [as bar] }\n          let element = file.getMember(localName);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            let globalElement = this.lookup(localName);\n            if (globalElement !== null && isDeclaredElement(globalElement.kind)) { // export { memory }\n              file.ensureExport(exportName, <DeclaredElement>globalElement);\n            } else {\n              this.error(\n                DiagnosticCode.Module_0_has_no_exported_member_1,\n                queuedExport.foreignIdentifier.range,\n                file.internalName, queuedExport.foreignIdentifier.text\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // register ArrayBuffer (id=0), String (id=1), ArrayBufferView (id=2)\n    assert(this.arrayBufferInstance.id == 0);\n    assert(this.stringInstance.id == 1);\n    assert(this.arrayBufferViewInstance.id == 2);\n\n    // register classes backing basic types\n    this.registerWrapperClass(Type.i8, CommonNames.I8);\n    this.registerWrapperClass(Type.i16, CommonNames.I16);\n    this.registerWrapperClass(Type.i32, CommonNames.I32);\n    this.registerWrapperClass(Type.i64, CommonNames.I64);\n    this.registerWrapperClass(options.isizeType, CommonNames.Isize);\n    this.registerWrapperClass(Type.u8, CommonNames.U8);\n    this.registerWrapperClass(Type.u16, CommonNames.U16);\n    this.registerWrapperClass(Type.u32, CommonNames.U32);\n    this.registerWrapperClass(Type.u64, CommonNames.U64);\n    this.registerWrapperClass(options.usizeType, CommonNames.Usize);\n    this.registerWrapperClass(Type.bool, CommonNames.Bool);\n    this.registerWrapperClass(Type.f32, CommonNames.F32);\n    this.registerWrapperClass(Type.f64, CommonNames.F64);\n    if (options.hasFeature(Feature.SIMD)) this.registerWrapperClass(Type.v128, CommonNames.V128);\n    if (options.hasFeature(Feature.REFERENCE_TYPES)) {\n      this.registerWrapperClass(Type.funcref, CommonNames.Funcref);\n      this.registerWrapperClass(Type.externref, CommonNames.Externref);\n      if (options.hasFeature(Feature.GC)) {\n        this.registerWrapperClass(Type.anyref, CommonNames.Anyref);\n        this.registerWrapperClass(Type.eqref, CommonNames.Eqref);\n        this.registerWrapperClass(Type.i31ref, CommonNames.I31ref);\n        this.registerWrapperClass(Type.dataref, CommonNames.Dataref);\n      }\n    }\n\n    // resolve prototypes of extended classes or interfaces\n    var resolver = this.resolver;\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends\n      let baseElement = resolver.resolveTypeName(extendsNode.name, thisPrototype.parent);\n      if (!baseElement) continue;\n      if (thisPrototype.kind == ElementKind.CLASS_PROTOTYPE) {\n        if (baseElement.kind == ElementKind.CLASS_PROTOTYPE) {\n          let basePrototype = <ClassPrototype>baseElement;\n          if (basePrototype.hasDecorator(DecoratorFlags.FINAL)) {\n            this.error(\n              DiagnosticCode.Class_0_is_final_and_cannot_be_extended,\n              extendsNode.range, basePrototype.identifierNode.text\n            );\n          }\n          if (\n            basePrototype.hasDecorator(DecoratorFlags.UNMANAGED) !=\n            thisPrototype.hasDecorator(DecoratorFlags.UNMANAGED)\n          ) {\n            this.error(\n              DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,\n              Range.join(thisPrototype.identifierNode.range, extendsNode.range)\n            );\n          }\n          thisPrototype.basePrototype = basePrototype;\n        } else {\n          this.error(\n            DiagnosticCode.A_class_may_only_extend_another_class,\n            extendsNode.range\n          );\n        }\n      } else if (thisPrototype.kind == ElementKind.INTERFACE_PROTOTYPE) {\n        if (baseElement.kind == ElementKind.INTERFACE_PROTOTYPE) {\n          thisPrototype.basePrototype = <InterfacePrototype>baseElement;\n        } else {\n          this.error(\n            DiagnosticCode.An_interface_can_only_extend_an_interface,\n            extendsNode.range\n          );\n        }\n      }\n    }\n\n    // resolve prototypes of implemented interfaces\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let implementsNodes = assert(thisPrototype.implementsNodes); // must be present if in queuedImplements\n      for (let j = 0, l = implementsNodes.length; j < l; ++j) {\n        let implementsNode = implementsNodes[j];\n        let interfaceElement = resolver.resolveTypeName(implementsNode.name, thisPrototype.parent);\n        if (!interfaceElement) continue;\n        if (interfaceElement.kind == ElementKind.INTERFACE_PROTOTYPE) {\n          let interfacePrototype = <InterfacePrototype>interfaceElement;\n          let interfacePrototypes = thisPrototype.interfacePrototypes;\n          if (!interfacePrototypes) thisPrototype.interfacePrototypes = interfacePrototypes = new Array();\n          interfacePrototypes.push(interfacePrototype);\n        } else {\n          this.error(\n            DiagnosticCode.A_class_can_only_implement_an_interface,\n            implementsNode.range\n          );\n        }\n      }\n    }\n\n    // check for virtual overloads in extended classes and implemented interfaces\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let basePrototype = thisPrototype.basePrototype;\n      if (basePrototype) {\n        this.markVirtuals(thisPrototype, basePrototype);\n      }\n    }\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let basePrototype = thisPrototype.basePrototype;\n      let interfacePrototypes = thisPrototype.interfacePrototypes;\n      if (basePrototype) {\n        this.markVirtuals(thisPrototype, basePrototype);\n      }\n      if (interfacePrototypes) {\n        for (let j = 0, l = interfacePrototypes.length; j < l; ++j) {\n          this.markVirtuals(thisPrototype, interfacePrototypes[j]);\n        }\n      }\n    }\n\n    // set up global aliases\n    {\n      let globalAliases = options.globalAliases;\n      if (!globalAliases) globalAliases = new Map();\n      let isWasi = this.isWasi;\n      if (!globalAliases.has(CommonNames.abort)) {\n        globalAliases.set(CommonNames.abort,\n          isWasi\n            ? BuiltinNames.wasiAbort\n            : BuiltinNames.abort\n        );\n      }\n      if (!globalAliases.has(CommonNames.trace)) {\n        globalAliases.set(CommonNames.trace,\n          isWasi\n            ? BuiltinNames.wasiTrace\n            : BuiltinNames.trace\n        );\n      }\n      if (!globalAliases.has(CommonNames.seed)) {\n        globalAliases.set(CommonNames.seed,\n          isWasi\n            ? BuiltinNames.wasiSeed\n            : BuiltinNames.seed\n        );\n      }\n      if (!globalAliases.has(CommonNames.Math)) {\n        globalAliases.set(CommonNames.Math, CommonNames.NativeMath);\n      }\n      if (!globalAliases.has(CommonNames.Mathf)) {\n        globalAliases.set(CommonNames.Mathf, CommonNames.NativeMathf);\n      }\n      // TODO: for (let [alias, name] of globalAliases) {\n      for (let _keys = Map_keys(globalAliases), i = 0, k = _keys.length; i < k; ++i) {\n        let alias = unchecked(_keys[i]);\n        let name = changetype<string>(globalAliases.get(alias));\n        assert(name != null);\n        if (!name.length) {\n          this.elementsByName.delete(alias);\n          continue;\n        }\n        let firstChar = name.charCodeAt(0);\n        if (firstChar >= CharCode._0 && firstChar <= CharCode._9) {\n          this.registerConstantInteger(alias, Type.i32, i64_new(<i32>parseInt(name, 10)));\n        } else {\n          let elementsByName = this.elementsByName;\n          if (elementsByName.has(name)) {\n            elementsByName.set(alias, assert(elementsByName.get(name)));\n          } else {\n            throw new Error(\"no such global element: \" + name);\n          }\n        }\n      }\n    }\n\n    // mark module exports, i.e. to apply proper wrapping behavior on the boundaries\n    // TODO: for (let file of this.filesByName.values()) {\n    for (let _values = Map_values(this.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) {\n        this.markModuleExports(file);\n      }\n    }\n  }\n\n  /** Marks virtual members in a base class overloaded in this class. */\n  private markVirtuals(thisPrototype: ClassPrototype, basePrototype: ClassPrototype): void {\n    // TODO: make this work with interfaaces as well\n    var thisInstanceMembers = thisPrototype.instanceMembers;\n    if (thisInstanceMembers) {\n      do {\n        let baseInstanceMembers = basePrototype.instanceMembers;\n        if (baseInstanceMembers) {\n          for (let _values = Map_values(thisInstanceMembers), j = 0, l = _values.length; j < l; ++j) {\n            let thisMember = _values[j];\n            if (\n              !thisMember.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.PRIVATE) &&\n              baseInstanceMembers.has(thisMember.name)\n            ) {\n              let baseMember = assert(baseInstanceMembers.get(thisMember.name));\n              if (\n                thisMember.kind == ElementKind.FUNCTION_PROTOTYPE &&\n                baseMember.kind == ElementKind.FUNCTION_PROTOTYPE\n              ) {\n                let thisMethod = <FunctionPrototype>thisMember;\n                let baseMethod = <FunctionPrototype>baseMember;\n                if (!thisMethod.visibilityEquals(baseMethod)) {\n                  this.errorRelated(\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n                    thisMethod.identifierNode.range, baseMethod.identifierNode.range\n                  );\n                }\n                baseMember.set(CommonFlags.VIRTUAL);\n                let overloads = baseMethod.overloads;\n                if (!overloads) baseMethod.overloads = overloads = new Set();\n                overloads.add(<FunctionPrototype>thisMember);\n                let baseMethodInstances = baseMethod.instances;\n                if (baseMethodInstances) {\n                  for (let _values = Map_values(baseMethodInstances), a = 0, b = _values.length; a < b; ++a) {\n                    let baseMethodInstance = _values[a];\n                    baseMethodInstance.set(CommonFlags.VIRTUAL);\n                  }\n                }\n              } else if (\n                thisMember.kind == ElementKind.PROPERTY_PROTOTYPE &&\n                baseMember.kind == ElementKind.PROPERTY_PROTOTYPE\n              ) {\n                let thisProperty = <PropertyPrototype>thisMember;\n                let baseProperty = <PropertyPrototype>baseMember;\n                if (!thisProperty.visibilityEquals(baseProperty)) {\n                  this.errorRelated(\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n                    thisProperty.identifierNode.range, baseProperty.identifierNode.range\n                  );\n                }\n                baseProperty.set(CommonFlags.VIRTUAL);\n                let baseGetter = baseProperty.getterPrototype;\n                if (baseGetter) {\n                  baseGetter.set(CommonFlags.VIRTUAL);\n                  let thisGetter = thisProperty.getterPrototype;\n                  if (thisGetter) {\n                    let overloads = baseGetter.overloads;\n                    if (!overloads) baseGetter.overloads = overloads = new Set();\n                    overloads.add(thisGetter);\n                  }\n                  let baseGetterInstances = baseGetter.instances;\n                  if (baseGetterInstances) {\n                    for (let _values = Map_values(baseGetterInstances), a = 0, b = _values.length; a < b; ++a) {\n                      let baseGetterInstance = _values[a];\n                      baseGetterInstance.set(CommonFlags.VIRTUAL);\n                    }\n                  }\n                }\n                let baseSetter = baseProperty.setterPrototype;\n                if (baseSetter !== null && thisProperty.setterPrototype !== null) {\n                  baseSetter.set(CommonFlags.VIRTUAL);\n                  let thisSetter = thisProperty.setterPrototype;\n                  if (thisSetter) {\n                    let overloads = baseSetter.overloads;\n                    if (!overloads) baseSetter.overloads = overloads = new Set();\n                    overloads.add(thisSetter);\n                  }\n                  let baseSetterInstances = baseSetter.instances;\n                  if (baseSetterInstances) {\n                    for (let _values = Map_values(baseSetterInstances), a = 0, b = _values.length; a < b; ++a) {\n                      let baseSetterInstance = _values[a];\n                      baseSetterInstance.set(CommonFlags.VIRTUAL);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        let nextPrototype = basePrototype.basePrototype;\n        if (!nextPrototype) break;\n        basePrototype = nextPrototype;\n      } while (true);\n    }\n  }\n\n  /** Looks up the element of the specified name in the global scope. */\n  lookup(name: string): Element | null {\n    var elements = this.elementsByName;\n    if (elements.has(name)) return assert(elements.get(name));\n    return null;\n  }\n\n  /** Requires that a global library element of the specified kind is present and returns it. */\n  private require(name: string, kind: ElementKind): Element {\n    var element = this.lookup(name);\n    if (!element) throw new Error(\"Missing standard library component: \" + name);\n    if (element.kind != kind) throw Error(\"Invalid standard library component kind: \" + name);\n    return element;\n  }\n\n  /** Requires that a global variable is present and returns it. */\n  requireGlobal(name: string): Global {\n    return <Global>this.require(name, ElementKind.GLOBAL);\n  }\n\n  /** Requires that a non-generic global class is present and returns it. */\n  requireClass(name: string): Class {\n    var prototype = this.require(name, ElementKind.CLASS_PROTOTYPE);\n    var resolved = this.resolver.resolveClass(<ClassPrototype>prototype, null);\n    if (!resolved) throw new Error(\"Invalid standard library class: \" + name);\n    return resolved;\n  }\n\n  /** Requires that a global function is present and returns it. */\n  requireFunction(name: string, typeArguments: Type[] | null = null): Function {\n    var prototype = <FunctionPrototype>this.require(name, ElementKind.FUNCTION_PROTOTYPE);\n    var resolved = this.resolver.resolveFunction(prototype, typeArguments);\n    if (!resolved) throw new Error(\"Invalid standard library function: \" + name);\n    return resolved;\n  }\n\n  /** Marks all exports of the specified file as module exports. */\n  private markModuleExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), j = 0, l = _values.length; j < l; ++j) {\n        let element = unchecked(_values[j]);\n        this.markModuleExport(element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.markModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Marks an element and its children as a module export. */\n  private markModuleExport(element: Element): void {\n    element.set(CommonFlags.MODULE_EXPORT);\n    switch (element.kind) {\n      case ElementKind.CLASS_PROTOTYPE: {\n        let instanceMembers = (<ClassPrototype>element).instanceMembers;\n        if (instanceMembers) {\n          // TODO: for (let member of instanceMembers.values()) {\n          for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n            let member = unchecked(_values[i]);\n            this.markModuleExport(member);\n          }\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>element;\n        let getterPrototype = propertyPrototype.getterPrototype;\n        if (getterPrototype) this.markModuleExport(getterPrototype);\n        let setterPrototype = propertyPrototype.setterPrototype;\n        if (setterPrototype) this.markModuleExport(setterPrototype);\n        break;\n      }\n      case ElementKind.PROPERTY:\n      case ElementKind.FUNCTION:\n      case ElementKind.FIELD:\n      case ElementKind.CLASS: assert(false); // assumes that there are no instances yet\n    }\n    var staticMembers = element.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.markModuleExport(member);\n      }\n    }\n  }\n\n  /** Registers a native type with the program. */\n  private registerNativeType(name: string, type: Type): void {\n    var element = new TypeDefinition(\n      name,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(name, CommonFlags.EXPORT),\n      DecoratorFlags.BUILTIN\n    );\n    element.setType(type);\n    this.nativeFile.add(name, element);\n  }\n\n  /** Registers the wrapper class of a non-class type. */\n  private registerWrapperClass(type: Type, className: string): void {\n    var wrapperClasses = this.wrapperClasses;\n    assert(!type.isInternalReference && !wrapperClasses.has(type));\n    var element = assert(this.lookup(className));\n    assert(element.kind == ElementKind.CLASS_PROTOTYPE);\n    var classElement = assert(this.resolver.resolveClass(<ClassPrototype>element, null));\n    classElement.wrappedType = type;\n    wrapperClasses.set(type, classElement);\n  }\n\n  /** Registers a constant integer value within the global scope. */\n  registerConstantInteger(name: string, type: Type, value: i64): void {\n    assert(type.isIntegerInclReference);\n    var global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.NONE,\n      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)\n    );\n    global.setConstantIntegerValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Registers a constant float value within the global scope. */\n  private registerConstantFloat(name: string, type: Type, value: f64): void {\n    assert(type.isFloatValue);\n    var global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.NONE,\n      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)\n    );\n    global.setConstantFloatValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Ensures that the given global element exists. Attempts to merge duplicates. */\n  ensureGlobal(name: string, element: DeclaredElement): DeclaredElement {\n    var elementsByName = this.elementsByName;\n    if (elementsByName.has(name)) {\n      let existing = assert(elementsByName.get(name));\n      // NOTE: this is effectively only performed when merging native types with\n      // their respective namespaces in std/builtins, but can also trigger when a\n      // user has multiple global elements of the same name in different files,\n      // which might result in unexpected shared symbols accross files. considering\n      // this a wonky feature for now that we might want to revisit later.\n      if (existing !== element) {\n        let merged = tryMerge(existing, element);\n        if (!merged) {\n          if (isDeclaredElement(existing.kind)) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range,\n              (<DeclaredElement>existing).declaration.name.range,\n              name\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range, name\n            );\n          }\n          return element;\n        }\n        element = merged;\n      }\n    }\n    elementsByName.set(name, element);\n    return element;\n  }\n\n  /** Tries to locate a foreign file given its normalized path. */\n  private lookupForeignFile(\n    /** Normalized path to the other file. */\n    foreignPath: string,\n    /** Alternative normalized path to the other file. */\n    foreignPathAlt: string\n  ): File | null {\n    var filesByName = this.filesByName;\n    return filesByName.has(foreignPath)\n      ? assert(filesByName.get(foreignPath))\n      : filesByName.has(foreignPathAlt)\n        ? assert(filesByName.get(foreignPathAlt))\n        : null;\n  }\n\n  /** Tries to locate a foreign element by traversing exports and queued exports. */\n  private lookupForeign(\n    /** Identifier within the other file. */\n    foreignName: string,\n    /** The other file. */\n    foreignFile: File,\n    /** So far queued exports. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): DeclaredElement | null {\n    do {\n      // check if already resolved\n      let element = foreignFile.lookupExport(foreignName);\n      if (element) return element;\n\n      // follow queued exports\n      if (queuedExports.has(foreignFile)) {\n        let fileQueuedExports = assert(queuedExports.get(foreignFile));\n        if (fileQueuedExports.has(foreignName)) {\n          let queuedExport = assert(fileQueuedExports.get(foreignName));\n          let queuedExportForeignPath = queuedExport.foreignPath;\n\n          // re-exported from another file\n          if (queuedExportForeignPath) {\n            let otherFile = this.lookupForeignFile(queuedExportForeignPath, assert(queuedExport.foreignPathAlt));\n            if (!otherFile) return null;\n            foreignName = queuedExport.localIdentifier.text;\n            foreignFile = otherFile;\n            continue;\n          }\n\n          // exported from this file\n          element = foreignFile.getMember(queuedExport.localIdentifier.text);\n          if (element) return element;\n        }\n      }\n      break;\n    } while (true);\n\n    // follow star exports\n    var exportsStar = foreignFile.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = this.lookupForeign(foreignName, exportsStar[i], queuedExports);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Validates that only supported decorators are present. */\n  private checkDecorators(\n    /** Decorators present on an element. */\n    decorators: DecoratorNode[] | null,\n    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */\n    acceptedFlags: DecoratorFlags\n  ): DecoratorFlags {\n    var flags = DecoratorFlags.NONE;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator = decorators[i];\n        let kind = DecoratorKind.fromNode(decorator.name);\n        let flag = DecoratorFlags.fromKind(kind);\n        if (flag) {\n          if (flag == DecoratorFlags.BUILTIN) {\n            if (!(acceptedFlags & flag) && !decorator.range.source.isLibrary) {\n              this.error(\n                DiagnosticCode.Decorator_0_is_not_valid_here,\n                decorator.range, decorator.name.range.toString()\n              );\n            } else {\n              flags |= flag;\n            }\n          } else if (!(acceptedFlags & flag)) {\n            this.error(\n              DiagnosticCode.Decorator_0_is_not_valid_here,\n              decorator.range, decorator.name.range.toString()\n            );\n          } else if (flags & flag) {\n            this.error(\n              DiagnosticCode.Duplicate_decorator,\n              decorator.range\n            );\n          } else {\n            flags |= flag;\n          }\n        }\n      }\n    }\n    return flags;\n  }\n\n  /** Initializes a class declaration. */\n  private initializeClass(\n    /** The declaration to initialize. */\n    declaration: ClassDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): ClassPrototype | null {\n    var name = declaration.name.text;\n    var element = new ClassPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL |\n        DecoratorFlags.FINAL |\n        DecoratorFlags.UNMANAGED\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember classes that implement interfaces\n    var implementsTypes = declaration.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        // cannot implement interfaces when unmanaged\n        if (element.hasDecorator(DecoratorFlags.UNMANAGED)) {\n          this.error(\n            DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,\n            Range.join(\n              declaration.name.range,\n              implementsTypes[numImplementsTypes - 1].range\n            )\n          );\n        } else {\n          queuedImplements.push(element);\n        }\n      }\n    }\n\n    // remember classes that extend another class\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    // initialize members\n    var memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FIELDDECLARATION: {\n          this.initializeField(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.METHODDECLARATION: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            let method = this.initializeMethod(methodDeclaration, element);\n            if (method !== null && methodDeclaration.name.kind == NodeKind.CONSTRUCTOR) {\n              element.constructorPrototype = method;\n            }\n          }\n          break;\n        }\n        case NodeKind.INDEXSIGNATURE: break; // ignored for now\n        default: assert(false); // class member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of a class or interface. */\n  private initializeField(\n    /** The declaration to initialize. */\n    declaration: FieldDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    var name = declaration.name.text;\n    var decorators = declaration.decorators;\n    var element: DeclaredElement;\n    var acceptedFlags: DecoratorFlags = DecoratorFlags.UNSAFE;\n    if (parent.is(CommonFlags.AMBIENT)) {\n      acceptedFlags |= DecoratorFlags.EXTERNAL;\n    }\n    if (declaration.is(CommonFlags.STATIC)) { // global variable\n      assert(parent.kind != ElementKind.INTERFACE_PROTOTYPE);\n      acceptedFlags |= DecoratorFlags.LAZY;\n      if (declaration.is(CommonFlags.READONLY)) {\n        acceptedFlags |= DecoratorFlags.INLINE;\n      }\n      element = new Global(\n        name,\n        parent,\n        this.checkDecorators(decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) return;\n    } else { // actual instance field\n      assert(!declaration.isAny(CommonFlags.ABSTRACT | CommonFlags.GET | CommonFlags.SET));\n      element = new FieldPrototype(\n        name,\n        parent,\n        declaration,\n        this.checkDecorators(decorators, acceptedFlags)\n      );\n      if (!parent.addInstance(name, element)) return;\n    }\n  }\n\n  /** Initializes a method of a class or interface. */\n  private initializeMethod(\n    /** The declaration to initialize. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): FunctionPrototype | null {\n    var name = declaration.name.text;\n    var isStatic = declaration.is(CommonFlags.STATIC);\n    var acceptedFlags = DecoratorFlags.INLINE | DecoratorFlags.UNSAFE;\n    if (!declaration.is(CommonFlags.GENERIC)) {\n      acceptedFlags |= DecoratorFlags.OPERATOR_BINARY\n                    |  DecoratorFlags.OPERATOR_PREFIX\n                    |  DecoratorFlags.OPERATOR_POSTFIX;\n    }\n    if (parent.is(CommonFlags.AMBIENT)) {\n      acceptedFlags |= DecoratorFlags.EXTERNAL;\n    }\n    var element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, acceptedFlags)\n    );\n    if (isStatic) { // global function\n      assert(declaration.name.kind != NodeKind.CONSTRUCTOR);\n      if (!parent.add(name, element)) return null;\n    } else { // actual instance method\n      if (!parent.addInstance(name, element)) return null;\n    }\n    this.checkOperatorOverloads(declaration.decorators, element, parent);\n    return element;\n  }\n\n  /** Checks that operator overloads are generally valid, if present. */\n  private checkOperatorOverloads(\n    /** Decorators to check. */\n    decorators: DecoratorNode[] | null,\n    /** Decorated method. */\n    prototype: FunctionPrototype,\n    /** Parent class. */\n    classPrototype: ClassPrototype\n  ): void {\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator: DecoratorNode = decorators[i]; // FIXME: why does tsc want a type here?\n        switch (decorator.decoratorKind) {\n          case DecoratorKind.OPERATOR:\n          case DecoratorKind.OPERATOR_BINARY:\n          case DecoratorKind.OPERATOR_PREFIX:\n          case DecoratorKind.OPERATOR_POSTFIX: {\n            let args = decorator.args;\n            let numArgs = args ? args.length : 0;\n            if (numArgs == 1) {\n              let firstArg = (<Expression[]>decorator.args)[0];\n              if (firstArg.isLiteralKind(LiteralKind.STRING)) {\n                let text = (<StringLiteralExpression>firstArg).value;\n                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);\n                if (kind == OperatorKind.INVALID) {\n                  this.error(\n                    DiagnosticCode._0_is_not_a_valid_operator,\n                    firstArg.range, text\n                  );\n                } else {\n                  let overloads = classPrototype.overloadPrototypes;\n                  if (overloads.has(kind)) {\n                    this.error(\n                      DiagnosticCode.Duplicate_function_implementation,\n                      firstArg.range\n                    );\n                  } else {\n                    prototype.operatorKind = kind;\n                    overloads.set(kind, prototype);\n                  }\n                }\n              } else {\n                this.error(\n                  DiagnosticCode.String_literal_expected,\n                  firstArg.range\n                );\n              }\n            } else {\n              this.error(\n                DiagnosticCode.Expected_0_arguments_but_got_1,\n                decorator.range, \"1\", numArgs.toString()\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /** Ensures that the property introduced by the specified getter or setter exists.*/\n  private ensureProperty(\n    /** The declaration of the getter or setter introducing the property. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): PropertyPrototype | null {\n    var name = declaration.name.text;\n    if (declaration.is(CommonFlags.STATIC)) {\n      let parentMembers = parent.members;\n      if (parentMembers !== null && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.add(name, element)) return null;\n        return element;\n      }\n    } else {\n      let parentMembers = parent.instanceMembers;\n      if (parentMembers !== null && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.addInstance(name, element)) return null;\n        return element;\n      }\n    }\n    this.error(\n      DiagnosticCode.Duplicate_property_0,\n      declaration.name.range, name\n    );\n    return null;\n  }\n\n  /** Initializes a property of a class. */\n  private initializeProperty(\n    /** The declaration of the getter or setter. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    var property = this.ensureProperty(declaration, parent);\n    if (!property) return;\n    var name = declaration.name.text;\n    var isGetter = declaration.is(CommonFlags.GET);\n    if (isGetter) {\n      if (property.getterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    } else {\n      if (property.setterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    }\n    var element = new FunctionPrototype(\n      (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + name,\n      property,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.INLINE | DecoratorFlags.UNSAFE\n      )\n    );\n    if (isGetter) {\n      property.getterPrototype = element;\n    } else {\n      property.setterPrototype = element;\n    }\n  }\n\n  /** Initializes an enum. */\n  private initializeEnum(\n    /** The declaration to initialize. */\n    declaration: EnumDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): Enum | null {\n    var name = declaration.name.text;\n    var element = new Enum(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL |\n        DecoratorFlags.INLINE |\n        DecoratorFlags.LAZY\n      )\n    );\n    if (!parent.add(name, element)) return null;\n    var values = declaration.values;\n    for (let i = 0, k = values.length; i < k; ++i) {\n      this.initializeEnumValue(values[i], element);\n    }\n    return element;\n  }\n\n  /** Initializes an enum value. */\n  private initializeEnumValue(\n    /** The declaration to initialize. */\n    declaration: EnumValueDeclaration,\n    /** Parent enum. */\n    parent: Enum\n  ): void {\n    var name = declaration.name.text;\n    var element = new EnumValue(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.NONE\n      )\n    );\n    if (!parent.add(name, element)) return;\n  }\n\n  /** Initializes an `export` statement. */\n  private initializeExports(\n    /** The statement to initialize. */\n    statement: ExportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>,\n    /** So far queued `export *`s. */\n    queuedExportsStar: Map<File,QueuedExportStar[]>\n  ): void {\n    var members = statement.members;\n    if (members) { // export { foo, bar } [from \"./baz\"]\n      for (let i = 0, k = members.length; i < k; ++i) {\n        this.initializeExport(members[i], parent, statement.internalPath, queuedExports);\n      }\n    } else { // export * from \"./baz\"\n      let queued: QueuedExportStar[];\n      if (queuedExportsStar.has(parent)) queued = assert(queuedExportsStar.get(parent));\n      else queuedExportsStar.set(parent, queued = []);\n      let foreignPath = statement.internalPath!; // must be set for export *\n      queued.push(new QueuedExportStar(\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX,\n        assert(statement.path)\n      ));\n    }\n  }\n\n  /** Initializes a single `export` member. Does not handle `export *`. */\n  private initializeExport(\n    /** The member to initialize. */\n    member: ExportMember,\n    /** Local file. */\n    localFile: File,\n    /** Path to the other file, if present. */\n    foreignPath: string | null,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var localName = member.localName.text;\n    var foreignName = member.exportedName.text;\n\n    // check for duplicates\n    var element = localFile.lookupExport(foreignName);\n    if (element) {\n      this.error(\n        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\n        member.exportedName.range, foreignName\n      );\n      return;\n    }\n    // local element, i.e. export { foo [as bar] }\n    if (foreignPath === null) {\n\n      // resolve right away if the local element already exists\n      if (element = localFile.getMember(localName)) {\n        localFile.ensureExport(foreignName, element);\n\n      // otherwise queue it\n      } else {\n        let queued: Map<string,QueuedExport>;\n        if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n        else queuedExports.set(localFile, queued = new Map());\n        queued.set(foreignName, new QueuedExport(\n          member.localName,\n          member.exportedName,\n          null, null\n        ));\n      }\n\n    // foreign element, i.e. export { foo } from \"./bar\"\n    } else {\n      let queued: Map<string,QueuedExport>;\n      if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n      else queuedExports.set(localFile, queued = new Map());\n      queued.set(foreignName, new QueuedExport(\n        member.localName,\n        member.exportedName,\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX\n      ));\n    }\n  }\n\n  private initializeExportDefault(\n    /** The statement to initialize. */\n    statement: ExportDefaultStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `extends` clauses. */\n    queuedExtends: Array<ClassPrototype>,\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): void {\n    var declaration = statement.declaration;\n    var element: DeclaredElement | null = null;\n    switch (declaration.kind) {\n      case NodeKind.ENUMDECLARATION: {\n        element = this.initializeEnum(<EnumDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        element = this.initializeFunction(<FunctionDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.CLASSDECLARATION: {\n        element = this.initializeClass(<ClassDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        element = this.initializeInterface(<InterfaceDeclaration>declaration, parent, queuedExtends);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        element = this.initializeNamespace(<NamespaceDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      default: assert(false);\n    }\n    if (element) {\n      let exports = parent.exports;\n      if (!exports) parent.exports = exports = new Map();\n      else {\n        if (exports.has(\"default\")) {\n          let existing = assert(exports.get(\"default\"));\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existing.declaration.name.range,\n            \"default\"\n          );\n          return;\n        }\n      }\n      exports.set(\"default\", element);\n    }\n  }\n\n  /** Initializes an `import` statement. */\n  private initializeImports(\n    /** The statement to initialize. */\n    statement: ImportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var declarations = statement.declarations;\n    if (declarations) { // import { foo [as bar] } from \"./baz\"\n      for (let i = 0, k = declarations.length; i < k; ++i) {\n        this.initializeImport(\n          declarations[i],\n          parent,\n          statement.internalPath,\n          queuedImports,\n          queuedExports\n        );\n      }\n    } else {\n      let namespaceName = statement.namespaceName;\n      if (namespaceName) { // import * as foo from \"./bar\"\n        queuedImports.push(new QueuedImport(\n          parent,\n          namespaceName,\n          null, // indicates import *\n          statement.internalPath,\n          statement.internalPath + INDEX_SUFFIX\n        ));\n      } else {\n        // import \"./foo\"\n      }\n    }\n  }\n\n  /** Initializes a single `import` declaration. Does not handle `import *`. */\n  private initializeImport( // { foo [as bar] }\n    /** The declaration to initialize. */\n    declaration: ImportDeclaration,\n    /** Parent file. */\n    parent: File,\n    /** Path to the other file. */\n    foreignPath: string,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var foreignPathAlt = foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n      ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n      : foreignPath + INDEX_SUFFIX;\n\n    // resolve right away if the element exists\n    var foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);\n    if (foreignFile) {\n      var element = this.lookupForeign(declaration.foreignName.text, foreignFile, queuedExports);\n      if (element) {\n        parent.add(declaration.name.text, element, declaration.name /* isImport */);\n        return;\n      }\n    }\n\n    // otherwise queue it\n    queuedImports.push(new QueuedImport(\n      parent,\n      declaration.name,\n      declaration.foreignName,\n      foreignPath,\n      foreignPathAlt\n    ));\n  }\n\n  /** Initializes a function. Does not handle methods. */\n  private initializeFunction(\n    /** The declaration to initialize. */\n    declaration: FunctionDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): FunctionPrototype | null {\n    var name = declaration.name.text;\n    var validDecorators = DecoratorFlags.UNSAFE | DecoratorFlags.BUILTIN;\n    if (declaration.is(CommonFlags.AMBIENT)) {\n      validDecorators |= DecoratorFlags.EXTERNAL;\n    } else {\n      validDecorators |= DecoratorFlags.INLINE;\n      if (declaration.range.source.isLibrary || declaration.is(CommonFlags.EXPORT)) {\n        validDecorators |= DecoratorFlags.LAZY;\n      }\n    }\n    if (!declaration.is(CommonFlags.INSTANCE)) {\n      if (parent.kind != ElementKind.CLASS_PROTOTYPE) {\n        validDecorators |= DecoratorFlags.GLOBAL;\n      }\n    }\n    var element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, validDecorators)\n    );\n    if (!parent.add(name, element)) return null;\n    return element;\n  }\n\n  /** Initializes an interface. */\n  private initializeInterface(\n    /** The declaration to initialize. */\n    declaration: InterfaceDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n  ): InterfacePrototype | null {\n    var name = declaration.name.text;\n    var element = new InterfacePrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember interfaces that extend another interface\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    var memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FIELDDECLARATION: {\n          this.initializeFieldAsProperty(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.METHODDECLARATION: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            this.initializeMethod(methodDeclaration, element);\n          }\n          break;\n        }\n        default: assert(false); // interface member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of an interface, as a property. */\n  private initializeFieldAsProperty(\n    /** Field declaration. */\n    declaration: FieldDeclaration,\n    /** Parent interface. */\n    parent: InterfacePrototype\n  ): void {\n    var typeNode = declaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(declaration.name.range.atEnd);\n    this.initializeProperty(\n      Node.createMethodDeclaration(\n        declaration.name,\n        declaration.decorators,\n        declaration.flags | CommonFlags.GET,\n        null,\n        Node.createFunctionType(\n          [],\n          typeNode,\n          null,\n          false,\n          declaration.range\n        ),\n        null,\n        declaration.range\n      ),\n      parent\n    );\n    if (!declaration.is(CommonFlags.READONLY)) {\n      this.initializeProperty(\n        Node.createMethodDeclaration(\n          declaration.name,\n          declaration.decorators,\n          declaration.flags | CommonFlags.SET,\n          null,\n          Node.createFunctionType(\n            [\n              Node.createParameter(\n                ParameterKind.DEFAULT,\n                declaration.name,\n                typeNode,\n                null,\n                declaration.name.range\n              )\n            ],\n            Node.createOmittedType(declaration.name.range.atEnd),\n            null,\n            false,\n            declaration.range\n          ),\n          null,\n          declaration.range\n        ),\n        parent\n      );\n    }\n  }\n\n  /** Initializes a namespace. */\n  private initializeNamespace(\n    /** The declaration to initialize. */\n    declaration: NamespaceDeclaration,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): DeclaredElement | null {\n    var name = declaration.name.text;\n    var original = new Namespace(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.GLOBAL)\n    );\n    if (!parent.add(name, original)) return null;\n    var element = assert(parent.getMember(name)); // possibly merged\n    var members = declaration.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      let member = members[i];\n      switch (member.kind) {\n        case NodeKind.CLASSDECLARATION: {\n          this.initializeClass(<ClassDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.ENUMDECLARATION: {\n          this.initializeEnum(<EnumDeclaration>member, original);\n          break;\n        }\n        case NodeKind.FUNCTIONDECLARATION: {\n          this.initializeFunction(<FunctionDeclaration>member, original);\n          break;\n        }\n        case NodeKind.INTERFACEDECLARATION: {\n          this.initializeInterface(<InterfaceDeclaration>member, original, queuedExtends);\n          break;\n        }\n        case NodeKind.NAMESPACEDECLARATION: {\n          this.initializeNamespace(<NamespaceDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.TYPEDECLARATION: {\n          this.initializeTypeDefinition(<TypeDeclaration>member, original);\n          break;\n        }\n        case NodeKind.VARIABLE: {\n          this.initializeVariables(<VariableStatement>member, original);\n          break;\n        }\n        default: assert(false); // namespace member expected\n      }\n    }\n    if (original != element) copyMembers(original, element); // keep original parent\n    return element;\n  }\n\n  /** Initializes a `type` definition. */\n  private initializeTypeDefinition(\n    /** The declaration to initialize. */\n    declaration: TypeDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    var name = declaration.name.text;\n    var element = new TypeDefinition(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.NONE)\n    );\n    parent.add(name, element); // reports\n  }\n\n  /** Initializes a variable statement. */\n  private initializeVariables(\n    /** The statement to initialize. */\n    statement: VariableStatement,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    var declarations = statement.declarations;\n    for (let i = 0, k = declarations.length; i < k; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let acceptedFlags = DecoratorFlags.GLOBAL | DecoratorFlags.LAZY;\n      if (declaration.is(CommonFlags.DECLARE)) {\n        acceptedFlags |= DecoratorFlags.EXTERNAL;\n      }\n      if (declaration.is(CommonFlags.CONST)) {\n        acceptedFlags |= DecoratorFlags.INLINE;\n      }\n      let element = new Global(\n        name,\n        parent,\n        this.checkDecorators(declaration.decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) continue; // reports\n    }\n  }\n\n  /** Determines the element type of a built-in array. */\n  // determineBuiltinArrayType(target: Class): Type | null {\n  //   switch (target.internalName) {\n  //     case BuiltinSymbols.Int8Array: return Type.i8;\n  //     case BuiltinSymbols.Uint8ClampedArray:\n  //     case BuiltinSymbols.Uint8Array: return Type.u8;\n  //     case BuiltinSymbols.Int16Array: return Type.i16;\n  //     case BuiltinSymbols.Uint16Array: return Type.u16;\n  //     case BuiltinSymbols.Int32Array: return Type.i32;\n  //     case BuiltinSymbols.Uint32Array: return Type.u32;\n  //     case BuiltinSymbols.Int64Array: return Type.i64;\n  //     case BuiltinSymbols.Uint64Array: return Type.u64;\n  //     case BuiltinSymbols.Float32Array: return Type.f32;\n  //     case BuiltinSymbols.Float64Array: return Type.f64;\n  //   }\n  //   var current: Class | null = target;\n  //   var arrayPrototype = this.arrayPrototype;\n  //   do {\n  //     if (current.prototype == arrayPrototype) { // Array<T>\n  //       let typeArguments = assert(current.typeArguments);\n  //       assert(typeArguments.length == 1);\n  //       return typeArguments[0];\n  //     }\n  //   } while (current = current.base);\n  //   return null;\n  // }\n}\n\n/** Indicates the specific kind of an {@link Element}. */\nexport enum ElementKind {\n  /** A {@link Global}. */\n  GLOBAL,\n  /** A {@link Local}. */\n  LOCAL,\n  /** An {@link Enum}. */\n  ENUM,\n  /** An {@link EnumValue}. */\n  ENUMVALUE,\n  /** A {@link FunctionPrototype}. */\n  FUNCTION_PROTOTYPE,\n  /** A {@link Function}. */\n  FUNCTION,\n  /** A {@link ClassPrototype}. */\n  CLASS_PROTOTYPE,\n  /** A {@link Class}. */\n  CLASS,\n  /** An {@link InterfacePrototype}. */\n  INTERFACE_PROTOTYPE,\n  /** An {@link Interface}. */\n  INTERFACE,\n  /** A {@link FieldPrototype}. */\n  FIELD_PROTOTYPE,\n  /** A {@link Field}. */\n  FIELD,\n  /** A {@link PropertyPrototype}.  */\n  PROPERTY_PROTOTYPE,\n  /** A {@link Property}. */\n  PROPERTY,\n  /** A {@link Namespace}. */\n  NAMESPACE,\n  /** A {@link File}. */\n  FILE,\n  /** A {@link TypeDefinition}.  */\n  TYPEDEFINITION,\n  /** An {@link IndexSignature}. */\n  INDEXSIGNATURE\n}\n\n/** Indicates built-in decorators that are present. */\nexport enum DecoratorFlags {\n  /** No flags set. */\n  NONE = 0,\n  /** Is a program global. */\n  GLOBAL = 1 << 0,\n  /** Is a binary operator overload. */\n  OPERATOR_BINARY = 1 << 1,\n  /** Is a unary prefix operator overload. */\n  OPERATOR_PREFIX = 1 << 2,\n  /** Is a unary postfix operator overload. */\n  OPERATOR_POSTFIX = 1 << 3,\n  /** Is an unmanaged class. */\n  UNMANAGED = 1 << 4,\n  /** Is a final class. */\n  FINAL = 1 << 5,\n  /** Is always inlined. */\n  INLINE = 1 << 6,\n  /** Is using a different external name. */\n  EXTERNAL = 1 << 7,\n  /** Is a builtin. */\n  BUILTIN = 1 << 8,\n  /** Is compiled lazily. */\n  LAZY = 1 << 9,\n  /** Is considered unsafe code. */\n  UNSAFE = 1 << 10\n}\n\nexport namespace DecoratorFlags {\n\n  /** Translates a decorator kind to the respective decorator flag. */\n  export function fromKind(kind: DecoratorKind): DecoratorFlags {\n    switch (kind) {\n      case DecoratorKind.GLOBAL: return DecoratorFlags.GLOBAL;\n      case DecoratorKind.OPERATOR:\n      case DecoratorKind.OPERATOR_BINARY: return DecoratorFlags.OPERATOR_BINARY;\n      case DecoratorKind.OPERATOR_PREFIX: return DecoratorFlags.OPERATOR_PREFIX;\n      case DecoratorKind.OPERATOR_POSTFIX: return DecoratorFlags.OPERATOR_POSTFIX;\n      case DecoratorKind.UNMANAGED: return DecoratorFlags.UNMANAGED;\n      case DecoratorKind.FINAL: return DecoratorFlags.FINAL;\n      case DecoratorKind.INLINE: return DecoratorFlags.INLINE;\n      case DecoratorKind.EXTERNAL: return DecoratorFlags.EXTERNAL;\n      case DecoratorKind.BUILTIN: return DecoratorFlags.BUILTIN;\n      case DecoratorKind.LAZY: return DecoratorFlags.LAZY;\n      case DecoratorKind.UNSAFE: return DecoratorFlags.UNSAFE;\n      default: return DecoratorFlags.NONE;\n    }\n  }\n}\n\n/** Base class of all program elements. */\nexport abstract class Element {\n\n  /** Parent element. */\n  parent!: Element;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.NONE;\n  /** Decorator flags indicating annotated traits. */\n  decoratorFlags: DecoratorFlags = DecoratorFlags.NONE;\n  /** Member elements. */\n  members: Map<string,DeclaredElement> | null = null;\n  /** Shadowing type in type space, if any. */\n  shadowType: TypeDefinition | null = null;\n\n  /** Constructs a new program element. */\n  protected constructor(\n    /** Specific element kind. */\n    public kind: ElementKind,\n    /** Simple name. */\n    public name: string,\n    /** Internal name referring to this element. */\n    public internalName: string,\n    /** Containing {@link Program}. */\n    public program: Program,\n    /** Parent element. */\n    parent: Element | null\n  ) {\n    this.program = program;\n    this.name = name;\n    this.internalName = internalName;\n    if (parent) {\n      this.parent = parent;\n    } else {\n      assert(this.kind == ElementKind.FILE);\n      this.parent = this; // special case to keep this.parent non-nullable\n    }\n  }\n\n  /** Gets the enclosing file. */\n  get file(): File {\n    var current: Element = this;\n    do {\n      current = current.parent;\n      if (current.kind == ElementKind.FILE) return <File>current;\n    } while (true);\n  }\n\n  /** Tests if this element has a specific flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this element has any of the specified flags. */\n  isAny(flags: CommonFlags): bool { return (this.flags & flags) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n  /** Unsets the specific flag or flags. */\n  unset(flag: CommonFlags): void {this.flags &= ~flag; }\n  /** Tests if this element has a specific decorator flag or flags. */\n  hasDecorator(flag: DecoratorFlags): bool { return (this.decoratorFlags & flag) == flag; }\n\n  /** Get the member with the specified name, if any. */\n  getMember(name: string): DeclaredElement | null {\n    var members = this.members;\n    if (members && members.has(name)) return assert(members.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to this element. */\n  lookup(name: string, isType: bool = false): Element | null {\n    return this.parent.lookup(name, isType);\n  }\n\n  /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    var originalDeclaration = element.declaration;\n    var members = this.members;\n    if (!members) this.members = members = new Map();\n    else if (members.has(name)) {\n      let existing = assert(members.get(name));\n      if (existing.parent !== this) {\n        // override non-own element\n      } else {\n        let merged = tryMerge(existing, element);\n        if (merged) {\n          element = merged; // use merged element\n        } else {\n          let reportedIdentifier = localIdentifierIfImport\n            ? localIdentifierIfImport\n            : element.identifierNode;\n          if (isDeclaredElement(existing.kind)) {\n            this.program.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range,\n              (<DeclaredElement>existing).identifierNode.range,\n              reportedIdentifier.text\n            );\n          } else {\n            this.program.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range, reportedIdentifier.text\n            );\n          }\n          return false;\n        }\n      }\n    }\n    members.set(name, element);\n    var program = this.program;\n    if (element.kind != ElementKind.FUNCTION_PROTOTYPE || !(<FunctionPrototype>element).isBound) {\n      // prefer unbound prototypes in global lookup maps\n      program.elementsByName.set(element.internalName, element);\n      program.elementsByDeclaration.set(originalDeclaration, element);\n    }\n    return true;\n  }\n\n  /** Checks if this element is public, explicitly or implicitly. */\n  get isPublic(): bool {\n    return !this.isAny(CommonFlags.PRIVATE | CommonFlags.PROTECTED);\n  }\n\n  /** Checks if this element is implicitly public, i.e. not explicitly declared to be. */\n  get isImplicitlyPublic(): bool {\n    return this.isPublic && !this.is(CommonFlags.PUBLIC);\n  }\n\n  /** Checks if the visibility of this element equals the specified. */\n  visibilityEquals(other: Element): bool {\n    if (this.isPublic == other.isPublic) return true;\n    const vis = CommonFlags.PRIVATE | CommonFlags.PROTECTED;\n    return (this.flags & vis) == (other.flags & vis);\n  }\n\n  /** Returns a string representation of this element. */\n  toString(): string {\n    return this.internalName + \", kind=\" + this.kind.toString();\n  }\n}\n\n// Kinds of all declared elements\nvar declaredElements = new Set<ElementKind>();\n\n/** Tests if the specified element kind indicates a declared element. */\nexport function isDeclaredElement(kind: ElementKind): bool {\n  return declaredElements.has(kind);\n}\n\n/** Base class of elements with an associated declaration statement. */\nexport abstract class DeclaredElement extends Element {\n\n  /** Constructs a new declared program element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    public declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent);\n    declaredElements.add(kind);\n    // It is necessary to have access to identifiers of all members and exports\n    // for reporting purposes and this is the lowest common denominator. Comes\n    // at the expense of not having more specific type information in derived\n    // classes, though. Instead, derived classes implement getters for other\n    // important AST nodes directly through manual casting, allowing the resolver\n    // etc. to not worry about actual declarations.\n    this.declaration = declaration;\n    this.flags = declaration.flags; // inherit\n  }\n\n  /** Tests if this element is a library element. */\n  get isDeclaredInLibrary(): bool {\n    return this.declaration.range.source.isLibrary;\n  }\n\n  /** Gets the associated identifier node. */\n  get identifierNode(): IdentifierExpression {\n    return this.declaration.name;\n  }\n\n  /** Gets the signature node, if applicable, along the identifier node. */\n  get identifierAndSignatureRange(): Range {\n    var declaration = this.declaration;\n    var identifierNode = declaration.name;\n    if (declaration.kind == NodeKind.FUNCTIONDECLARATION || declaration.kind == NodeKind.METHODDECLARATION) {\n      let signatureNode = (<FunctionDeclaration>declaration).signature;\n      return Range.join(identifierNode.range, signatureNode.range);\n    }\n    return identifierNode.range;\n  }\n\n  /** Gets the assiciated decorator nodes. */\n  get decoratorNodes(): DecoratorNode[] | null {\n    return this.declaration.decorators;\n  }\n\n  /** Checks if this element is a compatible override of the specified. */\n  isCompatibleOverride(base: DeclaredElement): bool {\n    var self: DeclaredElement = this; // TS\n    var kind = self.kind;\n    if (kind == base.kind) {\n      switch (kind) {\n        case ElementKind.FUNCTION: {\n          return (<Function>self).signature.isAssignableTo((<Function>base).signature, /* sameSize */ true);\n        }\n        case ElementKind.PROPERTY: {\n          let selfProperty = <Property>self;\n          let baseProperty = <Property>base;\n          let selfGetter = selfProperty.getterInstance;\n          let baseGetter = baseProperty.getterInstance;\n          if (selfGetter) {\n            if (!baseGetter || !selfGetter.signature.isAssignableTo(baseGetter.signature, true)) {\n              return false;\n            }\n          } else if (baseGetter) {\n            return false;\n          }\n          let selfSetter = selfProperty.setterInstance;\n          let baseSetter = baseProperty.setterInstance;\n          if (selfSetter) {\n            if (!baseSetter || !selfSetter.signature.isAssignableTo(baseSetter.signature, true)) {\n              return false;\n            }\n          } else if (baseSetter) {\n            return false;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n// Kinds of all typed elements\nvar typedElements = new Set<ElementKind>();\n\n/** Checks if the specified element kind indicates a typed element. */\nexport function isTypedElement(kind: ElementKind): bool {\n  return typedElements.has(kind);\n}\n\n/** Base class of elements that can be resolved to a concrete type. */\nexport abstract class TypedElement extends DeclaredElement {\n\n  /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */\n  type: Type = Type.void;\n\n  constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent, declaration);\n    typedElements.add(kind);\n  }\n\n  /** Sets the resolved type of this element. */\n  setType(type: Type): void {\n    assert(!this.is(CommonFlags.RESOLVED));\n    this.type = type;\n    this.set(CommonFlags.RESOLVED);\n  }\n}\n\n/** A file representing the implicit top-level namespace of a source. */\nexport class File extends Element {\n\n  /** File exports. */\n  exports: Map<string,DeclaredElement> | null = null;\n  /** File re-exports. */\n  exportsStar: File[] | null = null;\n  /** Top-level start function of this file. */\n  startFunction!: Function;\n  /** Array of `import * as X` alias namespaces of this file. */\n  aliasNamespaces: Array<Namespace> = new Array<Namespace>();\n\n  /** Constructs a new file. */\n  constructor(\n    /** Program this file belongs to. */\n    program: Program,\n    /** Source of this file. */\n    public source: Source\n  ) {\n    super(\n      ElementKind.FILE,\n      source.normalizedPath,\n      source.internalPath,\n      program,\n      null // special case for files\n    );\n    this.source = source;\n    assert(!program.filesByName.has(this.internalName));\n    program.filesByName.set(this.internalName, this);\n    var startFunction = this.program.makeNativeFunction(\n      \"start:\" + this.internalName,\n      new Signature(program, null, Type.void),\n      this\n    );\n    startFunction.internalName = startFunction.name;\n    this.startFunction = startFunction;\n  }\n\n  /* @override */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    if (element.hasDecorator(DecoratorFlags.GLOBAL)) {\n      element = this.program.ensureGlobal(name, element); // possibly merged globally\n    }\n    if (!super.add(name, element, localIdentifierIfImport)) return false;\n    element = assert(this.getMember(name)); // possibly merged locally\n    if (element.is(CommonFlags.EXPORT) && !localIdentifierIfImport) {\n      this.ensureExport(\n        element.name,\n        element\n      );\n    }\n    return true;\n  }\n\n  /* @override */\n  getMember(name: string): DeclaredElement | null {\n    var element = super.getMember(name);\n    if (element) return element;\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        if (element = exportsStar[i].getMember(name)) return element;\n      }\n    }\n    return null;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    var element = this.getMember(name);\n    if (element) return element;\n    return this.program.lookup(name); // has no meaningful parent\n  }\n\n  /** Ensures that an element is an export of this file. */\n  ensureExport(name: string, element: DeclaredElement): void {\n    var exports = this.exports;\n    if (!exports) this.exports = exports = new Map();\n    exports.set(name, element);\n    if (this.source.sourceKind == SourceKind.LIBRARY_ENTRY) this.program.ensureGlobal(name, element);\n\n    // Also, add to the namespaces that capture our exports\n    for(let i = 0; i < this.aliasNamespaces.length; i++) {\n      let ns = this.aliasNamespaces[i];\n      ns.add(name, element);\n    }\n  }\n\n  /** Ensures that another file is a re-export of this file. */\n  ensureExportStar(file: File): void {\n    var exportsStar = this.exportsStar;\n    if (!exportsStar) this.exportsStar = exportsStar = [];\n    else if (exportsStar.includes(file)) return;\n    exportsStar.push(file);\n  }\n\n  /** Looks up the export of the specified name. */\n  lookupExport(name: string): DeclaredElement | null {\n    var exports = this.exports;\n    if (exports !== null && exports.has(name)) return assert(exports.get(name));\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = exportsStar[i].lookupExport(name);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Creates an imported namespace from this file. */\n  asAliasNamespace(\n    name: string,\n    parent: Element,\n    localIdentifier: IdentifierExpression\n  ): Namespace {\n    var declaration = this.program.makeNativeNamespaceDeclaration(name);\n    declaration.name = localIdentifier;\n    var ns = new Namespace(name, parent, declaration);\n    ns.set(CommonFlags.SCOPED);\n    this.copyExportsToNamespace(ns);\n    // NOTE: Some exports are still queued, and can't yet be added here,\n    // so we remember all the alias namespaces and add to them as well\n    // when adding an element to the file.\n    this.aliasNamespaces.push(ns);\n    return ns;\n  }\n\n  /** Recursively copies the exports of this file to the specified namespace. */\n  private copyExportsToNamespace(ns: Namespace): void {\n    var exports = this.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        ns.add(memberName, member);\n      }\n    }\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        exportsStar[i].copyExportsToNamespace(ns);\n      }\n    }\n  }\n}\n\n/** A type definition. */\nexport class TypeDefinition extends TypedElement {\n\n  /** Constructs a new type definition. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: TypeDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.TYPEDEFINITION,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<TypeDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode {\n    return (<TypeDeclaration>this.declaration).type;\n  }\n}\n\n/** A namespace that differs from a file in being user-declared with a name. */\nexport class Namespace extends DeclaredElement {\n\n  /** Constructs a new namespace. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: NamespaceDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.NAMESPACE,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    var member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** An enum. */\nexport class Enum extends TypedElement {\n\n  /** Constructs a new enum. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: EnumDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.ENUM,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    var member = this.getMember(name);\n    if (member) return member;\n    return super.lookup(name, isType);\n  }\n}\n\n/** Indicates the kind of an inlined constant value. */\nexport const enum ConstantValueKind {\n  /** No constant value. */\n  NONE,\n  /** Constant integer value. */\n  INTEGER,\n  /** Constant float value. */\n  FLOAT\n}\n\n/** Base class of all variable-like program elements. */\nexport abstract class VariableLikeElement extends TypedElement {\n\n  /** Constant value kind. */\n  constantValueKind: ConstantValueKind = ConstantValueKind.NONE;\n  /** Constant integer value, if applicable. */\n  constantIntegerValue: i64 = i64_zero;\n  /** Constant float value, if applicable. */\n  constantFloatValue: f64 = 0;\n\n  /** Constructs a new variable-like element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or class. */\n    parent: Element,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      kind,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.flags = declaration.flags;\n  }\n\n  /** Gets the associated type node.s */\n  get typeNode(): TypeNode | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).initializer;\n  }\n\n  /** Applies a constant integer value to this element. */\n  setConstantIntegerValue(value: i64, type: Type): void {\n    assert(type.isIntegerInclReference);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.INTEGER;\n    this.constantIntegerValue = value;\n    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);\n  }\n\n  /** Applies a constant float value to this element. */\n  setConstantFloatValue(value: f64, type: Type): void {\n    assert(type.isFloatValue);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.FLOAT;\n    this.constantFloatValue = value;\n    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);\n  }\n}\n\n/** An enum value. */\nexport class EnumValue extends VariableLikeElement {\n\n  /** Constructs a new enum value. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent enum. */\n    parent: Enum,\n    /** Declaration reference. */\n    declaration: EnumValueDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.ENUMVALUE,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /** Whether this enum value is immutable. */\n  isImmutable: bool = false;\n\n  /** Gets the associated value node. */\n  get valueNode(): Expression | null {\n    return (<EnumValueDeclaration>this.declaration).initializer;\n  }\n}\n\n/** A global variable. */\nexport class Global extends VariableLikeElement {\n\n  /** Constructs a new global variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or static class. */\n    parent: Element,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.GLOBAL,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n}\n\n/** A function parameter. */\nexport class Parameter {\n  /** Constructs a new function parameter. */\n  constructor(\n    /** Parameter name. */\n    public name: string,\n    /** Parameter type. */\n    public type: Type,\n    /** Parameter initializer, if present. */\n    public initializer: Expression | null = null\n  ) {}\n}\n\n/** A local variable. */\nexport class Local extends VariableLikeElement {\n\n  /** Original name of the (temporary) local. */\n  private originalName: string;\n\n  /** Constructs a new local variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Zero-based index within the enclosing function. `-1` indicates a virtual local. */\n    public index: i32,\n    /** Resolved type. */\n    type: Type,\n    /** Parent function. */\n    parent: Function,\n    /** Declaration reference. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.LOCAL,\n      name,\n      parent,\n      declaration\n    );\n    this.originalName = name;\n    this.index = index;\n    assert(type != Type.void);\n    this.setType(type);\n  }\n\n  /** Sets the temporary name of this local. */\n  setTemporaryName(name: string): void {\n    this.name = name;\n    this.internalName = mangleInternalName(name, this.parent, false);\n  }\n\n  /** Resets the temporary name of this local. */\n  resetTemporaryName(): void {\n    var name = this.originalName;\n    this.name = name;\n    this.internalName = mangleInternalName(name, this.parent, false);\n  }\n}\n\n/** A yet unresolved function prototype. */\nexport class FunctionPrototype extends DeclaredElement {\n\n  /** Operator kind, if an overload. */\n  operatorKind: OperatorKind = OperatorKind.INVALID;\n  /** Already resolved instances. */\n  instances: Map<string,Function> | null = null;\n  /** Methods overloading this one, if any. These are unbound. */\n  overloads: Set<FunctionPrototype> | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,FunctionPrototype> | null = null;\n\n  /** Constructs a new function prototype. */\n  constructor(\n    /** Simple name */\n    name: string,\n    /** Parent element, usually a file, namespace or class (if a method). */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: FunctionDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.FUNCTION_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<FunctionDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated function type node. */\n  get functionTypeNode(): FunctionTypeNode {\n    return (<FunctionDeclaration>this.declaration).signature;\n  }\n\n  /** Gets the associated body node. */\n  get bodyNode(): Statement | null {\n    return (<FunctionDeclaration>this.declaration).body;\n  }\n\n  /** Gets the arrow function kind. */\n  get arrowKind(): ArrowKind {\n    return (<FunctionDeclaration>this.declaration).arrowKind;\n  }\n\n  /** Tests if this prototype is bound to a class. */\n  get isBound(): bool {\n    var parent = this.parent;\n    var parentKind = parent.kind;\n    if (parentKind == ElementKind.PROPERTY_PROTOTYPE) parentKind = parent.parent.kind;\n    return parentKind == ElementKind.CLASS || parentKind == ElementKind.INTERFACE;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): FunctionPrototype {\n    assert(this.is(CommonFlags.INSTANCE));\n    assert(!this.isBound);\n    var boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    var declaration = this.declaration;\n    assert(declaration.kind == NodeKind.METHODDECLARATION);\n    var bound = new FunctionPrototype(\n      this.name,\n      classInstance, // !\n      <MethodDeclaration>declaration,\n      this.decoratorFlags\n    );\n    bound.flags = this.flags;\n    bound.operatorKind = this.operatorKind;\n    bound.overloads = this.overloads;\n    // NOTE: this.instances holds instances per bound class / unbound\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Function | null {\n    var instances = this.instances;\n    if (instances !== null && instances.has(instanceKey)) return assert(instances.get(instanceKey));\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Function): void {\n    var instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved function. */\nexport class Function extends TypedElement {\n\n  /** Function prototype. */\n  prototype: FunctionPrototype;\n  /** Function signature. */\n  signature: Signature;\n  /** Map of locals by name. */\n  localsByName: Map<string,Local> = new Map();\n  /** Array of locals by index. */\n  localsByIndex: Local[] = [];\n  /** List of additional non-parameter locals. */\n  additionalLocals: Type[] = [];\n  /** Concrete type arguments. */\n  typeArguments: Type[] | null;\n  /** Contextual type arguments. */\n  contextualTypeArguments: Map<string,Type> | null;\n  /** Default control flow. */\n  flow!: Flow;\n  /** Remembered debug locations. */\n  debugLocations: Range[] = [];\n  /** Function reference, if compiled. */\n  ref: FunctionRef = 0;\n  /** Varargs stub for calling with omitted arguments. */\n  varargsStub: Function | null = null;\n  /** Virtual stub for calling overloads. */\n  virtualStub: Function | null = null;\n  /** Runtime memory segment, if created. */\n  memorySegment: MemorySegment | null = null;\n  /** Original function, if a stub. Otherwise `this`. */\n  original!: Function;\n\n  /** Counting id of inline operations involving this function. */\n  nextInlineId: i32 = 0;\n  /** Counting id of anonymous inner functions. */\n  nextAnonymousId: i32 = 0;\n\n  /** Constructs a new concrete function. */\n  constructor(\n    /** Name incl. type parameters, i.e. `foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** Respective function prototype. */\n    prototype: FunctionPrototype,\n    /** Concrete type arguments. */\n    typeArguments: Type[] | null,\n    /** Concrete signature. */\n    signature: Signature, // pre-resolved\n    /** Contextual type arguments inherited from its parent class, if any. */\n    contextualTypeArguments: Map<string,Type> | null = null\n  ) {\n    super(\n      ElementKind.FUNCTION,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.typeArguments = typeArguments;\n    this.signature = signature;\n    this.flags = prototype.flags | CommonFlags.RESOLVED;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.contextualTypeArguments = contextualTypeArguments;\n    this.original = this;\n    var program = prototype.program;\n    this.type = signature.type;\n    if (!prototype.is(CommonFlags.AMBIENT)) {\n      let localIndex = 0;\n      let thisType = signature.thisType;\n      if (thisType) {\n        let local = new Local(\n          CommonNames.this_,\n          localIndex++,\n          thisType,\n          this\n        );\n        this.localsByName.set(CommonNames.this_, local);\n        this.localsByIndex[local.index] = local;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let parameterType = parameterTypes[i];\n        let parameterName = this.getParameterName(i);\n        let local = new Local(\n          parameterName,\n          localIndex++,\n          parameterType,\n          this\n        );\n        this.localsByName.set(parameterName, local);\n        this.localsByIndex[local.index] = local;\n      }\n    }\n    this.flow = Flow.createParent(this);\n    registerConcreteElement(program, this);\n  }\n\n  /** Gets the name of the parameter at the specified index. */\n  getParameterName(index: i32): string {\n    var parameters = (<FunctionDeclaration>this.declaration).signature.parameters;\n    return parameters.length > index\n      ? parameters[index].name.text\n      : getDefaultParameterName(index);\n  }\n\n  /** Gets the class or interface this function belongs to, if an instance method. */\n  getClassOrInterface(): Class | null {\n    var parent = this.parent;\n    if (parent.kind == ElementKind.PROPERTY) parent = parent.parent;\n    if (parent.kind == ElementKind.CLASS || parent.kind == ElementKind.INTERFACE) {\n      return <Class>parent;\n    }\n    return null;\n  }\n\n  /** Creates a stub for use with this function, i.e. for varargs or virtual calls. */\n  newStub(postfix: string): Function {\n    var stub = new Function(\n      this.original.name + STUB_DELIMITER + postfix,\n      this.prototype,\n      this.typeArguments,\n      this.signature.clone(),\n      this.contextualTypeArguments\n    );\n    stub.original = this.original;\n    stub.set(this.flags & ~CommonFlags.COMPILED | CommonFlags.STUB);\n    return stub;\n  }\n\n  /** Adds a local of the specified type, with an optional name. */\n  addLocal(type: Type, name: string | null = null, declaration: VariableDeclaration | null = null): Local {\n    // if it has a name, check previously as this method will throw otherwise\n    var localIndex = this.signature.parameterTypes.length + this.additionalLocals.length;\n    if (this.is(CommonFlags.INSTANCE)) ++localIndex;\n    var localName = name !== null\n      ? name\n      : \"var$\" + localIndex.toString();\n    if (!declaration) declaration = this.program.makeNativeVariableDeclaration(localName);\n    var local = new Local(\n      localName,\n      localIndex,\n      type,\n      this,\n      declaration\n    );\n    if (name) {\n      if (this.localsByName.has(name)) throw new Error(\"duplicate local name\");\n      this.localsByName.set(name, local);\n    }\n    this.localsByIndex[local.index] = local;\n    this.additionalLocals.push(type);\n    return local;\n  }\n\n  /* @override */\n  lookup(name: string, isType: bool = false): Element | null {\n    if (!isType) {\n      let locals = this.localsByName;\n      if (locals.has(name)) return assert(locals.get(name));\n    }\n    return super.lookup(name, isType);\n  }\n\n  // used by flows to keep track of temporary locals\n  tempI32s: Local[] | null = null;\n  tempI64s: Local[] | null = null;\n  tempF32s: Local[] | null = null;\n  tempF64s: Local[] | null = null;\n  tempV128s: Local[] | null = null;\n  tempFuncrefs: Local[] | null = null;\n  tempExternrefs: Local[] | null = null;\n  tempAnyrefs: Local[] | null = null;\n  tempEqrefs: Local[] | null = null;\n  tempI31refs: Local[] | null = null;\n  tempDatarefs: Local[] | null = null;\n\n  // used by flows to keep track of break labels\n  nextBreakId: i32 = 0;\n  breakStack: i32[] | null = null;\n  breakLabel: string | null = null;\n\n  /** Finalizes the function once compiled, releasing no longer needed resources. */\n  finalize(module: Module, ref: FunctionRef): void {\n    this.ref = ref;\n    var breakStack = this.breakStack;\n    assert(!breakStack || !breakStack.length); // internal error\n    this.breakStack = breakStack = null;\n    this.breakLabel = null;\n    this.tempI32s = this.tempI64s = this.tempF32s = this.tempF64s = null;\n    if (this.program.options.sourceMap) {\n      let debugLocations = this.debugLocations;\n      for (let i = 0, k = debugLocations.length; i < k; ++i) {\n        let range = debugLocations[i];\n        let source = range.source;\n        module.setDebugLocation(\n          ref,\n          range.debugInfoRef,\n          source.debugInfoIndex,\n          source.lineAt(range.start),\n          source.columnAt() - 1 // source maps are 0-based\n        );\n      }\n    }\n  }\n}\n\n/** A yet unresolved instance field prototype. */\nexport class FieldPrototype extends DeclaredElement {\n\n  /** Constructs a new field prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent class. */\n    parent: ClassPrototype,\n    /** Declaration reference. */\n    declaration: FieldDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.FIELD_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, assert(declaration.is(CommonFlags.INSTANCE))),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode | null {\n    return (<FieldDeclaration>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<FieldDeclaration>this.declaration).initializer;\n  }\n\n  /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */\n  get parameterIndex(): i32 {\n    return (<FieldDeclaration>this.declaration).parameterIndex;\n  }\n}\n\n/** A resolved instance field. */\nexport class Field extends VariableLikeElement {\n\n  /** Field prototype reference. */\n  prototype: FieldPrototype;\n  /** Field memory offset, if an instance field. */\n  memoryOffset: i32 = -1;\n  /** Getter function reference, if compiled. */\n  getterRef: FunctionRef = 0;\n  /** Setter function reference, if compiled. */\n  setterRef: FunctionRef = 0;\n\n  /** Constructs a new field. */\n  constructor(\n    /** Respective field prototype. */\n    prototype: FieldPrototype,\n    /** Parent class. */\n    parent: Class,\n    /** Concrete type. */\n    type: Type\n  ) {\n    super(\n      ElementKind.FIELD,\n      prototype.name,\n      parent,\n      <VariableLikeDeclarationStatement>prototype.declaration\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    assert(type != Type.void);\n    this.setType(type);\n    registerConcreteElement(this.program, this);\n  }\n\n  /** Gets the field's `this` type. */\n  get thisType(): Type {\n    var parent = this.parent;\n    assert(parent.kind == ElementKind.CLASS);\n    return (<Class>parent).type;\n  }\n\n  /** Gets the internal name of the respective getter function. */\n  get internalGetterName(): string {\n    var cached = this._internalGetterName;\n    if (cached === null) this._internalGetterName = cached = this.parent.internalName + INSTANCE_DELIMITER + GETTER_PREFIX + this.name;\n    return cached;\n  }\n  private _internalGetterName: string | null = null;\n\n  /** Gets the internal name of the respective setter function. */\n  get internalSetterName(): string {\n    var cached = this._internalSetterName;\n    if (cached === null) this._internalSetterName = cached = this.parent.internalName + INSTANCE_DELIMITER + SETTER_PREFIX + this.name;\n    return cached;\n  }\n  private _internalSetterName: string | null = null;\n\n  /** Gets the signature of the respective getter function. */\n  get internalGetterSignature(): Signature {\n    var cached = this._internalGetterSignature;\n    if (!cached) this._internalGetterSignature = cached = new Signature(this.program, null, this.type, this.thisType);\n    return cached;\n  }\n  private _internalGetterSignature: Signature | null = null;\n\n  /** Gets the signature of the respective setter function. */\n  get internalSetterSignature(): Signature {\n    var cached = this._internalSetterSignature;\n    if (!cached) this._internalGetterSignature = cached = new Signature(this.program, [ this.type ], Type.void, this.thisType);\n    return cached;\n  }\n  private _internalSetterSignature: Signature | null = null;\n}\n\n/** A property comprised of a getter and a setter function. */\nexport class PropertyPrototype extends DeclaredElement {\n\n  /** Getter prototype. */\n  getterPrototype: FunctionPrototype | null = null;\n  /** Setter prototype. */\n  setterPrototype: FunctionPrototype | null = null;\n  /** Property instance, if resolved. */\n  instance: Property | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,PropertyPrototype> | null = null;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Either a class prototype or instance. */\n    parent: Element,\n    /** Declaration of the getter or setter introducing the property. */\n    firstDeclaration: FunctionDeclaration\n  ) {\n    super(\n      ElementKind.PROPERTY_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, firstDeclaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      firstDeclaration\n    );\n    this.flags &= ~(CommonFlags.GET | CommonFlags.SET);\n  }\n\n  /** Tests if this prototype is bound to a class. */\n  get isBound(): bool {\n    switch (this.parent.kind) {\n      case ElementKind.CLASS:\n      case ElementKind.INTERFACE: return true;\n    }\n    return false;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): PropertyPrototype {\n    assert(this.is(CommonFlags.INSTANCE));\n    assert(!this.isBound);\n    var boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    var firstDeclaration = this.declaration;\n    assert(firstDeclaration.kind == NodeKind.METHODDECLARATION);\n    var bound = new PropertyPrototype(\n      this.name,\n      classInstance, // !\n      <MethodDeclaration>firstDeclaration\n    );\n    bound.flags = this.flags;\n    var getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      bound.getterPrototype = getterPrototype.toBound(classInstance);\n    }\n    var setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      bound.setterPrototype = setterPrototype.toBound(classInstance);\n    }\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n}\n\n/** A resolved property. */\nexport class Property extends VariableLikeElement {\n\n  /** Prototype reference. */\n  prototype: PropertyPrototype;\n  /** Getter instance. */\n  getterInstance: Function | null = null;\n  /** Setter instance. */\n  setterInstance: Function | null = null;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Respective property prototype. */\n    prototype: PropertyPrototype,\n    /** Parent element, usually a static class prototype or class instance. */\n    parent: Element\n  ) {\n    super(\n      ElementKind.PROPERTY,\n      prototype.name,\n      parent,\n      Node.createVariableDeclaration(\n        prototype.identifierNode,\n        null,\n        prototype.is(CommonFlags.INSTANCE)\n          ? CommonFlags.INSTANCE\n          : CommonFlags.NONE,\n        null, null,\n        prototype.identifierNode.range\n      )\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    if (this.is(CommonFlags.INSTANCE)) {\n      registerConcreteElement(this.program, this);\n    }\n  }\n}\n\n/** A resolved index signature. */\nexport class IndexSignature extends TypedElement {\n\n  /** Constructs a new index prototype. */\n  constructor(\n    /** Parent class. */\n    parent: Class\n  ) {\n    super(\n      ElementKind.INDEXSIGNATURE,\n      \"[]\",\n      parent.internalName + \"[]\",\n      parent.program,\n      parent,\n      parent.program.makeNativeVariableDeclaration(\"[]\") // is fine\n    );\n  }\n\n  /** Obtains the getter instance. */\n  getGetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n  }\n\n  /** Obtains the setter instance. */\n  getSetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n  }\n}\n\n/** A yet unresolved class prototype. */\nexport class ClassPrototype extends DeclaredElement {\n\n  /** Instance member prototypes. */\n  instanceMembers: Map<string,DeclaredElement> | null = null;\n  /** Base class prototype, if applicable. */\n  basePrototype: ClassPrototype | null = null;\n  /** Interface prototypes, if applicable. */\n  interfacePrototypes: InterfacePrototype[] | null = null;\n  /** Constructor prototype. */\n  constructorPrototype: FunctionPrototype | null = null;\n  /** Operator overload prototypes. */\n  overloadPrototypes: Map<OperatorKind, FunctionPrototype> = new Map();\n  /** Already resolved instances. */\n  instances: Map<string,Class> | null = null;\n  /** Classes extending this class. */\n  extendees: Set<ClassPrototype> = new Set();\n\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: ClassDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.INTERFACE_PROTOTYPE : ElementKind.CLASS_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<ClassDeclaration>this.declaration).typeParameters;\n  }\n  /** Gets the associated extends node. */\n  get extendsNode(): NamedTypeNode | null {\n    return (<ClassDeclaration>this.declaration).extendsType;\n  }\n  /** Gets the associated implements nodes. */\n  get implementsNodes(): NamedTypeNode[] | null {\n    return (<ClassDeclaration>this.declaration).implementsTypes;\n  }\n\n  /** Tests if this prototype is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    var arrayBufferViewInstance = this.program.arrayBufferViewInstance;\n    return arrayBufferViewInstance !== null\n        && this.extends(arrayBufferViewInstance.prototype);\n  }\n\n  /** Tests if this prototype extends the specified. */\n  extends(basePtototype: ClassPrototype | null): bool {\n    var current: ClassPrototype | null = this;\n    var seen = new Set<ClassPrototype>();\n    do {\n      // cannot directly or indirectly extend itself\n      if (seen.has(current)) break;\n      seen.add(current);\n      if (current === basePtototype) return true;\n      current = current.basePrototype;\n    } while (current);\n    return false;\n  }\n\n  /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */\n  addInstance(name: string, element: DeclaredElement): bool {\n    var originalDeclaration = element.declaration;\n    var instanceMembers = this.instanceMembers;\n    if (!instanceMembers) this.instanceMembers = instanceMembers = new Map();\n    else if (instanceMembers.has(name)) {\n      let existing = assert(instanceMembers.get(name));\n      let merged = tryMerge(existing, element);\n      if (!merged) {\n        if (isDeclaredElement(existing.kind)) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range,\n            (<DeclaredElement>existing).declaration.name.range,\n            element.identifierNode.text\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range, element.identifierNode.text\n          );\n        }\n        return false;\n      }\n      element = merged;\n    }\n    instanceMembers.set(name, element);\n    if (element.is(CommonFlags.EXPORT) && this.is(CommonFlags.MODULE_EXPORT)) {\n      element.set(CommonFlags.MODULE_EXPORT); // propagate\n    }\n    this.program.elementsByDeclaration.set(originalDeclaration, element);\n    return true;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Class | null {\n    var instances = this.instances;\n    if (instances !== null && instances.has(instanceKey)) return <Class>instances.get(instanceKey);\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Class): void {\n    var instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n}\n\n/** A resolved class. */\nexport class Class extends TypedElement {\n\n  /** Class prototype. */\n  prototype: ClassPrototype;\n  /** Resolved type arguments. */\n  typeArguments: Type[] | null;\n  /** Base class, if applicable. */\n  base: Class | null = null;\n  /** Implemented interfaces, if applicable. */\n  interfaces: Set<Interface> | null = null;\n  /** Contextual type arguments for fields and methods. */\n  contextualTypeArguments: Map<string,Type> | null = null;\n  /** Current member memory offset. */\n  nextMemoryOffset: u32 = 0;\n  /** Constructor instance. */\n  constructorInstance: Function | null = null;\n  /** Operator overloads. */\n  overloads: Map<OperatorKind,Function> | null = null;\n  /** Index signature, if present. */\n  indexSignature: IndexSignature | null = null;\n  /** Unique class id. */\n  private _id: u32 = 0;\n  /** Runtime type information flags. */\n  rttiFlags: u32 = 0;\n  /** Wrapped type, if a wrapper for a basic type. */\n  wrappedType: Type | null = null;\n  /** Classes directly extending this class. */\n  extendees: Set<Class> | null = null;\n  /** Classes implementing this interface. */\n  implementers: Set<Class> | null = null;\n  /** Whether the field initialization check has already been performed. */\n  didCheckFieldInitialization: bool = false;\n  /** Runtime visitor function reference. */\n  visitRef: FunctionRef = 0;\n\n  /** Gets the unique runtime id of this class. */\n  get id(): u32 {\n    return this._id; // unmanaged remains 0 (=ArrayBuffer)\n  }\n\n  /** Tests if this class is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    return this.prototype.isBuiltinArray;\n  }\n\n  /** Tests if this class is array-like. */\n  get isArrayLike(): bool {\n    if (this.isBuiltinArray) return true;\n    var lengthField = this.getMember(\"length\");\n    return lengthField !== null && (\n      lengthField.kind == ElementKind.FIELD ||\n      (\n        lengthField.kind == ElementKind.PROPERTY_PROTOTYPE &&\n        (<PropertyPrototype>lengthField).getterPrototype !== null // TODO: resolve & check type?\n      )\n    ) && (\n      this.lookupOverload(OperatorKind.INDEXED_GET) !== null ||\n      this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET) !== null\n    );\n  }\n\n  /** Constructs a new class. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: ClassPrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.INTERFACE : ElementKind.CLASS,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    var program = this.program;\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.typeArguments = typeArguments;\n    var usizeType = program.options.usizeType;\n    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);\n    type.classReference = this;\n    this.setType(type);\n\n    if (!this.hasDecorator(DecoratorFlags.UNMANAGED)) {\n      let id = program.nextClassId++;\n      this._id = id;\n      program.managedClasses.set(id, this);\n    }\n\n    // apply pre-checked instance-specific contextual type arguments\n    var typeParameters = prototype.typeParameterNodes;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (!typeParameters || numTypeArguments != typeParameters.length) {\n        throw new Error(\"type argument count mismatch\");\n      }\n      if (numTypeArguments) {\n        let contextualTypeArguments = this.contextualTypeArguments;\n        if (!contextualTypeArguments) this.contextualTypeArguments = contextualTypeArguments = new Map();\n        for (let i = 0; i < numTypeArguments; ++i) {\n          contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\n        }\n      }\n    } else if (typeParameters !== null && typeParameters.length > 0) {\n      throw new Error(\"type argument count mismatch\");\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Sets the base class. */\n  setBase(base: Class): void {\n    assert(!this.base);\n    this.base = base;\n    var extendees = base.extendees;\n    if (!extendees) base.extendees = extendees = new Set();\n    extendees.add(this);\n\n    // Inherit contextual type arguments from base class\n    var inheritedTypeArguments = base.contextualTypeArguments;\n    if (inheritedTypeArguments) {\n      let contextualTypeArguments = this.contextualTypeArguments;\n      // TODO: for (let [baseName, baseType] of inheritedTypeArguments) {\n      for (let _keys = Map_keys(inheritedTypeArguments), i = 0, k = _keys.length; i < k; ++i) {\n        let baseName = unchecked(_keys[i]);\n        let baseType = assert(inheritedTypeArguments.get(baseName));\n        if (!contextualTypeArguments) {\n          this.contextualTypeArguments = contextualTypeArguments = new Map();\n          contextualTypeArguments.set(baseName, baseType);\n        } else if (!contextualTypeArguments.has(baseName)) {\n          contextualTypeArguments.set(baseName, baseType);\n        }\n      }\n    }\n  }\n\n  /** Adds an interface. */\n  addInterface(iface: Interface): void {\n    var interfaces = this.interfaces;\n    if (!interfaces) this.interfaces = interfaces = new Set();\n    interfaces.add(iface);\n    var implementers = iface.implementers;\n    if (!implementers) iface.implementers = implementers = new Set();\n    implementers.add(this);\n  }\n\n  /** Tests if a value of this class type is assignable to a target of the specified class type. */\n  isAssignableTo(target: Class): bool {\n    var current: Class | null = this;\n    do {\n      if (current == target) return true;\n      if (target.kind == ElementKind.INTERFACE) {\n        let interfaces = current.interfaces;\n        if (interfaces) {\n          for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n            let iface = _values[i];\n            if (iface.isAssignableTo(target)) return true;\n          }\n        }\n      }\n      current = current.base;\n    } while (current);\n    return false;\n  }\n\n  /** Looks up the operator overload of the specified kind. */\n  lookupOverload(kind: OperatorKind, unchecked: bool = false): Function | null {\n    if (unchecked) {\n      switch (kind) {\n        case OperatorKind.INDEXED_GET: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        case OperatorKind.INDEXED_SET: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_SET);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    var instance: Class | null = this;\n    do {\n      let overloads = instance.overloads;\n      if (overloads != null && overloads.has(kind)) {\n        return assert(overloads.get(kind));\n      }\n      instance = instance.base;\n    } while (instance);\n    return null;\n  }\n\n  /** Gets the method of the specified name, resolved with the given type arguments. */\n  getMethod(name: string, typeArguments: Type[] | null = null): Function | null {\n    var member = this.getMember(name);\n    if (member && member.kind == ElementKind.FUNCTION_PROTOTYPE) {\n      return this.program.resolver.resolveFunction(<FunctionPrototype>member, typeArguments);\n    }\n    return null;\n  }\n\n  /** Calculates the memory offset of the specified field. */\n  offsetof(fieldName: string): u32 {\n    var member = assert(this.getMember(fieldName));\n    assert(member.kind == ElementKind.FIELD);\n    return (<Field>member).memoryOffset;\n  }\n\n  /** Creates a buffer suitable to hold a runtime instance of this class. */\n  createBuffer(overhead: i32 = 0): Uint8Array {\n    var program = this.program;\n    var payloadSize = this.nextMemoryOffset + overhead;\n    var blockSize = program.computeBlockSize(payloadSize, true); // excl. overhead\n    var buffer = new Uint8Array(program.blockOverhead + blockSize);\n    var OBJECT = program.OBJECTInstance;\n    OBJECT.writeField(\"mmInfo\", blockSize, buffer, 0);\n    OBJECT.writeField(\"gcInfo\", 0, buffer, 0);\n    OBJECT.writeField(\"gcInfo2\", 0, buffer, 0);\n    OBJECT.writeField(\"rtId\", this.id, buffer, 0);\n    OBJECT.writeField(\"rtSize\", payloadSize, buffer, 0);\n    return buffer;\n  }\n\n  /** Writes a field value to a buffer and returns the number of bytes written. */\n  writeField<T>(name: string, value: T, buffer: Uint8Array, baseOffset: i32 = this.program.totalOverhead): i32 {\n    var member = this.getMember(name);\n    if (member !== null && member.kind == ElementKind.FIELD) {\n      let fieldInstance = <Field>member;\n      let offset = baseOffset + fieldInstance.memoryOffset;\n      let typeKind = fieldInstance.type.kind;\n      switch (typeKind) {\n        case TypeKind.I8:\n        case TypeKind.U8: {\n          assert(!i64_is(value));\n          writeI8(i32(value), buffer, offset);\n          return 1;\n        }\n        case TypeKind.I16:\n        case TypeKind.U16: {\n          assert(!i64_is(value));\n          writeI16(i32(value), buffer, offset);\n          return 2;\n        }\n        case TypeKind.I32:\n        case TypeKind.U32: {\n          assert(!i64_is(value));\n          writeI32(i32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.ISIZE:\n        case TypeKind.USIZE: {\n          if (this.program.options.isWasm64) {\n            if (i64_is(value)) {\n              writeI64(value, buffer, offset);\n            } else {\n              writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.USIZE);\n            }\n            return 8;\n          } else {\n            if (i64_is(value)) {\n              writeI64AsI32(value, buffer, offset, typeKind == TypeKind.USIZE);\n            } else {\n              writeI32(i32(value), buffer, offset);\n            }\n            return 4;\n          }\n        }\n        case TypeKind.I64:\n        case TypeKind.U64: {\n          if (i64_is(value)) {\n            writeI64(value, buffer, offset);\n          } else {\n            writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.U64);\n          }\n          return 8;\n        }\n        case TypeKind.F32: {\n          assert(!i64_is(value));\n          writeF32(f32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.F64: {\n          assert(!i64_is(value));\n          writeF64(f64(value), buffer, offset);\n          return 8;\n        }\n      }\n    }\n    assert(false);\n    return 0;\n  }\n\n  /** Tests if this class extends the specified prototype. */\n  extends(prototype: ClassPrototype): bool {\n    return this.prototype.extends(prototype);\n  }\n\n  /** Gets the concrete type arguments to the specified extendend prototype. */\n  getTypeArgumentsTo(extendedPrototype: ClassPrototype): Type[] | null {\n    var current: Class | null = this;\n    do {\n      if (current.prototype === extendedPrototype) return current.typeArguments;\n      current = current.base;\n    } while (current);\n    return null;\n  }\n\n  /** Gets the value type of an array. Must be an array. */\n  getArrayValueType(): Type {\n    var current: Class = this;\n    var program = this.program;\n    var arrayPrototype = program.arrayPrototype;\n    if (this.extends(arrayPrototype)) {\n      return this.getTypeArgumentsTo(arrayPrototype)![0];\n    }\n    var staticArrayPrototype = program.staticArrayPrototype;\n    if (this.extends(staticArrayPrototype)) {\n      return this.getTypeArgumentsTo(staticArrayPrototype)![0];\n    }\n    var abvInstance = program.arrayBufferViewInstance;\n    while (current.base !== abvInstance) {\n      current = assert(current.base);\n    }\n    var prototype = current.prototype;\n    switch (prototype.name.charCodeAt(0)) {\n      case CharCode.F: {\n        if (prototype == program.float32ArrayPrototype) return Type.f32;\n        if (prototype == program.float64ArrayPrototype) return Type.f64;\n        break;\n      }\n      case CharCode.I: {\n        if (prototype == program.int8ArrayPrototype) return Type.i8;\n        if (prototype == program.int16ArrayPrototype) return Type.i16;\n        if (prototype == program.int32ArrayPrototype) return Type.i32;\n        if (prototype == program.int64ArrayPrototype) return Type.i64;\n        break;\n      }\n      case CharCode.U: {\n        if (prototype == program.uint8ArrayPrototype) return Type.u8;\n        if (prototype == program.uint8ClampedArrayPrototype) return Type.u8;\n        if (prototype == program.uint16ArrayPrototype) return Type.u16;\n        if (prototype == program.uint32ArrayPrototype) return Type.u32;\n        if (prototype == program.uint64ArrayPrototype) return Type.u64;\n        break;\n      }\n    }\n    assert(false);\n    return Type.void;\n  }\n\n  /** Tests if this class is pointerfree. Useful to know for the GC. */\n  get isPointerfree(): bool {\n    var program = this.program;\n\n    var instanceMembers = this.members;\n    if (instanceMembers) {\n\n      // Check that there are no managed instance fields\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind == ElementKind.FIELD) {\n          let fieldType = (<Field>member).type;\n          if (fieldType.isManaged) return false;\n        }\n      }\n\n      // Check that this isn't a managed collection\n      if (instanceMembers.has(CommonNames.visit)) {\n        let prototype = this.prototype;\n        if (\n          prototype == program.arrayPrototype ||\n          prototype == program.staticArrayPrototype ||\n          prototype == program.setPrototype ||\n          prototype == program.mapPrototype\n        ) {\n          // Note that we cannot know for sure anymore as soon as the collection\n          // is extended, because user code may implement a custom visitor.\n          let typeArguments = assert(this.getTypeArgumentsTo(prototype));\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (typeArguments[i].isManaged) return false;\n          }\n          return true;\n        }\n        return false; // has a custom __visit\n      }\n    }\n    return true;\n  }\n\n  /** Gets all extendees of this class (that do not have the specified instance member). */\n  getAllExtendees(exceptIfMember: string | null = null, out: Set<Class> = new Set()): Set<Class> {\n    var extendees = this.extendees;\n    if (extendees) {\n      for (let _values = Set_values(extendees), i = 0, k = _values.length; i < k; ++i) {\n        let extendee = _values[i];\n        if (exceptIfMember) {\n          let instanceMembers = extendee.prototype.instanceMembers;\n          if (instanceMembers !== null && instanceMembers.has(exceptIfMember)) continue;\n        }\n        out.add(extendee);\n        extendee.getAllExtendees(exceptIfMember, out);\n      }\n    }\n    return out;\n  }\n}\n\n/** A yet unresolved interface. */\nexport class InterfacePrototype extends ClassPrototype {\n\n  /** Constructs a new interface prototype. */\n  constructor(\n    name: string,\n    parent: Element,\n    declaration: InterfaceDeclaration,\n    decoratorFlags: DecoratorFlags\n  ) {\n    super(\n      name,\n      parent,\n      declaration,\n      decoratorFlags,\n      true\n    );\n  }\n}\n\n/** A resolved interface. */\nexport class Interface extends Class { // FIXME\n\n  /** Constructs a new interface. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: InterfacePrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n  ) {\n    super(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      true\n    );\n  }\n}\n\n/** Registers a concrete element with a program. */\nfunction registerConcreteElement(program: Program, element: Element): void {\n  assert(!program.instancesByName.has(element.internalName));\n  program.instancesByName.set(element.internalName, element);\n}\n\n/** Attempts to merge two elements. Returns the merged element on success. */\nfunction tryMerge(older: Element, newer: Element): DeclaredElement | null {\n  // NOTE: some of the following cases are not supported by TS, not sure why exactly.\n  // suggesting to just merge what seems to be possible for now and revisit later.\n  assert(older.program === newer.program);\n  if (newer.members) return null;\n  var merged: DeclaredElement | null = null;\n  switch (older.kind) {\n    case ElementKind.FUNCTION_PROTOTYPE: {\n      switch (newer.kind) {\n        case ElementKind.NAMESPACE: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TYPEDEFINITION: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.CLASS_PROTOTYPE:\n    case ElementKind.ENUM: {\n      if (newer.kind == ElementKind.NAMESPACE) {\n        copyMembers(newer, older);\n        merged = <DeclaredElement>older;\n        break;\n      }\n      break;\n    }\n    case ElementKind.NAMESPACE: {\n      switch (newer.kind) {\n        case ElementKind.ENUM:\n        case ElementKind.CLASS_PROTOTYPE:      // TS2434\n        case ElementKind.FUNCTION_PROTOTYPE: { // TS2434\n          copyMembers(older, newer);\n          merged = <DeclaredElement>newer;\n          break;\n        }\n        case ElementKind.NAMESPACE: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TYPEDEFINITION: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.GLOBAL: {\n      if (newer.kind == ElementKind.TYPEDEFINITION) {\n        if (!older.shadowType) {\n          older.shadowType = <TypeDefinition>newer;\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n        }\n      }\n      break;\n    }\n    case ElementKind.TYPEDEFINITION: {\n      switch (newer.kind) {\n        case ElementKind.GLOBAL:\n        case ElementKind.FUNCTION_PROTOTYPE:\n        case ElementKind.NAMESPACE: {\n          if (!newer.shadowType) {\n            newer.shadowType = <TypeDefinition>older;\n            copyMembers(older, newer);\n            merged = <DeclaredElement>newer;\n          }\n          break;\n        }\n      }\n      break;\n    }\n  }\n  if (merged) {\n    let olderIsExport = older.is(CommonFlags.EXPORT) || older.hasDecorator(DecoratorFlags.GLOBAL);\n    let newerIsExport = newer.is(CommonFlags.EXPORT) || newer.hasDecorator(DecoratorFlags.GLOBAL);\n    if (olderIsExport != newerIsExport) {\n      older.program.error(\n        DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,\n        merged.identifierNode.range, merged.identifierNode.text\n      );\n    }\n  }\n  return merged;\n}\n\n/** Copies the members of `src` to `dest`. */\nfunction copyMembers(src: Element, dest: Element): void {\n  var srcMembers = src.members;\n  if (srcMembers) {\n    let destMembers = dest.members;\n    if (!destMembers) dest.members = destMembers = new Map();\n    // TODO: for (let [memberName, member] of srcMembers) {\n    for (let _keys = Map_keys(srcMembers), i = 0, k = _keys.length; i < k; ++i) {\n      let memberName = unchecked(_keys[i]);\n      let member = assert(srcMembers.get(memberName));\n      destMembers.set(memberName, member);\n    }\n  }\n}\n\n/** Mangles the internal name of an element with the specified name that is a child of the given parent. */\nexport function mangleInternalName(name: string, parent: Element, isInstance: bool, asGlobal: bool = false): string {\n  switch (parent.kind) {\n    case ElementKind.FILE: {\n      if (asGlobal) return name;\n      return parent.internalName + PATH_DELIMITER + name;\n    }\n    case ElementKind.FUNCTION: {\n      if (asGlobal) return name;\n      assert(!isInstance);\n      return parent.internalName + INNER_DELIMITER + name;\n    }\n    case ElementKind.PROPERTY_PROTOTYPE: // properties are just containers\n    case ElementKind.PROPERTY: {         //\n      parent = parent.parent;\n      // fall-through\n    }\n    default: {\n      return mangleInternalName(parent.name, parent.parent, parent.is(CommonFlags.INSTANCE), asGlobal)\n           + (isInstance ? INSTANCE_DELIMITER : STATIC_DELIMITER) + name;\n    }\n  }\n}\n\n// Cached default parameter names used where names are unknown.\nvar cachedDefaultParameterNames: string[] = [];\n\n/** Gets the cached default parameter name for the specified index. */\nexport function getDefaultParameterName(index: i32): string {\n  for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {\n    cachedDefaultParameterNames.push(\"$\" + i.toString());\n  }\n  return cachedDefaultParameterNames[index];\n}\n","/**\n * @fileoverview Resolve infrastructure to obtain types and elements.\n *\n * Similar to the compiler making instructions of expressions, the resolver\n * obtains metadata of expressions. As such, for each `compileX` method in\n * the compiler there is one `lookupX` method in the resolver returning the\n * respective IR element, respectively one `resolveX` method returning the\n * respective type of an expression. It is also able to make new elements,\n * like instances of classes given its concrete type arguments.\n *\n * @license Apache-2.0\n */\n\nimport {\n  DiagnosticEmitter,\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Program,\n  ElementKind,\n  OperatorKind,\n  Element,\n  Class,\n  ClassPrototype,\n  Interface,\n  Function,\n  FunctionPrototype,\n  VariableLikeElement,\n  Property,\n  PropertyPrototype,\n  Field,\n  FieldPrototype,\n  Global,\n  TypeDefinition,\n  TypedElement,\n  IndexSignature,\n  isTypedElement,\n  InterfacePrototype,\n  DeclaredElement\n} from \"./program\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  Range\n} from \"./tokenizer\";\n\nimport {\n  FunctionTypeNode,\n  ParameterKind,\n  TypeNode,\n  NodeKind,\n  NamedTypeNode,\n  TypeName,\n  TypeParameterNode,\n  Node,\n  IdentifierExpression,\n  CallExpression,\n  ElementAccessExpression,\n  PropertyAccessExpression,\n  LiteralExpression,\n  LiteralKind,\n  ParenthesizedExpression,\n  AssertionExpression,\n  Expression,\n  IntegerLiteralExpression,\n  UnaryPrefixExpression,\n  UnaryPostfixExpression,\n  AssertionKind,\n  BinaryExpression,\n  ThisExpression,\n  SuperExpression,\n  CommaExpression,\n  InstanceOfExpression,\n  TernaryExpression,\n  isTypeOmitted,\n  FunctionExpression,\n  NewExpression,\n  ArrayLiteralExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  Signature,\n  typesToString,\n  TypeKind\n} from \"./types\";\n\nimport {\n  CommonFlags,\n  CommonNames\n} from \"./common\";\n\nimport {\n  uniqueMap,\n  isPowerOf2\n} from \"./util\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Indicates whether errors are reported or not. */\nexport enum ReportMode {\n  /** Report errors. */\n  REPORT,\n  /** Swallow errors. */\n  SWALLOW\n}\n\n/** Provides tools to resolve types and expressions. */\nexport class Resolver extends DiagnosticEmitter {\n\n  /** The program this resolver belongs to. */\n  program: Program;\n\n  /** Target expression of the previously resolved property or element access. */\n  currentThisExpression: Expression | null = null;\n  /** Element expression of the previously resolved element access. */\n  currentElementExpression : Expression | null = null;\n  /** Whether a new overload has been discovered. */\n  discoveredOverload: bool = false;\n\n  /** Constructs the resolver for the specified program. */\n  constructor(\n    /** The program to construct a resolver for. */\n    program: Program\n  ) {\n    super(program.diagnostics);\n    this.program = program;\n  }\n\n  // ====================================================== Types ======================================================\n\n  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\n  resolveType(\n    /** The type to resolve. */\n    node: TypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.NAMEDTYPE: {\n        return this.resolveNamedType(\n          <NamedTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        return this.resolveFunctionType(\n          <FunctionTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */\n  private resolveNamedType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var nameNode = node.name;\n    var typeArgumentNodes = node.typeArguments;\n    var isSimpleType = !nameNode.next;\n\n    // Look up in contextual types if a simple type\n    if (isSimpleType) {\n      let simpleName = nameNode.identifier.text;\n      if (ctxTypes !== null && ctxTypes.has(simpleName)) {\n        let type = assert(ctxTypes.get(simpleName));\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, type.toString()\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, type.toString()\n            );\n          }\n        }\n        return type;\n      }\n    }\n\n    // Look up in context\n    var element = this.resolveTypeName(nameNode, ctxElement, reportMode);\n    if (!element) return null;\n\n    // Use shadow type if present (i.e. namespace sharing a type)\n    var shadowType = element.shadowType;\n    if (shadowType) {\n      element = shadowType;\n\n    } else {\n\n      // Handle enums (become i32)\n      if (element.kind == ElementKind.ENUM) {\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, element.name + \"/i32\"\n            );\n          }\n        }\n        return Type.i32;\n      }\n\n      // Handle classes and interfaces\n      if (\n        element.kind == ElementKind.CLASS_PROTOTYPE ||\n        element.kind == ElementKind.INTERFACE_PROTOTYPE\n      ) {\n        let instance = this.resolveClassInclTypeArguments(\n          <ClassPrototype>element,\n          typeArgumentNodes,\n          ctxElement,\n          uniqueMap<string,Type>(ctxTypes), // don't inherit\n          node,\n          reportMode\n        );\n        if (!instance) return null;\n        return node.isNullable ? instance.type.asNullable() : instance.type;\n      }\n    }\n\n    // Handle type definitions\n    if (element.kind == ElementKind.TYPEDEFINITION) {\n      let typeDefinition = <TypeDefinition>element;\n\n      // Shortcut already resolved (mostly builtins)\n      if (element.is(CommonFlags.RESOLVED)) {\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        let type = typeDefinition.type;\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              nameNode.range, nameNode.identifier.text\n            );\n          }\n        }\n        return type;\n      }\n\n      // Handle special built-in types\n      if (isSimpleType) {\n        let text = nameNode.identifier.text;\n        if (text == CommonNames.native) return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.indexof) return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.valueof) return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.returnof) return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.nonnull) return this.resolveBuiltinNotNullableType(node, ctxElement, ctxTypes, reportMode);\n      }\n\n      // Resolve normally\n      let typeParameterNodes = typeDefinition.typeParameterNodes;\n      let typeArguments: Type[] | null = null;\n      if (typeParameterNodes) {\n        typeArguments = this.resolveTypeArguments(\n          typeParameterNodes,\n          typeArgumentNodes,\n          ctxElement,\n          ctxTypes = uniqueMap(ctxTypes), // update\n          node,\n          reportMode\n        );\n        if (!typeArguments) return null;\n      } else if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          node.range, nameNode.identifier.text\n        );\n      }\n      let type = this.resolveType(\n        typeDefinition.typeNode,\n        element,\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      if (node.isNullable) {\n        if (type.isInternalReference) return type.asNullable();\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_cannot_be_nullable,\n            nameNode.range, nameNode.identifier.text\n          );\n        }\n      }\n      return type;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        nameNode.range, nameNode.identifier.text\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */\n  private resolveFunctionType(\n    /** The type to resolve. */\n    node: FunctionTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var explicitThisType = node.explicitThisType;\n    var thisType: Type | null = null;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n    }\n    var parameterNodes = node.parameters;\n    var numParameters = parameterNodes.length;\n    var parameterTypes = new Array<Type>(numParameters);\n    var requiredParameters = 0;\n    var hasRest = false;\n    for (let i = 0; i < numParameters; ++i) {\n      let parameterNode = parameterNodes[i];\n      switch (parameterNode.parameterKind) {\n        case ParameterKind.DEFAULT: {\n          requiredParameters = i + 1;\n          break;\n        }\n        case ParameterKind.REST: {\n          assert(i == numParameters);\n          hasRest = true;\n          break;\n        }\n      }\n      let parameterTypeNode = parameterNode.type;\n      if (isTypeOmitted(parameterTypeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            parameterTypeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        parameterTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      parameterTypes[i] = parameterType;\n    }\n    var returnTypeNode = node.returnType;\n    var returnType: Type | null;\n    if (isTypeOmitted(returnTypeNode)) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnTypeNode.range\n        );\n      }\n      returnType = Type.void;\n    } else {\n      returnType = this.resolveType(\n        returnTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!returnType) return null;\n    }\n    var signature = new Signature(this.program, parameterTypes, returnType, thisType);\n    signature.requiredParameters = requiredParameters;\n    signature.hasRest = hasRest;\n    return node.isNullable ? signature.type.asNullable() : signature.type;\n  }\n\n  private resolveBuiltinNativeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    switch (typeArgument.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: return Type.i32;\n      case TypeKind.ISIZE: if (!this.program.options.isWasm64) return Type.i32;\n      case TypeKind.I64: return Type.i64;\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return Type.u32;\n      case TypeKind.USIZE: if (!this.program.options.isWasm64) return Type.u32;\n      case TypeKind.U64: return Type.u64;\n      case TypeKind.F32: return Type.f32;\n      case TypeKind.F64: return Type.f64;\n      case TypeKind.V128: return Type.v128;\n      case TypeKind.VOID: return Type.void;\n      default: assert(false);\n    }\n    return null;\n  }\n\n  private resolveBuiltinIndexofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var classReference = typeArgument.classReference;\n    if (!classReference) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Index_signature_is_missing_in_type_0,\n          typeArgumentNode.range, typeArgument.toString()\n        );\n      }\n      return null;\n    }\n    var overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);\n    if (overload) {\n      if (overload.is(CommonFlags.STATIC)) {\n        assert(overload.signature.parameterTypes.length == 2);\n        return overload.signature.parameterTypes[1];\n      } else {\n        assert(overload.signature.parameterTypes.length == 1);\n        return overload.signature.parameterTypes[0];\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinValueofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var classReference = typeArgument.getClassOrWrapper(this.program);\n    if (classReference) {\n      let overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);\n      if (overload) return overload.signature.returnType;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinReturnTypeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventualy diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var signatureReference = typeArgument.getSignature();\n    if (signatureReference) return signatureReference.returnType;\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Type_0_has_no_call_signatures,\n        typeArgumentNode.range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinNotNullableType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\n    if (!typeArgumentNode) return null;\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    if (!typeArgument.isNullableReference) return typeArgument;\n    return typeArgument.nonNullableType;\n  }\n\n  /** Resolves a type name to the program element it refers to. */\n  resolveTypeName(\n    /** The type name to resolve. */\n    node: TypeName,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var element = ctxElement.lookup(node.identifier.text, true);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Cannot_find_name_0,\n          node.range, node.identifier.text\n        );\n      }\n      return null;\n    }\n    var prev = node;\n    var next = node.next;\n    while (next) {\n      if (!(element = element.getMember(next.identifier.text))) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\n            next.range, next.identifier.text, prev.identifier.text\n          );\n        }\n        return null;\n      }\n      prev = next;\n      next = next.next;\n    }\n    return element;\n  }\n\n  /** Resolves an array of type arguments to concrete types. */\n  resolveTypeArguments(\n    /** Type parameter nodes present. */\n    typeParameters: TypeParameterNode[],\n    /** Type argument nodes provided. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. Updated in place with the new set of contextual types. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** Alternative report node in case of empty type arguments. */\n    alternativeReportNode: Node | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type[] | null {\n    var minParameterCount = 0;\n    var maxParameterCount = 0;\n    for (let i = 0, k = typeParameters.length; i < k; ++i) {\n      if (!typeParameters[i].defaultType) ++minParameterCount;\n      ++maxParameterCount;\n    }\n    var argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\n    if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          argumentCount\n            ? Range.join(\n                typeArgumentNodes![0].range,\n                typeArgumentNodes![argumentCount - 1].range\n              )\n            : alternativeReportNode!.range,\n          (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(),\n          argumentCount.toString()\n        );\n      }\n      return null;\n    }\n    var typeArguments = new Array<Type>(maxParameterCount);\n    var oldCtxTypes = uniqueMap<string,Type>(ctxTypes);\n    ctxTypes.clear();\n    for (let i = 0; i < maxParameterCount; ++i) {\n      let type = i < argumentCount\n        ? this.resolveType( // reports\n            typeArgumentNodes![i],\n            ctxElement,\n            oldCtxTypes, // update\n            reportMode\n          )\n        : this.resolveType( // reports\n            assert(typeParameters[i].defaultType),\n            ctxElement,\n            uniqueMap<string,Type>(ctxTypes), // don't update\n            reportMode\n          );\n      if (!type) return null;\n      // TODO: check extendsType\n      ctxTypes.set(typeParameters[i].name.text, type);\n      typeArguments[i] = type;\n    }\n    return typeArguments;\n  }\n\n  /** Resolves respectively infers the concrete instance of a function by call context. */\n  maybeInferCall(\n    node: CallExpression,\n    prototype: FunctionPrototype,\n    ctxFlow: Flow,\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var typeArguments = node.typeArguments;\n\n    // resolve generic call if type arguments have been provided\n    if (typeArguments) {\n      if (!prototype.is(CommonFlags.GENERIC)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            node.expression.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n      return this.resolveFunctionInclTypeArguments(\n        prototype,\n        typeArguments,\n        ctxFlow.actualFunction,\n        uniqueMap(ctxFlow.contextualTypeArguments), // don't inherit\n        node,\n        reportMode\n      );\n    }\n\n    // infer generic call if type arguments have been omitted\n    if (prototype.is(CommonFlags.GENERIC)) {\n      let contextualTypeArguments = uniqueMap<string,Type>(ctxFlow.contextualTypeArguments);\n\n      // fill up contextual types with auto for each generic component\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let typeParameterNames = new Set<string>();\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let name = typeParameterNodes[i].name.text;\n        contextualTypeArguments.set(name, Type.auto);\n        typeParameterNames.add(name);\n      }\n\n      let parameterNodes = prototype.functionTypeNode.parameters;\n      let numParameters = parameterNodes.length;\n      let argumentNodes = node.args;\n      let numArguments = argumentNodes.length;\n\n      // infer types with generic components while updating contextual types\n      for (let i = 0; i < numParameters; ++i) {\n        let argumentExpression = i < numArguments ? argumentNodes[i] : parameterNodes[i].initializer;\n        if (!argumentExpression) { // missing initializer -> too few arguments\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              node.range, numParameters.toString(), numArguments.toString()\n            );\n          }\n          return null;\n        }\n        let typeNode = parameterNodes[i].type;\n        if (typeNode.hasGenericComponent(typeParameterNodes)) {\n          let type = this.resolveExpression(argumentExpression, ctxFlow, Type.auto, ReportMode.SWALLOW);\n          if (type) this.propagateInferredGenericTypes(typeNode, type, ctxFlow, contextualTypeArguments, typeParameterNames);\n        }\n      }\n\n      // apply concrete types to the generic function signature\n      let resolvedTypeArguments = new Array<Type>(numTypeParameters);\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let typeParameterNode = typeParameterNodes[i];\n        let name = typeParameterNode.name.text;\n        if (contextualTypeArguments.has(name)) {\n          let inferredType = assert(contextualTypeArguments.get(name));\n          if (inferredType != Type.auto) {\n            resolvedTypeArguments[i] = inferredType;\n            continue;\n          }\n          let defaultType = typeParameterNode.defaultType;\n          if (defaultType) {\n            let resolvedDefaultType = this.resolveType(defaultType, ctxFlow.actualFunction, contextualTypeArguments, reportMode);\n            if (!resolvedDefaultType) return null;\n            resolvedTypeArguments[i] = resolvedDefaultType;\n            continue;\n          }\n        }\n        // unused template, e.g. `function test<T>(): void {...}` called as `test()`\n        // invalid because the type is effectively unknown inside the function body\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            node.expression.range.atEnd\n          );\n        }\n        return null;\n      }\n      return this.resolveFunction(\n        prototype,\n        resolvedTypeArguments,\n        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),\n        reportMode\n      );\n    }\n\n    // otherwise resolve the non-generic call as usual\n    return this.resolveFunction(prototype, null, uniqueMap<string,Type>(), reportMode);\n  }\n\n  /** Updates contextual types with a possibly encapsulated inferred type. */\n  private propagateInferredGenericTypes(\n    /** The inferred type node. */\n    node: TypeNode,\n    /** The inferred type. */\n    type: Type,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */\n    ctxTypes: Map<string,Type>,\n    /** The names of the type parameters being inferred. */\n    typeParameterNames: Set<string>\n  ): void {\n    if (node.kind == NodeKind.NAMEDTYPE) {\n      let namedTypeNode = <NamedTypeNode>node;\n      let typeArgumentNodes = namedTypeNode.typeArguments;\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) { // foo<T>(bar: Array<T>)\n        let classReference = type.classReference;\n        if (classReference) {\n          let classPrototype = this.resolveTypeName(namedTypeNode.name, ctxFlow.actualFunction);\n          if (!classPrototype || classPrototype.kind != ElementKind.CLASS_PROTOTYPE) return;\n          if (classReference.prototype == <ClassPrototype>classPrototype) {\n            let typeArguments = classReference.typeArguments;\n            if (typeArguments !== null && typeArguments.length == typeArgumentNodes.length) {\n              for (let i = 0, k = typeArguments.length; i < k; ++i) {\n                this.propagateInferredGenericTypes(typeArgumentNodes[i], typeArguments[i], ctxFlow, ctxTypes, typeParameterNames);\n              }\n              return;\n            }\n          }\n        }\n      } else { // foo<T>(bar: T)\n        let name = namedTypeNode.name.identifier.text;\n        if (ctxTypes.has(name)) {\n          let currentType = assert(ctxTypes.get(name));\n          if (currentType == Type.auto || (typeParameterNames.has(name) && currentType.isAssignableTo(type))) {\n            ctxTypes.set(name, type);\n          }\n        }\n      }\n    } else if (node.kind == NodeKind.FUNCTIONTYPE) { // foo<T>(bar: (baz: T) => i32))\n      let functionTypeNode = <FunctionTypeNode>node;\n      let parameterNodes = functionTypeNode.parameters;\n      if (parameterNodes !== null && parameterNodes.length > 0) {\n        let signatureReference = type.signatureReference;\n        if (signatureReference) {\n          let parameterTypes = signatureReference.parameterTypes;\n          let thisType = signatureReference.thisType;\n          if (parameterTypes.length == parameterNodes.length && !thisType == !functionTypeNode.explicitThisType) {\n            for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n              this.propagateInferredGenericTypes(parameterNodes[i].type, parameterTypes[i], ctxFlow, ctxTypes, typeParameterNames);\n            }\n            this.propagateInferredGenericTypes(functionTypeNode.returnType, signatureReference.returnType, ctxFlow, ctxTypes, typeParameterNames);\n            if (thisType) this.propagateInferredGenericTypes(functionTypeNode.explicitThisType!, thisType, ctxFlow, ctxTypes, typeParameterNames);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  /** Gets the concrete type of an element. */\n  getTypeOfElement(element: Element): Type | null {\n    var kind = element.kind;\n    if (kind == ElementKind.GLOBAL) {\n      if (!this.ensureResolvedLazyGlobal(<Global>element, ReportMode.SWALLOW)) return null;\n    }\n    if (isTypedElement(kind)) {\n      let type = (<TypedElement>element).type;\n      let classReference = type.getClassOrWrapper(this.program);\n      if (classReference) {\n        let wrappedType = classReference.wrappedType;\n        if (wrappedType) type = wrappedType;\n      }\n      return type;\n    }\n    return null;\n  }\n\n  /** Gets the element of a concrete type. */\n  getElementOfType(type: Type): Element | null {\n    let classReference = type.getClassOrWrapper(this.program);\n    if (classReference) return classReference;\n    return null;\n  }\n\n  // =================================================== Expressions ===================================================\n\n  /** Looks up the program element the specified expression refers to. */\n  lookupExpression(\n    /** The expression to look up. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    while (node.kind == NodeKind.PARENTHESIZED) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.ASSERTION: {\n        return this.lookupAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.BINARY: {\n        return this.lookupBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.CALL: {\n        return this.lookupCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.COMMA: {\n        return this.lookupCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ELEMENTACCESS: {\n        return this.lookupElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.FUNCTION: {\n        return this.lookupFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.TRUE: {\n        return this.lookupIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxFlow.actualFunction, reportMode\n        );\n      }\n      case NodeKind.THIS: {\n        return this.lookupThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.SUPER: {\n        return this.lookupSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.INSTANCEOF: {\n        return this.lookupInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.LITERAL: {\n        return this.lookupLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.NEW: {\n        return this.lookupNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PROPERTYACCESS: {\n        return this.lookupPropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.TERNARY: {\n        return this.lookupTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        return this.lookupUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPREFIX: {\n        return this.lookupUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an expression to its static type. */\n  resolveExpression(\n    /** The expression to resolve. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    while (node.kind == NodeKind.PARENTHESIZED) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.ASSERTION: {\n        return this.resolveAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.BINARY: {\n        return this.resolveBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.CALL: {\n        return this.resolveCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.COMMA: {\n        return this.resolveCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ELEMENTACCESS: {\n        return this.resolveElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.FUNCTION: {\n        return this.resolveFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.TRUE: {\n        return this.resolveIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxType, ctxFlow.actualFunction, reportMode\n        );\n      }\n      case NodeKind.THIS: {\n        return this.resolveThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.SUPER: {\n        return this.resolveSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.INSTANCEOF: {\n        return this.resolveInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.LITERAL: {\n        return this.resolveLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.NEW: {\n        return this.resolveNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PROPERTYACCESS: {\n        return this.resolvePropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.TERNARY: {\n        return this.resolveTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        return this.resolveUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPREFIX: {\n        return this.resolveUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified identifier expression refers to. */\n  lookupIdentifierExpression(\n    /** The expression to look up. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    switch (node.kind) {\n      case NodeKind.TRUE:\n      case NodeKind.FALSE:\n      case NodeKind.NULL: {\n        let type = this.resolveIdentifierExpression(node, ctxFlow, Type.auto, ctxElement, reportMode);\n        return type ? this.getElementOfType(type) : null;\n      }\n    }\n    var name = node.text;\n    var element: Element | null;\n    if (element = ctxFlow.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    var outerFlow = ctxFlow.outer;\n    if (outerFlow) {\n      if (element = outerFlow.lookup(name)) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return element;\n      }\n    }\n    if (element = ctxElement.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (element = this.program.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        node.range, name\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an identifier to its static type. */\n  private resolveIdentifierExpression(\n    /** The expression to resolve. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.TRUE:\n      case NodeKind.FALSE: return Type.bool;\n      case NodeKind.NULL: {\n        let classReference = ctxType.getClass();\n        if (classReference) {\n          return classReference.type.asNullable();\n        } else {\n          let signatureReference = ctxType.getSignature();\n          if (signatureReference) {\n            return signatureReference.type.asNullable();\n          } else if (ctxType.isExternalReference) {\n            return ctxType; // TODO: nullable?\n          }\n        }\n        return this.program.options.usizeType;\n      }\n    }\n    var element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {\n      let instance = this.resolveFunction(<FunctionPrototype>element, null, uniqueMap<string,Type>(), reportMode);\n      if (!instance) return null;\n      element = instance;\n    }\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */\n  private ensureResolvedLazyGlobal(global: Global, reportMode: ReportMode = ReportMode.REPORT): bool {\n    if (global.is(CommonFlags.RESOLVED)) return true;\n    var type: Type | null;\n    var typeNode = global.typeNode;\n    if (typeNode) {\n      type = this.resolveType(typeNode, global.parent, null, reportMode);\n    } else {\n      type = this.resolveExpression(assert(global.initializerNode), global.file.startFunction.flow, Type.auto, reportMode);\n    }\n    if (!type) return false;\n    global.setType(type); // also sets resolved\n    return true;\n  }\n\n  /** Looks up the program element the specified property access expression refers to. */\n  private lookupPropertyAccessExpression(\n    /** The expression to look up. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var targetNode = node.expression;\n    var target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports\n    if (!target) return null;\n    var propertyName = node.property.text;\n\n    // Resolve variable-likes to their class type first\n    switch (target.kind) {\n      case ElementKind.GLOBAL: if (!this.ensureResolvedLazyGlobal(<Global>target, reportMode)) return null;\n      case ElementKind.ENUMVALUE:\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: { // someVar.prop\n        let variableLikeElement = <VariableLikeElement>target;\n        let type = variableLikeElement.type;\n        assert(type != Type.void);\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, variableLikeElement.type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: { // SomeClass.prop\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: { // someInstance.prop\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance); // must have a getter\n        let type = getterInstance.signature.returnType;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.INDEXSIGNATURE: { // someInstance[x].prop\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        let elementExpression = assert(this.currentElementExpression);\n        let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET);\n        if (!indexedGet) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              elementExpression.range, parent.internalName\n            );\n          }\n          return null;\n        }\n        let returnType = indexedGet.signature.returnType;\n        let classReference = returnType.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, returnType.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        // Function with shadow type, i.e. function Symbol() + type Symbol = _Symbol\n        let shadowType = target.shadowType;\n        if (shadowType) {\n          if (!shadowType.is(CommonFlags.RESOLVED)) {\n            let resolvedType = this.resolveType(shadowType.typeNode, shadowType.parent, null, reportMode);\n            if (resolvedType) shadowType.setType(resolvedType);\n          }\n          let classReference = shadowType.type.classReference;\n          if (classReference) target = classReference.prototype;\n          break;\n        } else if (!target.is(CommonFlags.GENERIC)) {\n          // Inherit from 'Function' if not overridden, i.e. fn.call\n          let ownMember = target.getMember(propertyName);\n          if (!ownMember) {\n            let functionInstance = this.resolveFunction(<FunctionPrototype>target, null, uniqueMap<string,Type>(), ReportMode.SWALLOW);\n            if (functionInstance) {\n              let wrapper = functionInstance.type.getClassOrWrapper(this.program);\n              if (wrapper) target = wrapper;\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    // Look up the member within\n    switch (target.kind) {\n      case ElementKind.CLASS_PROTOTYPE:\n      case ElementKind.INTERFACE_PROTOTYPE:\n      case ElementKind.CLASS:\n      case ElementKind.INTERFACE: {\n        do {\n          let member = target.getMember(propertyName);\n          if (member) {\n            if (member.kind == ElementKind.PROPERTY_PROTOTYPE) {\n              let propertyInstance = this.resolveProperty(<PropertyPrototype>member, reportMode);\n              if (!propertyInstance) return null;\n              member = propertyInstance;\n              if (propertyInstance.is(CommonFlags.STATIC)) {\n                this.currentThisExpression = null;\n              } else {\n                this.currentThisExpression = targetNode;\n              }\n            } else {\n              this.currentThisExpression = targetNode;\n            }\n            this.currentElementExpression = null;\n            return member; // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE, PROPERTY...\n          }\n          // traverse inherited static members on the base prototype if target is a class prototype\n          if (\n            target.kind == ElementKind.CLASS_PROTOTYPE ||\n            target.kind == ElementKind.INTERFACE_PROTOTYPE\n          ) {\n            let classPrototype = <ClassPrototype>target;\n            let basePrototype = classPrototype.basePrototype;\n            if (basePrototype) {\n              target = basePrototype;\n            } else {\n              break;\n            }\n          // traverse inherited instance members on the base class if target is a class instance\n          } else if (\n            target.kind == ElementKind.CLASS ||\n            target.kind == ElementKind.INTERFACE\n          ) {\n            let classInstance = <Class>target;\n            let baseInstance = classInstance.base;\n            if (baseInstance) {\n              target = baseInstance;\n            } else {\n              break;\n            }\n          } else {\n            break;\n          }\n        } while (true);\n        break;\n      }\n      default: { // enums or other namespace-like elements\n        let member = target.getMember(propertyName);\n        if (member) {\n          this.currentThisExpression = targetNode;\n          this.currentElementExpression = null;\n          return member; // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...\n        }\n        break;\n      }\n    }\n\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Property_0_does_not_exist_on_type_1,\n        node.property.range, propertyName, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a property access expression to its static type. */\n  private resolvePropertyAccessExpression(\n    /** The expression to resolve. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified element access expression refers to. */\n  private lookupElementAccessExpression(\n    /** The expression to look up. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var targetExpression = node.expression;\n    var targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);\n    if (!targetType) return null;\n    let classReference = targetType.getClassOrWrapper(this.program);\n    if (classReference) {\n      do {\n        let indexSignature = classReference.indexSignature;\n        if (indexSignature) {\n          this.currentThisExpression = targetExpression;\n          this.currentElementExpression = node.elementExpression;\n          return indexSignature;\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        targetExpression.range, targetType.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an element access expression to its static type. */\n  private resolveElementAccessExpression(\n    /** The expression to resolve. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Determines the final type of an integer literal given the specified contextual type. */\n  determineIntegerLiteralType(\n    /** Integer literal value. */\n    intValue: i64,\n    /** Contextual type. */\n    ctxType: Type\n  ): Type {\n    if (ctxType.isValue) {\n      // compile to contextual type if matching\n      switch (ctxType.kind) {\n        case TypeKind.I8: {\n          if (i64_is_i8(intValue)) return Type.i8;\n          break;\n        }\n        case TypeKind.U8: {\n          if (i64_is_u8(intValue)) return Type.u8;\n          break;\n        }\n        case TypeKind.I16: {\n          if (i64_is_i16(intValue)) return Type.i16;\n          break;\n        }\n        case TypeKind.U16: {\n          if (i64_is_u16(intValue)) return Type.u16;\n          break;\n        }\n        case TypeKind.I32: {\n          if (i64_is_i32(intValue)) return Type.i32;\n          break;\n        }\n        case TypeKind.U32: {\n          if (i64_is_u32(intValue)) return Type.u32;\n          break;\n        }\n        case TypeKind.BOOL: {\n          if (i64_is_bool(intValue)) return Type.bool;\n          break;\n        }\n        case TypeKind.ISIZE: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_i32(intValue)) return Type.isize32;\n            break;\n          }\n          return Type.isize64;\n        }\n        case TypeKind.USIZE: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_u32(intValue)) return Type.usize32;\n            break;\n          }\n          return Type.usize64;\n        }\n        case TypeKind.I64: return Type.i64;\n        case TypeKind.U64: return Type.u64;\n        case TypeKind.F32: return Type.f32;\n        case TypeKind.F64: return Type.f64;\n      }\n    }\n    // otherwise compile to best fitting type\n    if (i64_is_i32(intValue)) return Type.i32;\n    if (i64_is_u32(intValue)) return Type.u32;\n    return Type.i64; // TODO: u64 if positive and larger than i64?\n  }\n\n  /** Looks up the program element the specified assertion expression refers to. */\n  private lookupAssertionExpression(\n    /** The expression to look up. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    switch (node.assertionKind) {\n      case AssertionKind.AS:\n      case AssertionKind.PREFIX: {\n        let type = this.resolveType(\n          assert(node.toType), // must be set if not NONNULL\n          ctxFlow.actualFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n        if (!type) return null;\n        let element = this.getElementOfType(type);\n        if (element) return element;\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_illegal_in_this_context,\n            node.range, type.toString()\n          );\n        }\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return null;\n      }\n      case AssertionKind.NONNULL: {\n        return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n      }\n      case AssertionKind.CONST: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n        // if (!element) return null;\n        // if (element.kind == ElementKind.CLASS && (<Class>element).extends(this.program.arrayPrototype)) {\n        //   let elementType = assert((<Class>element).getTypeArgumentsTo(this.program.arrayPrototype))[0];\n        //   return this.resolveClass(this.program.readonlyArrayPrototype, [ elementType ]);\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          node.range,\n          \"Const assertion\"\n        );\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an assertion expression to its static type. */\n  private resolveAssertionExpression(\n    /** The expression to resolve. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.assertionKind) {\n      case AssertionKind.AS:\n      case AssertionKind.PREFIX: {\n        return this.resolveType(\n          assert(node.toType),\n          ctxFlow.actualFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n      }\n      case AssertionKind.NONNULL: {\n        let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);\n        return type ? type.nonNullableType : null;\n      }\n      case AssertionKind.CONST: {\n        let element = this.lookupExpression(node, ctxFlow, ctxType, reportMode);\n        if (!element) return null;\n        let type = this.getTypeOfElement(element);\n        if (!type) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n              node.range\n            );\n          }\n        }\n        return type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary prefix expression refers to. */\n  private lookupUnaryPrefixExpression(\n    /** The expression to look up. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary prefix expression to its static type. */\n  private resolveUnaryPrefixExpression(\n    /** The expression to resolve. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var operand = node.operand;\n    var operator = node.operator;\n    switch (operator) {\n      case Token.MINUS: {\n        // implicitly negate if an integer literal to distinguish between i32/u32/i64\n        if (operand.isLiteralKind(LiteralKind.INTEGER)) {\n          return this.determineIntegerLiteralType(i64_sub(i64_zero, (<IntegerLiteralExpression>operand).value), ctxType);\n        }\n        // fall-through\n      }\n      case Token.PLUS:\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPrefixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n      case Token.EXCLAMATION: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.NOT);\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool; // incl. references\n      }\n      case Token.TILDE: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, \"~\", type.toString()\n            );\n          }\n          return null;\n        }\n        return type.intType;\n      }\n      case Token.DOT_DOT_DOT: {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            node.range, \"Spread operator\"\n          );\n        }\n        return null;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary postfix expression refers to. */\n  private lookupUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary postfix expression to its static type. */\n  private resolveUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var operator = node.operator;\n    switch (operator) {\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPostfixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified binary expression refers to. */\n  private lookupBinaryExpression(\n    /** The expression to look up. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (element) return element; // otherwise void\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Type_0_is_illegal_in_this_context,\n        node.range, type.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a binary expression to its static type. */\n  private resolveBinaryExpression(\n    /** The expression to resolve. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var left = node.left;\n    var right = node.right;\n    var operator = node.operator;\n\n    switch (operator) {\n\n      // assignment: result is the target's type\n\n      case Token.EQUALS:\n      case Token.PLUS_EQUALS:\n      case Token.MINUS_EQUALS:\n      case Token.ASTERISK_EQUALS:\n      case Token.ASTERISK_ASTERISK_EQUALS:\n      case Token.SLASH_EQUALS:\n      case Token.PERCENT_EQUALS:\n      case Token.LESSTHAN_LESSTHAN_EQUALS:\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n      case Token.AMPERSAND_EQUALS:\n      case Token.BAR_EQUALS:\n      case Token.CARET_EQUALS: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n\n      // comparison: result is Bool, preferring overloads, integer/float only\n\n      case Token.LESSTHAN:\n      case Token.GREATERTHAN:\n      case Token.LESSTHAN_EQUALS:\n      case Token.GREATERTHAN_EQUALS: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return Type.bool;\n      }\n\n      // equality: result is Bool, preferring overloads, incl. references\n\n      case Token.EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool;\n      }\n\n      // identity: result is Bool, not supporting overloads\n\n      case Token.EQUALS_EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS_EQUALS: {\n        return Type.bool;\n      }\n\n      // arithmetics: result is common type of LHS and RHS, preferring overloads\n\n      case Token.PLUS:\n      case Token.MINUS:\n      case Token.ASTERISK:\n      case Token.SLASH:\n      case Token.PERCENT: // mod has special logic, but also behaves like this\n      case Token.ASTERISK_ASTERISK: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // shift: result is LHS (RHS is converted to LHS), preferring overloads\n\n      case Token.LESSTHAN_LESSTHAN:\n      case Token.GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isIntegerValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return leftType;\n      }\n\n      // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads\n\n      case Token.AMPERSAND:\n      case Token.BAR:\n      case Token.CARET: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType || !commonType.isIntegerValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // logical: result is LHS (RHS is converted to LHS), not supporting overloads\n\n      case Token.AMPERSAND_AMPERSAND:\n      case Token.BAR_BAR: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified this expression refers to. */\n  private lookupThisExpression(\n    /** The expression to look up. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let thisLocal = ctxFlow.lookupLocal(CommonNames.this_);\n      if (thisLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return thisLocal;\n      }\n    }\n    var parent = ctxFlow.actualFunction.parent;\n    if (parent) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return parent;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode._this_cannot_be_referenced_in_current_location,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a this expression to its static type. */\n  private resolveThisExpression(\n    /** The expression to resolve. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified super expression refers to. */\n  private lookupSuperExpression(\n    /** The expression to look up. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let superLocal = ctxFlow.lookupLocal(CommonNames.super_);\n      if (superLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return superLocal;\n      }\n    }\n    var parent: Element | null = ctxFlow.actualFunction.parent;\n    if (parent !== null && parent.kind == ElementKind.CLASS) {\n      let base = (<Class>parent).base;\n      if (base) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return base;\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a super expression to its static type. */\n  private resolveSuperExpression(\n    /** The expression to resolve. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified literal expression refers to. */\n  private lookupLiteralExpression(\n    /** The expression to look up. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    this.currentThisExpression = node;\n    this.currentElementExpression = null;\n    switch (node.literalKind) {\n      case LiteralKind.INTEGER: {\n        let intType = this.determineIntegerLiteralType(\n          (<IntegerLiteralExpression>node).value,\n          ctxType\n        );\n        return assert(intType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.FLOAT: {\n        let fltType = ctxType == Type.f32 ? Type.f32 : Type.f64;\n        return assert(fltType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.STRING:\n      case LiteralKind.TEMPLATE: {\n        return this.program.stringInstance;\n      }\n      case LiteralKind.ARRAY: {\n        let classReference = ctxType.getClass();\n        if (classReference !== null && classReference.prototype == this.program.arrayPrototype) {\n          return this.getElementOfType(ctxType);\n        }\n        // otherwise infer, ignoring ctxType\n        let expressions = (<ArrayLiteralExpression>node).elementExpressions;\n        let length = expressions.length;\n        let elementType = Type.auto;\n        let numNullLiterals = 0;\n        for (let i = 0, k = length; i < k; ++i) {\n          let expression = expressions[i];\n          if (expression) {\n            if (expression.kind == NodeKind.NULL && length > 1) {\n              ++numNullLiterals;\n            } else {\n              let currentType = this.resolveExpression(expression, ctxFlow, elementType);\n              if (!currentType) return null;\n              if (elementType == Type.auto) elementType = currentType;\n              else if (currentType != elementType) {\n                let commonType = Type.commonDenominator(elementType, currentType, false);\n                if (commonType) elementType = commonType;\n                // otherwise triggers error on compilation\n              }\n            }\n          }\n        }\n        if (elementType /* still */ == Type.auto) {\n          if (numNullLiterals == length) { // all nulls infers as usize\n            elementType = this.program.options.usizeType;\n          } else {\n            if (reportMode == ReportMode.REPORT) {\n              this.error(\n                DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,\n                node.range, \"T\"\n              );\n            }\n            return null;\n          }\n        }\n        if (\n          numNullLiterals > 0 &&\n          elementType.isInternalReference\n        ) {\n          elementType = elementType.asNullable();\n        }\n        return assert(this.resolveClass(this.program.arrayPrototype, [ elementType ]));\n      }\n      case LiteralKind.OBJECT: {\n        if (ctxType.isClass) return ctxType.classReference;\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            node.range\n          );\n        }\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves a literal expression to its static type. */\n  private resolveLiteralExpression(\n    /** The expression to resolve. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified call expression refers to. */\n  private lookupCallExpression(\n    /** The expression to look up. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a call expression to its static type. */\n  private resolveCallExpression(\n    /** The expression to resolve. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var targetExpression = node.expression;\n    var target = this.lookupExpression( // reports\n      targetExpression,\n      ctxFlow,\n      ctxType,\n      reportMode\n    );\n    if (!target) return null;\n    switch (target.kind) {\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        // `unchecked` behaves like parenthesized\n        if (\n          functionPrototype.internalName == BuiltinNames.unchecked &&\n          node.args.length > 0\n        ) {\n          return this.resolveExpression(node.args[0], ctxFlow, ctxType, reportMode);\n        }\n        let instance = this.maybeInferCall(node, functionPrototype, ctxFlow, reportMode);\n        if (!instance) return null;\n        return instance.signature.returnType;\n      }\n      case ElementKind.GLOBAL:\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: {\n        let varType = (<VariableLikeElement>target).type;\n        let varElement = this.getElementOfType(varType);\n        if (!varElement || varElement.kind != ElementKind.CLASS) {\n          break;\n        }\n        target = varElement;\n        // fall-through\n      }\n      case ElementKind.CLASS: {\n        let typeArguments = (<Class>target).getTypeArgumentsTo(this.program.functionPrototype);\n        if (typeArguments !== null && typeArguments.length > 0) {\n          let ftype = typeArguments[0];\n          let signatureReference = assert(ftype.signatureReference);\n          return signatureReference.returnType;\n        }\n        break;\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n        targetExpression.range, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified comma expression refers to. */\n  private lookupCommaExpression(\n    /** The expression to look up. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var expressions = node.expressions;\n    return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Resolves a comma expression to its static type. */\n  private resolveCommaExpression(\n    /** The expression to resolve. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var expressions = node.expressions;\n    return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Looks up the program element the specified instanceof expression refers to. */\n  private lookupInstanceOfExpression(\n    /** The expression to look up. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    return assert(Type.bool.getClassOrWrapper(this.program));\n  }\n\n  /** Resolves an instanceof expression to its static type. */\n  private resolveInstanceOfExpression(\n    /** The expression to resolve. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    return Type.bool;\n  }\n\n  /** Looks up the program element the specified ternary expression refers to. */\n  private lookupTernaryExpression(\n    /** The expression to look up. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a ternary expression to its static type. */\n  private resolveTernaryExpression(\n    /** The expression to resolve. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);\n    if (!thenType) return null;\n    var elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);\n    if (!elseType) return null;\n    var commonType = Type.commonDenominator(thenType, elseType, false);\n    if (!commonType) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n          node.range, \"?:\", thenType.toString(), elseType.toString()\n        );\n      }\n    }\n    return commonType;\n  }\n\n  /** Looks up the program element the specified new expression refers to. */\n  private lookupNewExpression(\n    /** The expression to look up. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var element = this.resolveTypeName(node.typeName, ctxFlow.actualFunction, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.CLASS_PROTOTYPE) {\n      return this.resolveClassInclTypeArguments(\n        <ClassPrototype>element,\n        node.typeArguments,\n        ctxFlow.actualFunction,\n        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),\n        node,\n        reportMode\n      );\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a new expression to its static type. */\n  private resolveNewExpression(\n    /** The expression to resolve. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified function expression refers to. */\n  private lookupFunctionExpression(\n    /** The expression to look up. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a function expression to its static type. */\n  private resolveFunctionExpression(\n    /** The expression to resolve. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    return this.resolveFunctionType(node.declaration.signature, ctxFlow.actualFunction, ctxFlow.contextualTypeArguments, reportMode);\n  }\n\n  // ==================================================== Elements =====================================================\n\n  /** Resolves a function prototype using the specified concrete type arguments. */\n  resolveFunction(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE\n      ? prototype.parent.parent\n      : prototype.parent;\n    var classInstance: Class | null = null; // if an instance method\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Instance method prototypes are pre-bound to their concrete class as their parent\n    if (prototype.is(CommonFlags.INSTANCE)) {\n      assert(actualParent.kind == ElementKind.CLASS || actualParent.kind == ElementKind.INTERFACE);\n      classInstance = <Class>actualParent;\n\n      // check if this exact concrete class and function combination is known already\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n\n      // inherit class specific type arguments\n      let classTypeArguments = classInstance.typeArguments;\n      if (classTypeArguments) {\n        let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);\n        let numClassTypeArguments = classTypeParameters.length;\n        assert(numClassTypeArguments == classTypeParameters.length);\n        for (let i = 0; i < numClassTypeArguments; ++i) {\n          let classTypeParameterName = classTypeParameters[i].name.text;\n          // override contextual\n          ctxTypes.set(classTypeParameterName, classTypeArguments[i]);\n        }\n      }\n    } else {\n      assert(actualParent.kind != ElementKind.CLASS); // must not be pre-bound\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n    }\n\n    // override whatever is contextual with actual function type arguments\n    var signatureNode = prototype.functionTypeNode;\n    var typeParameterNodes = prototype.typeParameterNodes;\n    var numFunctionTypeArguments: i32;\n    if (typeArguments !== null && (numFunctionTypeArguments = typeArguments.length) > 0) {\n      assert(typeParameterNodes !== null && numFunctionTypeArguments == typeParameterNodes.length);\n      for (let i = 0; i < numFunctionTypeArguments; ++i) {\n        ctxTypes.set(\n          (<TypeParameterNode[]>typeParameterNodes)[i].name.text,\n          typeArguments[i]\n        );\n      }\n    } else {\n      assert(!typeParameterNodes || typeParameterNodes.length == 0);\n    }\n\n    // resolve `this` type if applicable\n    var thisType: Type | null = null;\n    var explicitThisType = signatureNode.explicitThisType;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n      ctxTypes.set(CommonNames.this_, thisType);\n    } else if (classInstance) {\n      thisType = classInstance.type;\n      ctxTypes.set(CommonNames.this_, thisType);\n    }\n\n    // resolve parameter types\n    var signatureParameters = signatureNode.parameters;\n    var numSignatureParameters = signatureParameters.length;\n    var parameterTypes = new Array<Type>(numSignatureParameters);\n    var requiredParameters = 0;\n    for (let i = 0; i < numSignatureParameters; ++i) {\n      let parameterDeclaration = signatureParameters[i];\n      if (parameterDeclaration.parameterKind == ParameterKind.DEFAULT) {\n        requiredParameters = i + 1;\n      }\n      let typeNode = parameterDeclaration.type;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      if (parameterType == Type.void) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      parameterTypes[i] = parameterType;\n    }\n\n    // resolve return type\n    var returnType: Type;\n    if (prototype.is(CommonFlags.SET)) {\n      returnType = Type.void; // not annotated\n    } else if (prototype.is(CommonFlags.CONSTRUCTOR)) {\n      returnType = classInstance!.type; // not annotated\n    } else {\n      let typeNode = signatureNode.returnType;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let type = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      returnType = type;\n    }\n\n    var signature = new Signature(this.program, parameterTypes, returnType, thisType);\n    signature.requiredParameters = requiredParameters;\n\n    var nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += \"<\" + instanceKey + \">\";\n    var instance = new Function(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      signature,\n      ctxTypes\n    );\n    prototype.setResolvedInstance(instanceKey, instance);\n\n    // remember discovered overloads for virtual stub finalization\n    if (classInstance) {\n      let methodOrPropertyName = instance.declaration.name.text;\n      let baseClass = classInstance.base;\n      while (baseClass) {\n        let baseMembers = baseClass.members;\n        if (baseMembers && baseMembers.has(methodOrPropertyName)) {\n          this.discoveredOverload = true;\n          break;\n        }\n        baseClass = baseClass.base;\n      }\n    }\n    return instance;\n  }\n\n  /** Resolves a function prototypeby first resolving the specified type arguments. */\n  resolveFunctionInclTypeArguments(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE\n      ? prototype.parent.parent\n      : prototype.parent;\n    var resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.GENERIC)) {\n\n      // If this is an instance method, first apply the class's type arguments\n      if (prototype.is(CommonFlags.INSTANCE)) {\n        assert(actualParent.kind == ElementKind.CLASS);\n        let classInstance = <Class>actualParent;\n        let classTypeArguments = classInstance.typeArguments;\n        if (classTypeArguments) {\n          let typeParameterNodes = assert(classInstance.prototype.typeParameterNodes);\n          let numClassTypeArguments = classTypeArguments.length;\n          assert(numClassTypeArguments == typeParameterNodes.length);\n          for (let i = 0; i < numClassTypeArguments; ++i) {\n            ctxTypes.set(\n              typeParameterNodes[i].name.text,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes),\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveFunction(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves reachable overloads of the given instance method. */\n  resolveOverloads(instance: Function): Function[] | null {\n    var overloadPrototypes = instance.prototype.overloads;\n    if (!overloadPrototypes) return null;\n\n    var parentClassInstance = assert(instance.getClassOrInterface());\n    var overloads = new Set<Function>();\n\n    // A method's `overloads` property contains its unbound overload prototypes\n    // so we first have to find the concrete classes it became bound to, obtain\n    // their bound prototypes and make sure these are resolved.\n    for (let _values = Set_values(overloadPrototypes), i = 0, k = _values.length; i < k; ++i) {\n      let unboundOverloadPrototype = _values[i];\n      assert(!unboundOverloadPrototype.isBound);\n      let unboundOverloadParent = unboundOverloadPrototype.parent;\n      let isProperty = unboundOverloadParent.kind == ElementKind.PROPERTY_PROTOTYPE;\n      let classInstances: Map<string,Class> | null;\n      if (isProperty) {\n        let propertyParent = (<PropertyPrototype>unboundOverloadParent).parent;\n        assert(propertyParent.kind == ElementKind.CLASS_PROTOTYPE);\n        classInstances = (<ClassPrototype>propertyParent).instances;\n      } else {\n        assert(unboundOverloadParent.kind == ElementKind.CLASS_PROTOTYPE);\n        classInstances = (<ClassPrototype>unboundOverloadParent).instances;\n      }\n      if (!classInstances) continue;\n      for (let _values = Map_values(classInstances), j = 0, l = _values.length; j < l; ++j) {\n        let classInstance = _values[j];\n        // Check if the parent class is a subtype of instance's class\n        if (!classInstance.isAssignableTo(parentClassInstance)) continue;\n        let overloadInstance: Function | null;\n        if (isProperty) {\n          let boundProperty = assert(classInstance.members!.get(unboundOverloadParent.name));\n          assert(boundProperty.kind == ElementKind.PROPERTY_PROTOTYPE);\n          let boundPropertyInstance = this.resolveProperty(<PropertyPrototype>boundProperty);\n          if (!boundPropertyInstance) continue;\n          if (instance.is(CommonFlags.GET)) {\n            overloadInstance = boundPropertyInstance.getterInstance;\n          } else {\n            assert(instance.is(CommonFlags.SET));\n            overloadInstance = boundPropertyInstance.setterInstance;\n          }\n        } else {\n          let boundPrototype = assert(classInstance.members!.get(unboundOverloadPrototype.name));\n          assert(boundPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          overloadInstance = this.resolveFunction(<FunctionPrototype>boundPrototype, instance.typeArguments);\n        }\n        if (overloadInstance) overloads.add(overloadInstance);\n      }\n    }\n    return Set_values(overloads);\n  }\n\n  /** Currently resolving classes. */\n  private resolveClassPending: Set<Class> = new Set();\n\n  /** Resolves a class prototype using the specified concrete type arguments. */\n  resolveClass(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Class | null {\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Do not attempt to resolve the same class twice. This can return a class\n    // that isn't fully resolved yet, but only on deeper levels of recursion.\n    var instance = prototype.getResolvedInstance(instanceKey);\n    if (instance) return instance;\n\n    // Otherwise create\n    var nameInclTypeParamters = prototype.name;\n    if (instanceKey.length) nameInclTypeParamters += \"<\" + instanceKey + \">\";\n    if (prototype.kind == ElementKind.INTERFACE_PROTOTYPE) {\n      instance = new Interface(nameInclTypeParamters, <InterfacePrototype>prototype, typeArguments);\n    } else {\n      instance = new Class(nameInclTypeParamters, prototype, typeArguments);\n    }\n    prototype.setResolvedInstance(instanceKey, instance);\n    var pendingClasses = this.resolveClassPending;\n    pendingClasses.add(instance);\n\n    // Insert contextual type arguments for this operation. Internally, this method is always\n    // called with matching type parameter / argument counts.\n    if (typeArguments) {\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let numTypeArguments = typeArguments.length;\n      assert(numTypeArguments == numTypeParameters);\n      for (let i = 0; i < numTypeArguments; ++i) {\n        ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);\n      }\n    } else {\n      let typeParameterNodes = prototype.typeParameterNodes;\n      assert(!(typeParameterNodes !== null && typeParameterNodes.length > 0));\n    }\n    instance.contextualTypeArguments = ctxTypes;\n\n    var anyPending = false;\n\n    // Resolve base class if applicable\n    var basePrototype = prototype.basePrototype;\n    if (basePrototype) {\n      let current: ClassPrototype | null = basePrototype;\n      do {\n        if (current == prototype) {\n          this.error(\n            DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n            prototype.identifierNode.range,\n            prototype.internalName\n          );\n          return null;\n        }\n        current = current.basePrototype;\n      } while (current);\n      let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype\n      let base = this.resolveClassInclTypeArguments(\n        basePrototype,\n        extendsNode.typeArguments,\n        prototype.parent, // relative to derived class\n        uniqueMap(ctxTypes), // don't inherit\n        extendsNode,\n        reportMode\n      );\n      if (!base) return null;\n      instance.setBase(base);\n\n      // If the base class is still pending, yield here and instead resolve any\n      // derived classes once the base class's `finishResolveClass` is done.\n      // This is guaranteed to never happen at the entry of the recursion, i.e.\n      // where `resolveClass` is called from other code.\n      if (pendingClasses.has(base)) anyPending = true;\n    }\n\n    // Resolve interfaces if applicable\n    var interfacePrototypes = prototype.interfacePrototypes;\n    if (interfacePrototypes) {\n      for (let i = 0, k = interfacePrototypes.length; i < k; ++i) {\n        let interfacePrototype = interfacePrototypes[i];\n        let current: ClassPrototype | null = interfacePrototype;\n        do {\n          if (current == prototype) {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              prototype.identifierNode.range,\n              prototype.internalName\n            );\n            return null;\n          }\n          current = current.basePrototype;\n        } while (current);\n        let implementsNode = assert(prototype.implementsNodes![i]);\n        let iface = this.resolveClassInclTypeArguments(\n          interfacePrototype,\n          implementsNode.typeArguments,\n          prototype.parent,\n          uniqueMap(ctxTypes),\n          implementsNode,\n          reportMode\n        );\n        if (!iface) return null;\n        assert(iface.kind == ElementKind.INTERFACE);\n        instance.addInterface(<Interface>iface);\n\n        // Like above, if any implemented interface is still pending, yield\n        if (pendingClasses.has(iface)) anyPending = true;\n      }\n    }\n    if (anyPending) return instance;\n\n    // We only get here if the base class has been fully resolved already.\n    this.finishResolveClass(instance, reportMode);\n    return instance;\n  }\n\n  /** Finishes resolving the specified class. */\n  private finishResolveClass(\n    /** Class to finish resolving. */\n    instance: Class,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode\n  ): void {\n    var members = instance.members;\n    if (!members) instance.members = members = new Map();\n\n    var pendingClasses = this.resolveClassPending;\n    var unimplemented = new Map<string,DeclaredElement>();\n\n    // Alias interface members\n    var interfaces = instance.interfaces;\n    if (interfaces) {\n      for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n        let iface = _values[i];\n        assert(!pendingClasses.has(iface));\n        let ifaceMembers = iface.members;\n        if (ifaceMembers) {\n          for (let _keys = Map_keys(ifaceMembers), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let member = assert(ifaceMembers.get(memberName));\n            if (members.has(memberName)) {\n              let existing = assert(members.get(memberName));\n              if (!member.isCompatibleOverride(existing)) {\n                this.errorRelated(\n                  DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n                  member.identifierAndSignatureRange, existing.identifierAndSignatureRange\n                );\n                continue;\n              }\n            }\n            members.set(memberName, member);\n            unimplemented.set(memberName, member);\n          }\n        }\n      }\n    }\n\n    // Alias base members\n    var memoryOffset: u32 = 0;\n    var base = instance.base;\n    if (base) {\n      assert(!pendingClasses.has(base));\n      let baseMembers = base.members;\n      if (baseMembers) {\n        // TODO: for (let [baseMemberName, baseMember] of baseMembers) {\n        for (let _keys = Map_keys(baseMembers), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(baseMembers.get(memberName));\n          if (members.has(memberName)) {\n            let existing = assert(members.get(memberName));\n            if (!member.isCompatibleOverride(existing)) {\n              this.errorRelated(\n                DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n                member.identifierAndSignatureRange, existing.identifierAndSignatureRange\n              );\n              continue;\n            }\n          }\n          members.set(memberName, member);\n          if (member.is(CommonFlags.ABSTRACT)) {\n            unimplemented.set(memberName, member);\n          } else {\n            unimplemented.delete(memberName);\n          }\n        }\n      }\n      memoryOffset = base.nextMemoryOffset;\n    }\n\n    // Resolve instance members\n    var prototype = instance.prototype;\n    var instanceMemberPrototypes = prototype.instanceMembers;\n    var properties = new Array<Property>();\n    if (instanceMemberPrototypes) {\n      // TODO: for (let member of instanceMemberPrototypes.values()) {\n      for (let _values = Map_values(instanceMemberPrototypes), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        let memberName = member.name;\n        switch (member.kind) {\n\n          case ElementKind.FIELD_PROTOTYPE: {\n            let fieldPrototype = <FieldPrototype>member;\n            let fieldTypeNode = fieldPrototype.typeNode;\n            let fieldType: Type | null = null;\n            let existingField: Field | null = null;\n            if (base) {\n              let baseMembers = base.members;\n              if (baseMembers !== null && baseMembers.has(fieldPrototype.name)) {\n                let baseField = assert(baseMembers.get(fieldPrototype.name));\n                if (baseField.kind == ElementKind.FIELD) {\n                  existingField = <Field>baseField;\n                } else {\n                  this.errorRelated(\n                    DiagnosticCode.Duplicate_identifier_0,\n                    fieldPrototype.identifierNode.range, baseField.identifierNode.range,\n                    fieldPrototype.name\n                  );\n                }\n              }\n            }\n            if (!fieldTypeNode) {\n              if (existingField !== null && !existingField.is(CommonFlags.PRIVATE)) {\n                fieldType = existingField.type;\n              }\n              if (!fieldType) {\n                if (reportMode == ReportMode.REPORT) {\n                  this.error(\n                    DiagnosticCode.Type_expected,\n                    fieldPrototype.identifierNode.range.atEnd\n                  );\n                }\n              }\n            } else {\n              fieldType = this.resolveType(\n                fieldTypeNode,\n                prototype.parent, // relative to class\n                instance.contextualTypeArguments,\n                reportMode\n              );\n              if (fieldType == Type.void) {\n                if (reportMode == ReportMode.REPORT) {\n                  this.error(\n                    DiagnosticCode.Type_expected,\n                    fieldTypeNode.range\n                  );\n                }\n                break;\n              }\n            }\n            if (!fieldType) break; // did report above\n            if (existingField !== null) {\n              // visibility checks\n              /*\n                          existingField visibility on top\n                +==================+=========+===========+=========+\n                | Visibility Table | Private | Protected | Public  |\n                +==================+=========+===========+=========+\n                | Private          | error   | error     | error   |\n                +------------------+---------+-----------+---------+\n                | Protected        | error   | allowed   | error   |\n                +------------------+---------+-----------+---------+\n                | Public           | error   | allowed   | allowed |\n                +------------------+---------+-----------+---------+\n              */\n\n              let baseClass = <Class>base;\n\n              // handle cases row-by-row\n              if (fieldPrototype.is(CommonFlags.PRIVATE)) {\n                if (existingField.is(CommonFlags.PRIVATE)) {\n                  this.errorRelated(\n                    DiagnosticCode.Types_have_separate_declarations_of_a_private_property_0,\n                    fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                    fieldPrototype.name\n                  );\n                } else {\n                  this.errorRelated(\n                    DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n                    fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                    fieldPrototype.name, instance.internalName, baseClass.internalName\n                  );\n                }\n              } else if (fieldPrototype.is(CommonFlags.PROTECTED)) {\n                if (existingField.is(CommonFlags.PRIVATE)) {\n                  this.errorRelated(\n                    DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n                    fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                    fieldPrototype.name, baseClass.internalName, instance.internalName\n                  );\n                } else if (!existingField.is(CommonFlags.PROTECTED)) {\n                  // may be implicitly public\n                  this.errorRelated(\n                    DiagnosticCode.Property_0_is_protected_in_type_1_but_public_in_type_2,\n                    fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                    fieldPrototype.name, instance.internalName, baseClass.internalName\n                  );\n                }\n              } else {\n                // fieldPrototype is public here\n                if (existingField.is(CommonFlags.PRIVATE)) {\n                  this.errorRelated(\n                    DiagnosticCode.Property_0_is_private_in_type_1_but_not_in_type_2,\n                    fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                    fieldPrototype.name, baseClass.internalName, instance.internalName\n                  );\n                }\n              }\n\n              // assignability\n              if (!fieldType.isStrictlyAssignableTo(existingField.type)) {\n                this.errorRelated(\n                  DiagnosticCode.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,\n                  fieldPrototype.identifierNode.range, existingField.identifierNode.range,\n                  fieldPrototype.name, instance.internalName, baseClass.internalName\n                );\n              }\n            }\n            let fieldInstance = new Field(fieldPrototype, instance, fieldType);\n            assert(isPowerOf2(fieldType.byteSize));\n            if (existingField !== null) {\n              fieldInstance.memoryOffset = existingField.memoryOffset;\n            } else {\n              let mask = fieldType.byteSize - 1;\n              if (memoryOffset & mask) memoryOffset = (memoryOffset | mask) + 1;\n              fieldInstance.memoryOffset = memoryOffset;\n              memoryOffset += fieldType.byteSize;\n            }\n            instance.add(memberName, fieldInstance); // reports\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            let boundPrototype = (<FunctionPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let boundPrototype = (<PropertyPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          default: assert(false);\n        }\n        if (!member.is(CommonFlags.ABSTRACT)) {\n          unimplemented.delete(memberName);\n        }\n      }\n    }\n\n    // Check that property getters and setters match\n    for (let i = 0, k = properties.length; i < k; ++i) {\n      let property = properties[i];\n      let propertyGetter = property.getterInstance;\n      if (!propertyGetter) {\n        this.error(\n          DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,\n          property.identifierNode.range, property.name\n        );\n      } else {\n        let propertySetter = property.setterInstance;\n        if (propertySetter !== null && !propertyGetter.visibilityEquals(propertySetter)) {\n          this.errorRelated(\n            DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility,\n            propertyGetter.identifierNode.range, propertySetter.identifierNode.range\n          );\n        }\n      }\n    }\n\n    if (instance.kind != ElementKind.INTERFACE) {\n\n      // Check that all required members are implemented\n      if (!instance.is(CommonFlags.ABSTRACT) && unimplemented.size > 0) {\n        for (let _keys = Map_keys(unimplemented), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = _keys[i];\n          let member = assert(unimplemented.get(memberName));\n          this.errorRelated(\n            DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,\n            instance.identifierNode.range, member.identifierNode.range,\n            instance.internalName, memberName, member.parent.internalName\n          );\n        }\n      }\n\n      // Finalize memory offset\n      instance.nextMemoryOffset = memoryOffset;\n\n      // Link _own_ constructor if present\n      {\n        let ctorPrototype = instance.getMember(CommonNames.constructor);\n        if (ctorPrototype !== null && ctorPrototype.parent === instance) {\n          assert(ctorPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          let ctorInstance = this.resolveFunction(\n            <FunctionPrototype>ctorPrototype,\n            null,\n            assert(instance.contextualTypeArguments),\n            reportMode\n          );\n          if (ctorInstance) instance.constructorInstance = <Function>ctorInstance;\n        }\n      }\n    }\n\n    // Fully resolve operator overloads (don't have type parameters on their own)\n    var overloadPrototypes = prototype.overloadPrototypes;\n    // TODO: for (let [overloadKind, overloadPrototype] of overloadPrototypes) {\n    for (let _keys = Map_keys(overloadPrototypes), i = 0, k = _keys.length; i < k; ++i) {\n      let overloadKind = unchecked(_keys[i]);\n      let overloadPrototype = assert(overloadPrototypes.get(overloadKind));\n      assert(overloadKind != OperatorKind.INVALID);\n      if (overloadPrototype.is(CommonFlags.GENERIC)) {\n        // Already errored during initialization: AS212: Decorator '@operator' is not valid here\n        continue;\n      }\n      let operatorInstance: Function | null;\n      if (overloadPrototype.is(CommonFlags.INSTANCE)) {\n        let boundPrototype = overloadPrototype.toBound(instance);\n        operatorInstance = this.resolveFunction(\n          boundPrototype,\n          null,\n          uniqueMap<string,Type>(),\n          reportMode\n        );\n      } else {\n        operatorInstance = this.resolveFunction(\n          overloadPrototype,\n          null,\n          uniqueMap<string,Type>(),\n          reportMode\n        );\n      }\n      if (!operatorInstance) continue;\n      let overloads = instance.overloads;\n      if (!overloads) instance.overloads = overloads = new Map();\n      // inc/dec are special in that an instance overload attempts to re-assign\n      // the corresponding value, thus requiring a matching return type, while a\n      // static overload works like any other overload.\n      if (operatorInstance.is(CommonFlags.INSTANCE)) {\n        switch (overloadKind) {\n          case OperatorKind.PREFIX_INC:\n          case OperatorKind.PREFIX_DEC:\n          case OperatorKind.POSTFIX_INC:\n          case OperatorKind.POSTFIX_DEC: {\n            let returnType = operatorInstance.signature.returnType;\n            if (!returnType.isAssignableTo(instance.type)) {\n              if (reportMode == ReportMode.REPORT) {\n                this.error(\n                  DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n                  overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString()\n                );\n              }\n            }\n          }\n        }\n      }\n      if (!overloads.has(overloadKind)) {\n        overloads.set(overloadKind, operatorInstance);\n        if (overloadKind == OperatorKind.INDEXED_GET || overloadKind == OperatorKind.INDEXED_SET) {\n          let index = instance.indexSignature;\n          if (!index) instance.indexSignature = index = new IndexSignature(instance);\n          if (overloadKind == OperatorKind.INDEXED_GET) {\n            index.setType(operatorInstance.signature.returnType);\n          }\n        }\n      } else {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Duplicate_decorator,\n            operatorInstance.declaration.range\n          );\n        }\n      }\n    }\n\n    // Remove this class from pending\n    assert(pendingClasses.has(instance)); // must be pending\n    pendingClasses.delete(instance);\n\n    // Finish derived classes that we postponed in `resolveClass` due to the\n    // base class still being pending, again triggering `finishResolveClass`\n    // of any classes derived from those classes, ultimately leading to all\n    // pending classes being resolved.\n    for (let _values = Set_values(pendingClasses), i = 0, k = _values.length; i < k; ++i) {\n      let pending = _values[i];\n      let dependsOnInstance = pending.base === instance;\n      let interfaces = pending.interfaces;\n      if (interfaces) {\n        let anyPending = false;\n        for (let _values2 = Set_values(interfaces), j = 0, l = _values2.length; j < l; ++j) {\n          let iface = _values2[j];\n          if (iface === instance) dependsOnInstance = true;\n          else if (pendingClasses.has(iface)) anyPending = true;\n        }\n        if (anyPending) continue;\n      }\n      if (dependsOnInstance) this.finishResolveClass(pending, reportMode);\n    }\n  }\n\n  /** Resolves a class prototype by first resolving the specified type arguments. */\n  resolveClassInclTypeArguments(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Class | null {\n    var resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.GENERIC)) {\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes), // must be present if generic\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes, // update\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveClass(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves a property prototype. */\n  resolveProperty(\n    /** The prototype of the property. */\n    prototype: PropertyPrototype,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Property | null {\n    var instance = prototype.instance;\n    if (instance) return instance;\n    prototype.instance = instance = new Property(prototype, prototype);\n    var getterPrototype = prototype.getterPrototype;\n    if (getterPrototype) {\n      let getterInstance = this.resolveFunction(\n        getterPrototype,\n        null,\n        uniqueMap<string,Type>(),\n        reportMode\n      );\n      if (getterInstance) {\n        instance.getterInstance = getterInstance;\n        instance.setType(getterInstance.signature.returnType);\n      }\n    }\n    var setterPrototype = prototype.setterPrototype;\n    if (setterPrototype) {\n      let setterInstance = this.resolveFunction(\n        setterPrototype,\n        null,\n        uniqueMap<string,Type>(),\n        reportMode\n      );\n      if (setterInstance) {\n        instance.setterInstance = setterInstance;\n        if (!instance.is(CommonFlags.RESOLVED)) {\n          assert(setterInstance.signature.parameterTypes.length == 1);\n          instance.setType(setterInstance.signature.parameterTypes[0]);\n        }\n      }\n    }\n    return instance;\n  }\n\n  private ensureOneTypeArgument(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): TypeNode | null {\n    var typeArgumentNodes = node.typeArguments;\n    let numTypeArguments = 0;\n    if (!typeArgumentNodes || (numTypeArguments = typeArgumentNodes.length) != 1) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    return typeArgumentNodes[0];\n  }\n}\n","/**\n * @fileoverview A TypeScript tokenizer modified for AssemblyScript.\n *\n * The `Tokenizer` scans over a source file and returns one syntactic token\n * at a time that the parser will combine to an abstract syntax tree.\n *\n * It skips over trivia like comments and whitespace and provides a general\n * mark/reset mechanism for the parser to utilize on ambiguous tokens, with\n * one token of lookahead otherwise.\n *\n * @license Apache-2.0\n */\n\nimport {\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Source,\n  CommentKind\n} from \"./ast\";\n\nimport {\n  CharCode,\n  isLineBreak,\n  isWhiteSpace,\n  isIdentifierStart,\n  isIdentifierPart,\n  isDecimal,\n  isOctal,\n  isHighSurrogate,\n  isLowSurrogate\n} from \"./util\";\n\n/** Named token types. */\nexport enum Token {\n\n  // keywords\n  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\n\n  ABSTRACT,\n  AS,\n  ASYNC,\n  AWAIT,        // ES2017\n  BREAK,        // ES2017\n  CASE,         // ES2017\n  CATCH,        // ES2017\n  CLASS,        // ES2017\n  CONST,        // ES2017\n  CONTINUE,     // ES2017\n  CONSTRUCTOR,\n  DEBUGGER,     // ES2017\n  DECLARE,\n  DEFAULT,      // ES2017\n  DELETE,       // ES2017\n  DO,           // ES2017\n  ELSE,         // ES2017\n  ENUM,         // ES2017 future\n  EXPORT,       // ES2017\n  EXTENDS,      // ES2017\n  FALSE,        // ES\n  FINALLY,      // ES2017\n  FOR,          // ES2017\n  FROM,         // AS possible identifier\n  FUNCTION,     // ES2017\n  GET,\n  IF,           // ES2017\n  IMPLEMENTS,   // ES2017 non-lexical\n  IMPORT,       // ES2017\n  IN,           // ES2017\n  INSTANCEOF,   // ES2017\n  INTERFACE,    // ES2017 non-lexical\n  IS,\n  KEYOF,\n  LET,          // ES2017 non-lexical\n  MODULE,       // AS possible identifier\n  NAMESPACE,    // AS possible identifier\n  NEW,          // ES2017\n  NULL,         // ES\n  OF,\n  PACKAGE,      // ES2017 non-lexical\n  PRIVATE,      // ES2017 non-lexical\n  PROTECTED,    // ES2017 non-lexical\n  PUBLIC,       // ES2017 non-lexical\n  READONLY,\n  RETURN,       // ES2017\n  SET,\n  STATIC,       // ES2017 non-lexical\n  SUPER,        // ES2017\n  SWITCH,       // ES2017\n  THIS,         // ES2017\n  THROW,        // ES2017\n  TRUE,         // ES\n  TRY,          // ES2017\n  TYPE,         // AS possible identifier\n  TYPEOF,       // ES2017\n  VAR,          // ES2017\n  VOID,         // ES2017\n  WHILE,        // ES2017\n  WITH,         // ES2017\n  YIELD,        // ES2017\n\n  // punctuation\n\n  OPENBRACE,\n  CLOSEBRACE,\n  OPENPAREN,\n  CLOSEPAREN,\n  OPENBRACKET,\n  CLOSEBRACKET,\n  DOT,\n  DOT_DOT_DOT,\n  SEMICOLON,\n  COMMA,\n  LESSTHAN,\n  GREATERTHAN,\n  LESSTHAN_EQUALS,\n  GREATERTHAN_EQUALS,\n  EQUALS_EQUALS,\n  EXCLAMATION_EQUALS,\n  EQUALS_EQUALS_EQUALS,\n  EXCLAMATION_EQUALS_EQUALS,\n  EQUALS_GREATERTHAN,\n  PLUS,\n  MINUS,\n  ASTERISK_ASTERISK,\n  ASTERISK,\n  SLASH,\n  PERCENT,\n  PLUS_PLUS,\n  MINUS_MINUS,\n  LESSTHAN_LESSTHAN,\n  GREATERTHAN_GREATERTHAN,\n  GREATERTHAN_GREATERTHAN_GREATERTHAN,\n  AMPERSAND,\n  BAR,\n  CARET,\n  EXCLAMATION,\n  TILDE,\n  AMPERSAND_AMPERSAND,\n  BAR_BAR,\n  QUESTION,\n  COLON,\n  EQUALS,\n  PLUS_EQUALS,\n  MINUS_EQUALS,\n  ASTERISK_EQUALS,\n  ASTERISK_ASTERISK_EQUALS,\n  SLASH_EQUALS,\n  PERCENT_EQUALS,\n  LESSTHAN_LESSTHAN_EQUALS,\n  GREATERTHAN_GREATERTHAN_EQUALS,\n  GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS,\n  AMPERSAND_EQUALS,\n  BAR_EQUALS,\n  CARET_EQUALS,\n  AT,\n\n  // literals\n\n  IDENTIFIER,\n  STRINGLITERAL,\n  INTEGERLITERAL,\n  FLOATLITERAL,\n  TEMPLATELITERAL,\n\n  // meta\n\n  INVALID,\n  ENDOFFILE\n}\n\nexport enum IdentifierHandling {\n  DEFAULT,\n  PREFER,\n  ALWAYS\n}\n\nexport function tokenFromKeyword(text: string): Token {\n  let len = text.length;\n  assert(len);\n  switch (text.charCodeAt(0)) {\n    case CharCode.a: {\n      if (len == 5) {\n        if (text == \"async\") return Token.ASYNC;\n        if (text == \"await\") return Token.AWAIT;\n        break;\n      }\n      if (text == \"as\") return Token.AS;\n      if (text == \"abstract\") return Token.ABSTRACT;\n      break;\n    }\n    case CharCode.b: {\n      if (text == \"break\") return Token.BREAK;\n      break;\n    }\n    case CharCode.c: {\n      if (len == 5) {\n        if (text == \"const\") return Token.CONST;\n        if (text == \"class\") return Token.CLASS;\n        if (text == \"catch\") return Token.CATCH;\n        break;\n      }\n      if (text == \"case\") return Token.CASE;\n      if (text == \"continue\") return Token.CONTINUE;\n      if (text == \"constructor\") return Token.CONSTRUCTOR;\n      break;\n    }\n    case CharCode.d: {\n      if (len == 7) {\n        if (text == \"default\") return Token.DEFAULT;\n        if (text == \"declare\") return Token.DECLARE;\n        break;\n      }\n      if (text == \"do\") return Token.DO;\n      if (text == \"delete\") return Token.DELETE;\n      if (text == \"debugger\") return Token.DEBUGGER;\n      break;\n    }\n    case CharCode.e: {\n      if (len == 4) {\n        if (text == \"else\") return Token.ELSE;\n        if (text == \"enum\") return Token.ENUM;\n        break;\n      }\n      if (text == \"export\") return Token.EXPORT;\n      if (text == \"extends\") return Token.EXTENDS;\n      break;\n    }\n    case CharCode.f: {\n      if (len <= 5) {\n        if (text == \"false\") return Token.FALSE;\n        if (text == \"for\") return Token.FOR;\n        if (text == \"from\") return Token.FROM;\n        break;\n      }\n      if (text == \"function\") return Token.FUNCTION;\n      if (text == \"finally\") return Token.FINALLY;\n      break;\n    }\n    case CharCode.g: {\n      if (text == \"get\") return Token.GET;\n      break;\n    }\n    case CharCode.i: {\n      if (len == 2) {\n        if (text == \"if\") return Token.IF;\n        if (text == \"in\") return Token.IN;\n        if (text == \"is\") return Token.IS;\n        break;\n      }\n      switch (text.charCodeAt(3)) {\n        case CharCode.l: {\n          if (text == \"implements\") return Token.IMPLEMENTS;\n          break;\n        }\n        case CharCode.o: {\n          if (text == \"import\") return Token.IMPORT;\n          break;\n        }\n        case CharCode.t: {\n          if (text == \"instanceof\") return Token.INSTANCEOF;\n          break;\n        }\n        case CharCode.e: {\n          if (text == \"interface\") return Token.INTERFACE;\n          break;\n        }\n      }\n      break;\n    }\n    case CharCode.k: {\n      if (text == \"keyof\") return Token.KEYOF;\n      break;\n    }\n    case CharCode.l: {\n      if (text == \"let\") return Token.LET;\n      break;\n    }\n    case CharCode.m: {\n      if (text == \"module\") return Token.MODULE;\n      break;\n    }\n    case CharCode.n: {\n      if (text == \"new\") return Token.NEW;\n      if (text == \"null\") return Token.NULL;\n      if (text == \"namespace\") return Token.NAMESPACE;\n      break;\n    }\n    case CharCode.o: {\n      if (text == \"of\") return Token.OF;\n      break;\n    }\n    case CharCode.p: {\n      if (len == 7) {\n        if (text == \"private\") return Token.PRIVATE;\n        if (text == \"package\") return Token.PACKAGE;\n        break;\n      }\n      if (text == \"public\") return Token.PUBLIC;\n      if (text == \"protected\") return Token.PROTECTED;\n      break;\n    }\n    case CharCode.r: {\n      if (text == \"return\") return Token.RETURN;\n      if (text == \"readonly\") return Token.READONLY;\n      break;\n    }\n    case CharCode.s: {\n      if (len == 6) {\n        if (text == \"switch\") return Token.SWITCH;\n        if (text == \"static\") return Token.STATIC;\n        break;\n      }\n      if (text == \"set\") return Token.SET;\n      if (text == \"super\") return Token.SUPER;\n      break;\n    }\n    case CharCode.t: {\n      if (len == 4) {\n        if (text == \"true\") return Token.TRUE;\n        if (text == \"this\") return Token.THIS;\n        if (text == \"type\") return Token.TYPE;\n        break;\n      }\n      if (text == \"try\") return Token.TRY;\n      if (text == \"throw\") return Token.THROW;\n      if (text == \"typeof\") return Token.TYPEOF;\n      break;\n    }\n    case CharCode.v: {\n      if (text == \"var\") return Token.VAR;\n      if (text == \"void\") return Token.VOID;\n      break;\n    }\n    case CharCode.w: {\n      if (text == \"while\") return Token.WHILE;\n      if (text == \"with\") return Token.WITH;\n      break;\n    }\n    case CharCode.y: {\n      if (text == \"yield\") return Token.YIELD;\n      break;\n    }\n  }\n  return Token.INVALID;\n}\n\nexport function tokenIsAlsoIdentifier(token: Token): bool {\n  switch (token) {\n    case Token.ABSTRACT:\n    case Token.AS:\n    case Token.CONSTRUCTOR:\n    case Token.DECLARE:\n    case Token.DELETE:\n    case Token.FROM:\n    case Token.FOR:\n    case Token.GET:\n    case Token.INSTANCEOF:\n    case Token.IS:\n    case Token.KEYOF:\n    case Token.MODULE:\n    case Token.NAMESPACE:\n    case Token.NULL:\n    case Token.READONLY:\n    case Token.SET:\n    case Token.TYPE:\n    case Token.VOID: return true;\n    default: return false;\n  }\n}\n\nexport function isIllegalVariableIdentifier(name: string): bool {\n  assert(name.length);\n  switch (name.charCodeAt(0)) {\n    case CharCode.d: return name == \"delete\";\n    case CharCode.f: return name == \"for\";\n    case CharCode.i: return name == \"instanceof\";\n    case CharCode.n: return name == \"null\";\n    case CharCode.v: return name == \"void\";\n  }\n  return false;\n}\n\nexport function operatorTokenToString(token: Token): string {\n  switch (token) {\n    case Token.DELETE: return \"delete\";\n    case Token.IN: return \"in\";\n    case Token.INSTANCEOF: return \"instanceof\";\n    case Token.NEW: return \"new\";\n    case Token.TYPEOF: return \"typeof\";\n    case Token.VOID: return \"void\";\n    case Token.YIELD: return \"yield\";\n    case Token.DOT_DOT_DOT: return \"...\";\n    case Token.COMMA: return \",\";\n    case Token.LESSTHAN: return \"<\";\n    case Token.GREATERTHAN: return \">\";\n    case Token.LESSTHAN_EQUALS: return \"<=\";\n    case Token.GREATERTHAN_EQUALS: return \">=\";\n    case Token.EQUALS_EQUALS: return \"==\";\n    case Token.EXCLAMATION_EQUALS: return \"!=\";\n    case Token.EQUALS_EQUALS_EQUALS: return \"===\";\n    case Token.EXCLAMATION_EQUALS_EQUALS: return \"!==\";\n    case Token.PLUS: return \"+\";\n    case Token.MINUS: return \"-\";\n    case Token.ASTERISK_ASTERISK: return \"**\";\n    case Token.ASTERISK: return \"*\";\n    case Token.SLASH: return \"/\";\n    case Token.PERCENT: return \"%\";\n    case Token.PLUS_PLUS: return \"++\";\n    case Token.MINUS_MINUS: return \"--\";\n    case Token.LESSTHAN_LESSTHAN: return \"<<\";\n    case Token.GREATERTHAN_GREATERTHAN: return \">>\";\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return \">>>\";\n    case Token.AMPERSAND: return \"&\";\n    case Token.BAR: return \"|\";\n    case Token.CARET: return \"^\";\n    case Token.EXCLAMATION: return \"!\";\n    case Token.TILDE: return \"~\";\n    case Token.AMPERSAND_AMPERSAND: return \"&&\";\n    case Token.BAR_BAR: return \"||\";\n    case Token.EQUALS: return \"=\";\n    case Token.PLUS_EQUALS: return \"+=\";\n    case Token.MINUS_EQUALS: return \"-=\";\n    case Token.ASTERISK_EQUALS: return \"*=\";\n    case Token.ASTERISK_ASTERISK_EQUALS: return \"**=\";\n    case Token.SLASH_EQUALS: return \"/=\";\n    case Token.PERCENT_EQUALS: return \"%=\";\n    case Token.LESSTHAN_LESSTHAN_EQUALS: return \"<<=\";\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS: return \">>=\";\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return \">>>=\";\n    case Token.AMPERSAND_EQUALS: return \"&=\";\n    case Token.BAR_EQUALS: return \"|=\";\n    case Token.CARET_EQUALS: return \"^=\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\nexport class Range {\n\n  start: i32;\n  end: i32;\n  source!: Source;\n  debugInfoRef: usize = 0;\n\n  constructor(start: i32, end: i32) {\n    this.start = start;\n    this.end = end;\n  }\n\n  static join(a: Range, b: Range): Range {\n    if (a.source != b.source) throw new Error(\"source mismatch\");\n    let range = new Range(\n      a.start < b.start ? a.start : b.start,\n      a.end > b.end ? a.end : b.end\n    );\n    range.source = a.source;\n    return range;\n  }\n\n  equals(other: Range): bool {\n    return this.source == other.source && this.start == other.start && this.end == other.end;\n  }\n\n  get atStart(): Range {\n    let range = new Range(this.start, this.start);\n    range.source = this.source;\n    return range;\n  }\n\n  get atEnd(): Range {\n    let range = new Range(this.end, this.end);\n    range.source = this.source;\n    return range;\n  }\n\n  toString(): string {\n    return this.source.text.substring(this.start, this.end);\n  }\n}\n\n/** Handler for intercepting comments while tokenizing. */\nexport type CommentHandler = (kind: CommentKind, text: string, range: Range) => void;\n\n/** Tokenizes a source to individual {@link Token}s. */\nexport class Tokenizer extends DiagnosticEmitter {\n\n  source: Source;\n  end: i32 = 0;\n\n  pos: i32 = 0;\n  token: Token = -1;\n  tokenPos: i32 = 0;\n\n  nextToken: Token = -1;\n  nextTokenPos: i32 = 0;\n  nextTokenOnNewLine: bool = false;\n\n  onComment: CommentHandler | null = null;\n\n  /** Constructs a new tokenizer. */\n  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {\n    super(diagnostics);\n\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n    this.source = source;\n\n    var text = source.text;\n    var end = text.length;\n    var pos = 0;\n    // skip bom\n    if (\n      pos < end &&\n      text.charCodeAt(pos) == CharCode.BYTEORDERMARK\n    ) {\n      ++pos;\n    }\n\n    // skip shebang\n    if (\n      pos + 1 < end &&\n      text.charCodeAt(pos) == CharCode.HASH &&\n      text.charCodeAt(pos + 1) == CharCode.EXCLAMATION\n    ) {\n      pos += 2;\n      while (\n        pos < end &&\n        text.charCodeAt(pos) != CharCode.LINEFEED\n      ) {\n        ++pos;\n      }\n      // 'next' now starts at lf or eof\n    }\n    this.pos = pos;\n    this.end = end;\n  }\n\n  next(identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): Token {\n    this.nextToken = -1;\n    var token: Token;\n    do token = this.unsafeNext(identifierHandling);\n    while (token == Token.INVALID);\n    this.token = token;\n    return token;\n  }\n\n  private unsafeNext(\n    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,\n    maxTokenLength: i32 = i32.MAX_VALUE\n  ): Token {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    while (pos < end) {\n      this.tokenPos = pos;\n      let c = text.charCodeAt(pos);\n      switch (c) {\n        case CharCode.CARRIAGERETURN: {\n          if (!(\n            ++pos < end &&\n            text.charCodeAt(pos) == CharCode.LINEFEED\n          )) break;\n          // otherwise fall-through\n        }\n        case CharCode.LINEFEED:\n        case CharCode.TAB:\n        case CharCode.VERTICALTAB:\n        case CharCode.FORMFEED:\n        case CharCode.SPACE: {\n          ++pos;\n          break;\n        }\n        case CharCode.EXCLAMATION: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            ++pos;\n            if (\n              maxTokenLength > 2 && pos < end &&\n              text.charCodeAt(pos) == CharCode.EQUALS\n            ) {\n              this.pos = pos + 1;\n              return Token.EXCLAMATION_EQUALS_EQUALS;\n            }\n            this.pos = pos;\n            return Token.EXCLAMATION_EQUALS;\n          }\n          this.pos = pos;\n          return Token.EXCLAMATION;\n        }\n        case CharCode.DOUBLEQUOTE:\n        case CharCode.SINGLEQUOTE: {\n          this.pos = pos;\n          return Token.STRINGLITERAL;\n        }\n        case CharCode.BACKTICK: {\n          this.pos = pos;\n          return Token.TEMPLATELITERAL;\n        }\n        case CharCode.PERCENT: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            this.pos = pos + 1;\n            return Token.PERCENT_EQUALS;\n          }\n          this.pos = pos;\n          return Token.PERCENT;\n        }\n        case CharCode.AMPERSAND: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.AMPERSAND) {\n              this.pos = pos + 1;\n              return Token.AMPERSAND_AMPERSAND;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.AMPERSAND_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.AMPERSAND;\n        }\n        case CharCode.OPENPAREN: {\n          this.pos = pos + 1;\n          return Token.OPENPAREN;\n        }\n        case CharCode.CLOSEPAREN: {\n          this.pos = pos + 1;\n          return Token.CLOSEPAREN;\n        }\n        case CharCode.ASTERISK: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.ASTERISK_EQUALS;\n            }\n            if (chr == CharCode.ASTERISK) {\n              ++pos;\n              if (\n                maxTokenLength > 2 && pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.ASTERISK_ASTERISK_EQUALS;\n              }\n              this.pos = pos;\n              return Token.ASTERISK_ASTERISK;\n            }\n          }\n          this.pos = pos;\n          return Token.ASTERISK;\n        }\n        case CharCode.PLUS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.PLUS) {\n              this.pos = pos + 1;\n              return Token.PLUS_PLUS;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.PLUS_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.PLUS;\n        }\n        case CharCode.COMMA: {\n          this.pos = pos + 1;\n          return Token.COMMA;\n        }\n        case CharCode.MINUS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.MINUS) {\n              this.pos = pos + 1;\n              return Token.MINUS_MINUS;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.MINUS_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.MINUS;\n        }\n        case CharCode.DOT: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (isDecimal(chr)) {\n              this.pos = pos - 1;\n              return Token.FLOATLITERAL; // expects a call to readFloat\n            }\n            if (\n              maxTokenLength > 2 && pos + 1 < end &&\n              chr == CharCode.DOT &&\n              text.charCodeAt(pos + 1) == CharCode.DOT\n            ) {\n              this.pos = pos + 2;\n              return Token.DOT_DOT_DOT;\n            }\n          }\n          this.pos = pos;\n          return Token.DOT;\n        }\n        case CharCode.SLASH: {\n          let commentStartPos = pos;\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.SLASH) { // single-line\n              let commentKind = CommentKind.LINE;\n              if (\n                pos + 1 < end &&\n                text.charCodeAt(pos + 1) == CharCode.SLASH\n              ) {\n                ++pos;\n                commentKind = CommentKind.TRIPLE;\n              }\n              while (++pos < end) {\n                if (text.charCodeAt(pos) == CharCode.LINEFEED) {\n                  ++pos;\n                  break;\n                }\n              }\n              if (this.onComment) {\n                this.onComment(\n                  commentKind,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.ASTERISK) { // multi-line\n              let closed = false;\n              while (++pos < end) {\n                c = text.charCodeAt(pos);\n                if (\n                  c == CharCode.ASTERISK &&\n                  pos + 1 < end &&\n                  text.charCodeAt(pos + 1) == CharCode.SLASH\n                ) {\n                  pos += 2;\n                  closed = true;\n                  break;\n                }\n              }\n              if (!closed) {\n                this.error(\n                  DiagnosticCode._0_expected,\n                  this.range(pos), \"*/\"\n                );\n              } else if (this.onComment) {\n                this.onComment(\n                  CommentKind.BLOCK,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.SLASH_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.SLASH;\n        }\n        case CharCode._0:\n        case CharCode._1:\n        case CharCode._2:\n        case CharCode._3:\n        case CharCode._4:\n        case CharCode._5:\n        case CharCode._6:\n        case CharCode._7:\n        case CharCode._8:\n        case CharCode._9: {\n          this.pos = pos;\n          return this.testInteger()\n            ? Token.INTEGERLITERAL // expects a call to readInteger\n            : Token.FLOATLITERAL;  // expects a call to readFloat\n        }\n        case CharCode.COLON: {\n          this.pos = pos + 1;\n          return Token.COLON;\n        }\n        case CharCode.SEMICOLON: {\n          this.pos = pos + 1;\n          return Token.SEMICOLON;\n        }\n        case CharCode.LESSTHAN: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.LESSTHAN) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.LESSTHAN_LESSTHAN_EQUALS;\n              }\n              this.pos = pos;\n              return Token.LESSTHAN_LESSTHAN;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.LESSTHAN_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.LESSTHAN;\n        }\n        case CharCode.EQUALS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.EQUALS) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.EQUALS_EQUALS_EQUALS;\n              }\n              this.pos = pos;\n              return Token.EQUALS_EQUALS;\n            }\n            if (chr == CharCode.GREATERTHAN) {\n              this.pos = pos + 1;\n              return Token.EQUALS_GREATERTHAN;\n            }\n          }\n          this.pos = pos;\n          return Token.EQUALS;\n        }\n        case CharCode.GREATERTHAN: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.GREATERTHAN) {\n              ++pos;\n              if (maxTokenLength > 2 && pos < end) {\n                chr = text.charCodeAt(pos);\n                if (chr == CharCode.GREATERTHAN) {\n                  ++pos;\n                  if (\n                    maxTokenLength > 3 && pos < end &&\n                    text.charCodeAt(pos) == CharCode.EQUALS\n                  ) {\n                    this.pos = pos + 1;\n                    return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS;\n                  }\n                  this.pos = pos;\n                  return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN;\n                }\n                if (chr == CharCode.EQUALS) {\n                  this.pos = pos + 1;\n                  return Token.GREATERTHAN_GREATERTHAN_EQUALS;\n                }\n              }\n              this.pos = pos;\n              return Token.GREATERTHAN_GREATERTHAN;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.GREATERTHAN_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.GREATERTHAN;\n        }\n        case CharCode.QUESTION: {\n          this.pos = pos + 1;\n          return Token.QUESTION;\n        }\n        case CharCode.OPENBRACKET: {\n          this.pos = pos + 1;\n          return Token.OPENBRACKET;\n        }\n        case CharCode.CLOSEBRACKET: {\n          this.pos = pos + 1;\n          return Token.CLOSEBRACKET;\n        }\n        case CharCode.CARET: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            this.pos = pos + 1;\n            return Token.CARET_EQUALS;\n          }\n          this.pos = pos;\n          return Token.CARET;\n        }\n        case CharCode.OPENBRACE: {\n          this.pos = pos + 1;\n          return Token.OPENBRACE;\n        }\n        case CharCode.BAR: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.BAR) {\n              this.pos = pos + 1;\n              return Token.BAR_BAR;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.BAR_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.BAR;\n        }\n        case CharCode.CLOSEBRACE: {\n          this.pos = pos + 1;\n          return Token.CLOSEBRACE;\n        }\n        case CharCode.TILDE: {\n          this.pos = pos + 1;\n          return Token.TILDE;\n        }\n        case CharCode.AT: {\n          this.pos = pos + 1;\n          return Token.AT;\n        }\n        default: {\n          if (isIdentifierStart(c)) {\n            let posBefore = pos;\n            while (\n              ++pos < end &&\n              isIdentifierPart(c = text.charCodeAt(pos))\n            ) { /* nop */ }\n            if (identifierHandling != IdentifierHandling.ALWAYS) {\n              let maybeKeywordToken = tokenFromKeyword(text.substring(posBefore, pos));\n              if (\n                maybeKeywordToken != Token.INVALID &&\n                !(\n                  identifierHandling == IdentifierHandling.PREFER &&\n                  tokenIsAlsoIdentifier(maybeKeywordToken)\n                )\n              ) {\n                this.pos = pos;\n                return maybeKeywordToken;\n              }\n            }\n            this.pos = posBefore;\n            return Token.IDENTIFIER;\n          } else if (isWhiteSpace(c)) {\n            ++pos;\n            break;\n          }\n          let start = pos++;\n          if (\n            isHighSurrogate(c) && pos < end &&\n            isLowSurrogate(text.charCodeAt(pos))\n          ) ++pos;\n          this.error(\n            DiagnosticCode.Invalid_character,\n            this.range(start, pos)\n          );\n          this.pos = pos;\n          return Token.INVALID;\n        }\n      }\n    }\n    this.pos = pos;\n    return Token.ENDOFFILE;\n  }\n\n  peek(\n    checkOnNewLine: bool = false,\n    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,\n    maxCompoundLength: i32 = i32.MAX_VALUE\n  ): Token {\n    var text = this.source.text;\n    if (this.nextToken < 0) {\n      let posBefore = this.pos;\n      let tokenBefore = this.token;\n      let tokenPosBefore = this.tokenPos;\n      let nextToken: Token;\n      do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n      while (nextToken == Token.INVALID);\n      this.nextToken = nextToken;\n      this.nextTokenPos = this.tokenPos;\n      if (checkOnNewLine) {\n        this.nextTokenOnNewLine = false;\n        for (let pos = posBefore, end = this.nextTokenPos; pos < end; ++pos) {\n          if (isLineBreak(text.charCodeAt(pos))) {\n            this.nextTokenOnNewLine = true;\n            break;\n          }\n        }\n      }\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n    }\n    return this.nextToken;\n  }\n\n  skipIdentifier(identifierHandling: IdentifierHandling = IdentifierHandling.PREFER): bool {\n    return this.skip(Token.IDENTIFIER, identifierHandling);\n  }\n\n  skip(token: Token, identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): bool {\n    var posBefore = this.pos;\n    var tokenBefore = this.token;\n    var tokenPosBefore = this.tokenPos;\n    var maxCompoundLength = i32.MAX_VALUE;\n    if (token == Token.GREATERTHAN) {  // where parsing type arguments\n      maxCompoundLength = 1;\n    }\n    var nextToken: Token;\n    do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n    while (nextToken == Token.INVALID);\n    if (nextToken == token) {\n      this.token = token;\n      this.nextToken = -1;\n      return true;\n    } else {\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n      return false;\n    }\n  }\n\n  mark(): State {\n    var state = reusableState;\n    if (state) {\n      reusableState = null;\n      state.pos = this.pos;\n      state.token = this.token;\n      state.tokenPos = this.tokenPos;\n    } else {\n      state = new State(this.pos, this.token, this.tokenPos);\n    }\n    return state;\n  }\n\n  discard(state: State): void {\n    reusableState = state;\n  }\n\n  reset(state: State): void {\n    this.pos = state.pos;\n    this.token = state.token;\n    this.tokenPos = state.tokenPos;\n    this.nextToken = -1;\n  }\n\n  range(start: i32 = -1, end: i32 = -1): Range {\n    if (start < 0) {\n      start = this.tokenPos;\n      end = this.pos;\n    } else if (end < 0) {\n      end = start;\n    }\n    let range = new Range(start, end);\n    range.source = this.source;\n    return range;\n  }\n\n  readIdentifier(): string {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    var start = pos;\n    while (\n      ++pos < end &&\n      isIdentifierPart(text.charCodeAt(pos))\n    );\n    this.pos = pos;\n    return text.substring(start, pos);\n  }\n\n  readingTemplateString: bool = false;\n  readStringStart: i32 = 0;\n  readStringEnd: i32 = 0;\n\n  readString(quote: i32 = 0, isTaggedTemplate: bool = false): string {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    if (!quote) quote = text.charCodeAt(pos++);\n    var start = pos;\n    this.readStringStart = start;\n    var result = \"\";\n\n    while (true) {\n      if (pos >= end) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, end)\n        );\n        this.readStringEnd = end;\n        break;\n      }\n      let c = text.charCodeAt(pos);\n      if (c == quote) {\n        this.readStringEnd = pos;\n        result += text.substring(start, pos++);\n        break;\n      }\n      if (c == CharCode.BACKSLASH) {\n        result += text.substring(start, pos);\n        this.pos = pos; // save\n        result += this.readEscapeSequence(isTaggedTemplate);\n        pos = this.pos; // restore\n        start = pos;\n        continue;\n      }\n      if (quote == CharCode.BACKTICK) {\n        if (c == CharCode.DOLLAR && pos + 1 < end && text.charCodeAt(pos + 1) == CharCode.OPENBRACE) {\n          result += text.substring(start, pos);\n          this.readStringEnd = pos;\n          this.pos = pos + 2;\n          this.readingTemplateString = true;\n          return result;\n        }\n      } else if (isLineBreak(c)) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, pos)\n        );\n        this.readStringEnd = pos;\n        break;\n      }\n      ++pos;\n    }\n    this.pos = pos;\n    this.readingTemplateString = false;\n    return result;\n  }\n\n  readEscapeSequence(isTaggedTemplate: bool = false): string {\n    // for context on isTaggedTemplate, see: https://tc39.es/proposal-template-literal-revision/\n    var start = this.pos;\n    var end = this.end;\n    if (++this.pos >= end) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(end)\n      );\n      return \"\";\n    }\n\n    var text = this.source.text;\n    var c = text.charCodeAt(this.pos++);\n    switch (c) {\n      case CharCode._0: {\n        if (isTaggedTemplate && this.pos < end && isDecimal(text.charCodeAt(this.pos))) {\n          ++this.pos;\n          return text.substring(start, this.pos);\n        }\n        return \"\\0\";\n      }\n      case CharCode.b: return \"\\b\";\n      case CharCode.t: return \"\\t\";\n      case CharCode.n: return \"\\n\";\n      case CharCode.v: return \"\\v\";\n      case CharCode.f: return \"\\f\";\n      case CharCode.r: return \"\\r\";\n      case CharCode.SINGLEQUOTE: return \"'\";\n      case CharCode.DOUBLEQUOTE: return \"\\\"\";\n      case CharCode.u: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.OPENBRACE\n        ) {\n          ++this.pos;\n          return this.readExtendedUnicodeEscape(isTaggedTemplate ? start : -1); // \\u{DDDDDDDD}\n        }\n        return this.readUnicodeEscape(isTaggedTemplate ? start : -1); // \\uDDDD\n      }\n      case CharCode.x: {\n        return this.readHexadecimalEscape(2, isTaggedTemplate ? start : - 1); // \\xDD\n      }\n      case CharCode.CARRIAGERETURN: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.LINEFEED\n        ) {\n          ++this.pos;\n        }\n        // fall through\n      }\n      case CharCode.LINEFEED:\n      case CharCode.LINESEPARATOR:\n      case CharCode.PARAGRAPHSEPARATOR: return \"\";\n      default: return String.fromCodePoint(c);\n    }\n  }\n\n  readRegexpPattern(): string {\n    var text = this.source.text;\n    var start = this.pos;\n    var end = this.end;\n    var escaped = false;\n    while (true) {\n      if (this.pos >= end) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, end)\n        );\n        break;\n      }\n      if (text.charCodeAt(this.pos) == CharCode.BACKSLASH) {\n        ++this.pos;\n        escaped = true;\n        continue;\n      }\n      let c = text.charCodeAt(this.pos);\n      if (!escaped && c == CharCode.SLASH) break;\n      if (isLineBreak(c)) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, this.pos)\n        );\n        break;\n      }\n      ++this.pos;\n      escaped = false;\n    }\n    return text.substring(start, this.pos);\n  }\n\n  readRegexpFlags(): string {\n    var text = this.source.text;\n    var start = this.pos;\n    var end = this.end;\n    var flags = 0;\n    while (this.pos < end) {\n      let c: i32 = text.charCodeAt(this.pos);\n      if (!isIdentifierPart(c)) break;\n      ++this.pos;\n\n      // make sure each supported flag is unique\n      switch (c) {\n        case CharCode.g: {\n          flags |= flags & 1 ? -1 : 1;\n          break;\n        }\n        case CharCode.i: {\n          flags |= flags & 2 ? -1 : 2;\n          break;\n        }\n        case CharCode.m: {\n          flags |= flags & 4 ? -1 : 4;\n          break;\n        }\n        default: {\n          flags = -1;\n          break;\n        }\n      }\n    }\n    if (flags == -1) {\n      this.error(\n        DiagnosticCode.Invalid_regular_expression_flags,\n        this.range(start, this.pos)\n      );\n    }\n    return text.substring(start, this.pos);\n  }\n\n  testInteger(): bool {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    if (pos + 1 < end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 2) | 32) {\n        case CharCode.x:\n        case CharCode.b:\n        case CharCode.o: return true;\n      }\n    }\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode.DOT || (c | 32) == CharCode.e) return false;\n      if (c != CharCode._ && (c < CharCode._0 || c > CharCode._9)) break;\n      // does not validate separator placement (this is done in readXYInteger)\n      pos++;\n    }\n    return true;\n  }\n\n  readInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    if (pos + 2 < this.end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 1) | 32) {\n        case CharCode.x: {\n          this.pos = pos + 2;\n          return this.readHexInteger();\n        }\n        case CharCode.b: {\n          this.pos = pos + 2;\n          return this.readBinaryInteger();\n        }\n        case CharCode.o: {\n          this.pos = pos + 2;\n          return this.readOctalInteger();\n        }\n      }\n      if (isOctal(text.charCodeAt(pos + 1))) {\n        let start = pos;\n        this.pos = pos + 1;\n        let value = this.readOctalInteger();\n        this.error(\n          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,\n          this.range(start, this.pos)\n        );\n        return value;\n      }\n    }\n    return this.readDecimalInteger();\n  }\n\n  readHexInteger(): i64 {\n    var text = this.source.text;\n    let pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_4 = i64_new(4);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        // value = (value << 4) + c - CharCode._0;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c >= CharCode.A && c <= CharCode.F) {\n        // value = (value << 4) + 10 + c - CharCode.A;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(10 + c - CharCode.A)\n        );\n      } else if (c >= CharCode.a && c <= CharCode.f) {\n        // value = (value << 4) + 10 + c - CharCode.a;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(10 + c - CharCode.a)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Hexadecimal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readDecimalInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_10 = i64_new(10);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        // value = value * 10 + c - CharCode._0;\n        value = i64_add(\n          i64_mul(value, i64_10),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readOctalInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_3 = i64_new(3);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._7) {\n        // value = (value << 3) + c - CharCode._0;\n        value = i64_add(\n          i64_shl(value, i64_3),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Octal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readBinaryInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_1 = i64_new(1);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode._0) {\n        // value = (value << 1);\n        value = i64_shl(value, i64_1);\n      } else if (c == CharCode._1) {\n        // value = (value << 1) + 1;\n        value = i64_add(\n          i64_shl(value, i64_1),\n          i64_1\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Binary_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readFloat(): f64 {\n    // var text = this.source.text;\n    // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {\n    //   switch (text.charCodeAt(this.pos + 1)) {\n    //     case CharCode.X:\n    //     case CharCode.x: {\n    //       this.pos += 2;\n    //       return this.readHexFloat();\n    //     }\n    //   }\n    // }\n    return this.readDecimalFloat();\n  }\n\n  readDecimalFloat(): f64 {\n    var text = this.source.text;\n    var end = this.end;\n    var start = this.pos;\n    var sepCount = this.readDecimalFloatPartial(false);\n    if (this.pos < end && text.charCodeAt(this.pos) == CharCode.DOT) {\n      ++this.pos;\n      sepCount += this.readDecimalFloatPartial();\n    }\n    if (this.pos < end) {\n      let c = text.charCodeAt(this.pos);\n      if ((c | 32) == CharCode.e) {\n        if (\n          ++this.pos < end &&\n          (c = text.charCodeAt(this.pos)) == CharCode.MINUS || c == CharCode.PLUS &&\n          isDecimal(text.charCodeAt(this.pos + 1))\n        ) {\n          ++this.pos;\n        }\n        sepCount += this.readDecimalFloatPartial();\n      }\n    }\n    let result = text.substring(start, this.pos);\n    if (sepCount) result = result.replaceAll(\"_\", \"\");\n    return parseFloat(result);\n  }\n\n  /** Reads past one section of a decimal float literal. Returns the number of separators encountered. */\n  private readDecimalFloatPartial(allowLeadingZeroSep: bool = true): u32 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var start = pos;\n    var end = this.end;\n    var sepEnd = start;\n    var sepCount = 0;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n\n      if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (!allowLeadingZeroSep && pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n        ++sepCount;\n      } else if (!isDecimal(c)) {\n        break;\n      }\n      ++pos;\n    }\n\n    if (pos != start && sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n\n    this.pos = pos;\n    return sepCount;\n  }\n\n  readHexFloat(): f64 {\n    throw new Error(\"not implemented\"); // TBD\n  }\n\n  readHexadecimalEscape(remain: i32 = 2, startIfTaggedTemplate: i32 = -1): string {\n    var value = 0;\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    while (pos < end) {\n      let c = text.charCodeAt(pos++);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        value = (value << 4) + c - CharCode._0;\n      } else if (c >= CharCode.A && c <= CharCode.F) {\n        value = (value << 4) + c + (10 - CharCode.A);\n      } else if (c >= CharCode.a && c <= CharCode.f) {\n        value = (value << 4) + c + (10 - CharCode.a);\n      } else if (~startIfTaggedTemplate) {\n        this.pos = --pos;\n        return text.substring(startIfTaggedTemplate, pos);\n      } else {\n        this.pos = pos;\n        this.error(\n          DiagnosticCode.Hexadecimal_digit_expected,\n          this.range(pos - 1, pos)\n        );\n        return \"\";\n      }\n      if (--remain == 0) break;\n    }\n    if (remain) { // invalid\n      this.pos = pos;\n      if (~startIfTaggedTemplate) {\n        return text.substring(startIfTaggedTemplate, pos);\n      }\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(pos)\n      );\n      return \"\";\n    }\n    this.pos = pos;\n    return String.fromCodePoint(value);\n  }\n\n  checkForIdentifierStartAfterNumericLiteral(): void {\n    // TODO: BigInt n\n    var pos = this.pos;\n    if (pos < this.end && isIdentifierStart(this.source.text.charCodeAt(pos))) {\n      this.error(\n        DiagnosticCode.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal,\n        this.range(pos)\n      );\n    }\n  }\n\n  readUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    return this.readHexadecimalEscape(4, startIfTaggedTemplate);\n  }\n\n  private readExtendedUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\n    var start = this.pos;\n    var value = this.readHexInteger();\n    var value32 = i64_low(value);\n    var invalid = false;\n\n    assert(!i64_high(value));\n    if (value32 > 0x10FFFF) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    var end = this.end;\n    var text = this.source.text;\n    if (this.pos >= end) {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unexpected_end_of_text,\n          this.range(start, end)\n        );\n      }\n      invalid = true;\n    } else if (text.charCodeAt(this.pos) == CharCode.CLOSEBRACE) {\n      ++this.pos;\n    } else {\n      if (startIfTaggedTemplate == -1) {\n        this.error(\n          DiagnosticCode.Unterminated_Unicode_escape_sequence,\n          this.range(start, this.pos)\n        );\n      }\n      invalid = true;\n    }\n\n    if (invalid) {\n      return ~startIfTaggedTemplate\n        ? text.substring(startIfTaggedTemplate, this.pos)\n        : \"\";\n    }\n    return String.fromCodePoint(value32);\n  }\n}\n\n/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */\nexport class State {\n  constructor(\n    /** Current position. */\n    public pos: i32,\n    /** Current token. */\n    public token: Token,\n    /** Current token's position. */\n    public tokenPos: i32\n  ) {}\n}\n\n// Reusable state object to reduce allocations\nvar reusableState: State | null = null;\n","/**\n * @fileoverview Mappings from AssemblyScript types to WebAssembly types.\n * @license Apache-2.0\n */\n\nimport {\n  Class,\n  Program,\n  DecoratorFlags\n} from \"./program\";\n\nimport {\n  TypeRef,\n  createType\n} from \"./module\";\n\n/** Indicates the kind of a type. */\nexport const enum TypeKind {\n\n  // signed integers\n\n  /** An 8-bit signed integer. */\n  I8,\n  /** A 16-bit signed integer. */\n  I16,\n  /** A 32-bit signed integer. */\n  I32,\n  /** A 64-bit signed integer. */\n  I64,\n  /** A 32-bit/64-bit signed integer, depending on the target. */\n  ISIZE,\n\n  // unsigned integers\n\n  /** An 8-bit unsigned integer. */\n  U8,\n  /** A 16-bit unsigned integer. */\n  U16,\n  /** A 32-bit unsigned integer. Also the base of function types. */\n  U32,\n  /** A 64-bit unsigned integer. */\n  U64,\n  /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */\n  USIZE,\n  /** A 1-bit unsigned integer. */\n  BOOL, // sic\n\n  // floats\n\n  /** A 32-bit float. */\n  F32,\n  /** A 64-bit double. */\n  F64,\n\n  // vectors\n\n  /** A 128-bit vector. */\n  V128,\n\n  // references\n\n  /** Function reference. */\n  FUNCREF,\n  /** External reference. */\n  EXTERNREF,\n  /** Any reference. */\n  ANYREF,\n  /** Equatable reference. */\n  EQREF,\n  /** 31-bit integer reference. */\n  I31REF,\n  /** Data reference. */\n  DATAREF,\n\n  // other\n\n  /** No return type. */\n  VOID\n}\n\n/** Indicates capabilities of a type. */\nexport const enum TypeFlags {\n  NONE = 0,\n  /** Is a signed type that can represent negative values. */\n  SIGNED = 1 << 0,\n  /** Is an unsigned type that cannot represent negative values. */\n  UNSIGNED = 1 << 1,\n  /** Is an integer type. */\n  INTEGER = 1 << 2,\n  /** Is a floating point type. */\n  FLOAT = 1 << 3,\n  /** Is a varying (in size) type. */\n  VARYING = 1 << 4,\n  /** Is smaller than 32-bits. */\n  SHORT = 1 << 5,\n  /** Is larger than 32-bits. */\n  LONG = 1 << 6,\n  /** Is a value type. */\n  VALUE = 1 << 7,\n  /** Is a reference type (either a class or a function type). */\n  REFERENCE = 1 << 8,\n  /** Is a nullable type. */\n  NULLABLE = 1 << 9,\n  /** Is a vector type. */\n  VECTOR = 1 << 10,\n  /** Is an external type. */\n  EXTERNAL = 1 << 11,\n  /** Is a class. */\n  CLASS = 1 << 12,\n  /** Is a function. */\n  FUNCTION = 1 << 13\n}\n\n/** Represents a resolved type. */\nexport class Type {\n\n  /** Type kind. */\n  kind: TypeKind;\n  /** Type flags. */\n  flags: TypeFlags;\n  /** Size in bits. */\n  size: i32;\n  /** Size in bytes. */\n  byteSize: i32;\n  /** Underlying class reference, if a class type. */\n  classReference: Class | null;\n  /** Underlying signature reference, if a function type. */\n  signatureReference: Signature | null;\n  /** Respective non-nullable type, if nullable. */\n  private _nonNullableType: Type | null = null;\n  /** Respective nullable type, if non-nullable. */\n  private _nullableType: Type | null = null;\n\n  /** Constructs a new resolved type. */\n  constructor(kind: TypeKind, flags: TypeFlags, size: u32) {\n    this.kind = kind;\n    this.flags = flags;\n    this.size = size;\n    this.byteSize = <i32>ceil<f64>(<f64>size / 8);\n    this.classReference = null;\n    this.signatureReference = null;\n    if (!(flags & TypeFlags.NULLABLE)) {\n      this._nonNullableType = this;\n    } else {\n      this._nullableType = this;\n    }\n  }\n\n  /** Returns the closest int type representing this type. */\n  get intType(): Type {\n    if (this == Type.auto) return this; // keep auto as a hint\n    switch (this.kind) {\n      case TypeKind.I8: return Type.i8;\n      case TypeKind.I16: return Type.i16;\n      case TypeKind.F32:\n      case TypeKind.I32: return Type.i32;\n      case TypeKind.F64:\n      case TypeKind.I64: return Type.i64;\n      case TypeKind.ISIZE: return this.size == 64 ? Type.isize64 : Type.isize32;\n      case TypeKind.U8: return Type.u8;\n      case TypeKind.U16: return Type.u16;\n      case TypeKind.U32: return Type.u32;\n      case TypeKind.U64: return Type.u64;\n      case TypeKind.USIZE: return this.size == 64 ? Type.usize64 : Type.usize32;\n      case TypeKind.BOOL:\n      default: return Type.i32;\n    }\n  }\n\n  /** Substitutes this type with the auto type if this type is void. */\n  get exceptVoid(): Type {\n    if (this.kind == TypeKind.VOID) return Type.auto;\n    return this;\n  }\n\n  /** Gets this type's logarithmic alignment in memory. */\n  get alignLog2(): i32 {\n    return 31 - clz<i32>(this.byteSize);\n  }\n\n  /** Tests if this type represents a basic value. */\n  get isValue(): bool {\n    return this.is(TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an integer value. */\n  get isIntegerValue(): bool {\n    return this.is(TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a small (< 32 bits) integer value. */\n  get isShortIntegerValue(): bool {\n    return this.is(TypeFlags.SHORT | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a long (> 32 bits) integer value. */\n  get isLongIntegerValue(): bool {\n    return this.is(TypeFlags.LONG | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a signed integer value. */\n  get isSignedIntegerValue(): bool {\n    return this.is(TypeFlags.SIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an unsigned integer value. */\n  get isUnsignedIntegerValue(): bool {\n    return this.is(TypeFlags.UNSIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a varying (in size) integer value. */\n  get isVaryingIntegerValue(): bool {\n    return this.is(TypeFlags.VARYING | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an integer, including references.  */\n  get isIntegerInclReference(): bool {\n    return this.is(TypeFlags.INTEGER);\n  }\n\n  /** Tests if this type represents a floating point value. */\n  get isFloatValue(): bool {\n    return this.is(TypeFlags.FLOAT | TypeFlags.VALUE);\n  }\n  \n  /** Tests if this type represents a numeric (integer or floating point) value. */\n  get isNumericValue(): bool {\n    return this.isIntegerValue || this.isFloatValue;\n  }\n\n  /** Tests if this type represents a boolean value. */\n  get isBooleanValue(): bool {\n    return this == Type.bool;\n  }\n\n  /** Tests if this type represents a vector value. */\n  get isVectorValue(): bool {\n    return this.is(TypeFlags.VECTOR | TypeFlags.VALUE);\n  }\n  \n  /** Tests if this type represents an internal or external reference. */\n  get isReference(): bool {\n    return this.is(TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents a nullable internal or external reference. */\n  get isNullableReference(): bool {\n    return this.is(TypeFlags.NULLABLE | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents an internal object. */\n  get isInternalReference(): bool {\n    return this.is(TypeFlags.INTEGER | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents an external object. */\n  get isExternalReference(): bool {\n    return this.is(TypeFlags.EXTERNAL | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents a class. */\n  get isClass(): bool {\n    return this.isInternalReference\n      ? this.classReference !== null\n      : false;\n  }\n\n  /** Gets the underlying class of this type, if any. */\n  getClass(): Class | null {\n    return this.isInternalReference\n      ? this.classReference\n      : null;\n  }\n\n  /** Gets the underlying class or wrapper class of this type, if any. */\n  getClassOrWrapper(program: Program): Class | null {\n    let classReference = this.getClass();\n    if (classReference) {\n      // typical class\n      return classReference;\n    } else {\n      let signatureReference = this.getSignature();\n      if (signatureReference) {\n        // function wrapper\n        let type = signatureReference.type;\n        let wrapper = assert(program.resolver.resolveClass(program.functionPrototype, [ type ]));\n        wrapper.wrappedType = type;\n        return wrapper;\n      } else {\n        let wrapperClasses = program.wrapperClasses;\n        if (wrapperClasses.has(this)) {\n          // value wrapper\n          return assert(wrapperClasses.get(this));\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Tests if this type represents a function. */\n  get isFunction(): bool {\n    return this.isInternalReference\n      ? this.signatureReference !== null\n      : false;\n  }\n\n  /** Gets the underlying function signature of this type, if any. */\n  getSignature(): Signature | null {\n    return this.isInternalReference\n      ? this.signatureReference\n      : null;\n  }\n\n  /** Tests if this is a managed type that needs GC hooks. */\n  get isManaged(): bool {\n    if (this.isInternalReference) {\n      let classReference = this.classReference;\n      if (classReference) return !classReference.hasDecorator(DecoratorFlags.UNMANAGED);\n      return this.signatureReference !== null; // function references are managed\n    }\n    return false;\n  }\n\n  /** Tests if this is a class type explicitly annotated as unmanaged. */\n  get isUnmanaged(): bool {\n    var classReference = this.classReference;\n    return classReference !== null && classReference.hasDecorator(DecoratorFlags.UNMANAGED);\n  }\n\n  /** Gets the corresponding non-nullable type. */\n  get nonNullableType(): Type {\n    if (this.isExternalReference) {\n      return this; // TODO\n    }\n    return assert(this._nonNullableType); // set either in ctor or asNullable\n  }\n\n  /** Gets the corresponding nullable type, if applicable. */\n  get nullableType(): Type | null {\n    return this._nullableType; // set either in ctor or asNullable\n  }\n\n  /** Computes the sign-extending shift in the target type. */\n  computeSmallIntegerShift(targetType: Type): i32 {\n    return targetType.size - this.size;\n  }\n\n  /** Computes the truncating mask in the target type. */\n  computeSmallIntegerMask(targetType: Type): i32 {\n    var size = this.is(TypeFlags.UNSIGNED) ? this.size : this.size - 1;\n    return ~0 >>> (targetType.size - size);\n  }\n\n  /** Tests if this type has (all of) the specified flags. */\n  is(flags: TypeFlags): bool { return (this.flags & flags) == flags; }\n  /** Tests if this type has any of the specified flags. */\n  isAny(flags: TypeFlags): bool { return (this.flags & flags) != 0; }\n\n  /** Composes the respective nullable type of this type. */\n  asNullable(): Type {\n    assert(this.isInternalReference);\n    var nullableType = this._nullableType;\n    if (!nullableType) {\n      assert(!this.isNullableReference);\n      this._nullableType = nullableType = new Type(this.kind, this.flags | TypeFlags.NULLABLE, this.size);\n      nullableType.classReference = this.classReference;         // either a class reference\n      nullableType.signatureReference = this.signatureReference; // or a function reference\n      nullableType._nonNullableType = this;\n    }\n    return nullableType;\n  }\n\n  /** Tests if this type equals the specified. */\n  equals(other: Type): bool {\n    if (this.kind != other.kind) return false;\n    if (this.isReference) {\n      return (\n        this.classReference == other.classReference &&\n        this.signatureReference == other.signatureReference &&\n        this.isNullableReference == other.isNullableReference\n      );\n    }\n    return true;\n  }\n\n  /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */\n  isAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    var currentClass: Class | null;\n    var targetClass: Class | null;\n    var currentFunction: Signature | null;\n    var targetFunction: Signature | null;\n    if (this.isReference) {\n      if (target.isReference) {\n        if (!this.isNullableReference || target.isNullableReference) {\n          if (currentClass = this.getClass()) {\n            if (targetClass = target.getClass()) {\n              return currentClass.isAssignableTo(targetClass);\n            }\n          } else if (currentFunction = this.getSignature()) {\n            if (targetFunction = target.getSignature()) {\n              return currentFunction.isAssignableTo(targetFunction);\n            }\n          } else if (this.isExternalReference && (this.kind == target.kind || (target.kind == TypeKind.ANYREF && this.kind != TypeKind.EXTERNREF))) {\n            return true;\n          }\n        }\n      }\n    } else if (!target.isReference) {\n      if (this.isIntegerValue) {\n        if (target.isIntegerValue) {\n          if (\n            !signednessIsRelevant ||\n            this.isBooleanValue || // a bool (0 or 1) can be safely assigned to all sorts of integers\n            this.isSignedIntegerValue == target.isSignedIntegerValue\n          ) {\n            return this.size <= target.size;\n          }\n        } else if (target.kind == TypeKind.F32) {\n          return this.size <= 23; // mantissa bits\n        } else if (target.kind == TypeKind.F64) {\n          return this.size <= 52; // ^\n        }\n      } else if (this.isFloatValue) {\n        if (target.isFloatValue) {\n          return this.size <= target.size;\n        }\n      } else if (this.isVectorValue) {\n        if (target.isVectorValue) {\n          return this.size == target.size;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */\n  isStrictlyAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    if (this.isReference) return this.isAssignableTo(target);\n    else if (target.isReference) return false;\n    // not dealing with references from here on\n    if (this.isIntegerValue) {\n      return target.isIntegerValue && target.size == this.size && (\n        !signednessIsRelevant ||\n        this.isSignedIntegerValue == target.isSignedIntegerValue\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if a value of this type can be changed to the target type using `changetype`. */\n  isChangeableTo(target: Type): bool {\n    // special in that it allows integer references as well\n    if (this.is(TypeFlags.INTEGER) && target.is(TypeFlags.INTEGER)) {\n      let size = this.size;\n      return size == target.size && (size >= 32 || this.is(TypeFlags.SIGNED) == target.is(TypeFlags.SIGNED));\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Determines the common denominator type of two types, if there is any. */\n  static commonDenominator(left: Type, right: Type, signednessIsImportant: bool): Type | null {\n    if (right.isAssignableTo(left, signednessIsImportant)) return left;\n    else if (left.isAssignableTo(right, signednessIsImportant)) return right;\n    return null;\n  }\n\n  /** Converts this type to a string. */\n  toString(validWat: bool = false): string {\n    const nullablePostfix = validWat\n      ? \"|null\"\n      : \" | null\";\n    if (this.isReference) {\n      let classReference = this.getClass();\n      if (classReference) {\n        return this.isNullableReference\n          ? classReference.internalName + nullablePostfix\n          : classReference.internalName;\n      } else {\n        let signatureReference = this.getSignature();\n        if (signatureReference) {\n          return this.isNullableReference\n            ? \"(\" + signatureReference.toString(validWat) + \")\" + nullablePostfix\n            : signatureReference.toString(validWat);\n        }\n      }\n    }\n    switch (this.kind) {\n      case TypeKind.I8: return \"i8\";\n      case TypeKind.I16: return \"i16\";\n      case TypeKind.I32: return \"i32\";\n      case TypeKind.I64: return \"i64\";\n      case TypeKind.ISIZE: return \"isize\";\n      case TypeKind.U8: return \"u8\";\n      case TypeKind.U16: return \"u16\";\n      case TypeKind.U32: return \"u32\";\n      case TypeKind.U64: return \"u64\";\n      case TypeKind.USIZE: return \"usize\";\n      case TypeKind.BOOL: return \"bool\";\n      case TypeKind.F32: return \"f32\";\n      case TypeKind.F64: return \"f64\";\n      case TypeKind.V128: return \"v128\";\n      case TypeKind.FUNCREF: return \"funcref\";\n      case TypeKind.EXTERNREF: return \"externref\";\n      case TypeKind.ANYREF: return \"anyref\";\n      case TypeKind.EQREF: return \"eqref\";\n      case TypeKind.I31REF: return \"i31ref\";\n      case TypeKind.DATAREF: return \"dataref\";\n      default: assert(false);\n      case TypeKind.VOID: return \"void\";\n    }\n  }\n\n  // Binaryen specific\n\n  /** Converts this type to its respective type reference. */\n  toRef(): TypeRef {\n    switch (this.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return TypeRef.I32;\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (this.size != 64) return TypeRef.I32;\n      case TypeKind.I64:\n      case TypeKind.U64: return TypeRef.I64;\n      case TypeKind.F32: return TypeRef.F32;\n      case TypeKind.F64: return TypeRef.F64;\n      case TypeKind.V128: return TypeRef.V128;\n      // TODO: nullable/non-nullable refs have different type refs\n      case TypeKind.FUNCREF: return TypeRef.Funcref;\n      case TypeKind.EXTERNREF: return TypeRef.Externref;\n      case TypeKind.ANYREF: return TypeRef.Anyref;\n      case TypeKind.EQREF: return TypeRef.Eqref;\n      case TypeKind.I31REF: return TypeRef.I31ref;\n      case TypeKind.DATAREF: return TypeRef.Dataref;\n      case TypeKind.VOID: return TypeRef.None;\n    }\n  }\n\n  // Types\n\n  /** An 8-bit signed integer. */\n  static readonly i8: Type  = new Type(TypeKind.I8,\n    TypeFlags.SIGNED   |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   8\n  );\n\n  /** A 16-bit signed integer. */\n  static readonly i16: Type = new Type(TypeKind.I16,\n    TypeFlags.SIGNED   |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  16\n  );\n\n  /** A 32-bit signed integer. */\n  static readonly i32: Type = new Type(TypeKind.I32,\n    TypeFlags.SIGNED   |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit signed integer. */\n  static readonly i64: Type = new Type(TypeKind.I64,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 32-bit signed size. WASM32 only. */\n  static readonly isize32: Type = new Type(TypeKind.ISIZE,\n    TypeFlags.SIGNED   |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit signed size. WASM64 only. */\n  static readonly isize64: Type = new Type(TypeKind.ISIZE,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** An 8-bit unsigned integer. */\n  static readonly u8: Type = new Type(TypeKind.U8,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   8\n  );\n\n  /** A 16-bit unsigned integer. */\n  static readonly u16: Type = new Type(TypeKind.U16,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  16\n  );\n\n  /** A 32-bit unsigned integer. */\n  static readonly u32: Type = new Type(TypeKind.U32,\n    TypeFlags.UNSIGNED |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit unsigned integer. */\n  static readonly u64: Type = new Type(TypeKind.U64,\n    TypeFlags.UNSIGNED |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 32-bit unsigned size. WASM32 only. */\n  static readonly usize32: Type = new Type(TypeKind.USIZE,\n    TypeFlags.UNSIGNED |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit unsigned size. WASM64 only. */\n  static readonly usize64: Type = new Type(TypeKind.USIZE,\n    TypeFlags.UNSIGNED |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 1-bit unsigned integer. */\n  static readonly bool: Type = new Type(TypeKind.BOOL,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   1\n  );\n\n  /** A 32-bit float. */\n  static readonly f32: Type = new Type(TypeKind.F32,\n    TypeFlags.SIGNED   |\n    TypeFlags.FLOAT    |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit float. */\n  static readonly f64: Type = new Type(TypeKind.F64,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.FLOAT    |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 128-bit vector. */\n  static readonly v128: Type = new Type(TypeKind.V128,\n    TypeFlags.VECTOR   |\n    TypeFlags.VALUE, 128\n  );\n\n  /** Function reference. */\n  static readonly funcref: Type = new Type(TypeKind.FUNCREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** External reference. */\n  static readonly externref: Type = new Type(TypeKind.EXTERNREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** Any reference. */\n  static readonly anyref: Type = new Type(TypeKind.ANYREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** Equatable reference. */\n  static readonly eqref: Type = new Type(TypeKind.EQREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** 31-bit integer reference. */\n  static readonly i31ref: Type = new Type(TypeKind.I31REF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** Data reference. */\n  static readonly dataref: Type = new Type(TypeKind.DATAREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** No return type. */\n  static readonly void: Type = new Type(TypeKind.VOID, TypeFlags.NONE, 0);\n\n  /** Alias of i32 indicating type inference of locals and globals with just an initializer. */\n  static readonly auto: Type = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);\n}\n\n/** Converts an array of types to an array of type references. */\nexport function typesToRefs(types: Type[]): TypeRef[] {\n  var numTypes = types.length;\n  var ret = new Array<TypeRef>(numTypes);\n  for (let i = 0; i < numTypes; ++i) ret[i] = types[i].toRef();\n  return ret;\n}\n\n/** Converts an array of types to its combined string representation. */\nexport function typesToString(types: Type[]): string {\n  var numTypes = types.length;\n  if (!numTypes) return \"\";\n  var sb = new Array<string>(numTypes);\n  for (let i = 0; i < numTypes; ++i) sb[i] = types[i].toString(true);\n  return sb.join(\",\");\n}\n\n/** Represents a fully resolved function signature. */\nexport class Signature {\n  /** Unique id representing this signature. */\n  id: u32 = 0;\n  /** Parameter types, if any, excluding `this`. */\n  parameterTypes: Type[];\n  /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n  requiredParameters: i32;\n  /** Return type. */\n  returnType: Type;\n  /** This type, if an instance signature. */\n  thisType: Type | null;\n  /** Whether the last parameter is a rest parameter. */\n  hasRest: bool;\n  /** Respective function type. */\n  type: Type;\n  /** The program that created this signature. */\n  program: Program;\n\n  /** Constructs a new signature. */\n  constructor(\n    program: Program,\n    parameterTypes: Type[] | null = null,\n    returnType: Type | null = null,\n    thisType: Type | null = null\n  ) {\n    this.parameterTypes = parameterTypes ? parameterTypes : [];\n    this.requiredParameters = 0;\n    this.returnType = returnType ? returnType : Type.void;\n    this.thisType = thisType;\n    this.program = program;\n    this.hasRest = false;\n    var usizeType = program.options.usizeType;\n    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);\n    this.type = type;\n    type.signatureReference = this;\n\n    var signatureTypes = program.uniqueSignatures;\n    var length = signatureTypes.length;\n    for (let i = 0; i < length; i++) {\n      let compare = signatureTypes[i];\n      if (this.equals(compare)) {\n        this.id = compare.id;\n        return this;\n      }\n    }\n    this.id = program.nextSignatureId++;\n    program.uniqueSignatures.push(this);\n  }\n\n  get paramRefs(): TypeRef {\n    var thisType = this.thisType;\n    var parameterTypes = this.parameterTypes;\n    var numParameterTypes = parameterTypes.length;\n    if (!numParameterTypes) {\n      if (!thisType) return TypeRef.None;\n      return thisType.toRef();\n    }\n    if (thisType) {\n      let typeRefs = new Array<TypeRef>(1 + numParameterTypes);\n      typeRefs[0] = thisType.toRef();\n      for (let i = 0; i < numParameterTypes; ++i) {\n        typeRefs[i + 1] = parameterTypes[i].toRef();\n      }\n      return createType(typeRefs);\n    }\n    return createType(typesToRefs(parameterTypes));\n  }\n\n  get resultRefs(): TypeRef {\n    return this.returnType.toRef();\n  }\n\n  /** Tests if this signature equals the specified. */\n  equals(other: Signature): bool {\n\n    // check `this` type\n    var thisThisType = this.thisType;\n    var otherThisType = other.thisType;\n    if (thisThisType !== null) {\n      if (otherThisType === null || !thisThisType.equals(otherThisType)) return false;\n    } else if (otherThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != other.hasRest) return false;\n\n    // check parameter types\n    var thisParameterTypes = this.parameterTypes;\n    var otherParameterTypes = other.parameterTypes;\n    var numParameters = thisParameterTypes.length;\n    if (numParameters != otherParameterTypes.length) return false;\n    for (let i = 0; i < numParameters; ++i) {\n      if (!thisParameterTypes[i].equals(otherParameterTypes[i])) return false;\n    }\n\n    // check return type\n    return this.returnType.equals(other.returnType);\n  }\n\n  /** Tests if a value of this function type is assignable to a target of the specified function type. */\n  isAssignableTo(target: Signature, requireSameSize: bool = false): bool {\n\n    // check `this` type\n    var thisThisType = this.thisType;\n    var targetThisType = target.thisType;\n    if (thisThisType !== null) {\n      if (targetThisType === null || !thisThisType.isAssignableTo(targetThisType)) return false;\n    } else if (targetThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != target.hasRest) return false; // TODO\n\n    // check parameter types\n    var thisParameterTypes = this.parameterTypes;\n    var targetParameterTypes = target.parameterTypes;\n    var numParameters = thisParameterTypes.length;\n    if (numParameters != targetParameterTypes.length) return false; // TODO\n    for (let i = 0; i < numParameters; ++i) {\n      let thisParameterType = thisParameterTypes[i];\n      let targetParameterType = targetParameterTypes[i];\n      if (!thisParameterType.isAssignableTo(targetParameterType)) return false;\n    }\n\n    // check return type\n    var thisReturnType = this.returnType;\n    var targetReturnType = target.returnType;\n    return thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType);\n  }\n\n  /** Tests if this signature has at least one managed operand. */\n  get hasManagedOperands(): bool {\n    var thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isManaged) return true;\n    }\n    var parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (parameterTypes[i].isManaged) return true;\n    }\n    return false;\n  }\n\n  /** Gets the indices of all managed operands. */\n  getManagedOperandIndices(): i32[] {\n    var indices = new Array<i32>();\n    var index = 0;\n    var thisType = this.thisType;\n    if (thisType) {\n      if (thisType.isManaged) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    var parameterTypes = this.parameterTypes;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      if (parameterTypes[i].isManaged) {\n        indices.push(index);\n      }\n      ++index;\n    }\n    return indices;\n  }\n\n  /** Converts this signature to a string. */\n  toString(validWat: bool = false): string {\n    var sb = new Array<string>();\n    sb.push(validWat ? \"%28\" : \"(\");\n    var index = 0;\n    var thisType = this.thisType;\n    if (thisType) {\n      sb.push(validWat ? \"this:\" : \"this: \");\n      assert(!thisType.signatureReference);\n      sb.push(thisType.toString(validWat));\n      index = 1;\n    }\n    var parameters = this.parameterTypes;\n    var numParameters = parameters.length;\n    if (numParameters) {\n      let optionalStart = this.requiredParameters;\n      let restIndex = this.hasRest ? numParameters - 1 : -1;\n      for (let i = 0; i < numParameters; ++i, ++index) {\n        if (index) sb.push(validWat ? \"%2C\" : \", \");\n        if (i == restIndex) sb.push(\"...\");\n        sb.push(parameters[i].toString(validWat));\n        if (i >= optionalStart && i != restIndex) sb.push(\"?\");\n      }\n    }\n    sb.push(validWat ? \"%29=>\" : \") => \");\n    sb.push(this.returnType.toString(validWat));\n    return sb.join(\"\");\n  }\n\n  /** Creates a clone of this signature that is safe to modify. */\n  clone(): Signature {\n    var parameterTypes = this.parameterTypes;\n    var numParameterTypes = parameterTypes.length;\n    var cloneParameterTypes = new Array<Type>(numParameterTypes);\n    for (let i = 0; i < numParameterTypes; ++i) {\n      cloneParameterTypes[i] = parameterTypes[i];\n    }\n    return new Signature(this.program, cloneParameterTypes, this.returnType, this.thisType);\n  }\n}\n","/**\n * @fileoverview Various binary reading and writing utility.\n * @license Apache-2.0\n */\n\n/** Reads an 8-bit integer from the specified buffer. */\nexport function readI8(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset];\n}\n\n/** Writes an 8-bit integer to the specified buffer. */\nexport function writeI8(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset] = value;\n}\n\n/** Reads a 16-bit integer from the specified buffer. */\nexport function readI16(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8;\n}\n\n/** Writes a 16-bit integer to the specified buffer. */\nexport function writeI16(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n}\n\n/** Reads a 32-bit integer from the specified buffer. */\nexport function readI32(buffer: Uint8Array, offset: i32): i32 {\n  return i32(buffer[offset    ])\n       | i32(buffer[offset + 1]) << 8\n       | i32(buffer[offset + 2]) << 16\n       | i32(buffer[offset + 3]) << 24;\n}\n\n/** Writes a 32-bit integer to the specified buffer. */\nexport function writeI32(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n  buffer[offset + 2] = value >>> 16;\n  buffer[offset + 3] = value >>> 24;\n}\n\n/** Writes a 32-bit integer as a 64-bit integer to the specified buffer. */\nexport function writeI32AsI64(value: i32, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  writeI32(value, buffer, offset);\n  writeI32(unsigned || value >= 0 ? 0 : -1, buffer, offset + 4);\n}\n\n/** Reads a 64-bit integer from the specified buffer. */\nexport function readI64(buffer: Uint8Array, offset: i32): i64 {\n  var lo = readI32(buffer, offset);\n  var hi = readI32(buffer, offset + 4);\n  return i64_new(lo, hi);\n}\n\n/** Writes a 64-bit integer to the specified buffer. */\nexport function writeI64(value: i64, buffer: Uint8Array, offset: i32): void {\n  writeI32(i64_low(value), buffer, offset);\n  writeI32(i64_high(value), buffer, offset + 4);\n}\n\n/** Writes a 64-bit integer as a 32-bit integer to the specified buffer. */\nexport function writeI64AsI32(value: i64, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  assert(unsigned ? i64_is_u32(value) : i64_is_i32(value));\n  writeI32(i64_low(value), buffer, offset);\n}\n\n/** Reads a 32-bit float from the specified buffer. */\nexport function readF32(buffer: Uint8Array, offset: i32): f32 {\n  return i32_as_f32(readI32(buffer, offset));\n}\n\n/** Writes a 32-bit float to the specified buffer. */\nexport function writeF32(value: f32, buffer: Uint8Array, offset: i32): void {\n  writeI32(f32_as_i32(value), buffer, offset);\n}\n\n/** Reads a 64-bit float from the specified buffer. */\nexport function readF64(buffer: Uint8Array, offset: i32): f64 {\n  return i64_as_f64(readI64(buffer, offset));\n}\n\n/** Writes a 64-bit float to the specified buffer. */\nexport function writeF64(value: f64, buffer: Uint8Array, offset: i32): void {\n  var valueI64 = f64_as_i64(value);\n  writeI32(i64_low(valueI64), buffer, offset);\n  writeI32(i64_high(valueI64), buffer, offset + 4);\n}\n","/**\n * @fileoverview Various collections utility.\n * @license Apache-2.0\n */\n\n/** Makes a unique map. Typically used to track contextual type arguemnts. */\nexport function uniqueMap<K,V>(original: Map<K,V> | null = null, overrides: Map<K,V> | null = null): Map<K,V> {\n  var cloned = new Map<K,V>();\n  if (original) {\n    // TODO: for (let [k, v] of original) {\n    for (let _keys = Map_keys(original), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(original.get(k));\n      cloned.set(k, v);\n    }\n  }\n  if (overrides) {\n    // TODO: for (let [k, v] of overrides) {\n    for (let _keys = Map_keys(overrides), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(overrides.get(k));\n      cloned.set(k, v);\n    }\n  }\n  return cloned;\n}\n","/**\n * @fileoverview Various utility.\n * @license Apache-2.0\n */\n\nexport * from \"./binary\";\nexport * from \"./collections\";\nexport * from \"./math\";\nexport * from \"./path\";\nexport * from \"./terminal\";\nexport * from \"./text\";\nexport * from \"./vector\";\n","/**\n * @fileoverview Various math utility.\n * @license Apache-2.0\n */\n\n/** Tests if `x` is a power of two. */\nexport function isPowerOf2(x: i32): bool {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n","/**\n * @fileoverview Various file path utility.\n * @license Apache-2.0\n */\n\nimport {\n  CharCode\n} from \"./text\";\n\nimport {\n  PATH_DELIMITER\n} from \"../common\";\n\nconst separator = CharCode.SLASH;\n\n/**\n * Normalizes the specified path, removing interior placeholders.\n * Expects a posix-compatible relative path (not Windows compatible).\n */\nexport function normalizePath(path: string): string {\n  var pos = 0;\n  var len = path.length;\n\n  // trim leading './'\n  while (pos + 1 < len &&\n    path.charCodeAt(pos) == CharCode.DOT &&\n    path.charCodeAt(pos + 1) == separator\n  ) {\n    pos += 2;\n  }\n\n  if (pos > 0 || len < path.length) {\n    path = path.substring(pos, len);\n    len -= pos;\n    pos = 0;\n  }\n\n  var atEnd: bool;\n  while (pos + 1 < len) {\n    atEnd = false;\n\n    // we are only interested in '/.' sequences ...\n    if (\n      path.charCodeAt(pos) == separator &&\n      path.charCodeAt(pos + 1) == CharCode.DOT\n    ) {\n      // '/.' ( '/' | $ )\n      atEnd = pos + 2 == len;\n      if (atEnd ||\n        pos + 2 < len &&\n        path.charCodeAt(pos + 2) == separator\n      ) {\n        path = atEnd\n          ? path.substring(0, pos)\n          : path.substring(0, pos) + path.substring(pos + 2);\n        len -= 2;\n        continue;\n      }\n\n      // '/.' ( './' | '.' $ )\n      atEnd = pos + 3 == len;\n      if (atEnd && path.charCodeAt(pos + 2) == CharCode.DOT ||\n        pos + 3 < len &&\n        path.charCodeAt(pos + 2) == CharCode.DOT &&\n        path.charCodeAt(pos + 3) == separator\n      ) {\n        // find preceeding '/'\n        let ipos = pos;\n        while (--ipos >= 0) {\n          if (path.charCodeAt(ipos) == separator) {\n            if (pos - ipos != 3 ||\n              path.charCodeAt(ipos + 1) != CharCode.DOT ||\n              path.charCodeAt(ipos + 2) != CharCode.DOT\n            ) { // exclude '..' itself\n              path = atEnd\n                ? path.substring(0, ipos)\n                : path.substring(0, ipos) + path.substring(pos + 3);\n              len -= pos + 3 - ipos;\n              pos = ipos - 1; // incremented again at end of loop\n            }\n            break;\n          }\n        }\n\n        // if there's no preceeding '/', trim start if non-empty\n        if (ipos < 0 && pos > 0) {\n          if (pos != 2 ||\n            path.charCodeAt(0) != CharCode.DOT ||\n            path.charCodeAt(1) != CharCode.DOT\n          ) { // exclude '..' itself\n            path = path.substring(pos + 4);\n            len = path.length;\n            continue;\n          }\n        }\n      }\n    }\n    pos++;\n  }\n  return len > 0 ? path : \".\";\n}\n\n/** Resolves the specified path relative to the specified origin. */\nexport function resolvePath(normalizedPath: string, origin: string): string {\n  if (normalizedPath.startsWith(\"std/\")) {\n    return normalizedPath;\n  }\n  return normalizePath(\n    dirname(origin) + PATH_DELIMITER + normalizedPath\n  );\n}\n\n/** Obtains the directory portion of a normalized path. */\nexport function dirname(normalizedPath: string): string {\n  var pos = normalizedPath.length;\n  if (pos <= 1) {\n    if (pos == 0) return \".\";\n    if (normalizedPath.charCodeAt(0) == separator) {\n      return normalizedPath;\n    }\n  }\n  while (--pos > 0) {\n    if (normalizedPath.charCodeAt(pos) == separator) {\n      return normalizedPath.substring(0, pos);\n    }\n  }\n  return \".\";\n}\n","/**\n * @fileoverview Terminal utility.\n * @license Apache-2.0\n */\n\n/** Gray terminal color code. */\nexport const COLOR_GRAY = \"\\u001b[90m\";\n/** Red terminal color code. */\nexport const COLOR_RED = \"\\u001b[91m\";\n/** Green terminal color code. */\nexport const COLOR_GREEN = \"\\u001b[92m\";\n/** Yellow terminal color code. */\nexport const COLOR_YELLOW = \"\\u001b[93m\";\n/** Blue terminal color code. */\nexport const COLOR_BLUE = \"\\u001b[94m\";\n/** Magenta terminal color code. */\nexport const COLOR_MAGENTA = \"\\u001b[95m\";\n/** Cyan terminal color code. */\nexport const COLOR_CYAN = \"\\u001b[96m\";\n/** White terminal color code. */\nexport const COLOR_WHITE = \"\\u001b[97m\";\n/** Terminal color reset code. */\nexport const COLOR_RESET = \"\\u001b[0m\";\n\n/** Whether terminal colors are enabled or not. */\nvar colorsEnabled = true;\n\n/** Checks whether terminal colors are enabled or not. */\nexport function isColorsEnabled(): bool {\n  return colorsEnabled;\n}\n\n/** Sets whether terminal colors are enabled or not. */\nexport function setColorsEnabled(isEnabled: bool): bool {\n  var wasEnabled = isEnabled;\n  colorsEnabled = isEnabled;\n  return wasEnabled;\n}\n\n/** Wraps the specified text in the specified terminal color code. */\nexport function colorize(text: string, color: string): string {\n  return colorsEnabled ? color + text + COLOR_RESET : text;\n}\n","/**\n * @fileoverview Various character and text utility.\n * @license Apache-2.0\n */\n\n/** An enum of named character codes. */\nexport const enum CharCode {\n\n  NULL = 0,\n  LINEFEED = 0x0A,\n  CARRIAGERETURN = 0x0D,\n  LINESEPARATOR = 0x2028,\n  PARAGRAPHSEPARATOR = 0x2029,\n  NEXTLINE = 0x0085,\n\n  SPACE = 0x20,\n  NONBREAKINGSPACE = 0xA0,\n  ENQUAD = 0x2000,\n  EMQUAD = 0x2001,\n  ENSPACE = 0x2002,\n  EMSPACE = 0x2003,\n  THREEPEREMSPACE = 0x2004,\n  FOURPEREMSPACE = 0x2005,\n  SIXPEREMSPACE = 0x2006,\n  FIGURESPACE = 0x2007,\n  PUNCTUATIONSPACE = 0x2008,\n  THINSPACE = 0x2009,\n  HAIRSPACE = 0x200A,\n  ZEROWIDTHSPACE = 0x200B,\n  NARROWNOBREAKSPACE = 0x202F,\n  IDEOGRAPHICSPACE = 0x3000,\n  MATHEMATICALSPACE = 0x205F,\n  OGHAM = 0x1680,\n\n  _ = 0x5F,\n\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n\n  a = 0x61,\n  b = 0x62,\n  c = 0x63,\n  d = 0x64,\n  e = 0x65,\n  f = 0x66,\n  g = 0x67,\n  h = 0x68,\n  i = 0x69,\n  j = 0x6A,\n  k = 0x6B,\n  l = 0x6C,\n  m = 0x6D,\n  n = 0x6E,\n  o = 0x6F,\n  p = 0x70,\n  q = 0x71,\n  r = 0x72,\n  s = 0x73,\n  t = 0x74,\n  u = 0x75,\n  v = 0x76,\n  w = 0x77,\n  x = 0x78,\n  y = 0x79,\n  z = 0x7A,\n\n  A = 0x41,\n  B = 0x42,\n  C = 0x43,\n  D = 0x44,\n  E = 0x45,\n  F = 0x46,\n  G = 0x47,\n  H = 0x48,\n  I = 0x49,\n  J = 0x4A,\n  K = 0x4B,\n  L = 0x4C,\n  M = 0x4D,\n  N = 0x4E,\n  O = 0x4F,\n  P = 0x50,\n  Q = 0x51,\n  R = 0x52,\n  S = 0x53,\n  T = 0x54,\n  U = 0x55,\n  V = 0x56,\n  W = 0x57,\n  X = 0x58,\n  Y = 0x59,\n  Z = 0x5a,\n\n  AMPERSAND = 0x26,\n  ASTERISK = 0x2A,\n  AT = 0x40,\n  BACKSLASH = 0x5C,\n  BACKTICK = 0x60,\n  BAR = 0x7C,\n  CARET = 0x5E,\n  CLOSEBRACE = 0x7D,\n  CLOSEBRACKET = 0x5D,\n  CLOSEPAREN = 0x29,\n  COLON = 0x3A,\n  COMMA = 0x2C,\n  DOLLAR = 0x24,\n  DOT = 0x2E,\n  DOUBLEQUOTE = 0x22,\n  EQUALS = 0x3D,\n  EXCLAMATION = 0x21,\n  GREATERTHAN = 0x3E,\n  HASH = 0x23,\n  LESSTHAN = 0x3C,\n  MINUS = 0x2D,\n  OPENBRACE = 0x7B,\n  OPENBRACKET = 0x5B,\n  OPENPAREN = 0x28,\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  QUESTION = 0x3F,\n  SEMICOLON = 0x3B,\n  SINGLEQUOTE = 0x27,\n  SLASH = 0x2F,\n  TILDE = 0x7E,\n\n  BACKSPACE = 0x08,\n  FORMFEED = 0x0C,\n  BYTEORDERMARK = 0xFEFF,\n  TAB = 0x09,\n  VERTICALTAB = 0x0B\n}\n\n/** Tests if the specified character code is some sort of line break. */\nexport function isLineBreak(c: i32): bool {\n  switch (c) {\n    case CharCode.LINEFEED:\n    case CharCode.CARRIAGERETURN:\n    case CharCode.LINESEPARATOR:\n    case CharCode.PARAGRAPHSEPARATOR: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\n/** Tests if the specified character code is some sort of white space. */\nexport function isWhiteSpace(c: i32): bool {\n  switch (c) {\n    case CharCode.SPACE:\n    case CharCode.TAB:\n    case CharCode.VERTICALTAB:\n    case CharCode.FORMFEED:\n    case CharCode.NONBREAKINGSPACE:\n    case CharCode.NEXTLINE:\n    case CharCode.OGHAM:\n    case CharCode.NARROWNOBREAKSPACE:\n    case CharCode.MATHEMATICALSPACE:\n    case CharCode.IDEOGRAPHICSPACE:\n    case CharCode.BYTEORDERMARK: {\n      return true;\n    }\n    default: {\n      return c >= CharCode.ENQUAD && c <= CharCode.ZEROWIDTHSPACE;\n    }\n  }\n}\n\n/** First high (lead) surrogate. */\nexport const SURROGATE_HIGH = 0xD800;\n\n/** First low (trail) surrogate. */\nexport const SURROGATE_LOW = 0xDC00;\n\n/** Tests if a code unit or code point is a surrogate. */\nexport function isSurrogate(c: i32): bool {\n  // F800: 11111 0 0000000000 Mask\n  // D800: 11011 X XXXXXXXXXX Any surrogate\n  return (c & 0xF800) == SURROGATE_HIGH;\n}\n\n/** Tests if a surrogate is a high (lead) surrogate. */\nexport function isSurrogateHigh(c: i32): bool {\n  // D800-DBFF\n  return c < SURROGATE_LOW;\n}\n\n/** Tests if a surrogate is a low (trail) surrogate. */\nexport function isSurrogateLow(c: i32): bool {\n  // DC00-DFFF\n  return c >= SURROGATE_LOW;\n}\n\n/** Tests if a code unit or code point is a high (lead) surrogate. */\nexport function isHighSurrogate(c: i32): bool {\n  // FC00: 11111 1 0000000000 Mask\n  // D800: 11011 0 XXXXXXXXXX High/Lead surrogate\n  return (c & 0xFC00) == SURROGATE_HIGH;\n}\n\n/** Tests if a code unit or code point is a low (trail) surrogate. */\nexport function isLowSurrogate(c: i32): bool {\n  // FC00: 11111 1 0000000000 Mask\n  // DC00: 11011 1 XXXXXXXXXX Low/Trail surrogate\n  return (c & 0xFC00) == SURROGATE_LOW;\n}\n\n/** Converts a surrogate pair to its respective code point. */\nexport function combineSurrogates(hi: i32, lo: i32): i32 {\n  return 0x10000 + ((hi & 0x3FF) << 10) | (lo & 0x3FF);\n}\n\nexport function isAlpha(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z;\n}\n\n/** Tests if the specified character code is a valid decimal digit. */\nexport function isDecimal(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid octal digit. */\nexport function isOctal(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._7;\n}\n\n/** Tests if the specified character code is a valid hexadecimal digit. */\nexport function isHex(c: i32): bool {\n  let c0 = c | 32; // unify uppercases and lowercases a|A - f|F\n  return isDecimal(c) || (c0 >= CharCode.a && c0 <= CharCode.f);\n}\n\n/** Tests if the specified character code is trivially alphanumeric. */\nexport function isAlphaOrDecimal(c: i32): bool {\n  return isAlpha(c) || isDecimal(c);\n}\n\n/** Tests if the specified character code is a valid start of an identifier. */\nexport function isIdentifierStart(c: i32): bool {\n  return isAlpha(c)\n      || c == CharCode._\n      || c == CharCode.DOLLAR\n      || c >= 170 && c <= 65500\n         && lookupInUnicodeMap(c as u16, unicodeIdentifierStart);\n}\n\n/** Tests if the specified character code is a valid part of an identifier. */\nexport function isIdentifierPart(c: i32): bool {\n  return isAlphaOrDecimal(c)\n      || c == CharCode._\n      || c == CharCode.DOLLAR\n      || c >= 170 && c <= 65500\n         && lookupInUnicodeMap(c as u16, unicodeIdentifierPart);\n}\n\n// storing as u16 to save memory\nconst unicodeIdentifierStart: u16[] = [\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\n  740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906,\n  908, 908, 910, 929, 931,\n  1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,\n  1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774,\n  1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969,\n  1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088,\n  2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384,\n  2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474,\n  2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,\n  2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613,\n  2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705,\n  2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784,\n  2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873,\n  2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958,\n  2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986,\n  2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125,\n  3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,\n  3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333,\n  3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,\n  3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634,\n  3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725,\n  3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757,\n  3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840,\n  3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186,\n  4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293,\n  4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696,\n  4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798,\n  4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992,\n  5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872,\n  5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016,\n  6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389,\n  6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688,\n  6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141,\n  7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424,\n  7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025,\n  8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130,\n  8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,\n  8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469,\n  8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505,\n  8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584,\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520,\n  11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670,\n  11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720,\n  11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329,\n  12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540,\n  12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893,\n  19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538,\n  42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888,\n  42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015,\n  43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,\n  43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520,\n  43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695,\n  43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739,\n  43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798,\n  43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243,\n  55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285,\n  64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323,\n  64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,\n  65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474,\n  65479, 65482, 65487, 65490, 65495, 65498, 65500,\n];\nconst unicodeIdentifierPart: u16[] = [\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\n  740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906,\n  908, 908, 910, 929, 931,\n  1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415,\n  1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520,\n  1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788,\n  1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112,\n  2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423,\n  2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482,\n  2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525,\n  2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602,\n  2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632,\n  2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693,\n  2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757,\n  2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821,\n  2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884,\n  2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929,\n  2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972,\n  2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018,\n  3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088,\n  3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157,\n  3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216,\n  3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285,\n  3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340,\n  3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424,\n  3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515,\n  3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570,\n  3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720,\n  3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751,\n  3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789,\n  3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895,\n  3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028,\n  4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304,\n  4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744,\n  4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808,\n  4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108,\n  5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902,\n  5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099,\n  6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272,\n  6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516,\n  6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783,\n  6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155,\n  7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676,\n  7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027,\n  8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134,\n  8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205,\n  8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417,\n  8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477,\n  8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517,\n  8521, 8526, 8526, 8544, 8584,\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559,\n  11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686,\n  11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728,\n  11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335,\n  12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449,\n  12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799,\n  13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512,\n  42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783,\n  42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072,\n  43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309,\n  43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584,\n  43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741,\n  43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808,\n  43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203,\n  55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275,\n  64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321,\n  64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008,\n  65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140,\n  65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382,\n  65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,\n];\n\nfunction lookupInUnicodeMap(code: u16, map: u16[]): bool {\n  var lo = 0;\n  var hi = map.length;\n  var mid: u32;\n  var midVal: u16;\n\n  while (lo + 1 < hi) {\n    mid = lo + ((hi - lo) >>> 1);\n    mid -= (mid & 1);\n    midVal = map[mid];\n    if (midVal <= code && code <= map[mid + 1]) {\n      return true;\n    }\n    if (code < midVal) {\n      hi = mid;\n    } else {\n      lo = mid + 2;\n    }\n  }\n  return false;\n}\n\nconst indentX1 = \"  \";\nconst indentX2 = \"    \";\nconst indentX4 = \"        \";\n\n/** Creates an indentation matching the number of specified levels. */\nexport function indent(sb: string[], level: i32): void {\n  while (level >= 4) {\n    sb.push(indentX4);\n    level -= 4;\n  }\n  if (level >= 2) {\n    sb.push(indentX2);\n    level -= 2;\n  }\n  if (level) {\n    sb.push(indentX1);\n  }\n}\n","/**\n * @fileoverview Various vector utility.\n * @license Apache-2.0\n */\n\n/** v128 zero constant. */\nexport const v128_zero = new Uint8Array(16);\n","// This file is shared with the compiler and must remain portable\n\n/** Indicates specific features to activate. */\nexport const enum Feature {\n  /** No additional features. */\n  NONE = 0,\n  /** Sign extension operations. */\n  SIGN_EXTENSION = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\n  /** Mutable global imports and exports. */\n  MUTABLE_GLOBALS = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\n  /** Non-trapping float to integer operations. */\n  NONTRAPPING_F2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  /** Bulk memory operations. */\n  BULK_MEMORY = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\n  /** SIMD types and operations. */\n  SIMD = 1 << 4, // see: https://github.com/WebAssembly/simd\n  /** Threading and atomic operations. */\n  THREADS = 1 << 5, // see: https://github.com/WebAssembly/threads\n  /** Exception handling operations. */\n  EXCEPTION_HANDLING = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\n  /** Tail call operations. */\n  TAIL_CALLS = 1 << 7, // see: https://github.com/WebAssembly/tail-call\n  /** Reference types. */\n  REFERENCE_TYPES = 1 << 8, // see: https://github.com/WebAssembly/reference-types\n  /** Multi value types. */\n  MULTI_VALUE = 1 << 9, // see: https://github.com/WebAssembly/multi-value\n  /** Garbage collection. */\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\n  /** Memory64. */\n  MEMORY64 = 1 << 11 // see: https://github.com/WebAssembly/memory64\n}\n\n/** Gets the name of the specified feature one would specify on the command line. */\nexport function featureToString(feature: Feature): string {\n  switch (feature) {\n    case Feature.SIGN_EXTENSION: return \"sign-extension\";\n    case Feature.MUTABLE_GLOBALS: return \"mutable-globals\";\n    case Feature.NONTRAPPING_F2I: return \"nontrapping-f2i\";\n    case Feature.BULK_MEMORY: return \"bulk-memory\";\n    case Feature.SIMD: return \"simd\";\n    case Feature.THREADS: return \"threads\";\n    case Feature.EXCEPTION_HANDLING: return \"exception-handling\";\n    case Feature.TAIL_CALLS: return \"tail-calls\";\n    case Feature.REFERENCE_TYPES: return \"reference-types\";\n    case Feature.MULTI_VALUE: return \"multi-value\";\n    case Feature.GC: return \"gc\";\n    case Feature.MEMORY64: return \"memory64\";\n  }\n  assert(false);\n  return \"\";\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Compilation target. */\nexport enum Target {\n  /** Portable. */\n  JS = 0,\n  /** WebAssembly with 32-bit pointers. */\n  WASM32 = 1,\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\n  WASM64 = 2,\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__725__;","// GENERATED FILE. DO NOT EDIT.\nvar Long = (function(exports) {\n  \"use strict\";\n  \n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = void 0;\n  \n  /**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   */\n  // WebAssembly optimizations to do native i64 multiplication and divide\n  var wasm = null;\n  \n  try {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n  } catch (e) {// no wasm support :(\n  }\n  /**\n   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n   *  See the from* functions below for more convenient ways of constructing Longs.\n   * @exports Long\n   * @class A Long class for representing a 64 bit two's-complement integer value.\n   * @param {number} low The low (signed) 32 bits of the long\n   * @param {number} high The high (signed) 32 bits of the long\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @constructor\n   */\n  \n  \n  function Long(low, high, unsigned) {\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */\n    this.low = low | 0;\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */\n  \n    this.high = high | 0;\n    /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */\n  \n    this.unsigned = !!unsigned;\n  } // The internal representation of a long is the two given signed, 32-bit values.\n  // We use 32-bit pieces because these are the size of integers on which\n  // Javascript performs bit-operations.  For operations like addition and\n  // multiplication, we split each number into 16 bit pieces, which can easily be\n  // multiplied within Javascript's floating-point representation without overflow\n  // or change in sign.\n  //\n  // In the algorithms below, we frequently reduce the negative case to the\n  // positive case by negating the input(s) and then post-processing the result.\n  // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n  // a positive number, it overflows back into a negative).  Not handling this\n  // case would often result in infinite recursion.\n  //\n  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n  // methods on which they depend.\n  \n  /**\n   * An indicator used to reliably determine if an object is a Long or not.\n   * @type {boolean}\n   * @const\n   * @private\n   */\n  \n  \n  Long.prototype.__isLong__;\n  Object.defineProperty(Long.prototype, \"__isLong__\", {\n    value: true\n  });\n  /**\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   * @inner\n   */\n  \n  function isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n  }\n  /**\n   * @function\n   * @param {*} value number\n   * @returns {number}\n   * @inner\n   */\n  \n  \n  function ctz32(value) {\n    var c = Math.clz32(value & -value);\n    return value ? 31 - c : c;\n  }\n  /**\n   * Tests if the specified object is a Long.\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   */\n  \n  \n  Long.isLong = isLong;\n  /**\n   * A cache of the Long representations of small integer values.\n   * @type {!Object}\n   * @inner\n   */\n  \n  var INT_CACHE = {};\n  /**\n   * A cache of the Long representations of small unsigned integer values.\n   * @type {!Object}\n   * @inner\n   */\n  \n  var UINT_CACHE = {};\n  /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n  \n    if (unsigned) {\n      value >>>= 0;\n  \n      if (cache = 0 <= value && value < 256) {\n        cachedObj = UINT_CACHE[value];\n        if (cachedObj) return cachedObj;\n      }\n  \n      obj = fromBits(value, 0, true);\n      if (cache) UINT_CACHE[value] = obj;\n      return obj;\n    } else {\n      value |= 0;\n  \n      if (cache = -128 <= value && value < 128) {\n        cachedObj = INT_CACHE[value];\n        if (cachedObj) return cachedObj;\n      }\n  \n      obj = fromBits(value, value < 0 ? -1 : 0, false);\n      if (cache) INT_CACHE[value] = obj;\n      return obj;\n    }\n  }\n  /**\n   * Returns a Long representing the given 32 bit integer value.\n   * @function\n   * @param {number} value The 32 bit integer in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromInt = fromInt;\n  /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromNumber(value, unsigned) {\n    if (isNaN(value)) return unsigned ? UZERO : ZERO;\n  \n    if (unsigned) {\n      if (value < 0) return UZERO;\n      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n    } else {\n      if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n    }\n  \n    if (value < 0) return fromNumber(-value, unsigned).neg();\n    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n  }\n  /**\n   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @function\n   * @param {number} value The number in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromNumber = fromNumber;\n  /**\n   * @param {number} lowBits\n   * @param {number} highBits\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n  }\n  /**\n   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n   *  assumed to use 32 bits.\n   * @function\n   * @param {number} lowBits The low 32 bits\n   * @param {number} highBits The high 32 bits\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBits = fromBits;\n  /**\n   * @function\n   * @param {number} base\n   * @param {number} exponent\n   * @returns {number}\n   * @inner\n   */\n  \n  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n  \n  /**\n   * @param {string} str\n   * @param {(boolean|number)=} unsigned\n   * @param {number=} radix\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromString(str, unsigned, radix) {\n    if (str.length === 0) throw Error('empty string');\n  \n    if (typeof unsigned === 'number') {\n      // For goog.math.long compatibility\n      radix = unsigned;\n      unsigned = false;\n    } else {\n      unsigned = !!unsigned;\n    }\n  \n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return unsigned ? UZERO : ZERO;\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw RangeError('radix');\n    var p;\n    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {\n      return fromString(str.substring(1), unsigned, radix).neg();\n    } // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n  \n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n    var result = ZERO;\n  \n    for (var i = 0; i < str.length; i += 8) {\n      var size = Math.min(8, str.length - i),\n          value = parseInt(str.substring(i, i + size), radix);\n  \n      if (size < 8) {\n        var power = fromNumber(pow_dbl(radix, size));\n        result = result.mul(power).add(fromNumber(value));\n      } else {\n        result = result.mul(radixToPower);\n        result = result.add(fromNumber(value));\n      }\n    }\n  \n    result.unsigned = unsigned;\n    return result;\n  }\n  /**\n   * Returns a Long representation of the given string, written using the specified radix.\n   * @function\n   * @param {string} str The textual representation of the Long\n   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromString = fromString;\n  /**\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromValue(val, unsigned) {\n    if (typeof val === 'number') return fromNumber(val, unsigned);\n    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:\n  \n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n  }\n  /**\n   * Converts the specified value to a Long using the appropriate from* function for its type.\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long}\n   */\n  \n  \n  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n  // no runtime penalty for these.\n  \n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_16_DBL = 1 << 16;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_24_DBL = 1 << 24;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n  /**\n   * @type {!Long}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var ZERO = fromInt(0);\n  /**\n   * Signed zero.\n   * @type {!Long}\n   */\n  \n  Long.ZERO = ZERO;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var UZERO = fromInt(0, true);\n  /**\n   * Unsigned zero.\n   * @type {!Long}\n   */\n  \n  Long.UZERO = UZERO;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var ONE = fromInt(1);\n  /**\n   * Signed one.\n   * @type {!Long}\n   */\n  \n  Long.ONE = ONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var UONE = fromInt(1, true);\n  /**\n   * Unsigned one.\n   * @type {!Long}\n   */\n  \n  Long.UONE = UONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var NEG_ONE = fromInt(-1);\n  /**\n   * Signed negative one.\n   * @type {!Long}\n   */\n  \n  Long.NEG_ONE = NEG_ONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n  /**\n   * Maximum signed value.\n   * @type {!Long}\n   */\n  \n  Long.MAX_VALUE = MAX_VALUE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n  /**\n   * Maximum unsigned value.\n   * @type {!Long}\n   */\n  \n  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n  /**\n   * Minimum signed value.\n   * @type {!Long}\n   */\n  \n  Long.MIN_VALUE = MIN_VALUE;\n  /**\n   * @alias Long.prototype\n   * @inner\n   */\n  \n  var LongPrototype = Long.prototype;\n  /**\n   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  LongPrototype.toInt = function toInt() {\n    return this.unsigned ? this.low >>> 0 : this.low;\n  };\n  /**\n   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  \n  LongPrototype.toNumber = function toNumber() {\n    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n  };\n  /**\n   * Converts the Long to a string written in the specified radix.\n   * @this {!Long}\n   * @param {number=} radix Radix (2-36), defaults to 10\n   * @returns {string}\n   * @override\n   * @throws {RangeError} If `radix` is out of range\n   */\n  \n  \n  LongPrototype.toString = function toString(radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw RangeError('radix');\n    if (this.isZero()) return '0';\n  \n    if (this.isNegative()) {\n      // Unsigned Longs are never negative\n      if (this.eq(MIN_VALUE)) {\n        // We need to change the Long value before it can be negated, so we remove\n        // the bottom-most digit in this base and then recurse to do the rest.\n        var radixLong = fromNumber(radix),\n            div = this.div(radixLong),\n            rem1 = div.mul(radixLong).sub(this);\n        return div.toString(radix) + rem1.toInt().toString(radix);\n      } else return '-' + this.neg().toString(radix);\n    } // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n  \n  \n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n        rem = this;\n    var result = '';\n  \n    while (true) {\n      var remDiv = rem.div(radixToPower),\n          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n          digits = intval.toString(radix);\n      rem = remDiv;\n      if (rem.isZero()) return digits + result;else {\n        while (digits.length < 6) digits = '0' + digits;\n  \n        result = '' + digits + result;\n      }\n    }\n  };\n  /**\n   * Gets the high 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed high bits\n   */\n  \n  \n  LongPrototype.getHighBits = function getHighBits() {\n    return this.high;\n  };\n  /**\n   * Gets the high 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned high bits\n   */\n  \n  \n  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n    return this.high >>> 0;\n  };\n  /**\n   * Gets the low 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed low bits\n   */\n  \n  \n  LongPrototype.getLowBits = function getLowBits() {\n    return this.low;\n  };\n  /**\n   * Gets the low 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned low bits\n   */\n  \n  \n  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n    return this.low >>> 0;\n  };\n  /**\n   * Gets the number of bits needed to represent the absolute value of this Long.\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  \n  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n    if (this.isNegative()) // Unsigned Longs are never negative\n      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n    var val = this.high != 0 ? this.high : this.low;\n  \n    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;\n  \n    return this.high != 0 ? bit + 33 : bit + 1;\n  };\n  /**\n   * Tests if this Long's value equals zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isZero = function isZero() {\n    return this.high === 0 && this.low === 0;\n  };\n  /**\n   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.eqz = LongPrototype.isZero;\n  /**\n   * Tests if this Long's value is negative.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  LongPrototype.isNegative = function isNegative() {\n    return !this.unsigned && this.high < 0;\n  };\n  /**\n   * Tests if this Long's value is positive or zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isPositive = function isPositive() {\n    return this.unsigned || this.high >= 0;\n  };\n  /**\n   * Tests if this Long's value is odd.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isOdd = function isOdd() {\n    return (this.low & 1) === 1;\n  };\n  /**\n   * Tests if this Long's value is even.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isEven = function isEven() {\n    return (this.low & 1) === 0;\n  };\n  /**\n   * Tests if this Long's value equals the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.equals = function equals(other) {\n    if (!isLong(other)) other = fromValue(other);\n    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n    return this.high === other.high && this.low === other.low;\n  };\n  /**\n   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.eq = LongPrototype.equals;\n  /**\n   * Tests if this Long's value differs from the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.notEquals = function notEquals(other) {\n    return !this.eq(\n    /* validates */\n    other);\n  };\n  /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.neq = LongPrototype.notEquals;\n  /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.ne = LongPrototype.notEquals;\n  /**\n   * Tests if this Long's value is less than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.lessThan = function lessThan(other) {\n    return this.comp(\n    /* validates */\n    other) < 0;\n  };\n  /**\n   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.lt = LongPrototype.lessThan;\n  /**\n   * Tests if this Long's value is less than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n    return this.comp(\n    /* validates */\n    other) <= 0;\n  };\n  /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.lte = LongPrototype.lessThanOrEqual;\n  /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.le = LongPrototype.lessThanOrEqual;\n  /**\n   * Tests if this Long's value is greater than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.greaterThan = function greaterThan(other) {\n    return this.comp(\n    /* validates */\n    other) > 0;\n  };\n  /**\n   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.gt = LongPrototype.greaterThan;\n  /**\n   * Tests if this Long's value is greater than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n    return this.comp(\n    /* validates */\n    other) >= 0;\n  };\n  /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n  /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n  /**\n   * Compares this Long's value with the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */\n  \n  LongPrototype.compare = function compare(other) {\n    if (!isLong(other)) other = fromValue(other);\n    if (this.eq(other)) return 0;\n    var thisNeg = this.isNegative(),\n        otherNeg = other.isNegative();\n    if (thisNeg && !otherNeg) return -1;\n    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same\n  \n    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned\n  \n    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n  };\n  /**\n   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */\n  \n  \n  LongPrototype.comp = LongPrototype.compare;\n  /**\n   * Negates this Long's value.\n   * @this {!Long}\n   * @returns {!Long} Negated Long\n   */\n  \n  LongPrototype.negate = function negate() {\n    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n    return this.not().add(ONE);\n  };\n  /**\n   * Negates this Long's value. This is an alias of {@link Long#negate}.\n   * @function\n   * @returns {!Long} Negated Long\n   */\n  \n  \n  LongPrototype.neg = LongPrototype.negate;\n  /**\n   * Returns the sum of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} addend Addend\n   * @returns {!Long} Sum\n   */\n  \n  LongPrototype.add = function add(addend) {\n    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n  \n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n    var c48 = 0,\n        c32 = 0,\n        c16 = 0,\n        c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n  };\n  /**\n   * Returns the difference of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */\n  \n  \n  LongPrototype.subtract = function subtract(subtrahend) {\n    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n    return this.add(subtrahend.neg());\n  };\n  /**\n   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n   * @function\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */\n  \n  \n  LongPrototype.sub = LongPrototype.subtract;\n  /**\n   * Returns the product of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */\n  \n  LongPrototype.multiply = function multiply(multiplier) {\n    if (this.isZero()) return this;\n    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present\n  \n    if (wasm) {\n      var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n  \n    if (this.isNegative()) {\n      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();\n    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication\n  \n  \n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n  \n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n    var c48 = 0,\n        c32 = 0,\n        c16 = 0,\n        c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n  };\n  /**\n   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n   * @function\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */\n  \n  \n  LongPrototype.mul = LongPrototype.multiply;\n  /**\n   * Returns this Long divided by the specified. The result is signed if this Long is signed or\n   *  unsigned if this Long is unsigned.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */\n  \n  LongPrototype.divide = function divide(divisor) {\n    if (!isLong(divisor)) divisor = fromValue(divisor);\n    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present\n  \n    if (wasm) {\n      // guard against signed division overflow: the largest\n      // negative number / -1 would be 1 larger than the largest\n      // positive number, due to two's complement.\n      if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n        // be consistent with non-wasm code path\n        return this;\n      }\n  \n      var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(this.low, this.high, divisor.low, divisor.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n  \n    if (!this.unsigned) {\n      // This section is only relevant for signed longs and is derived from the\n      // closure library as a whole.\n      if (this.eq(MIN_VALUE)) {\n        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n        else if (divisor.eq(MIN_VALUE)) return ONE;else {\n          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n          var halfThis = this.shr(1);\n          approx = halfThis.div(divisor).shl(1);\n  \n          if (approx.eq(ZERO)) {\n            return divisor.isNegative() ? ONE : NEG_ONE;\n          } else {\n            rem = this.sub(divisor.mul(approx));\n            res = approx.add(rem.div(divisor));\n            return res;\n          }\n        }\n      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n  \n      if (this.isNegative()) {\n        if (divisor.isNegative()) return this.neg().div(divisor.neg());\n        return this.neg().div(divisor).neg();\n      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n  \n      res = ZERO;\n    } else {\n      // The algorithm below has not been made for unsigned longs. It's therefore\n      // required to take special care of the MSB prior to running it.\n      if (!divisor.unsigned) divisor = divisor.toUnsigned();\n      if (divisor.gt(this)) return UZERO;\n      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n        return UONE;\n      res = UZERO;\n    } // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n  \n  \n    rem = this;\n  \n    while (rem.gte(divisor)) {\n      // Approximate the result of division. This may be a little greater or\n      // smaller than the actual value.\n      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or\n      // the smallest non-fractional digit, whichever is larger.\n  \n      var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),\n          // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      approxRes = fromNumber(approx),\n          approxRem = approxRes.mul(divisor);\n  \n      while (approxRem.isNegative() || approxRem.gt(rem)) {\n        approx -= delta;\n        approxRes = fromNumber(approx, this.unsigned);\n        approxRem = approxRes.mul(divisor);\n      } // We know the answer can't be zero... and actually, zero would cause\n      // infinite recursion since we would make no progress.\n  \n  \n      if (approxRes.isZero()) approxRes = ONE;\n      res = res.add(approxRes);\n      rem = rem.sub(approxRem);\n    }\n  \n    return res;\n  };\n  /**\n   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */\n  \n  \n  LongPrototype.div = LongPrototype.divide;\n  /**\n   * Returns this Long modulo the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  LongPrototype.modulo = function modulo(divisor) {\n    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present\n  \n    if (wasm) {\n      var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(this.low, this.high, divisor.low, divisor.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    return this.sub(this.div(divisor).mul(divisor));\n  };\n  /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  \n  LongPrototype.mod = LongPrototype.modulo;\n  /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  LongPrototype.rem = LongPrototype.modulo;\n  /**\n   * Returns the bitwise NOT of this Long.\n   * @this {!Long}\n   * @returns {!Long}\n   */\n  \n  LongPrototype.not = function not() {\n    return fromBits(~this.low, ~this.high, this.unsigned);\n  };\n  /**\n   * Returns count leading zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */\n  \n  \n  LongPrototype.countLeadingZeros = function countLeadingZeros() {\n    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n  };\n  /**\n   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */\n  \n  \n  LongPrototype.clz = LongPrototype.countLeadingZeros;\n  /**\n   * Returns count trailing zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */\n  \n  LongPrototype.countTrailingZeros = function countTrailingZeros() {\n    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n  };\n  /**\n   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */\n  \n  \n  LongPrototype.ctz = LongPrototype.countTrailingZeros;\n  /**\n   * Returns the bitwise AND of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  LongPrototype.and = function and(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n  };\n  /**\n   * Returns the bitwise OR of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  \n  LongPrototype.or = function or(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n  };\n  /**\n   * Returns the bitwise XOR of this Long and the given one.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  \n  LongPrototype.xor = function xor(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shiftLeft = function shiftLeft(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shl = LongPrototype.shiftLeft;\n  /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shiftRight = function shiftRight(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shr = LongPrototype.shiftRight;\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);\n    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n  /**\n   * Returns this Long with bits rotated to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  LongPrototype.rotateLeft = function rotateLeft(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  \n    if (numBits < 32) {\n      b = 32 - numBits;\n      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);\n    }\n  \n    numBits -= 32;\n    b = 32 - numBits;\n    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  \n  LongPrototype.rotl = LongPrototype.rotateLeft;\n  /**\n   * Returns this Long with bits rotated to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  LongPrototype.rotateRight = function rotateRight(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  \n    if (numBits < 32) {\n      b = 32 - numBits;\n      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);\n    }\n  \n    numBits -= 32;\n    b = 32 - numBits;\n    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  \n  LongPrototype.rotr = LongPrototype.rotateRight;\n  /**\n   * Converts this Long to signed.\n   * @this {!Long}\n   * @returns {!Long} Signed long\n   */\n  \n  LongPrototype.toSigned = function toSigned() {\n    if (!this.unsigned) return this;\n    return fromBits(this.low, this.high, false);\n  };\n  /**\n   * Converts this Long to unsigned.\n   * @this {!Long}\n   * @returns {!Long} Unsigned long\n   */\n  \n  \n  LongPrototype.toUnsigned = function toUnsigned() {\n    if (this.unsigned) return this;\n    return fromBits(this.low, this.high, true);\n  };\n  /**\n   * Converts this Long to its byte representation.\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @this {!Long}\n   * @returns {!Array.<number>} Byte representation\n   */\n  \n  \n  LongPrototype.toBytes = function toBytes(le) {\n    return le ? this.toBytesLE() : this.toBytesBE();\n  };\n  /**\n   * Converts this Long to its little endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Little endian byte representation\n   */\n  \n  \n  LongPrototype.toBytesLE = function toBytesLE() {\n    var hi = this.high,\n        lo = this.low;\n    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];\n  };\n  /**\n   * Converts this Long to its big endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Big endian byte representation\n   */\n  \n  \n  LongPrototype.toBytesBE = function toBytesBE() {\n    var hi = this.high,\n        lo = this.low;\n    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];\n  };\n  /**\n   * Creates a Long from its byte representation.\n   * @param {!Array.<number>} bytes Byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytes = function fromBytes(bytes, unsigned, le) {\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n  };\n  /**\n   * Creates a Long from its little endian byte representation.\n   * @param {!Array.<number>} bytes Little endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n  };\n  /**\n   * Creates a Long from its big endian byte representation.\n   * @param {!Array.<number>} bytes Big endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n  };\n  \n  var _default = Long;\n  exports.default = _default;\n  return \"default\" in exports ? exports.default : exports;\n})({});\nif (typeof define === 'function' && define.amd) define([], function() { return Long; });\nelse if (typeof module === 'object' && typeof exports==='object') module.exports = Long;\n","/**\n * @fileoverview Binaryen glue code for JavaScript.\n * @license Apache-2.0\n */\n\nconst binaryen = global.binaryen || (global.binaryen = require(\"binaryen\"));\n\nmodule.exports = binaryen;\n\nconst { Module } = require(\"../module\");\n\nModule.prototype.toText = function toText(watFormat = true) {\n  if (watFormat) {\n    // NOTE: Conversion to StackIR can yield conversion artifacts like sequences\n    // of unreachable statements not actually emitted by the compiler. Optimizing\n    // StackIR removes these again, but may also suppress useless code emitted by\n    // the compiler that's then no longer visible in tests. Both not ideal.\n    return binaryen.wrapModule(this.ref).emitStackIR(/* optimize-stack-ir */ true);\n  } else {\n    return binaryen.wrapModule(this.ref).emitText();\n  }\n};\n\nModule.prototype.toAsmjs = function toAsmjs() {\n  return binaryen.wrapModule(this.ref).emitAsmjs();\n};\n","/**\n * @fileoverview Collections glue code for JavaScript.\n * @license Apache-2.0\n */\n\nglobal.Map_keys = function Map_keys(map) {\n  return Array.from(map.keys());\n};\n\nglobal.Map_values = function Map_values(map) {\n  return Array.from(map.values());\n};\n\nglobal.Set_values = function Set_values(set) {\n  return Array.from(set.values());\n};\n","/**\n * @fileoverview Floating point glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nconst F64 = new Float64Array(1);\nconst F32 = new Float32Array(F64.buffer);\nconst I32 = new Int32Array(F64.buffer);\n\nglobal.f32_as_i32 = function f32_as_i32(value) {\n  F32[0] = value;\n  return I32[0];\n};\n\nglobal.i32_as_f32 = function i32_as_f32(value) {\n  I32[0] = value;\n  return F32[0];\n};\n\nglobal.f64_as_i64 = function f64_as_i64(value) {\n  F64[0] = value;\n  return i64_new(I32[0], I32[1]);\n};\n\nglobal.i64_as_f64 = function i64_as_f64(value) {\n  I32[0] = i64_low(value);\n  I32[1] = i64_high(value);\n  return F64[0];\n};\n","/**\n * @fileoverview 64-bit integer glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nconst Long = global.Long || require(\"long\");\n\nglobal.i64_zero    = Long.ZERO;\nglobal.i64_one     = Long.ONE;\nglobal.i64_neg_one = Long.fromInt(-1);\n\nglobal.i64_is = function i64_is(value) {\n  return Long.isLong(value);\n};\n\nglobal.i64_new = function i64_new(lo, hi) {\n  return Long.fromBits(lo, hi);\n};\n\nglobal.i64_low = function i64_low(value) {\n  return value.low;\n};\n\nglobal.i64_high = function i64_high(value) {\n  return value.high;\n};\n\nglobal.i64_not = function i64_not(value) {\n  return value.not();\n};\n\nglobal.i64_clz = function i64_clz(value) {\n  return value.clz();\n};\n\nglobal.i64_ctz = function i64_ctz(value) {\n  return value.ctz();\n};\n\nglobal.i64_add = function i64_add(left, right) {\n  return left.add(right);\n};\n\nglobal.i64_sub = function i64_sub(left, right) {\n  return left.sub(right);\n};\n\nglobal.i64_mul = function i64_mul(left, right) {\n  return left.mul(right);\n};\n\nglobal.i64_pow = function i64_pow(left, right) {\n  var rightLo = right.low;\n  var rightHi = right.high;\n  if (rightHi <= 0) {\n    if (rightHi < 0) {\n      if (left.eq(global.i64_neg_one)) {\n        return rightLo & 1 ? left : Long.ONE;\n      }\n      return left.eq(Long.ONE) ? left : Long.ZERO;\n    }\n    if (rightLo == 0) return Long.ONE;\n    if (rightLo == 1) return left;\n    if (rightLo == 2) return left.mul(left);\n  }\n  var result = Long.ONE;\n  while (rightLo | rightHi) {\n    if (rightLo & 1) result = result.mul(left);\n    right = right.shru(1);\n    left  = left.mul(left);\n    rightLo = right.low;\n    rightHi = right.high;\n  }\n  return result;\n};\n\nglobal.i64_div = function i64_div(left, right) {\n  return left.div(right);\n};\n\nglobal.i64_div_u = function i64_div_u(left, right) {\n  return left.toUnsigned().div(right.toUnsigned()).toSigned();\n};\n\nglobal.i64_rem = function i64_rem(left, right) {\n  return left.mod(right);\n};\n\nglobal.i64_rem_u = function i64_rem_u(left, right) {\n  return left.toUnsigned().mod(right.toUnsigned()).toSigned();\n};\n\nglobal.i64_and = function i64_and(left, right) {\n  return left.and(right);\n};\n\nglobal.i64_or = function i64_or(left, right) {\n  return left.or(right);\n};\n\nglobal.i64_xor = function i64_xor(left, right) {\n  return left.xor(right);\n};\n\nglobal.i64_shl = function i64_shl(left, right) {\n  return left.shl(right);\n};\n\nglobal.i64_shr = function i64_shr(left, right) {\n  return left.shr(right);\n};\n\nglobal.i64_shr_u = function i64_shr_u(left, right) {\n  return left.shru(right);\n};\n\nglobal.i64_eq = function i64_eq(left, right) {\n  return left.eq(right);\n};\n\nglobal.i64_ne = function i64_ne(left, right) {\n  return left.ne(right);\n};\n\nglobal.i64_gt = function i64_gt(left, right) {\n  return left.gt(right);\n};\n\nglobal.i64_align = function i64_align(value, alignment) {\n  assert(alignment && (alignment & (alignment - 1)) == 0);\n  var mask = Long.fromInt(alignment - 1);\n  return value.add(mask).and(mask.not());\n};\n\nglobal.i64_is_i8 = function i64_is_i8(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)\n      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);\n};\n\nglobal.i64_is_i16 = function i64_is_i16(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)\n      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);\n};\n\nglobal.i64_is_i32 = function i64_is_i32(value) {\n  return (value.high === 0 && value.low >= 0)\n      || (value.high === -1 && value.low < 0);\n};\n\nglobal.i64_is_u8 = function i64_is_u8(value) {\n  return value.high === 0 && (value.low >>> 0) <= u8.MAX_VALUE;\n};\n\nglobal.i64_is_u16 = function i64_is_u16(value) {\n  return value.high === 0 && (value.low >>> 0) <= u16.MAX_VALUE;\n};\n\nglobal.i64_is_u32 = function i64_is_u32(value) {\n  return value.high === 0;\n};\n\nglobal.i64_is_bool = function i64_is_bool(value) {\n  return (value.high | (value.low & ~1)) === 0;\n};\n\nconst minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);\nconst maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);\n\nglobal.i64_is_f32 = function i64_is_f32(value) {\n  return value.gte(minSafeF32) && value.lte(maxSafeF32);\n};\n\nconst minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);\nconst maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);\n\nglobal.i64_is_f64 = function i64_is_f64(value) {\n  return value.gte(minSafeF64) && value.lte(maxSafeF64);\n};\n\nglobal.i64_to_f32 = function i64_to_f32(value) {\n  return global.Math.fround(value.toNumber());\n};\n\nglobal.i64_to_f64 = function i64_to_f64(value) {\n  return value.toNumber();\n};\n\nglobal.i64_to_string = function i64_to_string(value, unsigned) {\n  return unsigned ? value.toUnsigned().toString() : value.toString();\n};\n","/** @module std/portable *//***/\n\nvar globalScope = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || self;\nif (typeof globalScope.ASC_TARGET === \"undefined\") {\n\n  globalScope.ASC_TARGET = 0; // Target.JS\n  globalScope.ASC_RUNTIME = 0; // Runtime.Stub\n  globalScope.ASC_NO_ASSERT = false;\n  globalScope.ASC_MEMORY_BASE = 0;\n  globalScope.ASC_OPTIMIZE_LEVEL = 3;\n  globalScope.ASC_SHRINK_LEVEL = 0;\n  globalScope.ASC_FEATURE_MUTABLE_GLOBAL = false;\n  globalScope.ASC_FEATURE_SIGN_EXTENSION = false;\n  globalScope.ASC_FEATURE_BULK_MEMORY = false;\n  globalScope.ASC_FEATURE_SIMD = false;\n  globalScope.ASC_FEATURE_THREADS = false;\n\n  var F64 = new Float64Array(1);\n  var U64 = new Uint32Array(F64.buffer);\n\n  Object.defineProperties(\n    globalScope[\"i8\"] = function i8(value) { return value << 24 >> 24; },\n    {\n      \"MIN_VALUE\": { value: -128 },\n      \"MAX_VALUE\": { value:  127 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"i16\"] = function i16(value) { return value << 16 >> 16; },\n    {\n      \"MIN_VALUE\": { value: -32768 },\n      \"MAX_VALUE\": { value:  32767 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"i32\"] = globalScope[\"isize\"] = function i32(value) { return value | 0; },\n    {\n      \"MIN_VALUE\": { value: -2147483648 },\n      \"MAX_VALUE\": { value:  2147483647 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u8\"] = function u8(value) { return value & 0xff; },\n    {\n      \"MIN_VALUE\": { value:   0 },\n      \"MAX_VALUE\": { value: 255 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u16\"] = function u16(value) { return value & 0xffff; },\n    {\n      \"MIN_VALUE\": { value:     0 },\n      \"MAX_VALUE\": { value: 65535 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"u32\"] = globalScope[\"usize\"] = function u32(value) { return value >>> 0; },\n    {\n      \"MIN_VALUE\": { value:          0 },\n      \"MAX_VALUE\": { value: 4294967295 }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"bool\"] = function bool(value) { return !!value; },\n    {\n      \"MIN_VALUE\": { value: false },\n      \"MAX_VALUE\": { value: true }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"f32\"] = function f32(value) { return Math.fround(value); },\n    {\n      \"EPSILON\":   { value: 1.1920928955078125e-07 },\n      \"MIN_VALUE\": { value: 1.401298464324817e-45 },\n      \"MAX_VALUE\": { value: 3.4028234663852886e+38 },\n      \"MIN_NORMAL_VALUE\":  { value:  1.1754943508222875e-38 },\n      \"MIN_SAFE_INTEGER\":  { value: -16777215 },\n      \"MAX_SAFE_INTEGER\":  { value:  16777215 },\n      \"POSITIVE_INFINITY\": { value:  Infinity },\n      \"NEGATIVE_INFINITY\": { value: -Infinity },\n      \"NaN\": { value: NaN }\n    }\n  );\n\n  Object.defineProperties(\n    globalScope[\"f64\"] = function f64(value) { return +value; },\n    {\n      \"EPSILON\":   { value: 2.2204460492503131e-016 },\n      \"MIN_VALUE\": { value:                  5e-324 },\n      \"MAX_VALUE\": { value: 1.7976931348623157e+308 },\n      \"MIN_NORMAL_VALUE\":  { value:  2.2250738585072014e-308 },\n      \"MIN_SAFE_INTEGER\":  { value: -9007199254740991 },\n      \"MAX_SAFE_INTEGER\":  { value:  9007199254740991 },\n      \"POSITIVE_INFINITY\": { value:  Infinity },\n      \"NEGATIVE_INFINITY\": { value: -Infinity },\n      \"NaN\": { value: NaN }\n    }\n  );\n\n  globalScope[\"clz\"] = Math.clz32;\n\n  globalScope[\"ctz\"] = function ctz(value) {\n    return 32 - Math.clz32(~value & (value - 1));\n  };\n\n  globalScope[\"popcnt\"] = function popcnt(value) {\n    value -= value >>> 1 & 0x55555555;\n    value = (value & 0x33333333) + (value >>> 2 & 0x33333333);\n    return (((value + (value >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;\n  };\n\n  globalScope[\"rotl\"] = function rotl(value, shift) {\n    shift &= 31;\n    return (value << shift) | (value >>> (32 - shift));\n  };\n\n  globalScope[\"rotr\"] = function rotr(value, shift) {\n    shift &= 31;\n    return (value >>> shift) | (value << (32 - shift));\n  };\n\n  globalScope[\"abs\"] = Math.abs;\n\n  globalScope[\"max\"] = Math.max;\n\n  globalScope[\"min\"] = Math.min;\n\n  globalScope[\"ceil\"] = Math.ceil;\n\n  globalScope[\"floor\"] = Math.floor;\n\n  globalScope[\"nearest\"] = function nearest(value) {\n    const INV_EPS64 = 4503599627370496.0;\n    const y = Math.abs(value);\n    return y < INV_EPS64\n      ? Math.abs(y + INV_EPS64 - INV_EPS64) * Math.sign(value)\n      : value;\n  };\n\n  globalScope[\"select\"] = function select(ifTrue, ifFalse, condition) {\n    return condition ? ifTrue : ifFalse;\n  };\n\n  globalScope[\"sqrt\"] = Math.sqrt;\n\n  globalScope[\"trunc\"] = Math.trunc;\n\n  globalScope[\"copysign\"] = function copysign(x, y) {\n    return Math.abs(x) * Math.sign(y);\n  };\n\n  globalScope[\"bswap\"] = function bswap(value) {\n    var a = value >> 8 & 0x00FF00FF;\n    var b = (value & 0x00FF00FF) << 8;\n    value = a | b;\n    a = value >> 16 & 0x0000FFFF;\n    b = (value & 0x0000FFFF) << 16;\n    return a | b;\n  };\n\n  globalScope[\"bswap16\"] = function bswap16(value) {\n    return ((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF) | (value & 0xFFFF0000);\n  };\n\n  function UnreachableError() {\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnreachableError);\n    } else {\n      this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n    }\n  }\n  UnreachableError.prototype = Object.create(Error.prototype);\n  UnreachableError.prototype.name = \"UnreachableError\";\n  UnreachableError.prototype.message = \"unreachable\";\n\n  globalScope[\"unreachable\"] = function unreachable() {\n    throw new UnreachableError();\n  };\n\n  function AssertionError(message) {\n    this.message = message || \"assertion failed\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AssertionError);\n    } else {\n      this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n    }\n  }\n  AssertionError.prototype = Object.create(Error.prototype);\n  AssertionError.prototype.name = \"AssertionError\";\n\n  globalScope[\"assert\"] = function assert(isTrueish, message) {\n    if (isTrueish) return isTrueish;\n    throw new AssertionError(message);\n  };\n\n  globalScope[\"changetype\"] = function changetype(value) {\n    return value;\n  };\n\n  String[\"fromCharCodes\"] = function fromCharCodes(arr) {\n    const CHUNKSIZE = 1 << 13;\n    const len = arr.length;\n    if (len <= CHUNKSIZE) {\n      return String.fromCharCode.apply(String, arr);\n    }\n    let index = 0;\n    let parts = '';\n    while (index < len) {\n      parts += String.fromCharCode.apply(\n        String,\n        arr.slice(index, Math.min(index + CHUNKSIZE, len))\n      );\n      index += CHUNKSIZE;\n    }\n    return parts;\n  };\n\n  String[\"fromCodePoints\"] = function fromCodePoints(arr) {\n    const CHUNKSIZE = 1 << 13;\n    const len = arr.length;\n    if (len <= CHUNKSIZE) {\n      return String.fromCodePoint.apply(String, arr);\n    }\n    let index = 0;\n    let parts = '';\n    while (index < len) {\n      parts += String.fromCodePoint.apply(\n        String,\n        arr.slice(index, Math.min(index + CHUNKSIZE, len))\n      );\n      index += CHUNKSIZE;\n    }\n    return parts;\n  };\n\n  if (!String.prototype.at) {\n    Object.defineProperty(String.prototype, \"at\", {\n      value: function at(index) {\n        return this.charAt(index >= 0 ? index : index + this.length);\n      },\n      configurable: true\n    });\n  }\n\n  if (!String.prototype.replaceAll) {\n    Object.defineProperty(String.prototype, \"replaceAll\", {\n      value: function replaceAll(search, replacment) {\n        var res = this.split(search).join(replacment);\n        if (!search.length) res = replacment + res + replacment;\n        return res;\n      },\n      configurable: true\n    });\n  }\n\n  function defaultComparator(a, b) {\n    if (a === b) {\n      if (a !== 0) return 0;\n      a = 1 / a, b = 1 / b;\n    } else {\n      var nanA = a != a, nanB = b != b;\n      if (nanA | nanB) return nanA - nanB;\n      if (a == null) a = String(a);\n      if (b == null) b = String(b);\n    }\n    return a > b ? 1 : -1;\n  }\n\n  const arraySort = Array.prototype.sort;\n  Array.prototype.sort = function sort(comparator) {\n    return arraySort.call(this, comparator || defaultComparator);\n  };\n\n  [ Array,\n    Uint8ClampedArray,\n    Uint8Array, Int8Array,\n    Uint16Array, Int16Array,\n    Uint32Array, Int32Array,\n    Float32Array, Float64Array\n  ].forEach(Ctr => {\n    if (!Ctr.prototype.at) {\n      Object.defineProperty(Ctr.prototype, \"at\", {\n        value: function at(index) {\n          return this[index >= 0 ? index : index + this.length];\n        },\n        configurable: true\n      });\n    }\n\n    if (!Ctr.prototype.findLastIndex) {\n      Object.defineProperty(Ctr.prototype, \"findLastIndex\", {\n        value: function findLastIndex(fn) {\n          for (let i = this.length - 1; i >= 0; --i) {\n            if (fn(this[i], i, this)) return i;\n          }\n          return -1;\n        },\n        configurable: true\n      });\n    }\n\n    if (Ctr != Array) {\n      Object.defineProperty(Ctr, \"wrap\", {\n        value: function wrap(buffer, byteOffset, length) {\n          return new Ctr(buffer, byteOffset, length);\n        },\n        configurable: true\n      });\n    }\n  });\n\n  globalScope[\"isInteger\"] = Number.isInteger;\n\n  globalScope[\"isFloat\"] = function isFloat(arg) {\n    return typeof arg === \"number\";\n  };\n\n  globalScope[\"isNullable\"] = function isNullable(arg) {\n    return true;\n  };\n\n  globalScope[\"isReference\"] = function isReference(arg) {\n    return typeof arg === \"object\" || typeof arg === \"string\";\n  };\n\n  globalScope[\"isFunction\"] = function isFunction(arg) {\n    return typeof arg === \"function\";\n  };\n\n  globalScope[\"isString\"] = function isString(arg) {\n    return typeof arg === \"string\" || arg instanceof String;\n  };\n\n  globalScope[\"isArray\"] = Array.isArray;\n  globalScope[\"isArrayLike\"] = function isArrayLike(expr) {\n    return expr\n      && typeof expr === 'object'\n      && typeof expr.length === 'number'\n      && expr.length >= 0\n      && Math.trunc(expr.length) === expr.length;\n  };\n\n  globalScope[\"isDefined\"] = function isDefined(expr) {\n    return typeof expr !== \"undefined\";\n  };\n\n  globalScope[\"isConstant\"] = function isConstant(expr) {\n    return false;\n  };\n\n  globalScope[\"unchecked\"] = function unchecked(expr) {\n    return expr;\n  };\n\n  globalScope[\"fmod\"] = function fmod(x, y) {\n    return x % y;\n  };\n\n  globalScope[\"fmodf\"] = function fmodf(x, y) {\n    return Math.fround(x % y);\n  };\n\n  globalScope[\"JSMath\"] = Math;\n\n  Object.defineProperties(globalScope[\"JSMath\"], {\n    sincos_sin: { value: 0.0, writable: true },\n    sincos_cos: { value: 0.0, writable: true },\n    signbit: {\n      value: function signbit(x) {\n        F64[0] = x; return Boolean(U64[1] >>> 31);\n      }\n    },\n    sincos: {\n      value: function sincos(x) {\n        this.sincos_sin = Math.sin(x);\n        this.sincos_cos = Math.cos(x);\n      }\n    },\n    exp2: {\n      value: function exp2(x) {\n        return Math.pow(2, x);\n      }\n    }\n  });\n\n  globalScope[\"unmanaged\"] = function() { /* nop */ };\n\n  globalScope[\"trace\"] = function(message, n) {\n    if (n) message += Array.prototype.slice.call(arguments, 2, 2 + n);\n    console.error(\"trace: \" + message);\n  };\n} else {\n  console.warn(\"compiler mismatch: std/portable included twice\");\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// startup\n// Load entry module and return exports\n__webpack_require__(308);\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(780);\n"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__725__","NodeKind","DecoratorKind","LiteralKind","SourceKind","Node","constructor","kind","range","static","name","TypeName","createIdentifierExpression","typeArguments","isNullable","NamedTypeNode","parameters","returnType","explicitThisType","FunctionTypeNode","createSimpleTypeName","extendsType","defaultType","TypeParameterNode","parameterKind","type","initializer","ParameterNode","args","DecoratorNode","fromNode","commentKind","text","CommentNode","isQuoted","IdentifierExpression","elementExpressions","ArrayLiteralExpression","assertionKind","expression","toType","AssertionExpression","operator","left","right","BinaryExpression","CallExpression","declaration","ClassExpression","expressions","CommaExpression","ConstructorExpression","elementExpression","ElementAccessExpression","FalseExpression","value","FloatLiteralExpression","FunctionExpression","isType","InstanceOfExpression","IntegerLiteralExpression","typeName","NewExpression","NullExpression","names","values","ObjectLiteralExpression","OmittedExpression","ParenthesizedExpression","property","PropertyAccessExpression","pattern","patternFlags","RegexpLiteralExpression","condition","ifThen","ifElse","TernaryExpression","StringLiteralExpression","SuperExpression","tag","parts","rawParts","TemplateLiteralExpression","ThisExpression","TrueExpression","operand","UnaryPostfixExpression","UnaryPrefixExpression","expr","CompiledExpression","statements","BlockStatement","label","BreakStatement","decorators","flags","typeParameters","implementsTypes","members","ClassDeclaration","ContinueStatement","statement","DoStatement","EmptyStatement","EnumDeclaration","EnumValueDeclaration","path","isDeclare","ExportStatement","ExportDefaultStatement","externalName","ExportImportStatement","localName","exportedName","ExportMember","ExpressionStatement","ifTrue","ifFalse","IfStatement","declarations","ImportStatement","namespaceName","foreignName","ImportDeclaration","InterfaceDeclaration","FieldDeclaration","incrementor","ForStatement","variable","iterable","ForOfStatement","signature","body","arrowKind","FunctionDeclaration","keyType","valueType","IndexSignatureNode","MethodDeclaration","NamespaceDeclaration","ReturnStatement","cases","SwitchStatement","SwitchCase","ThrowStatement","catchVariable","catchStatements","finallyStatements","TryStatement","TypeDeclaration","VariableStatement","VariableDeclaration","VoidStatement","WhileStatement","isLiteralKind","literalKind","LITERAL","changetype","isNumericLiteral","FLOAT","INTEGER","compilesToConst","STRING","NULL","TRUE","FALSE","isAccessOn","node","CALL","PROPERTYACCESS","isAccessOnThis","THIS","isAccessOnSuper","SUPER","TypeNode","super","hasGenericComponent","typeParameterNodes","NAMEDTYPE","namedTypeNode","next","typeArgumentNodes","length","i","k","identifier","FUNCTIONTYPE","functionTypeNode","parameterNodes","assert","TYPENAME","hasTypeArguments","TYPEPARAMETER","ParameterKind","PARAMETER","implicitFieldDeclaration","CommonFlags","NONE","is","flag","isAny","set","nameNode","IDENTIFIER","nameStr","charCodeAt","BUILTIN","EXTERNAL","FINAL","GLOBAL","INLINE","LAZY","OPERATOR","UNMANAGED","UNSAFE","propertyAccessNode","propStr","OPERATOR_BINARY","OPERATOR_PREFIX","OPERATOR_POSTFIX","CUSTOM","decoratorKind","DECORATOR","CommentKind","COMMENT","Expression","LiteralExpression","ARRAY","AssertionKind","ASSERTION","BINARY","typeArgumentsRange","numTypeArguments","Range","join","argumentsRange","numArguments","CLASS","COMMA","CONSTRUCTOR","ELEMENTACCESS","FUNCTION","INSTANCEOF","NEW","OBJECT","OMITTED","PARENTHESIZED","REGEXP","TERNARY","TEMPLATE","UnaryExpression","UNARYPOSTFIX","UNARYPREFIX","COMPILED","Statement","sourceKind","normalizedPath","SOURCE","Array","debugInfoIndex","exportPaths","lineCache","lineColumn","internalPath","mangleInternalPath","pos","lastIndexOf","PATH_DELIMITER","simplePath","substring","source","isNative","LIBRARY_SUBST","isLibrary","LIBRARY","LIBRARY_ENTRY","lineAt","off","end","push","l","r","m","s","unchecked","columnAt","DeclarationStatement","INDEXSIGNATURE","VariableLikeDeclarationStatement","BLOCK","BREAK","CLASSDECLARATION","indexSignature","isGeneric","CONTINUE","DO","EMPTY","ENUMDECLARATION","ENUMVALUEDECLARATION","EXPORTIMPORT","EXPORTMEMBER","EXPORT","normalizePath","startsWith","resolvePath","LIBRARY_PREFIX","EXPORTDEFAULT","EXPRESSION","parameterIndex","FIELDDECLARATION","FOR","FOROF","ArrowKind","FUNCTIONDECLARATION","clone","IF","IMPORTDECLARATION","IMPORT","INTERFACEDECLARATION","METHODDECLARATION","NAMESPACEDECLARATION","RETURN","SWITCHCASE","SWITCH","THROW","TRY","TYPEDECLARATION","VARIABLEDECLARATION","VARIABLE","VOID","WHILE","len","cur","isAlphaOrDecimal","decorator","BuiltinNames","start","started","argumentsLength","setArgumentsLength","abort","trace","seed","isInteger","isFloat","isBoolean","isSigned","isReference","isString","isArray","isArrayLike","isFunction","isDefined","isConstant","isManaged","isVoid","add","sub","mul","div","clz","ctz","popcnt","rotl","rotr","abs","max","min","ceil","floor","copysign","nearest","reinterpret","sqrt","trunc","load","store","atomic_load","atomic_store","atomic_add","atomic_sub","atomic_and","atomic_or","atomic_xor","atomic_xchg","atomic_cmpxchg","atomic_wait","atomic_notify","atomic_fence","sizeof","alignof","offsetof","nameof","lengthof","select","unreachable","call_indirect","instantiate","idof","i8","i16","i32","i64","isize","u8","u16","u32","u64","usize","bool","f32","f64","v128","i32_clz","i64_clz","i32_ctz","i64_ctz","i32_popcnt","i64_popcnt","i32_rotl","i64_rotl","i32_rotr","i64_rotr","f32_abs","f64_abs","f32_max","f64_max","f32_min","f64_min","f32_ceil","f64_ceil","f32_floor","f64_floor","f32_copysign","f64_copysign","f32_nearest","f64_nearest","i32_reinterpret_f32","i64_reinterpret_f64","f32_reinterpret_i32","f64_reinterpret_i64","f32_sqrt","f64_sqrt","f32_trunc","f64_trunc","i32_add","i64_add","f32_add","f64_add","i32_sub","i64_sub","f32_sub","f64_sub","i32_mul","i64_mul","f32_mul","f64_mul","i32_div_s","i32_div_u","i64_div_s","i64_div_u","f32_div","f64_div","i32_load8_s","i32_load8_u","i32_load16_s","i32_load16_u","i32_load","i64_load8_s","i64_load8_u","i64_load16_s","i64_load16_u","i64_load32_s","i64_load32_u","i64_load","f32_load","f64_load","i32_store8","i32_store16","i32_store","i64_store8","i64_store16","i64_store32","i64_store","f32_store","f64_store","i32_atomic_load8_u","i32_atomic_load16_u","i32_atomic_load","i64_atomic_load8_u","i64_atomic_load16_u","i64_atomic_load32_u","i64_atomic_load","i32_atomic_store8","i32_atomic_store16","i32_atomic_store","i64_atomic_store8","i64_atomic_store16","i64_atomic_store32","i64_atomic_store","i32_atomic_rmw8_add_u","i32_atomic_rmw16_add_u","i32_atomic_rmw_add","i64_atomic_rmw8_add_u","i64_atomic_rmw16_add_u","i64_atomic_rmw32_add_u","i64_atomic_rmw_add","i32_atomic_rmw8_sub_u","i32_atomic_rmw16_sub_u","i32_atomic_rmw_sub","i64_atomic_rmw8_sub_u","i64_atomic_rmw16_sub_u","i64_atomic_rmw32_sub_u","i64_atomic_rmw_sub","i32_atomic_rmw8_and_u","i32_atomic_rmw16_and_u","i32_atomic_rmw_and","i64_atomic_rmw8_and_u","i64_atomic_rmw16_and_u","i64_atomic_rmw32_and_u","i64_atomic_rmw_and","i32_atomic_rmw8_or_u","i32_atomic_rmw16_or_u","i32_atomic_rmw_or","i64_atomic_rmw8_or_u","i64_atomic_rmw16_or_u","i64_atomic_rmw32_or_u","i64_atomic_rmw_or","i32_atomic_rmw8_xor_u","i32_atomic_rmw16_xor_u","i32_atomic_rmw_xor","i64_atomic_rmw8_xor_u","i64_atomic_rmw16_xor_u","i64_atomic_rmw32_xor_u","i64_atomic_rmw_xor","i32_atomic_rmw8_xchg_u","i32_atomic_rmw16_xchg_u","i32_atomic_rmw_xchg","i64_atomic_rmw8_xchg_u","i64_atomic_rmw16_xchg_u","i64_atomic_rmw32_xchg_u","i64_atomic_rmw_xchg","i32_atomic_rmw8_cmpxchg_u","i32_atomic_rmw16_cmpxchg_u","i32_atomic_rmw_cmpxchg","i64_atomic_rmw8_cmpxchg_u","i64_atomic_rmw16_cmpxchg_u","i64_atomic_rmw32_cmpxchg_u","i64_atomic_rmw_cmpxchg","i32_wait","i64_wait","v128_splat","v128_extract_lane","v128_replace_lane","v128_shuffle","v128_swizzle","v128_load_splat","v128_load_ext","v128_load_zero","v128_load_lane","v128_store_lane","v128_load","v128_load8x8_s","v128_load8x8_u","v128_load16x4_s","v128_load16x4_u","v128_load32x2_s","v128_load32x2_u","v128_load8_splat","v128_load16_splat","v128_load32_splat","v128_load64_splat","v128_load32_zero","v128_load64_zero","v128_load8_lane","v128_load16_lane","v128_load32_lane","v128_load64_lane","v128_store8_lane","v128_store16_lane","v128_store32_lane","v128_store64_lane","v128_store","v128_add","v128_sub","v128_mul","v128_div","v128_neg","v128_add_sat","v128_sub_sat","v128_shl","v128_shr","v128_and","v128_or","v128_xor","v128_andnot","v128_not","v128_bitselect","v128_any_true","v128_all_true","v128_bitmask","v128_popcnt","v128_min","v128_max","v128_pmin","v128_pmax","v128_dot","v128_avgr","v128_abs","v128_sqrt","v128_ceil","v128_floor","v128_trunc","v128_nearest","v128_eq","v128_ne","v128_lt","v128_le","v128_gt","v128_ge","v128_convert","v128_convert_low","v128_trunc_sat","v128_trunc_sat_zero","v128_narrow","v128_extend_low","v128_extend_high","v128_extadd_pairwise","v128_demote_zero","v128_promote_low","v128_q15mulr_sat","v128_extmul_low","v128_extmul_high","i8x16","i16x8","i32x4","i64x2","f32x4","f64x2","i8x16_splat","i8x16_extract_lane_s","i8x16_extract_lane_u","i8x16_replace_lane","i8x16_add","i8x16_sub","i8x16_mul","i8x16_min_s","i8x16_min_u","i8x16_max_s","i8x16_max_u","i8x16_avgr_u","i8x16_abs","i8x16_neg","i8x16_add_sat_s","i8x16_add_sat_u","i8x16_sub_sat_s","i8x16_sub_sat_u","i8x16_shl","i8x16_shr_s","i8x16_shr_u","i8x16_all_true","i8x16_bitmask","i8x16_popcnt","i8x16_eq","i8x16_ne","i8x16_lt_s","i8x16_lt_u","i8x16_le_s","i8x16_le_u","i8x16_gt_s","i8x16_gt_u","i8x16_ge_s","i8x16_ge_u","i8x16_narrow_i16x8_s","i8x16_narrow_i16x8_u","i8x16_shuffle","i8x16_swizzle","i16x8_splat","i16x8_extract_lane_s","i16x8_extract_lane_u","i16x8_replace_lane","i16x8_add","i16x8_sub","i16x8_mul","i16x8_min_s","i16x8_min_u","i16x8_max_s","i16x8_max_u","i16x8_avgr_u","i16x8_abs","i16x8_neg","i16x8_add_sat_s","i16x8_add_sat_u","i16x8_sub_sat_s","i16x8_sub_sat_u","i16x8_shl","i16x8_shr_s","i16x8_shr_u","i16x8_all_true","i16x8_bitmask","i16x8_eq","i16x8_ne","i16x8_lt_s","i16x8_lt_u","i16x8_le_s","i16x8_le_u","i16x8_gt_s","i16x8_gt_u","i16x8_ge_s","i16x8_ge_u","i16x8_narrow_i32x4_s","i16x8_narrow_i32x4_u","i16x8_extend_low_i8x16_s","i16x8_extend_low_i8x16_u","i16x8_extend_high_i8x16_s","i16x8_extend_high_i8x16_u","i16x8_extadd_pairwise_i8x16_s","i16x8_extadd_pairwise_i8x16_u","i16x8_q15mulr_sat_s","i16x8_extmul_low_i8x16_s","i16x8_extmul_low_i8x16_u","i16x8_extmul_high_i8x16_s","i16x8_extmul_high_i8x16_u","i32x4_splat","i32x4_extract_lane","i32x4_replace_lane","i32x4_add","i32x4_sub","i32x4_mul","i32x4_min_s","i32x4_min_u","i32x4_max_s","i32x4_max_u","i32x4_dot_i16x8_s","i32x4_abs","i32x4_neg","i32x4_shl","i32x4_shr_s","i32x4_shr_u","i32x4_all_true","i32x4_bitmask","i32x4_eq","i32x4_ne","i32x4_lt_s","i32x4_lt_u","i32x4_le_s","i32x4_le_u","i32x4_gt_s","i32x4_gt_u","i32x4_ge_s","i32x4_ge_u","i32x4_trunc_sat_f32x4_s","i32x4_trunc_sat_f32x4_u","i32x4_trunc_sat_f64x2_s_zero","i32x4_trunc_sat_f64x2_u_zero","i32x4_extend_low_i16x8_s","i32x4_extend_low_i16x8_u","i32x4_extend_high_i16x8_s","i32x4_extend_high_i16x8_u","i32x4_extadd_pairwise_i16x8_s","i32x4_extadd_pairwise_i16x8_u","i32x4_extmul_low_i16x8_s","i32x4_extmul_low_i16x8_u","i32x4_extmul_high_i16x8_s","i32x4_extmul_high_i16x8_u","i64x2_splat","i64x2_extract_lane","i64x2_replace_lane","i64x2_add","i64x2_sub","i64x2_mul","i64x2_abs","i64x2_neg","i64x2_shl","i64x2_shr_s","i64x2_shr_u","i64x2_all_true","i64x2_bitmask","i64x2_eq","i64x2_ne","i64x2_lt_s","i64x2_lt_u","i64x2_le_s","i64x2_le_u","i64x2_gt_s","i64x2_gt_u","i64x2_ge_s","i64x2_ge_u","i64x2_extend_low_i32x4_s","i64x2_extend_low_i32x4_u","i64x2_extend_high_i32x4_s","i64x2_extend_high_i32x4_u","i64x2_extmul_low_i32x4_s","i64x2_extmul_low_i32x4_u","i64x2_extmul_high_i32x4_s","i64x2_extmul_high_i32x4_u","f32x4_splat","f32x4_extract_lane","f32x4_replace_lane","f32x4_add","f32x4_sub","f32x4_mul","f32x4_div","f32x4_neg","f32x4_min","f32x4_max","f32x4_pmin","f32x4_pmax","f32x4_abs","f32x4_sqrt","f32x4_ceil","f32x4_floor","f32x4_trunc","f32x4_nearest","f32x4_eq","f32x4_ne","f32x4_lt","f32x4_le","f32x4_gt","f32x4_ge","f32x4_convert_i32x4_s","f32x4_convert_i32x4_u","f32x4_demote_f64x2_zero","f64x2_splat","f64x2_extract_lane","f64x2_replace_lane","f64x2_add","f64x2_sub","f64x2_mul","f64x2_div","f64x2_neg","f64x2_min","f64x2_max","f64x2_pmin","f64x2_pmax","f64x2_abs","f64x2_sqrt","f64x2_ceil","f64x2_floor","f64x2_trunc","f64x2_nearest","f64x2_eq","f64x2_ne","f64x2_lt","f64x2_le","f64x2_gt","f64x2_ge","f64x2_convert_low_i32x4_s","f64x2_convert_low_i32x4_u","f64x2_promote_low_f32x4","i31_new","i31_get","data_end","stack_pointer","heap_base","rtti_base","visit_globals","visit_members","tostack","isNaN","isFinite","ERROR","WARNING","INFO","Function","memory_size","memory_grow","memory_copy","memory_fill","memory_data","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Int64Array","Uint64Array","Float32Array","Float64Array","String_raw","wasiAbort","wasiTrace","wasiSeed","builtin_clz","ctx","compiler","checkTypeOptional","checkArgsRequired","arg0","compileExpression","operands","Type","currentType","isValue","unary","UnaryOp","ClzI32","options","isWasm64","ClzI64","error","DiagnosticCode","Operation_0_cannot_be_applied_to_type_1","reportNode","toString","builtin_ctz","CtzI32","CtzI64","builtin_popcnt","PopcntI32","PopcntI64","builtin_rotl","arg1","flow","currentFlow","temp1","getTempLocal","findUsedLocals","setLocalFlag","index","LocalFlags","WRAPPED","temp2","ret","binary","BinaryOp","OrI32","ShlI32","local_tee","AndI32","size","ShrU32","local_get","TypeRef","I32","SubI32","freeTempLocal","RotlI32","RotlI64","builtin_rotr","RotrI32","RotrI64","builtin_abs","auto","XorI32","AddI32","ShrI32","usizeType","XorI64","AddI64","ShrI64","sizeTypeRef","I64","AbsF32","AbsF64","builtin_max","op","GtI32","GtU32","GtI64","GtU64","MaxF32","MaxF64","typeRef","toRef","builtin_min","LtI32","LtU32","LtI64","LtU64","MinF32","MinF64","builtin_ceil","CeilF32","CeilF64","builtin_floor","FloorF32","FloorF64","builtin_copysign","CopysignF32","CopysignF64","builtin_nearest","NearestF32","NearestF64","builtin_reinterpret","checkTypeRequired","ReinterpretF32ToI32","ReinterpretF64ToI64","ReinterpretI32ToF32","ReinterpretI64ToF64","builtin_sqrt","SqrtF32","SqrtF64","builtin_trunc","TruncF32","TruncF64","builtin_load","checkArgsOptional","contextualType","outType","isIntegerValue","numOperands","immOffset","immAlign","byteSize","evaluateImmediateOffset","evaluateImmediateAlign","isSignedIntegerValue","builtin_store","void","contextIsExact","inType","convertExpression","builtin_add","isNumericValue","makeAdd","builtin_sub","makeSub","builtin_mul","makeMul","builtin_div","makeDiv","builtin_atomic_load","checkFeatureEnabled","builtin_atomic_store","builtin_atomic_binary","opName","atomic_rmw","builtin_atomic_add","AtomicRMWOp","Add","builtin_atomic_sub","Sub","builtin_atomic_and","And","builtin_atomic_or","Or","builtin_atomic_xor","Xor","builtin_atomic_xchg","Xchg","builtin_atomic_cmpxchg","arg2","builtin_atomic_wait","builtin_diagnostic","category","checkTypeAbsent","emitDiagnostic","User_defined_0","DiagnosticCategory","nop","builtin_conversion","builtin_i8x16","bytes","precomp","runExpression","ExpressionRunnerFlags","PreserveSideeffects","writeI8","getConstValueI32","Expression_must_be_a_compile_time_constant","builtin_v128_splat","SplatI8x16","SplatI16x8","SplatI32x4","SplatI64x2","SplatF32x4","SplatF64x2","builtin_v128_extract_lane","idx","maxIdx","_0_must_be_a_value_between_1_and_2_inclusive","simd_extract","SIMDExtractOp","ExtractLaneI8x16","ExtractLaneU8x16","ExtractLaneI16x8","ExtractLaneU16x8","ExtractLaneI32x4","ExtractLaneI64x2","ExtractLaneF32x4","ExtractLaneF64x2","builtin_v128_replace_lane","simd_replace","SIMDReplaceOp","ReplaceLaneI8x16","ReplaceLaneI16x8","ReplaceLaneI32x4","ReplaceLaneI64x2","ReplaceLaneF32x4","ReplaceLaneF64x2","builtin_v128_shuffle","laneWidth","laneCount","isPowerOf2","mask","argN","off8","idx8","simd_shuffle","builtin_v128_swizzle","SwizzleI8x16","builtin_v128_load_splat","simd_load","SIMDLoadOp","Load8Splat","Load16Splat","Load32Splat","Load64Splat","builtin_v128_load_ext","Load8x8S","Load8x8U","Load16x4S","Load16x4U","Load32x2S","Load32x2U","builtin_v128_load_zero","Load32Zero","Load64Zero","builtin_v128_load_lane","simd_loadstorelane","SIMDLoadStoreLaneOp","Load8Lane","Load16Lane","Load32Lane","Load64Lane","builtin_v128_store_lane","Store8Lane","Store16Lane","Store32Lane","Store64Lane","builtin_v128_add","AddI8x16","AddI16x8","AddI32x4","AddI64x2","AddF32x4","AddF64x2","builtin_v128_sub","SubI8x16","SubI16x8","SubI32x4","SubI64x2","SubF32x4","SubF64x2","builtin_v128_mul","MulI16x8","MulI32x4","MulI64x2","MulF32x4","MulF64x2","builtin_v128_div","DivF32x4","DivF64x2","builtin_v128_add_sat","AddSatI8x16","AddSatU8x16","AddSatI16x8","AddSatU16x8","builtin_v128_sub_sat","SubSatI8x16","SubSatU8x16","SubSatI16x8","SubSatU16x8","builtin_v128_min","MinI8x16","MinU8x16","MinI16x8","MinU16x8","MinI32x4","MinU32x4","MinF32x4","MinF64x2","builtin_v128_max","MaxI8x16","MaxU8x16","MaxI16x8","MaxU16x8","MaxI32x4","MaxU32x4","MaxF32x4","MaxF64x2","builtin_v128_pmin","PminF32x4","PminF64x2","builtin_v128_pmax","PmaxF32x4","PmaxF64x2","builtin_v128_dot","DotI16x8","builtin_v128_avgr","AvgrU8x16","AvgrU16x8","builtin_v128_eq","EqI8x16","EqI16x8","EqI32x4","EqI64x2","EqF32x4","EqF64x2","builtin_v128_ne","NeI8x16","NeI16x8","NeI32x4","NeI64x2","NeF32x4","NeF64x2","builtin_v128_lt","LtI8x16","LtU8x16","LtI16x8","LtU16x8","LtI32x4","LtU32x4","LtI64x2","LtF32x4","LtF64x2","builtin_v128_le","LeI8x16","LeU8x16","LeI16x8","LeU16x8","LeI32x4","LeU32x4","LeI64x2","LeF32x4","LeF64x2","builtin_v128_gt","GtI8x16","GtU8x16","GtI16x8","GtU16x8","GtI32x4","GtU32x4","GtI64x2","GtF32x4","GtF64x2","builtin_v128_ge","GeI8x16","GeU8x16","GeI16x8","GeU16x8","GeI32x4","GeU32x4","GeI64x2","GeF32x4","GeF64x2","builtin_v128_narrow","NarrowI16x8ToI8x16","NarrowU16x8ToU8x16","NarrowI32x4ToI16x8","NarrowU32x4ToU16x8","builtin_v128_neg","NegI8x16","NegI16x8","NegI32x4","NegI64x2","NegF32x4","NegF64x2","builtin_v128_abs","AbsI8x16","AbsI16x8","AbsI32x4","AbsI64x2","AbsF32x4","AbsF64x2","builtin_v128_sqrt","SqrtF32x4","SqrtF64x2","builtin_v128_ceil","CeilF32x4","CeilF64x2","builtin_v128_floor","FloorF32x4","FloorF64x2","builtin_v128_trunc","TruncF32x4","TruncF64x2","builtin_v128_nearest","NearestF32x4","NearestF64x2","builtin_v128_convert","ConvertI32x4ToF32x4","ConvertU32x4ToF32x4","builtin_v128_convert_low","ConvertLowI32x4ToF64x2","ConvertLowU32x4ToF64x2","builtin_v128_trunc_sat","TruncSatF32x4ToI32x4","TruncSatF32x4ToU32x4","builtin_v128_trunc_sat_zero","TruncSatF64x2ToI32x4Zero","TruncSatF64x2ToU32x4Zero","builtin_v128_extend_low","ExtendLowI8x16ToI16x8","ExtendLowU8x16ToU16x8","ExtendLowI16x8ToI32x4","ExtendLowU16x8ToU32x4","ExtendLowI32x4ToI64x2","ExtendLowU32x4ToU64x2","builtin_v128_extend_high","ExtendHighI8x16ToI16x8","ExtendHighU8x16ToU16x8","ExtendHighI16x8ToI32x4","ExtendHighU16x8ToU32x4","ExtendHighI32x4ToI64x2","ExtendHighU32x4ToU64x2","builtin_v128_shl","simd_shift","SIMDShiftOp","ShlI8x16","ShlI16x8","ShlI32x4","ShlI64x2","builtin_v128_shr","ShrI8x16","ShrU8x16","ShrI16x8","ShrU16x8","ShrI32x4","ShrU32x4","ShrI64x2","ShrU64x2","builtin_v128_bitwise_binary","builtin_v128_all_true","AllTrueI8x16","AllTrueI16x8","AllTrueI32x4","AllTrueI64x2","builtin_v128_bitmask","BitmaskI8x16","BitmaskI16x8","BitmaskI32x4","BitmaskI64x2","builtin_v128_popcnt","PopcntI8x16","builtin_v128_extadd_pairwise","ExtaddPairwiseI8x16ToI16x8","ExtaddPairwiseU8x16ToU16x8","ExtaddPairwiseI16x8ToI32x4","ExtaddPairwiseU16x8ToU32x4","builtin_v128_demote_zero","DemoteZeroF64x2ToF32x4","builtin_v128_promote_low","PromoteLowF32x4ToF64x2","builtin_v128_q15mulr_sat","Q15mulrSatI16x8","builtin_v128_extmul_low","ExtmulLowI16x8","ExtmulLowU16x8","ExtmulLowI32x4","ExtmulLowU32x4","ExtmulLowI64x2","ExtmulLowU64x2","builtin_v128_extmul_high","ExtmulHighI16x8","ExtmulHighU16x8","ExtmulHighI32x4","ExtmulHighU32x4","ExtmulHighI64x2","ExtmulHighU64x2","ensureVisitMembersOf","instance","visitRef","program","sizeTypeSize","visitInstance","base","call","internalName","None","hasVisitImpl","isDeclaredInLibrary","visitPrototype","getMember","ElementKind","FUNCTION_PROTOTYPE","resolver","resolveFunction","compileFunction","visitSignature","visitThisType","thisType","parameterTypes","isStrictlyAssignableTo","needsTempValue","_values","Map_values","j","member","FIELD","parent","fieldOffset","memoryOffset","if","addFunction","createType","flatten","typeToRuntimeFlags","alignLog2","evaluateConstantType","Expected_0_type_arguments_but_got_1","Expected_0_arguments_but_got_1","usize64","getConstValueI64High","getConstValueI64Low","usize32","naturalAlign","align","_0_must_be_a_power_of_two","feature","hasFeature","Feature_0_is_not_enabled","featureToString","setCurrentTypeOnError","prototype","Type_0_is_not_generic","expected","expectedMinimum","expectedMaximum","Expected_at_least_0_arguments_but_got_1","contextualUsize","i64_is_i32","i64_low","i64_is_u32","i64_high","thisOperand","builtins","Map","function_builtins","isFloatValue","isBooleanValue","classReference","getClass","isAssignableTo","stringInstance","extends","arrayPrototype","isNullableReference","element","lookupExpression","ReportMode","SWALLOW","getExpressionId","ExpressionId","Const","signatureReference","Type_0_has_no_call_signatures","i64_new","getClassOrWrapper","firstOperand","String_literal_expected","fieldName","classMembers","has","get","Type_0_has_no_property_1","nextMemoryOffset","resultType","isInternalReference","getSignature","ensureStaticString","id","hasDecorator","DecoratorFlags","maybeDropCondition","LocalGet","NeF32","getLocalGetIndex","F32","temp","NeF64","F64","EqF32","SubF32","EqF64","SubF64","makeIsTrueish","compileCallDirect","offset","elementType","valuesOperand","Array_literal_expected","numElements","exprs","isStatic","makeZero","buf","writeStaticBuffer","byteLength","addAlignedMemorySegment","MAX_VALUE","i31ref","fromType","isChangeableTo","Type_0_cannot_be_changed_to_type_1","nonNullableType","noAssert","evaled","Default","getExpressionType","getConstValueF32","getConstValueF64","makeAbort","EqzI32","EqzI64","ref_is","RefIsOp","RefIsNull","alreadyUnchecked","unset","indexArg","operandExprs","paramTypeRefs","classInstance","This_expression_is_not_constructable","ctor","ensureConstructor","checkFieldInitialization","compileInstantiate","functionPrototype","ftype","requiredParameters","functionArg","shift","thisArg","_this_cannot_be_referenced_in_current_location","compileCallIndirect","Not_implemented_0","isizeType","writeI16","writeI32","writeF32","writeF64","AndV128","OrV128","XorV128","AndnotV128","builtin_v128_bitwise_unary","NotV128","simd_ternary","builtin_v128_bitwise_ternary","SIMDTernaryOp","Bitselect","AnyTrueV128","runtimeFeatures","elementsByName","global","INLINED","constantIntegerValue","global_get","block","managedClasses","nextId","_keys","Map_keys","instanceId","isPointerfree","return","current","switch","SubI64","count","data","abvInstance","arrayBufferViewInstance","abvPrototype","setPrototype","mapPrototype","staticArrayPrototype","lastId","getArrayValueType","getTypeArgumentsTo","rttiFlags","segment","addGlobal","instanceofInstance","stmts","instances","PARENT_SUBST","GETTER_PREFIX","SETTER_PREFIX","INSTANCE_DELIMITER","STATIC_DELIMITER","INNER_DELIMITER","INDEX_SUFFIX","STUB_DELIMITER","CommonNames","funcref","externref","anyref","eqref","dataref","u8x16","u16x8","u32x4","u64x2","void_","number","boolean","string","native","indexof","valueof","returnof","nonnull","null_","true_","false_","this_","super_","ASC_TARGET","ASC_RUNTIME","ASC_NO_ASSERT","ASC_MEMORY_BASE","ASC_TABLE_BASE","ASC_OPTIMIZE_LEVEL","ASC_SHRINK_LEVEL","ASC_LOW_MEMORY_LIMIT","ASC_EXPORT_RUNTIME","ASC_WASI","ASC_FEATURE_SIGN_EXTENSION","ASC_FEATURE_MUTABLE_GLOBALS","ASC_FEATURE_NONTRAPPING_F2I","ASC_FEATURE_BULK_MEMORY","ASC_FEATURE_SIMD","ASC_FEATURE_THREADS","ASC_FEATURE_EXCEPTION_HANDLING","ASC_FEATURE_TAIL_CALLS","ASC_FEATURE_REFERENCE_TYPES","ASC_FEATURE_MULTI_VALUE","ASC_FEATURE_GC","ASC_FEATURE_MEMORY64","ASC_VERSION_MAJOR","ASC_VERSION_MINOR","ASC_VERSION_PATCH","I8","I16","Isize","U8","U16","U32","U64","Usize","Bool","V128","Funcref","Externref","Anyref","Eqref","I31ref","Dataref","String","Object","StaticArray","Set","ArrayBufferView","ArrayBuffer","Math","Mathf","NativeMath","NativeMathf","TemplateStringsArray","Error","pow","ipow32","ipow64","mod","alloc","realloc","free","new_","renew","link","collect","typeinfo","instanceof_","visit","newBuffer","newArray","Feature","Target","Runtime","Typeinfo","TypeinfoFlags","ExportNames","target","WASM32","runtime","Incremental","exportMemory","importMemory","initialMemory","maximumMemory","sharedMemory","zeroFilledMemory","importTable","exportTable","sourceMap","explicitStart","memoryBase","tableBase","globalAliases","features","noUnsafe","pedantic","lowMemoryLimit","exportRuntime","stackSize","bundleMajorVersion","bundleMinorVersion","bundlePatchVersion","optimizeLevelHint","shrinkLevelHint","WASM64","isize64","isize32","willOptimize","Constraints","RuntimeFeatures","memory","table","runtimeFunctions","runtimeGlobals","Compiler","DiagnosticEmitter","diagnostics","currentParent","memorySegments","stringSegments","functionTable","builtinArgumentsLength","inlineStack","lazyFunctions","pendingClassInstanceOf","virtualStubs","pendingElements","doneModuleExports","f32ModInstance","f64ModInstance","f32PowInstance","f64PowInstance","i32PowInstance","i64PowInstance","_reusableCallExpression","Module","create","setLowMemoryUnused","featureFlags","FeatureFlags","SignExt","MutableGloabls","TruncSat","BulkMemory","SIMD","Atomics","ExceptionHandling","TailCall","ReferenceTypes","MultiValue","GC","Memory64","setFeatures","startFunctionInstance","makeNativeFunction","Signature","currentBody","shadowStack","ShadowStackPass","compile","hasShadowStack","initialize","actualFunction","startFunctionBody","files","filesByName","file","USER_ENTRY","compileFile","compileExports","ensureModuleExports","requireFunction","hasExport","addFunctionExport","requireGlobal","compileGlobal","addGlobalExport","functionsToCompile","Set_values","clear","compileClassInstanceOf","VIRTUAL","INSTANCE","ensureVirtualStub","ensureVarargsStub","virtualStubsSeen","discoveredOverload","overloadInstances","resolveOverloads","finalizeVirtualStub","removeGlobal","compileRTTI","compileVisitGlobals","compileVisitMembers","i64_align","lowMemoryLimit32","i64_gt","Low_memory_limit_exceeded_by_static_data_0_1","i64_to_string","initialPages","i64_shr_u","Module_requires_at_least_0_pages_of_initial_memory","maximumPages","UNLIMITED_MEMORY","Module_requires_at_least_0_pages_of_maximum_memory","isSharedMemory","Shared_memory_requires_maximum_memory_to_be_defined","Shared_memory_requires_feature_threads_to_be_enabled","setMemory","addMemoryImport","addTableImport","Importing_the_table_disables_some_indirect_call_optimizations","addTableExport","Exporting_the_table_disables_some_indirect_call_optimizations","functionTableNames","addFunctionTable","UNLIMITED_TABLE","global_set","ensureArgumentsLength","startIsEmpty","isWasi","unshift","funcRef","paramRefs","resultRefs","typesToRefs","additionalLocals","finalize","setStart","walkModule","lookup","RtraceMemory","elementName","ensureModuleExport","exportsStar","prefix","functionInstances","instanceName","GENERIC","fullName","Exported_generic_function_or_class_has_no_concrete_instances","identifierNode","CLASS_PROTOTYPE","classPrototype","classInstances","PROPERTY_PROTOTYPE","propertyInstance","CONST","STATIC","READONLY","exportName","Cannot_export_a_mutable_global","ENUMVALUE","enumValue","isImmutable","functionInstance","hasManagedOperands","noteExport","getManagedOperandIndices","PROPERTY","getterInstance","setterInstance","fieldInstance","getterExportName","compileFieldGetter","internalGetterName","internalGetterSignature","setterExportName","compileFieldSetter","internalSetterName","internalSetterSignature","isUnmanaged","ENUM","INTERFACE_PROTOTYPE","NAMESPACE","TYPEDEFINITION","subPrefix","implicitExport","SCOPED","memberName","PRIVATE","compileElement","compileMembers","compileEnum","resolveClass","compileClass","resolveProperty","compileProperty","exportStar","compileFileByPath","normalizedPathWithoutExtension","pathWithIndex","File_0_not_found","startFunction","startSignature","previousBody","previousFlow","compileTopLevelStatement","locals","localsByIndex","numLocals","varTypes","ERRORED","initExpr","typeNode","initializerNode","RESOLVED","resolvedType","resolveType","delete","Type_expected","setType","checkTypeSupported","atEnd","Type_0_is_not_assignable_to_type_1","AMBIENT","isDeclaredConstant","isDeclaredInline","MODULE_IMPORT","mangleImportName","addGlobalImport","mangleImportName_moduleName","mangleImportName_elementName","initializeInStart","GlobalGet","fromName","getGlobalGetName","isGlobalMutable","getGlobal","warning","Mutable_value_cannot_be_inlined","constantValueKind","constantFloatValue","compileInlineConstant","Decorator_0_is_not_valid_here","findDecorator","decoratorNodes","previousParent","previousValue","previousValueIsMut","isInline","initInStart","valueNode","In_const_enum_declarations_member_initializer_must_be_constant_expression","Enum_member_must_have_initializer","makeGlobalAssignment","setConstantIntegerValue","MODULE_EXPORT","forceStdAlternative","numParameters","visited","paramIdentifier","paramName","Duplicate_identifier_0","previousType","bodyNode","declarationNode","checkSignatureSupported","An_implementation_cannot_be_declared_in_ambient_contexts","compileFunctionBody","addFunctionImport","getFunction","ABSTRACT","INTERFACE","Function_implementation_is_missing_or_not_immediately_following_the_declaration","thisLocal","lookupLocal","bodyStartIndex","compileStatements","GET","SET","canOverflow","isNonnull","allocStmts","makeConditionalAllocation","makeFieldInitializationInConstructor","Explicitly_returning_constructor_drops_this_allocation","A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final","Constructors_for_derived_classes_must_contain_a_super_call","A_function_whose_declared_type_is_not_void_must_return_a_value","staticMembers","instanceMembers","compileField","getterRef","valueTypeRef","thisTypeRef","setterRef","bodyExpr","linkInstance","compilePropertyGetter","compilePropertySetter","buffer","alignment","MemorySegment","addRuntimeMemorySegment","computeBlockStart64","stringValue","ptr","ensureStaticStringPtr","stringSegment","totalOverhead","segments","createBuffer","elementTypeRef","writeI64","addStaticBuffer","arrayBufferInstance","OBJECTInstance","writeField","addStaticArrayHeader","bufferSegment","arrayInstance","bufferLength","readI32","arrayLength","bufferAddress","ensureRuntimeFunction","STUB","memorySegment","rtInstance","memberStatements","getElementByDeclaration","exportStatement","importStatement","stmt","compileStatement","Nop","isLastInBody","compileBlockStatement","compileBreakStatement","compileContinueStatement","compileDoStatement","compileEmptyStatement","compileExpressionStatement","compileForStatement","compileForOfStatement","compileIfStatement","compileReturnStatement","compileSwitchStatement","compileThrowStatement","compileTryStatement","compileVariableStatement","compileVoidStatement","compileWhileStatement","addDebugLocation","isBody","numStatements","Block","getBlockName","getBlockChildCount","getBlockChildAt","needsExplicitUnreachable","outerFlow","innerFlow","fork","freeScopedLocals","inherit","labelNode","breakLabel","A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement","br","continueLabel","A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement","doCompileDoStatement","flowAfter","pushBreakLabel","unifyLocalFlags","flowBefore","loopLabel","bodyFlow","bodyStmts","possiblyContinues","condFlow","condExpr","condKind","evaluateCondition","drop","Flow","hasIncompatibleLocalStates","popBreakLabel","hasScopedLocals","loop","doCompileForStatement","tcond","loopStmts","local_set","inheritNonnullIfTrue","inheritBranch","ifStmts","incrFlow","thenStmts","thenFlow","elseStmts","elseFlow","inheritNonnullIfFalse","inheritMutual","valueExpression","constraints","inlineReturnLabel","numCases","context","tempLocal","tempLocalIndex","breaks","breakIndex","defaultIndex","EqI32","currentBlock","commonCategorical","commonConditional","isLast","nextLabel","terminates","deriveConditionalFlags","message","newArgs","numDeclarations","initializers","uniqueMap","contextualTypeArguments","dummy","addScopedDummyLocal","freeScopedDummyLocal","isConst","local","Local","parentFunction","setConstantFloatValue","scopedLocals","existing","errorRelated","_const_declarations_must_be_initialized","LET","existingLocal","getScopedLocal","addScopedLocal","CONSTANT","addLocal","makeLocalAssignment","isShortIntegerValue","doCompileWhileStatement","i64_ne","i64_zero","computeSmallIntegerShift","computeSmallIntegerMask","compileAssertionExpression","compileBinaryExpression","compileCallExpression","compileCommaExpression","compileElementAccessExpression","compileFunctionExpression","compileIdentifierExpression","compileInstanceOfExpression","compileLiteralExpression","compileNewExpression","compilePropertyAccessExpression","compileTernaryExpression","compileUnaryPostfixExpression","compileUnaryPrefixExpression","compiled","wrap","ensureSmallIntegerWrap","explicit","makeRuntimeNonNullCheck","isExternalReference","makeRuntimeUpcastCheck","Conversion_from_type_0_to_1_requires_an_explicit_cast","PromoteF32ToF64","DemoteF64ToF32","saturating","isLongIntegerValue","TruncSatF32ToI64","TruncF32ToI64","TruncSatF32ToI32","TruncF32ToI32","TruncSatF32ToU64","TruncF32ToU64","TruncSatF32ToU32","TruncF32ToU32","TruncSatF64ToI64","TruncF64ToI64","TruncSatF64ToI32","TruncF64ToI32","TruncSatF64ToU64","TruncF64ToU64","TruncSatF64ToU32","TruncF64ToU32","ConvertI64ToF32","ConvertU64ToF32","ConvertI32ToF32","ConvertU32ToF32","ConvertI64ToF64","ConvertU64ToF64","ConvertI32ToF64","ConvertU32ToF64","NeI64","WrapI64ToI32","ExtendI32ToI64","ExtendU32ToU64","isVaryingIntegerValue","Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit","inheritedConstraints","PREFIX","AS","NONNULL","exceptVoid","info","Expression_is_never_null","leftExpr","leftType","rightExpr","rightType","commonType","compound","Token","LESSTHAN","overload","lookupOverload","OperatorKind","LT","compileBinaryOverload","commonDenominator","Operator_0_cannot_be_applied_to_types_1_and_2","makeLt","GREATERTHAN","GT","makeGt","LESSTHAN_EQUALS","LE","makeLe","GREATERTHAN_EQUALS","GE","makeGe","EQUALS_EQUALS_EQUALS","EQUALS_EQUALS","EQ","operatorTokenToString","makeEq","EXCLAMATION_EQUALS_EQUALS","EXCLAMATION_EQUALS","NE","makeNe","EQUALS","compileAssignment","PLUS_EQUALS","PLUS","ADD","The_0_operator_cannot_be_applied_to_type_1","MINUS_EQUALS","MINUS","SUB","ASTERISK_EQUALS","ASTERISK","MUL","ASTERISK_ASTERISK_EQUALS","ASTERISK_ASTERISK","POW","makePow","SLASH_EQUALS","SLASH","DIV","PERCENT_EQUALS","PERCENT","REM","makeRem","LESSTHAN_LESSTHAN_EQUALS","LESSTHAN_LESSTHAN","intType","BITWISE_SHL","makeShl","GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN","BITWISE_SHR","makeShr","GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN_GREATERTHAN","BITWISE_SHR_U","makeShru","AMPERSAND_EQUALS","AMPERSAND","BITWISE_AND","makeAnd","BAR_EQUALS","BAR","BITWISE_OR","makeOr","CARET_EQUALS","CARET","BITWISE_XOR","makeXor","AMPERSAND_AMPERSAND","rightFlow","tryCopyTrivialExpression","BAR_BAR","targetType","getTypeOfElement","makeAssignment","currentThisExpression","currentElementExpression","LtF32","LtF64","GtF32","GtF64","LeI32","LeI64","LeU32","LeU64","LeF32","LeF64","GeI32","GeI64","GeU32","GeU64","GeF32","GeF64","EqI64","ref_eq","NeI32","AddF32","AddF64","MulI32","MulI64","MulF32","MulF64","Cannot_find_name_0","makeCallDirect","namespace","namespaceMembers","DivI32","DivI64","DivU32","DivU64","DivF32","DivF64","RemI32","RemI64","RemU32","RemU64","ShlI64","ShrU64","AndI64","OrI64","compileUnaryOverload","operatorInstance","valueExpr","thisExpression","LOCAL","Variable_0_used_before_its_declaration","checkUnsafe","propertyPrototype","Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property","isUnchecked","indexedSet","INDEXED_SET","INDEXED_GET","Index_signature_in_type_0_only_permits_reading","Index_signature_is_missing_in_type_0","Indexed_access_may_involve_bounds_checking","indexExpression","tee","isLocalFlag","isConstructor","setThisFieldFlag","FieldFlags","INITIALIZED","fieldParent","makeFieldAssignment","thisExpr","returnTypeRef","tempThis","elementExpr","tempTarget","tempElement","localIndex","unsetLocalFlag","field","fieldType","fieldTypeRef","Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors","baseClassInstance","_super_can_only_be_referenced_in_a_derived_class","baseCtorInstance","superCall","_super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class","compileCallExpressionBuiltin","maybeInferCall","inlinedValue","Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures","Expression_cannot_be_represented_by_a_type","compileCallExpressionLike","createCallExpression","resolveTypeArguments","callee","BuiltinContext","fn","methodName","checkCallSignature","hasThis","The_this_types_of_each_signature_are_incompatible","hasRest","minimum","maximum","relatedReportNode","Operation_is_unsafe","argumentExpressions","includes","makeCallInline","pop","Function_0_cannot_be_inlined_into_itself","numArgumentsInclThis","paramType","paramExpr","immediatelyDropped","createInline","usedLocals","argumentLocal","getParameterName","addScopedAlias","initType","checkFieldInitializationInFlow","original","stub","varargsStub","originalSignature","originalParameterTypes","originalParameterDeclarations","isInstance","minArguments","minOperands","maxArguments","maxOperands","numOptional","forwardedOperands","operandIndex","newStub","numNames","ofN","Optional_parameter_must_have_an_initializer","virtualStub","ref","tempIndex","builder","SwitchBuilder","overloadInstance","overloadType","originalType","overloadSignature","overloadParameterTypes","overloadNumParameters","paramExprs","n","needsVarargsStub","calledName","getClassOrInterface","addCase","extendees","getAllExtendees","a","b","extendee","removeFunction","render","operandsTostack","isConstZero","Function_0_is_virtual_and_will_not_be_inlined","theOperands","slice","allOptionalsAreConstant","resolved","lastOperand","getSideEffects","SideEffects","WritesGlobal","lastOperandType","makeCallIndirect","numExpressions","targetExpression","resolveExpression","indexedGet","isNamed","isSemanticallyAnonymous","FunctionPrototype","nextAnonymousId","contextualSignature","signatureNode","numPresentParameters","parameterNode","isTypeOmitted","thisTypeNode","outer","worked","fname","maybeCompileEnclosingSource","asNullable","Expression_resolves_to_unusual_type_0","_this_cannot_be_referenced_in_constructor_arguments","_super_cannot_be_referenced_in_constructor_arguments","_super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class","scopedThis","superType","lookupIdentifierExpression","localType","globalType","A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums","Type_argument_expected","ref_func","Expression_does_not_compile_to_a_value_at_runtime","namedType","resolveTypeName","makeInstanceofClass","expectedType","makeInstanceofType","actualType","Expression_compiles_to_a_dynamic_check_at_runtime","implicitlyNegate","compileArrayLiteral","floatValue","intValue","determineIntegerLiteralType","i64_to_f32","i64_to_f64","compileStringLiteral","compileTemplateLiteral","compileObjectLiteral","numParts","stringType","lhsLen","rhsLen","makeToString","hasPrefix","lhs","rhs","concatMethod","getMethod","exprA","exprB","joinInstance","indexedSetInstance","temps","tsaArrayInstance","templateStringsArrayInstance","first","arraySegment","partExprs","rawExprs","rawHeaderSegment","createCompiledExpression","nativeRange","contextualClass","compileStaticArrayLiteral","arrayType","tempDataStart","arrayAddress","makeNewArray","arrayTypeRef","dataStartMember","newArrayInstance","bufferSize","newBufferInstance","classType","Cannot_create_an_instance_of_an_abstract_class","ctorPrototype","constructorPrototype","Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal","hasErrors","classTypeRef","omittedFields","memberKey","Property_0_does_not_exist_on_type_1","Property_0_is_private_and_only_accessible_within_class_1","PROTECTED","Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses","Property_0_is_missing_in_type_1_but_required_in_type_2","resolveClassInclTypeArguments","constructorInstance","baseClass","baseCtor","makeNativeFunctionDeclaration","setResolvedInstance","relatedNode","didCheckFieldInitialization","isThisFieldFlag","DEFINITELY_ASSIGNED","Property_0_is_always_assigned_before_being_used","Unnecessary_definite_assignment","Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned","ctorInstance","ctxType","parentEnum","Property_0_is_used_before_being_assigned","Object_is_possibly_null","ifThenFlow","ifThenExpr","ifThenType","ifElseFlow","ifElseExpr","ifElseType","getValue","Unreachable","PLUS_PLUS","POSTFIX_INC","getLocalSetValue","makeOne","MINUS_MINUS","POSTFIX_DEC","setValue","NegF32","NegF64","PREFIX_INC","PREFIX_DEC","EXCLAMATION","NOT","TILDE","BITWISE_NOT","makeNegOne","TYPEOF","compileTypeof","DOT_DOT_DOT","typeString","REPORT","Extend8I32","Extend16I32","addDebugInfoFile","debugInfoRef","debugLocations","supported","parameterReportNode","v128_zero","ref_null","toStringInstance","toStringSignature","identifierAndSignatureRange","toStringReturnType","makeAllocation","allocInstance","newInstance","thisIndex","thisLocalIndex","nonParameterFields","fieldPrototype","codeLocation","abortInstance","messageArg","makeStaticAbort","messageExpr","filenameExpr","mangleInternalName","arg","ExportsWalker","includePrivate","seen","walk","visitFile","visitElement","visitGlobal","visitEnum","visitFunctionInstances","visitClassInstances","visitField","visitFunction","hasCompiledMember","visitNamespace","visitAlias","visitClass","IDLBuilder","sb","indentLevel","build","indent","typeToString","visitInterface","originalName","TSDBuilder","remainingMembers","isInterface","extendsNode","code","diagnosticCategoryToString","PEDANTIC","diagnosticCategoryToColor","COLOR_MAGENTA","COLOR_CYAN","COLOR_YELLOW","COLOR_RED","diagnosticCodeToString","DiagnosticMessage","relatedRange","replace","equals","other","thisRange","otherRange","thisRelatedRange","otherRelatedRange","withRange","withRelatedRange","formatDiagnosticContext","isLineBreak","isColorsEnabled","COLOR_RESET","useColors","showContext","wasColorsEnabled","setColorsEnabled","relatedSource","seenInSource","seenMessagesAtPos","pedanticRelated","infoRelated","warningRelated","ASTBuilder","visitNode","finish","visitSource","visitNamedTypeNode","visitFunctionTypeNode","visitTypeParameter","visitIdentifierExpression","visitAssertionExpression","visitBinaryExpression","visitCallExpression","visitClassExpression","visitCommaExpression","visitElementAccessExpression","visitFunctionExpression","visitInstanceOfExpression","visitLiteralExpression","visitNewExpression","visitParenthesizedExpression","visitPropertyAccessExpression","visitTernaryExpression","visitUnaryPostfixExpression","visitUnaryPrefixExpression","visitBlockStatement","visitBreakStatement","visitContinueStatement","visitDoStatement","visitEmptyStatement","visitExportStatement","visitExportDefaultStatement","visitExportImportStatement","visitExpressionStatement","visitForStatement","visitForOfStatement","visitIfStatement","visitImportStatement","visitReturnStatement","visitSwitchStatement","visitThrowStatement","visitTryStatement","visitVariableStatement","visitWhileStatement","visitClassDeclaration","visitEnumDeclaration","visitEnumValueDeclaration","visitFieldDeclaration","visitFunctionDeclaration","visitImportDeclaration","visitInterfaceDeclaration","visitMethodDeclaration","visitNamespaceDeclaration","visitTypeDeclaration","visitVariableDeclaration","serializeDecorator","visitExportMember","serializeParameter","visitSwitchCase","visitIndexSignature","visitNodeAndTerminate","visitTypeNode","visitTypeName","visitStringLiteral","visitArrayLiteralExpression","elements","visitObjectLiteralExpression","visitArguments","numArgs","visitFunctionCommon","visitFloatLiteralExpression","visitIntegerLiteralExpression","visitStringLiteralExpression","visitTemplateLiteralExpression","visitRegexpLiteralExpression","str","visitRawString","quote","visitUnaryExpression","last","lastCharPos","isDefault","serializeExternalModifiers","numImplementsTypes","numMembers","numValues","serializeAccessModifiers","numTypeParameters","firstDeclaration","REST","OPTIONAL","DECLARE","PUBLIC","FlowFlags","ConditionKind","localFlags","thisFieldFlags","inlineFunction","initThisFieldFlags","nextInlineId","condiFlags","resetBreakContext","branch","except","tempI32s","tempI64s","tempF32s","tempF64s","tempV128s","tempFuncrefs","tempExternrefs","tempAnyrefs","tempEqrefs","tempI31refs","tempDatarefs","resetTemporaryName","scopedLocal","setTemporaryName","scopedDummy","Cannot_redeclare_block_scoped_variable_0","scopedAlias","scope","localsByName","defaultIfInlined","isAnyLocalFlag","actualParent","actualClass","fieldFlags","nextBreakId","stack","breakStack","otherFlags","conditionKind","thisFlags","newFlags","thisLocalFlags","numThisLocalFlags","otherLocalFlags","numOtherLocalFlags","maxLocalFlags","leftFlags","rightFlags","rightLocalFlags","leftLocalFlags","numLeftLocalFlags","numRightLocalFlags","leftFieldFlags","newFieldFlags","rightFieldFlags","key","before","after","LocalSet","isLocalTee","getLocalSetIndex","iff","If","getIfFalse","getIfCondition","getIfTrue","Unary","getUnaryOp","getUnaryValue","Binary","getBinaryOp","getBinaryLeft","getBinaryRight","exprType","canConversionOverflow","isUnsignedIntegerValue","Extend8I64","Extend16I64","Extend32I64","MIN_VALUE","Load","signed","isLoadSigned","getLoadBytes","Select","getSelectThen","getSelectElse","Call","instancesByName","getCallTarget","levels","formatDiagnosticMessage","Options","alias","DEFAULT_STACK_SIZE","FEATURE_SIGN_EXTENSION","FEATURE_MUTABLE_GLOBALS","FEATURE_NONTRAPPING_F2I","FEATURE_BULK_MEMORY","FEATURE_SIMD","FEATURE_THREADS","FEATURE_EXCEPTION_HANDLING","FEATURE_TAIL_CALLS","FEATURE_REFERENCE_TYPES","FEATURE_MULTI_VALUE","FEATURE_GC","FEATURE_MEMORY64","optimizeLevel","shrinkLevel","Program","diagnosticsOffset","getSource","isEntry","parser","parseFile","nextFile","getDependee","util","Auto","ExternalKind","RefAsOp","BrOnOp","useShadowStack","sizeType","hasTemporaryFunction","cachedStringsToPointers","cachedPointersToStrings","lit","binaryen","_malloc","_BinaryenSizeofLiteral","_BinaryenModuleCreate","cArr","allocU8Array","_BinaryenModuleRead","_free","out","_BinaryenLiteralInt32","_BinaryenConst","valueLow","valueHigh","_BinaryenLiteralInt64","i64_is","_BinaryenLiteralFloat32","_BinaryenLiteralFloat64","__i32_store8","_BinaryenLiteralVec128","_BinaryenRefNull","_BinaryenRefEq","_last","isWam64","ClzSize","CtzSize","PopcntSize","EqzSize","_BinaryenUnary","AddSize","SubSize","MulSize","DivISize","DivUSize","RemISize","RemUSize","AndSize","OrSize","XorSize","ShlSize","ShrISize","ShrUSize","RotlSize","RotrSize","EqSize","NeSize","LtISize","LtUSize","LeISize","LeUSize","GtISize","GtUSize","GeISize","GeUSize","_BinaryenBinary","_BinaryenMemorySize","delta","_BinaryenMemoryGrow","table_size","cStr","allocStringCached","_BinaryenTableSize","table_grow","_BinaryenTableGrow","_BinaryenLocalGet","_BinaryenExpressionGetType","_BinaryenLocalTee","_BinaryenGlobalGet","table_get","_BinaryenTableGet","_BinaryenLoad","_BinaryenStore","_BinaryenAtomicLoad","_BinaryenAtomicStore","_BinaryenAtomicRMW","replacement","_BinaryenAtomicCmpxchg","timeout","_BinaryenAtomicWait","notifyCount","_BinaryenAtomicNotify","_BinaryenAtomicFence","_BinaryenLocalSet","_BinaryenGlobalSet","table_set","_BinaryenTableSet","children","allocPtrArray","_BinaryenBlock","single","Return","Throw","singleType","_BinaryenBreak","_BinaryenDrop","result","ReadsLocal","ReadsGlobal","_BinaryenLoop","_BinaryenIf","_BinaryenNop","_BinaryenReturn","_BinaryenSelect","defaultName","strs","_BinaryenSwitch","isReturn","_BinaryenReturnCall","_BinaryenCall","return_call","tableName","params","results","_BinaryenReturnCallIndirect","_BinaryenCallIndirect","return_call_indirect","_BinaryenUnreachable","dest","_BinaryenMemoryCopy","_BinaryenMemoryFill","try","catchTags","catchBodies","delegateTarget","numCatchTags","cArr1","cArr2","cStr1","cStr2","_BinaryenTry","throw","tagName","_BinaryenThrow","rethrow","_BinaryenRethrow","_BinaryenPop","tuple_make","_BinaryenTupleMake","tuple_extract","tuple","_BinaryenTupleExtract","vec","_BinaryenSIMDExtract","_BinaryenSIMDReplace","vec1","vec2","_BinaryenSIMDShuffle","c","_BinaryenSIMDTernary","_BinaryenSIMDShift","_BinaryenSIMDLoad","_BinaryenSIMDLoadStoreLane","_BinaryenRefIs","ref_as","_BinaryenRefAs","_BinaryenRefFunc","_BinaryenI31New","_BinaryenI31Get","mutable","_BinaryenAddGlobal","_BinaryenGetGlobal","_BinaryenRemoveGlobal","addTag","_BinaryenAddTag","getTag","_BinaryenGetTag","removeTag","_BinaryenRemoveTag","_BinaryenAddFunction","_BinaryenGetFunction","_BinaryenRemoveFunction","hasFunction","addTemporaryFunction","paramTypes","tempName","removeTemporaryFunction","func","_BinaryenSetStart","_BinaryenAddFunctionExport","_BinaryenAddTableExport","addMemoryExport","_BinaryenAddMemoryExport","_BinaryenAddGlobalExport","addTagExport","_BinaryenAddTagExport","removeExport","_BinaryenRemoveExport","_BinaryenGetExport","externalModuleName","externalBaseName","cStr3","_BinaryenAddFunctionImport","_BinaryenAddTableImport","shared","_BinaryenAddMemoryImport","_BinaryenAddGlobalImport","addTagImport","_BinaryenAddTagImport","initial","segs","psvs","offs","sizs","cArr3","cArr4","u32s","val","__i32_store","HEAPU32","allocU32Array","_BinaryenSetMemory","funcs","tableRef","_BinaryenGetTable","_BinaryenTableSetInitial","_BinaryenTableSetMax","_BinaryenAddTable","_BinaryenAddActiveElementSegment","addCustomSection","contents","_BinaryenAddCustomSection","getOptimizeLevel","_BinaryenGetOptimizeLevel","setOptimizeLevel","level","_BinaryenSetOptimizeLevel","getShrinkLevel","_BinaryenGetShrinkLevel","setShrinkLevel","_BinaryenSetShrinkLevel","getDebugInfo","_BinaryenGetDebugInfo","setDebugInfo","on","_BinaryenSetDebugInfo","getLowMemoryUnused","_BinaryenGetLowMemoryUnused","_BinaryenSetLowMemoryUnused","getZeroFilledMemory","_BinaryenGetZeroFilledMemory","setZeroFilledMemory","_BinaryenSetZeroFilledMemory","getFastMath","_BinaryenGetFastMath","setFastMath","_BinaryenSetFastMath","getPassArgument","_BinaryenGetPassArgument","readString","setPassArgument","_BinaryenSetPassArgument","clearPassArguments","_BinaryenClearPassArguments","getAlwaysInlineMaxSize","_BinaryenGetAlwaysInlineMaxSize","setAlwaysInlineMaxSize","_BinaryenSetAlwaysInlineMaxSize","getFlexibleInlineMaxSize","_BinaryenGetFlexibleInlineMaxSize","setFlexibleInlineMaxSize","_BinaryenSetFlexibleInlineMaxSize","getOneCallerInlineMaxSize","_BinaryenGetOneCallerInlineMaxSize","setOneCallerInlineMaxSize","_BinaryenSetOneCallerInlineMaxSize","getAllowInliningFunctionsWithLoops","_BinaryenGetAllowInliningFunctionsWithLoops","setAllowInliningFunctionsWithLoops","enabled","_BinaryenSetAllowInliningFunctionsWithLoops","getFeatures","_BinaryenModuleGetFeatures","_BinaryenModuleSetFeatures","runPasses","passes","cStrs","allocString","_BinaryenFunctionRunPasses","_BinaryenModuleRunPasses","optimize","debugInfo","validate","_BinaryenModuleValidate","interpret","_BinaryenModuleInterpret","toBinary","sourceMapUrl","binaryPtr","sourceMapPtr","_BinaryenModuleAllocateAndWrite","__i32_load","binaryLen","BinaryModule","__i32_load8_u","HEAPU8","readBuffer","toText","watFormat","toAsmjs","cached","readStringCached","dispose","_BinaryenModuleDispose","createRelooper","Relooper","_BinaryenExpressionGetId","MemorySize","DataDrop","RefNull","RttCanon","copyExpression","_BinaryenExpressionCopy","maxDepth","maxLoopIterations","runner","_ExpressionRunnerCreate","_ExpressionRunnerRunAndDispose","_BinaryenModuleAddDebugInfoFileName","getDebugInfoFile","_BinaryenModuleGetDebugInfoFileName","setDebugLocation","fileIndex","lineNumber","columnNumber","_BinaryenFunctionSetDebugLocation","types","_BinaryenTypeCreate","_BinaryenConstGetValueI32","_BinaryenConstGetValueI64Low","_BinaryenConstGetValueI64High","_BinaryenConstGetValueF32","_BinaryenConstGetValueF64","arity","_BinaryenTypeArity","_BinaryenTypeExpand","_BinaryenLocalGetGetIndex","_BinaryenLocalSetGetIndex","_BinaryenLocalSetGetValue","_BinaryenLocalSetIsTee","_BinaryenGlobalGetGetName","_BinaryenBinaryGetOp","_BinaryenBinaryGetLeft","_BinaryenBinaryGetRight","_BinaryenUnaryGetOp","_BinaryenUnaryGetValue","_BinaryenLoadGetBytes","_BinaryenLoadGetOffset","_BinaryenLoadGetPtr","_BinaryenLoadIsSigned","_BinaryenStoreGetBytes","_BinaryenStoreGetOffset","_BinaryenStoreGetPtr","_BinaryenStoreGetValue","_BinaryenBlockGetName","_BinaryenBlockGetNumChildren","_BinaryenBlockGetChildAt","_BinaryenIfGetCondition","_BinaryenIfGetIfTrue","_BinaryenIfGetIfFalse","_BinaryenLoopGetName","_BinaryenLoopGetBody","_BinaryenBreakGetName","_BinaryenBreakGetCondition","_BinaryenSelectGetIfTrue","_BinaryenSelectGetIfFalse","_BinaryenSelectGetCondition","_BinaryenDropGetValue","_BinaryenReturnGetValue","_BinaryenCallGetTarget","_BinaryenCallGetNumOperands","_BinaryenCallGetOperandAt","_BinaryenMemoryGrowGetDelta","_BinaryenFunctionGetBody","_BinaryenFunctionGetName","_BinaryenFunctionGetParams","_BinaryenFunctionGetResults","_BinaryenFunctionGetNumVars","_BinaryenFunctionGetVar","_BinaryenGlobalGetName","_BinaryenGlobalGetType","_BinaryenGlobalIsMutable","_BinaryenGlobalGetInitExpr","_BinaryenTagGetName","_BinaryenTagGetParams","_BinaryenTagGetResults","_RelooperCreate","addBlock","_RelooperAddBlock","addBranch","from","to","_RelooperAddBranch","addBlockWithSwitch","_RelooperAddBlockWithSwitch","addBranchForSwitch","indexes","i32s","HEAP32","allocI32Array","_RelooperAddBranchForSwitch","renderAndDispose","entry","labelHelper","_RelooperRenderAndDispose","_BinaryenExpressionGetSideEffects","u8s","ptrs","c1","isHighSurrogate","isLowSurrogate","stringLengthUTF8","u","c2","combineSurrogates","cp","u1","u2","u3","arr","ch","SURROGATE_HIGH","SURROGATE_LOW","fromCharCodes","indexOf","addDefault","labelPostfix","labels","defaultLabel","lastCase","output","Break","numChildren","Dependee","Parser","sources","backlog","seenlog","donelog","onComment","currentSource","dependees","tryParseSignatureIsSignature","parseParametersThis","dependee","Source","USER","tn","Tokenizer","skip","ENDOFFILE","parseTopLevelStatement","skipStatement","startPos","AT","tokenPos","parseDecorator","exportStart","exportEnd","defaultStart","defaultEnd","DEFAULT","declareStart","declareEnd","contextIsAmbient","A_declare_modifier_cannot_be_used_in_an_already_ambient_context","peek","nextTokenPos","parseEnum","parseVariable","VAR","parseFunction","state","mark","abstractStart","abstractEnd","nextTokenOnNewLine","reset","parseStatement","_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration","discard","parseClassOrInterface","IdentifierHandling","PREFER","parseNamespace","parseExportImport","parseImport","TYPE","parseTypeDeclaration","skipIdentifier","An_export_assignment_cannot_have_modifiers","parseExportDefaultAlias","parseExport","_0_modifier_cannot_be_used_here","Decorators_are_not_valid_here","createExportDefaultStatement","dependent","parseTypeName","readIdentifier","DOT","Identifier_expected","parseType","acceptParenthesized","suppressErrors","token","OPENPAREN","isNullableSignature","tryParseFunctionType","CLOSEPAREN","_0_expected","Unexpected_token","innerType","createNamedType","STRINGLITERAL","parameter","notNullStart","notNull","OPENBRACKET","bracketStart","CLOSEBRACKET","bracketRange","nullable","isSignature","firstParamNameNoType","firstParamKind","paramStart","COLON","QUESTION","A_rest_parameter_cannot_be_optional","param","createParameter","createOmittedType","EQUALS_GREATERTHAN","createFunctionType","createPropertyAccessExpression","createDecorator","parseArguments","isFor","parseVariableDeclaration","createVariableStatement","SEMICOLON","parentFlags","parentDecorators","isIllegalVariableIdentifier","Initializers_are_not_allowed_in_ambient_contexts","parseExpression","A_definite_assignment_assertion_is_not_permitted_in_this_context","createVariableDeclaration","OPENBRACE","CLOSEBRACE","parseEnumValue","createEnumDeclaration","createEnumValueDeclaration","parseReturn","nextToken","createReturnStatement","parseTypeParameters","seenOptional","typeParameter","parseTypeParameter","Required_type_parameters_may_not_follow_optional_type_parameters","Type_parameter_list_cannot_be_empty","EXTENDS","createTypeParameter","parseParameters","seenRest","reportedRest","parseParameter","A_rest_parameter_must_be_last_in_a_parameter_list","A_required_parameter_cannot_follow_an_optional_parameter","isRest","isOptional","startRange","accessFlags","A_parameter_property_cannot_be_declared_using_a_rest_parameter","A_rest_parameter_cannot_have_an_initializer","Parameter_cannot_have_question_mark_and_initializer","signatureStart","isSetter","A_set_accessor_must_have_exactly_one_parameter","A_set_accessor_parameter_cannot_have_an_initializer","A_get_accessor_cannot_have_parameters","parseBlockStatement","createFunctionDeclaration","parseFunctionExpression","createEmptyIdentifierExpression","parseFunctionExpressionCommon","explicitThis","bodyExpression","createExpressionStatement","createFunctionExpression","IMPLEMENTS","Interface_declaration_cannot_have_implements_clause","createInterfaceDeclaration","createClassDeclaration","parseClassMember","parseClassExpression","createClassExpression","accessStart","accessEnd","staticStart","staticEnd","GENERIC_CONTEXT","readonlyStart","readonlyEnd","isGetter","getStart","getEnd","setEnd","isGetterOrSetter","createConstructorExpression","retIndex","parseIndexSignature","ALWAYS","typeParametersStart","Type_parameters_cannot_appear_on_a_constructor_declaration","An_accessor_cannot_have_type_parameters","_0_modifier_cannot_appear_on_class_elements_of_this_kind","createFieldDeclaration","_0_keyword_cannot_be_used_here","Type_annotation_cannot_appear_on_a_constructor_declaration","A_set_accessor_cannot_have_a_return_type_annotation","Method_0_cannot_have_an_implementation_because_it_is_marked_abstract","retMethod","createMethodDeclaration","Constructor_implementation_is_missing","Optional_properties_are_not_supported","retField","createIndexSignature","createNamespaceDeclaration","parseExportMember","FROM","createStringLiteralExpression","createExportStatement","asIdentifier","createExportMember","skipFrom","parseImportDeclaration","createImportDeclaration","createWildcardImportStatement","createImportStatement","createExportImportStatement","topLevel","parseBreak","parseContinue","parseDoStatement","parseForStatement","parseIfStatement","A_return_statement_can_only_be_used_within_a_function_body","createEmptyStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVoidStatement","parseWhileStatement","parseExpressionStatement","createBlockStatement","createBreakStatement","createContinueStatement","createDoStatement","OF","parseForOfStatement","The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer","createForStatement","createForOfStatement","elseStatement","ELSE","createIfStatement","switchCases","switchCase","parseSwitchCase","createSwitchStatement","CASE","createSwitchCase","_case_or_default_expected","createThrowStatement","CATCH","FINALLY","createTryStatement","createTypeDeclaration","createVoidStatement","createWhileStatement","parseExpressionStart","YIELD","DELETE","createUnaryPrefixExpression","The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access","arguments_","tryParseTypeArgumentsBeforeArguments","createNewExpression","createNullExpression","createTrueExpression","createFalseExpression","createThisExpression","again","inner","createParenthesizedExpression","maybeParseCallExpression","createOmittedExpression","createArrayLiteralExpression","createObjectLiteralExpression","createAssertionExpression","identifierText","TEMPLATELITERAL","parseTemplateLiteral","_super_must_be_followed_by_an_argument_list_or_member_access","createSuperExpression","INTEGERLITERAL","readInteger","checkForIdentifierStartAfterNumericLiteral","createIntegerLiteralExpression","FLOATLITERAL","readFloat","createFloatLiteralExpression","regexpPattern","readRegexpPattern","createRegexpLiteralExpression","readRegexpFlags","Unexpected_end_of_text","Expression_expected","Type_argument_list_cannot_be_empty","precedence","nextPrecedence","determinePrecedence","createInstanceOfExpression","createElementAccessExpression","createUnaryPostfixExpression","createTernaryExpression","commaExprs","createCommaExpression","joinPropertyCall","createBinaryExpression","readStringStart","readStringEnd","readingTemplateString","createTemplateLiteralExpression","potentiallyGeneric","skipBlock","depth","IN","Precedence","FindUsedLocalsVisitor","Visitor","used","visitLocalGet","localGet","visitLocalSet","localSet","singleton","visitor","_currentExpression","currentExpression","parentExpressionOrNull","visitBlock","visitIf","visitLoop","visitBreak","visitSwitch","visitCallPre","visitCall","visitCallIndirectPre","visitCallIndirect","visitGlobalGet","visitGlobalSet","visitLoad","visitStore","visitConst","visitUnary","visitBinary","visitSelect","visitDrop","visitReturn","visitMemorySize","visitMemoryGrow","visitNop","visitUnreachable","visitAtomicRMW","visitAtomicCmpxchg","visitAtomicWait","visitAtomicNotify","visitAtomicFence","visitSIMDExtract","visitSIMDReplace","visitSIMDShuffle","visitSIMDTernary","visitSIMDShift","visitSIMDLoad","visitSIMDLoadStoreLane","visitMemoryInit","visitDataDrop","visitMemoryCopy","visitMemoryFill","visitPop","visitRefNull","visitRefIs","visitRefFunc","visitRefEq","visitTry","visitThrow","visitRethrow","visitTupleMake","visitTupleExtract","visitI31New","visitI31Get","visitCallRef","visitRefTest","visitRefCast","visitBrOn","visitRttCanon","visitRttSub","visitStructNew","visitStructGet","visitStructSet","visitArrayNew","visitArrayGet","visitArraySet","visitArrayLen","visitRefAs","visitName","visitLabel","visitIndex","visitTag","previousExpression","Loop","_BinaryenBreakGetValue","Switch","_BinaryenSwitchGetDefaultName","_BinaryenSwitchGetNumNames","_BinaryenSwitchGetNameAt","_BinaryenSwitchGetCondition","_BinaryenSwitchGetValue","CallIndirect","_BinaryenCallIndirectGetTarget","_BinaryenCallIndirectGetNumOperands","_BinaryenCallIndirectGetOperandAt","GlobalSet","_BinaryenGlobalSetGetName","_BinaryenGlobalSetGetValue","Store","Drop","MemoryGrow","AtomicRMW","_BinaryenAtomicRMWGetPtr","_BinaryenAtomicRMWGetValue","AtomicCmpxchg","_BinaryenAtomicCmpxchgGetPtr","_BinaryenAtomicCmpxchgGetExpected","_BinaryenAtomicCmpxchgGetReplacement","AtomicWait","_BinaryenAtomicWaitGetPtr","_BinaryenAtomicWaitGetExpected","_BinaryenAtomicWaitGetTimeout","AtomicNotify","_BinaryenAtomicNotifyGetPtr","_BinaryenAtomicNotifyGetNotifyCount","AtomicFence","SIMDExtract","_BinaryenSIMDExtractGetVec","SIMDReplace","_BinaryenSIMDReplaceGetVec","_BinaryenSIMDReplaceGetValue","SIMDShuffle","_BinaryenSIMDShuffleGetLeft","_BinaryenSIMDShuffleGetRight","SIMDTernary","_BinaryenSIMDTernaryGetA","_BinaryenSIMDTernaryGetB","_BinaryenSIMDTernaryGetC","SIMDShift","_BinaryenSIMDShiftGetVec","_BinaryenSIMDShiftGetShift","SIMDLoad","_BinaryenSIMDLoadGetPtr","SIMDLoadStoreLane","_BinaryenSIMDLoadStoreLaneGetPtr","_BinaryenSIMDLoadStoreLaneGetVec","MemoryInit","_BinaryenMemoryInitGetDest","_BinaryenMemoryInitGetOffset","_BinaryenMemoryInitGetSize","MemoryCopy","_BinaryenMemoryCopyGetDest","_BinaryenMemoryCopyGetSource","_BinaryenMemoryCopyGetSize","MemoryFill","_BinaryenMemoryFillGetDest","_BinaryenMemoryFillGetValue","_BinaryenMemoryFillGetSize","Pop","RefIs","_BinaryenRefIsGetValue","RefFunc","_BinaryenRefFuncGetFunc","RefEq","_BinaryenRefEqGetLeft","_BinaryenRefEqGetRight","Try","_BinaryenTryGetBody","numCatchBodies","_BinaryenTryGetNumCatchBodies","_BinaryenTryGetCatchBodyAt","_BinaryenThrowGetTag","_BinaryenThrowGetNumOperands","_BinaryenThrowGetOperandAt","Rethrow","TupleMake","_BinaryenTupleMakeGetNumOperands","_BinaryenTupleMakeGetOperandAt","TupleExtract","_BinaryenTupleExtractGetTuple","I31New","_BinaryenI31NewGetValue","I31Get","_BinaryenI31GetGetI31","CallRef","RefTest","RefCast","BrOn","RttSub","StructNew","StructGet","StructSet","ArrayNew","ArrayGet","ArraySet","ArrayLen","RefAs","replaceChild","search","child","_BinaryenBlockSetChildAt","_BinaryenIfSetCondition","_BinaryenIfSetIfTrue","_BinaryenIfSetIfFalse","_BinaryenLoopSetBody","_BinaryenBreakSetCondition","_BinaryenBreakSetValue","_BinaryenSwitchSetCondition","_BinaryenSwitchSetValue","_BinaryenCallSetOperandAt","_BinaryenCallIndirectSetTarget","_BinaryenCallIndirectSetOperandAt","_BinaryenLocalSetSetValue","_BinaryenGlobalSetSetValue","_BinaryenLoadSetPtr","_BinaryenStoreSetPtr","_BinaryenStoreSetValue","_BinaryenUnarySetValue","_BinaryenBinarySetLeft","_BinaryenBinarySetRight","_BinaryenSelectSetIfTrue","_BinaryenSelectSetIfFalse","_BinaryenSelectSetCondition","_BinaryenDropSetValue","_BinaryenReturnSetValue","_BinaryenMemoryGrowSetDelta","_BinaryenAtomicRMWSetPtr","_BinaryenAtomicRMWSetValue","_BinaryenAtomicCmpxchgSetPtr","_BinaryenAtomicCmpxchgSetExpected","repl","_BinaryenAtomicCmpxchgSetReplacement","_BinaryenAtomicWaitSetPtr","_BinaryenAtomicWaitSetExpected","_BinaryenAtomicWaitSetTimeout","_BinaryenAtomicNotifySetPtr","_BinaryenAtomicNotifySetNotifyCount","_BinaryenSIMDExtractSetVec","_BinaryenSIMDReplaceSetVec","_BinaryenSIMDReplaceSetValue","_BinaryenSIMDShuffleSetLeft","_BinaryenSIMDShuffleSetRight","_BinaryenSIMDTernarySetA","_BinaryenSIMDTernarySetB","_BinaryenSIMDTernarySetC","_BinaryenSIMDShiftSetVec","_BinaryenSIMDShiftSetShift","_BinaryenSIMDLoadSetPtr","_BinaryenSIMDLoadStoreLaneSetPtr","_BinaryenSIMDLoadStoreLaneSetVec","_BinaryenMemoryInitSetDest","_BinaryenMemoryInitSetOffset","_BinaryenMemoryInitSetSize","_BinaryenMemoryCopySetDest","_BinaryenMemoryCopySetSource","_BinaryenMemoryCopySetSize","_BinaryenMemoryFillSetDest","_BinaryenMemoryFillSetValue","_BinaryenMemoryFillSetSize","_BinaryenRefIsSetValue","_BinaryenRefEqSetLeft","_BinaryenRefEqSetRight","_BinaryenTrySetBody","catchBody","_BinaryenTrySetCatchBodyAt","_BinaryenThrowSetOperandAt","_BinaryenTupleMakeSetOperandAt","_BinaryenTupleExtractSetTuple","_BinaryenI31NewSetValue","i31Expr","_BinaryenI31GetSetI31","_currentFunction","_currentGlobal","currentFunction","currentGlobal","walkFunctions","walkGlobals","moduleRef","_BinaryenGetNumFunctions","walkFunction","_BinaryenGetFunctionByIndex","_BinaryenGetNumGlobals","walkGlobal","_BinaryenGetGlobalByIndex","init","replaceCurrent","_BinaryenFunctionSetBody","_BinaryenExpressionFinalize","Pass","seenStores","ptrType","checkRT","matchPattern","needsSlot","slotMaps","tempMaps","exportMap","hasStackCheckFunction","callSlotOffset","callSlotStack","ptrSize","ptrBinaryAdd","ptrBinarySub","ptrConst","noteSlot","slotMap","slotIndex","managedOperandIndices","getSharedTemp","tempMap","_BinaryenFunctionGetNumLocals","makeStackOffset","makeStackCheck","makeStackFill","frameSize","remain","nativeSource","updateCallOperands","numSlots","match","callIndirect","updateFunction","numVars","vars","updateExport","exportRef","_BinaryenExportGetKind","internalNameRef","_BinaryenExportGetValue","externalNameRef","_BinaryenExportGetName","expandType","numParams","wrapperName","wrapperNameRef","instrumentReturns","InstrumentReturns","bodyType","parentPass","AL_MASK","AL_SIZE","QueuedImport","localFile","localIdentifier","foreignIdentifier","foreignPath","foreignPathAlt","QueuedExport","QueuedExportStar","pathLiteral","fromDecorator","UNCHECKED_INDEXED_GET","UNCHECKED_INDEXED_SET","INVALID","fromBinaryToken","fromUnaryPrefixToken","fromUnaryPostfixToken","nextClassId","nextSignatureId","initialized","elementsByDeclaration","wrapperClasses","uniqueSignatures","_arrayBufferViewInstance","_arrayBufferInstance","_arrayPrototype","_staticArrayPrototype","_setPrototype","_mapPrototype","_functionPrototype","_int8ArrayPrototype","_int16ArrayPrototype","_int32ArrayPrototype","_int64ArrayPrototype","_uint8ArrayPrototype","_uint8ClampedArrayPrototype","_uint16ArrayPrototype","_uint32ArrayPrototype","_uint64ArrayPrototype","_float32ArrayPrototype","_float64ArrayPrototype","_stringInstance","_objectInstance","_templateStringsArrayInstance","_allocInstance","_reallocInstance","_freeInstance","_newInstance","_renewInstance","_linkInstance","_collectInstance","_visitInstance","_typeinfoInstance","_instanceofInstance","_newBufferInstance","_newArrayInstance","_BLOCKInstance","_OBJECTInstance","nativeDummySignature","Resolver","nativeFile","File","requireClass","int8ArrayPrototype","int16ArrayPrototype","int32ArrayPrototype","int64ArrayPrototype","uint8ArrayPrototype","uint8ClampedArrayPrototype","uint16ArrayPrototype","uint32ArrayPrototype","uint64ArrayPrototype","float32ArrayPrototype","float64ArrayPrototype","objectInstance","reallocInstance","freeInstance","renewInstance","collectInstance","typeinfoInstance","BLOCKInstance","blockOverhead","objectOverhead","computeBlockStart","currentOffset","computeBlockSize","payloadSize","blockSize","blockMinsize","makeNativeVariableDeclaration","makeNativeTypeDeclaration","makeNativeNamespaceDeclaration","decoratorFlags","registerNativeType","TypeDefinition","registerConstantInteger","queuedImports","queuedExports","queuedExportsStar","queuedExtends","queuedImplements","initializeExports","initializeExportDefault","initializeImports","initializeVariables","initializeClass","initializeEnum","initializeFunction","initializeInterface","initializeNamespace","initializeTypeDefinition","starExports","foreignFile","lookupForeignFile","ensureExportStar","madeProgress","queuedImport","lookupForeign","splice","asAliasNamespace","Module_0_has_no_exported_member_1","exportNames","queuedExport","ensureExport","globalElement","isDeclaredElement","registerWrapperClass","thisPrototype","baseElement","basePrototype","Class_0_is_final_and_cannot_be_extended","Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa","A_class_may_only_extend_another_class","An_interface_can_only_extend_an_interface","implementsNodes","implementsNode","interfaceElement","interfacePrototype","interfacePrototypes","A_class_can_only_implement_an_interface","markVirtuals","firstChar","parseInt","markModuleExports","thisInstanceMembers","baseInstanceMembers","thisMember","baseMember","thisMethod","baseMethod","visibilityEquals","Overload_signatures_must_all_be_public_private_or_protected","overloads","baseMethodInstances","thisProperty","baseProperty","baseGetter","getterPrototype","thisGetter","baseGetterInstances","baseSetter","setterPrototype","thisSetter","baseSetterInstances","nextPrototype","markModuleExport","className","classElement","wrappedType","isIntegerInclReference","Global","registerConstantFloat","ensureGlobal","merged","tryMerge","lookupExport","fileQueuedExports","queuedExportForeignPath","otherFile","checkDecorators","acceptedFlags","fromKind","Duplicate_decorator","ClassPrototype","Unmanaged_classes_cannot_implement_interfaces","memberDeclarations","memberDeclaration","initializeField","methodDeclaration","initializeProperty","method","initializeMethod","FieldPrototype","addInstance","checkOperatorOverloads","firstArg","_0_is_not_a_valid_operator","overloadPrototypes","Duplicate_function_implementation","operatorKind","ensureProperty","parentMembers","PropertyPrototype","Duplicate_property_0","Enum","initializeEnumValue","EnumValue","initializeExport","queued","endsWith","Export_declaration_conflicts_with_exported_declaration_of_0","initializeImport","validDecorators","InterfacePrototype","initializeFieldAsProperty","Namespace","copyMembers","Element","shadowType","FILE","localIdentifierIfImport","originalDeclaration","reportedIdentifier","isBound","isPublic","isImplicitlyPublic","vis","declaredElements","DeclaredElement","isCompatibleOverride","selfProperty","selfGetter","selfSetter","typedElements","TypedElement","aliasNamespaces","ns","copyExportsToNamespace","ConstantValueKind","VariableLikeElement","boundPrototypes","parentKind","toBound","bound","getResolvedInstance","instanceKey","nameInclTypeParameters","parameterType","parameterName","createParent","registerConcreteElement","getDefaultParameterName","postfix","FIELD_PROTOTYPE","_internalGetterName","_internalSetterName","_internalGetterSignature","_internalSetterSignature","getGetterInstance","getSetterInstance","_isInterface","isBuiltinArray","basePtototype","Class","interfaces","_id","implementers","lengthField","setBase","inheritedTypeArguments","baseName","baseType","addInterface","iface","uncheckedOverload","overhead","baseOffset","typeKind","writeI32AsI64","writeI64AsI32","extendedPrototype","exceptIfMember","older","newer","Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local","src","srcMembers","destMembers","asGlobal","cachedDefaultParameterNames","resolveClassPending","ctxElement","ctxTypes","reportMode","resolveNamedType","resolveFunctionType","isSimpleType","simpleName","Type_0_cannot_be_nullable","typeDefinition","resolveBuiltinNativeType","resolveBuiltinIndexofType","resolveBuiltinValueofType","resolveBuiltinReturnTypeType","resolveBuiltinNotNullableType","parameterTypeNode","returnTypeNode","typeArgumentNode","ensureOneTypeArgument","typeArgument","prev","alternativeReportNode","minParameterCount","maxParameterCount","argumentCount","oldCtxTypes","ctxFlow","resolveFunctionInclTypeArguments","typeParameterNames","argumentNodes","argumentExpression","propagateInferredGenericTypes","resolvedTypeArguments","typeParameterNode","inferredType","resolvedDefaultType","ensureResolvedLazyGlobal","isTypedElement","getElementOfType","lookupAssertionExpression","lookupBinaryExpression","lookupCallExpression","lookupCommaExpression","lookupElementAccessExpression","lookupFunctionExpression","lookupThisExpression","lookupSuperExpression","lookupInstanceOfExpression","lookupLiteralExpression","lookupNewExpression","lookupPropertyAccessExpression","lookupTernaryExpression","lookupUnaryPostfixExpression","lookupUnaryPrefixExpression","resolveAssertionExpression","resolveBinaryExpression","resolveCallExpression","resolveCommaExpression","resolveElementAccessExpression","resolveFunctionExpression","resolveIdentifierExpression","resolveThisExpression","resolveSuperExpression","resolveInstanceOfExpression","resolveLiteralExpression","resolveNewExpression","resolvePropertyAccessExpression","resolveTernaryExpression","resolveUnaryPostfixExpression","resolveUnaryPrefixExpression","targetNode","propertyName","variableLikeElement","wrapper","baseInstance","i64_is_i8","i64_is_u8","i64_is_i16","i64_is_u16","i64_is_bool","Type_0_is_illegal_in_this_context","superLocal","fltType","numNullLiterals","The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly","isClass","varType","varElement","thenType","elseType","typesToString","resolvedInstance","classTypeArguments","classTypeParameters","numClassTypeArguments","classTypeParameterName","numFunctionTypeArguments","signatureParameters","numSignatureParameters","parameterDeclaration","methodOrPropertyName","baseMembers","parentClassInstance","unboundOverloadPrototype","unboundOverloadParent","isProperty","propertyParent","boundProperty","boundPropertyInstance","boundPrototype","nameInclTypeParamters","Interface","pendingClasses","anyPending","_0_is_referenced_directly_or_indirectly_in_its_own_base_expression","finishResolveClass","unimplemented","ifaceMembers","This_overload_signature_is_not_compatible_with_its_implementation_signature","instanceMemberPrototypes","properties","fieldTypeNode","existingField","baseField","Types_have_separate_declarations_of_a_private_property_0","Property_0_is_private_in_type_1_but_not_in_type_2","Property_0_is_protected_in_type_1_but_public_in_type_2","Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2","Field","propertyGetter","propertySetter","Getter_and_setter_accessors_do_not_agree_in_visibility","Property_0_only_has_a_setter_and_is_missing_a_getter","Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2","overloadKind","overloadPrototype","IndexSignature","pending","dependsOnInstance","_values2","Property","tokenFromKeyword","ASYNC","AWAIT","DEBUGGER","IS","KEYOF","MODULE","PACKAGE","WITH","tokenIsAlsoIdentifier","atStart","identifierHandling","unsafeNext","maxTokenLength","chr","isDecimal","commentStartPos","LINE","TRIPLE","closed","testInteger","isIdentifierStart","posBefore","isIdentifierPart","maybeKeywordToken","isWhiteSpace","Invalid_character","checkOnNewLine","maxCompoundLength","tokenBefore","tokenPosBefore","reusableState","State","isTaggedTemplate","Unterminated_string_literal","readEscapeSequence","readExtendedUnicodeEscape","readUnicodeEscape","readHexadecimalEscape","fromCodePoint","escaped","Unterminated_regular_expression_literal","Invalid_regular_expression_flags","readHexInteger","readBinaryInteger","readOctalInteger","isOctal","Octal_literals_are_not_allowed_in_strict_mode","readDecimalInteger","sepEnd","i64_4","i64_shl","Numeric_separators_are_not_allowed_here","Multiple_consecutive_numeric_separators_are_not_permitted","Hexadecimal_digit_expected","i64_10","Digit_expected","i64_3","Octal_digit_expected","i64_1","Binary_digit_expected","readDecimalFloat","sepCount","readDecimalFloatPartial","replaceAll","parseFloat","allowLeadingZeroSep","readHexFloat","startIfTaggedTemplate","An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal","value32","invalid","An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive","Unterminated_Unicode_escape_sequence","TypeKind","TypeFlags","_nonNullableType","_nullableType","isVectorValue","nullableType","signednessIsRelevant","currentClass","targetClass","targetFunction","signednessIsImportant","validWat","nullablePostfix","numTypes","signatureTypes","compare","numParameterTypes","typeRefs","thisThisType","otherThisType","thisParameterTypes","otherParameterTypes","requireSameSize","targetThisType","targetParameterTypes","thisParameterType","targetParameterType","thisReturnType","targetReturnType","indices","optionalStart","restIndex","cloneParameterTypes","readI64","lo","hi","unsigned","i32_as_f32","f32_as_i32","i64_as_f64","valueI64","f64_as_i64","overrides","cloned","v","x","separator","ipos","dirname","origin","COLOR_GRAY","COLOR_GREEN","COLOR_BLUE","COLOR_WHITE","colorsEnabled","isEnabled","color","isAlpha","c0","CharCode","lookupInUnicodeMap","unicodeIdentifierStart","unicodeIdentifierPart","map","mid","midVal","unmanaged","Long","defineProperty","default","wasm","WebAssembly","Instance","e","low","high","isLong","obj","ctz32","clz32","__isLong__","INT_CACHE","UINT_CACHE","fromInt","cachedObj","cache","fromBits","fromNumber","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","neg","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","fromString","radix","RangeError","p","radixToPower","power","fromValue","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","LongPrototype","toInt","toNumber","isZero","isNegative","eq","radixLong","rem1","rem","remDiv","digits","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","eqz","isPositive","isOdd","isEven","notEquals","neq","ne","lessThan","comp","lt","lessThanOrEqual","lte","le","greaterThan","gt","greaterThanOrEqual","gte","ge","thisNeg","otherNeg","negate","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtract","subtrahend","multiply","multiplier","b00","divide","divisor","approx","res","toUnsigned","shru","shr","shl","log2","log","LN2","approxRes","approxRem","modulo","countLeadingZeros","countTrailingZeros","and","or","xor","shiftLeft","numBits","shiftRight","shiftRightUnsigned","shr_u","rotateLeft","rotateRight","toSigned","toBytes","toBytesLE","toBytesBE","fromBytes","fromBytesLE","fromBytesBE","_default","g","wrapModule","emitStackIR","emitText","emitAsmjs","keys","i64_one","i64_neg_one","i64_not","i64_pow","rightLo","rightHi","i64_div","i64_rem","i64_rem_u","i64_and","i64_or","i64_xor","i64_shr","i64_eq","minSafeF32","MIN_SAFE_INTEGER","maxSafeF32","MAX_SAFE_INTEGER","i64_is_f32","minSafeF64","maxSafeF64","i64_is_f64","fround","globalScope","window","ASC_FEATURE_MUTABLE_GLOBAL","UnreachableError","captureStackTrace","AssertionError","defaultComparator","nanA","nanB","defineProperties","Infinity","NaN","INV_EPS64","y","sign","isTrueish","CHUNKSIZE","fromCharCode","apply","at","charAt","configurable","replacment","split","arraySort","sort","comparator","forEach","Ctr","findLastIndex","byteOffset","Number","sincos_sin","writable","sincos_cos","signbit","Boolean","sincos","sin","cos","exp2","arguments","console","warn","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","globalThis"],"sourceRoot":""}